"use strict";
((typeof self !== 'undefined' ? self : this)["webpackChunk_subwallet_extension_koni"] = (typeof self !== 'undefined' ? self : this)["webpackChunk_subwallet_extension_koni"] || []).push([["vendors-node_modules_smoldot_dist_mjs_index-browser_js"],{

/***/ "../../node_modules/smoldot/dist/mjs/index-browser.js":
/*!************************************************************!*\
  !*** ../../node_modules/smoldot/dist/mjs/index-browser.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AddChainError": () => (/* reexport safe */ _client_js__WEBPACK_IMPORTED_MODULE_0__.AddChainError),
/* harmony export */   "AlreadyDestroyedError": () => (/* reexport safe */ _client_js__WEBPACK_IMPORTED_MODULE_0__.AlreadyDestroyedError),
/* harmony export */   "CrashError": () => (/* reexport safe */ _client_js__WEBPACK_IMPORTED_MODULE_0__.CrashError),
/* harmony export */   "JsonRpcDisabledError": () => (/* reexport safe */ _client_js__WEBPACK_IMPORTED_MODULE_0__.JsonRpcDisabledError),
/* harmony export */   "MalformedJsonRpcError": () => (/* reexport safe */ _client_js__WEBPACK_IMPORTED_MODULE_0__.MalformedJsonRpcError),
/* harmony export */   "QueueFullError": () => (/* reexport safe */ _client_js__WEBPACK_IMPORTED_MODULE_0__.QueueFullError),
/* harmony export */   "start": () => (/* binding */ start)
/* harmony export */ });
/* harmony import */ var _client_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./client.js */ "../../node_modules/smoldot/dist/mjs/client.js");
/* harmony import */ var _instance_instance_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./instance/instance.js */ "../../node_modules/smoldot/dist/mjs/instance/instance.js");
/* harmony import */ var _base64_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base64.js */ "../../node_modules/smoldot/dist/mjs/base64.js");
/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! pako */ "../../node_modules/pako/dist/pako.esm.mjs");
/* harmony import */ var _instance_autogen_wasm_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./instance/autogen/wasm.js */ "../../node_modules/smoldot/dist/mjs/instance/autogen/wasm.js");
// Smoldot
// Copyright (C) 2019-2022  Parity Technologies (UK) Ltd.
// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
/// <reference lib="dom" />






/**
 * Initializes a new client. This is a pre-requisite to connecting to a blockchain.
 *
 * Can never fail.
 *
 * @param options Configuration of the client. Defaults to `{}`.
 */
function start(options) {
    options = options || {};
    // The actual Wasm bytecode is base64-decoded then deflate-decoded from a constant found in a
    // different file.
    // This is suboptimal compared to using `instantiateStreaming`, but it is the most
    // cross-platform cross-bundler approach.
    const wasmModule = WebAssembly.compile((0,pako__WEBPACK_IMPORTED_MODULE_3__.inflate)((0,_base64_js__WEBPACK_IMPORTED_MODULE_2__.classicDecode)(_instance_autogen_wasm_js__WEBPACK_IMPORTED_MODULE_4__["default"])));
    return (0,_client_js__WEBPACK_IMPORTED_MODULE_0__.start)(options, wasmModule, {
        registerShouldPeriodicallyYield: (callback) => {
            if (typeof document === 'undefined') // We might be in a web worker.
                return [false, () => { }];
            const wrappedCallback = () => callback(document.visibilityState === 'visible');
            document.addEventListener('visibilitychange', wrappedCallback);
            return [document.visibilityState === 'visible', () => { document.removeEventListener('visibilitychange', wrappedCallback); }];
        },
        performanceNow: () => {
            return performance.now();
        },
        getRandomValues: (buffer) => {
            const crypto = globalThis.crypto;
            if (!crypto)
                throw new Error('randomness not available');
            // Browsers have this completely undocumented behavior (it's not even part of a spec)
            // that for some reason `getRandomValues` can't be called on arrayviews back by
            // `SharedArrayBuffer`s and they throw an exception if you try.
            if (buffer.buffer instanceof ArrayBuffer)
                crypto.getRandomValues(buffer);
            else {
                const tmpArray = new Uint8Array(buffer.length);
                crypto.getRandomValues(tmpArray);
                buffer.set(tmpArray);
            }
        },
        connect: (config) => {
            return connect(config, (options === null || options === void 0 ? void 0 : options.forbidWs) || false, (options === null || options === void 0 ? void 0 : options.forbidNonLocalWs) || false, (options === null || options === void 0 ? void 0 : options.forbidWss) || false, (options === null || options === void 0 ? void 0 : options.forbidWebRtc) || false);
        }
    });
}
/**
 * Tries to open a new connection using the given configuration.
 *
 * @see Connection
 * @throws {@link ConnectionError} If the multiaddress couldn't be parsed or contains an invalid protocol.
 */
function connect(config, forbidWs, forbidNonLocalWs, forbidWss, forbidWebRTC) {
    // Attempt to parse the multiaddress.
    // TODO: remove support for `/wss` in a long time (https://github.com/paritytech/smoldot/issues/1940)
    const wsParsed = config.address.match(/^\/(ip4|ip6|dns4|dns6|dns)\/(.*?)\/tcp\/(.*?)\/(ws|wss|tls\/ws)$/);
    const webRTCParsed = config.address.match(/^\/(ip4|ip6)\/(.*?)\/udp\/(.*?)\/webrtc-direct\/certhash\/(.*?)$/);
    if (wsParsed != null) {
        const proto = (wsParsed[4] == 'ws') ? 'ws' : 'wss';
        if ((proto == 'ws' && forbidWs) ||
            (proto == 'ws' && wsParsed[2] != 'localhost' && wsParsed[2] != '127.0.0.1' && forbidNonLocalWs) ||
            (proto == 'wss' && forbidWss)) {
            throw new _instance_instance_js__WEBPACK_IMPORTED_MODULE_1__.ConnectionError('Connection type not allowed');
        }
        const url = (wsParsed[1] == 'ip6') ?
            (proto + "://[" + wsParsed[2] + "]:" + wsParsed[3]) :
            (proto + "://" + wsParsed[2] + ":" + wsParsed[3]);
        const connection = new WebSocket(url);
        connection.binaryType = 'arraybuffer';
        const bufferedAmountCheck = { quenedUnreportedBytes: 0, nextTimeout: 10 };
        const checkBufferedAmount = () => {
            if (connection.readyState != 1)
                return;
            // Note that we might expect `bufferedAmount` to always be <= the sum of the lengths
            // of all the data that has been sent, but that might not be the case. For this
            // reason, we use `bufferedAmount` as a hint rather than a correct value.
            const bufferedAmount = connection.bufferedAmount;
            let wasSent = bufferedAmountCheck.quenedUnreportedBytes - bufferedAmount;
            if (wasSent < 0)
                wasSent = 0;
            bufferedAmountCheck.quenedUnreportedBytes -= wasSent;
            if (bufferedAmountCheck.quenedUnreportedBytes != 0) {
                setTimeout(checkBufferedAmount, bufferedAmountCheck.nextTimeout);
                bufferedAmountCheck.nextTimeout *= 2;
                if (bufferedAmountCheck.nextTimeout > 500)
                    bufferedAmountCheck.nextTimeout = 500;
            }
            // Note: it is important to call `onWritableBytes` at the very end, as it might
            // trigger a call to `send`.
            if (wasSent != 0)
                config.onWritableBytes(wasSent);
        };
        connection.onopen = () => {
            config.onOpen({
                type: 'single-stream', handshake: 'multistream-select-noise-yamux',
                initialWritableBytes: 1024 * 1024, writeClosable: false,
            });
        };
        connection.onclose = (event) => {
            const message = "Error code " + event.code + (!!event.reason ? (": " + event.reason) : "");
            config.onConnectionReset(message);
        };
        connection.onmessage = (msg) => {
            config.onMessage(new Uint8Array(msg.data));
        };
        return {
            reset: () => {
                connection.onopen = null;
                connection.onclose = null;
                connection.onmessage = null;
                connection.onerror = null;
                connection.close();
            },
            send: (data) => {
                connection.send(data);
                if (bufferedAmountCheck.quenedUnreportedBytes == 0) {
                    bufferedAmountCheck.nextTimeout = 10;
                    setTimeout(checkBufferedAmount, 10);
                }
                bufferedAmountCheck.quenedUnreportedBytes += data.length;
            },
            closeSend: () => { throw new Error('Wrong connection type'); },
            openOutSubstream: () => { throw new Error('Wrong connection type'); }
        };
    }
    else if (webRTCParsed != null) {
        const targetPort = webRTCParsed[3];
        if (forbidWebRTC || targetPort === '0') {
            throw new _instance_instance_js__WEBPACK_IMPORTED_MODULE_1__.ConnectionError('Connection type not allowed');
        }
        const ipVersion = webRTCParsed[1] == 'ip4' ? '4' : '6';
        const targetIp = webRTCParsed[2];
        const remoteCertMultibase = webRTCParsed[4];
        // The payload of `/certhash` is the hash of the self-generated certificate that the
        // server presents.
        // This function throws an exception if the certhash isn't correct. For this reason, this call
        // is performed as part of the parsing of the multiaddr.
        const remoteCertMultihash = (0,_base64_js__WEBPACK_IMPORTED_MODULE_2__.multibaseBase64Decode)(remoteCertMultibase);
        const remoteCertSha256Hash = multihashToSha256(remoteCertMultihash);
        // TODO: detect localhost for Firefox? https://bugzilla.mozilla.org/show_bug.cgi?id=1659672
        // Note that `pc` can be the connection, but also null or undefined.
        // `undefined` means "certificate generation in progress", while `null` means "opening must
        // be cancelled".
        // While it would be better to use for example a string instead of `null`, using `null` lets
        // us use the `!` operator more easily and leads to more readable code.
        let pc = undefined;
        // Contains the data channels that are open and have been reported to smoldot.
        const dataChannels = new Map();
        // For various reasons explained below, we open a data channel in advance without reporting it
        // to smoldot. This data channel is stored in this variable. Once it is reported to smoldot,
        // it is inserted in `dataChannels`.
        let handshakeDataChannel;
        // Multihash-encoded DTLS certificate of the local node. Unknown as long as it hasn't been
        // generated.
        // TODO: could be merged with `pc` in one variable, and maybe even the other fields as well
        let localTlsCertificateMultihash;
        // Kills all the JavaScript objects (the connection and all its substreams), ensuring that no
        // callback will be called again. Doesn't report anything to smoldot, as this should be done
        // by the caller.
        const killAllJs = () => {
            // The `RTCPeerConnection` is created pretty quickly. It is however still possible for
            // smoldot to cancel the opening, in which case `pc` will still be undefined.
            if (!pc) {
                console.assert(dataChannels.size === 0 && !handshakeDataChannel, "substreams exist while pc is undef");
                pc = null;
                return;
            }
            pc.onconnectionstatechange = null;
            pc.onnegotiationneeded = null;
            pc.ondatachannel = null;
            for (const channel of Array.from(dataChannels.values())) {
                channel.channel.onopen = null;
                channel.channel.onerror = null;
                channel.channel.onclose = null;
                channel.channel.onbufferedamountlow = null;
                channel.channel.onmessage = null;
            }
            dataChannels.clear();
            if (handshakeDataChannel) {
                handshakeDataChannel.onopen = null;
                handshakeDataChannel.onerror = null;
                handshakeDataChannel.onclose = null;
                handshakeDataChannel.onbufferedamountlow = null;
                handshakeDataChannel.onmessage = null;
            }
            handshakeDataChannel = undefined;
            pc.close(); // Not necessarily necessary, but it doesn't hurt to do so.
        };
        // Function that configures a newly-opened channel and adds it to the map. Used for both
        // inbound and outbound substreams.
        const addChannel = (dataChannel, direction) => {
            const dataChannelId = dataChannel.id;
            dataChannel.binaryType = 'arraybuffer';
            let isOpen = false;
            dataChannel.onopen = () => {
                console.assert(!isOpen, "substream opened twice");
                isOpen = true;
                if (direction === 'first-outbound') {
                    console.assert(dataChannels.size === 0, "dataChannels not empty when opening");
                    console.assert(handshakeDataChannel === dataChannel, "handshake substream mismatch");
                    config.onOpen({
                        type: 'multi-stream',
                        handshake: 'webrtc',
                        // `addChannel` can never be called before the local certificate is generated, so this
                        // value is always defined.
                        localTlsCertificateMultihash: localTlsCertificateMultihash,
                        remoteTlsCertificateMultihash: remoteCertMultihash
                    });
                }
                else {
                    console.assert(direction !== 'outbound' || !handshakeDataChannel, "handshakeDataChannel still defined");
                    config.onStreamOpened(dataChannelId, direction, 65536);
                }
            };
            dataChannel.onerror = dataChannel.onclose = (_error) => {
                // A couple of different things could be happening here.
                if (handshakeDataChannel === dataChannel && !isOpen) {
                    // The handshake data channel that we have opened ahead of time failed to open. As this
                    // happens before we have reported the WebRTC connection as a whole as being open, we
                    // need to report that the connection has failed to open.
                    killAllJs();
                    // Note that the event doesn't give any additional reason for the failure.
                    config.onConnectionReset("handshake data channel failed to open");
                }
                else if (handshakeDataChannel === dataChannel) {
                    // The handshake data channel has been closed before we reported it to smoldot. This
                    // isn't really a problem. We just update the state and continue running. If smoldot
                    // requests a substream, another one will be opened. It could be a valid implementation
                    // to also just kill the entire connection, however doing so is a bit too intrusive and
                    // punches through abstraction layers.
                    handshakeDataChannel.onopen = null;
                    handshakeDataChannel.onerror = null;
                    handshakeDataChannel.onclose = null;
                    handshakeDataChannel.onbufferedamountlow = null;
                    handshakeDataChannel.onmessage = null;
                    handshakeDataChannel = undefined;
                }
                else if (!isOpen) {
                    // Substream wasn't opened yet and thus has failed to open. The API has no mechanism to
                    // report substream openings failures. We could try opening it again, but given that
                    // it's unlikely to succeed, we simply opt to kill the entire connection.
                    killAllJs();
                    // Note that the event doesn't give any additional reason for the failure.
                    config.onConnectionReset("data channel failed to open");
                }
                else {
                    // Substream was open and is now closed. Normal situation.
                    config.onStreamReset(dataChannelId);
                }
            };
            dataChannel.onbufferedamountlow = () => {
                const channel = dataChannels.get(dataChannelId);
                const val = channel.bufferedBytes;
                channel.bufferedBytes = 0;
                config.onWritableBytes(val, dataChannelId);
            };
            dataChannel.onmessage = (m) => {
                // The `data` field is an `ArrayBuffer`.
                config.onMessage(new Uint8Array(m.data), dataChannelId);
            };
            if (direction !== 'first-outbound')
                dataChannels.set(dataChannelId, { channel: dataChannel, bufferedBytes: 0 });
            else
                handshakeDataChannel = dataChannel;
        };
        // It is possible for the browser to use multiple different certificates.
        // In order for our local certificate to be deterministic, we need to generate it manually and
        // set it explicitly as part of the configuration.
        // According to <https://w3c.github.io/webrtc-pc/#dom-rtcpeerconnection-generatecertificate>,
        // browsers are guaranteed to support `{ name: "ECDSA", namedCurve: "P-256" }`.
        RTCPeerConnection.generateCertificate({ name: "ECDSA", namedCurve: "P-256", hash: "SHA-256" }).then((localCertificate) => __awaiter(this, void 0, void 0, function* () {
            if (pc === null)
                return;
            // Create a new WebRTC connection.
            pc = new RTCPeerConnection({ certificates: [localCertificate] });
            // We need to build the multihash corresponding to the local certificate.
            // While there exists a `RTCPeerConnection.getFingerprints` function, Firefox notably
            // doesn't support it.
            // See <https://developer.mozilla.org/en-US/docs/Web/API/RTCCertificate#browser_compatibility>
            // An alternative to `getFingerprints` is to ask the browser to generate an SDP offer and
            // extract from fingerprint from it. Because we explicitly provide a certificate, we have
            // the guarantee that the list of certificates will always be the same whenever an SDP offer
            // is generated by the browser. However, while this alternative does work on Firefox, it
            // doesn't on Chrome, as the SDP offer is for some reason missing the fingerprints.
            // Therefore, our strategy is to use `getFingerprints` when it is available (i.e. every
            // browser except Firefox), and parse the SDP offer when it is not (i.e. Firefox). In the
            // future, only `getFingerprints` would be used.
            let localTlsCertificateHex;
            if (localCertificate.getFingerprints) {
                for (const { algorithm, value } of localCertificate.getFingerprints()) {
                    if (algorithm === 'sha-256') {
                        localTlsCertificateHex = value;
                        break;
                    }
                }
            }
            else {
                const localSdpOffer = yield pc.createOffer();
                // Note that this regex is not strict. The browser isn't a malicious actor, and the
                // objective of this regex is not to detect invalid input.
                const localSdpOfferFingerprintMatch = localSdpOffer.sdp.match(/a(\s*)=(\s*)fingerprint:(\s*)(sha|SHA)-256(\s*)(([a-fA-F0-9]{2}(:)*){32})/);
                if (localSdpOfferFingerprintMatch) {
                    localTlsCertificateHex = localSdpOfferFingerprintMatch[6];
                }
            }
            if (localTlsCertificateHex === undefined) {
                // Because we've already returned from the `connect` function at this point, we pretend
                // that the connection has failed to open.
                config.onConnectionReset('Failed to obtain the browser certificate fingerprint');
                return;
            }
            localTlsCertificateMultihash = new Uint8Array(34);
            localTlsCertificateMultihash.set([0x12, 32], 0);
            localTlsCertificateMultihash.set(localTlsCertificateHex.split(':').map((s) => parseInt(s, 16)), 2);
            // `onconnectionstatechange` is used to detect when the connection has closed or has failed
            // to open.
            // Note that smoldot will think that the connection is open even when it is still opening.
            // Therefore we don't care about events concerning the fact that the connection is now fully
            // open.
            pc.onconnectionstatechange = (_event) => {
                if (pc.connectionState == "closed" || pc.connectionState == "disconnected" || pc.connectionState == "failed") {
                    killAllJs();
                    config.onConnectionReset("WebRTC state transitioned to " + pc.connectionState);
                }
            };
            pc.onnegotiationneeded = (_event) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                // Create a new offer and set it as local description.
                let sdpOffer = (yield pc.createOffer()).sdp;
                // We check that the locally-generated SDP offer has a data channel with the UDP
                // protocol. If that isn't the case, the connection will likely fail.
                if (sdpOffer.match(/^m=application(\s+)(\d+)(\s+)UDP\/DTLS\/SCTP(\s+)webrtc-datachannel$/m) === null) {
                    console.error("Local offer doesn't contain UDP data channel. WebRTC connections will likely fail. Please report this issue.");
                }
                // According to the libp2p WebRTC spec, the ufrag and pwd are the same
                // randomly-generated string on both sides, and must be prefixed with
                // `libp2p-webrtc-v1:`. We modify the local description to ensure that.
                // While we could randomly generate a new string, we just grab the one that the
                // browser has generated, in order to make sure that it respects the constraints
                // of the ICE protocol.
                const browserGeneratedPwd = (_a = sdpOffer.match(/^a=ice-pwd:(.+)$/m)) === null || _a === void 0 ? void 0 : _a.at(1);
                if (browserGeneratedPwd === undefined) {
                    console.error("Failed to set ufrag to pwd. WebRTC connections will likely fail. Please report this issue.");
                }
                const ufragPwd = "libp2p+webrtc+v1/" + browserGeneratedPwd;
                sdpOffer = sdpOffer.replace(/^a=ice-ufrag.*$/m, 'a=ice-ufrag:' + ufragPwd);
                sdpOffer = sdpOffer.replace(/^a=ice-pwd.*$/m, 'a=ice-pwd:' + ufragPwd);
                yield pc.setLocalDescription({ type: 'offer', sdp: sdpOffer });
                // Transform certificate hash into fingerprint (upper-hex; each byte separated by ":").
                const fingerprint = Array.from(remoteCertSha256Hash).map((n) => ("0" + n.toString(16)).slice(-2).toUpperCase()).join(':');
                // Note that the trailing line feed is important, as otherwise Chrome
                // fails to parse the payload.
                const remoteSdp = 
                // Version of the SDP protocol. Always 0. (RFC8866)
                "v=0" + "\n" +
                    // Identifies the creator of the SDP document. We are allowed to use dummy values
                    // (`-` and `0.0.0.0`) to remain anonymous, which we do. Note that "IN" means
                    // "Internet" (and not "input"). (RFC8866)
                    "o=- 0 0 IN IP" + ipVersion + " " + targetIp + "\n" +
                    // Name for the session. We are allowed to pass a dummy `-`. (RFC8866)
                    "s=-" + "\n" +
                    // Start and end of the validity of the session. `0 0` means that the session never
                    // expires. (RFC8866)
                    "t=0 0" + "\n" +
                    // A lite implementation is only appropriate for devices that will
                    // always be connected to the public Internet and have a public
                    // IP address at which it can receive packets from any
                    // correspondent.  ICE will not function when a lite implementation
                    // is placed behind a NAT (RFC8445).
                    "a=ice-lite" + "\n" +
                    // A `m=` line describes a request to establish a certain protocol.
                    // The protocol in this line (i.e. `TCP/DTLS/SCTP` or `UDP/DTLS/SCTP`) must always be
                    // the same as the one in the offer. We know that this is true because checked above.
                    // The `<fmt>` component must always be `webrtc-datachannel` for WebRTC.
                    // The rest of the SDP payload adds attributes to this specific media stream.
                    // RFCs: 8839, 8866, 8841
                    "m=application " + targetPort + " " + "UDP/DTLS/SCTP webrtc-datachannel" + "\n" +
                    // Indicates the IP address of the remote.
                    // Note that "IN" means "Internet" (and not "input").
                    "c=IN IP" + ipVersion + " " + targetIp + "\n" +
                    // Media ID - uniquely identifies this media stream (RFC9143).
                    "a=mid:0" + "\n" +
                    // Indicates that we are complying with RFC8839 (as oppposed to the legacy RFC5245).
                    "a=ice-options:ice2" + "\n" +
                    // ICE username and password, which are used for establishing and
                    // maintaining the ICE connection. (RFC8839)
                    // These values are set according to the libp2p WebRTC specification.
                    "a=ice-ufrag:" + ufragPwd + "\n" +
                    "a=ice-pwd:" + ufragPwd + "\n" +
                    // Fingerprint of the certificate that the server will use during the TLS
                    // handshake. (RFC8122)
                    // MUST be derived from the certificate used by the answerer (server).
                    "a=fingerprint:sha-256 " + fingerprint + "\n" +
                    // Indicates that the remote DTLS server will only listen for incoming
                    // connections. (RFC5763)
                    // The answerer (server) MUST not be located behind a NAT (RFC6135).
                    "a=setup:passive" + "\n" +
                    // The SCTP port (RFC8841)
                    // Note it's different from the "m=" line port value, which
                    // indicates the port of the underlying transport-layer protocol
                    // (UDP or TCP)
                    "a=sctp-port:5000" + "\n" +
                    // The maximum SCTP user message size (in bytes) (RFC8841)
                    // Setting this field is part of the libp2p spec.
                    "a=max-message-size:16384" + "\n" +
                    // A transport address for a candidate that can be used for connectivity
                    // checks (RFC8839).
                    "a=candidate:1 1 UDP 1 " + targetIp + " " + targetPort + " typ host" + "\n";
                yield pc.setRemoteDescription({ type: "answer", sdp: remoteSdp });
            });
            pc.ondatachannel = ({ channel }) => {
                // TODO: is the substream maybe already open? according to the Internet it seems that no but it's unclear
                addChannel(channel, 'inbound');
            };
            // Creating a `RTCPeerConnection` doesn't actually do anything before `createDataChannel` is
            // called. Smoldot's API, however, requires you to treat entire connections as open or
            // closed. We know, according to the libp2p WebRTC specification, that every connection
            // always starts with a substream where a handshake is performed. After we've reported that
            // the connection is open, smoldot will open a substream in order to perform the handshake.
            // Instead of following this API, we open this substream in advance, and will notify smoldot
            // that the connection is open when the substream is open.
            // Note that the label passed to `createDataChannel` is required to be empty as per the
            // libp2p WebRTC specification.
            addChannel(pc.createDataChannel("", { id: 0, negotiated: true }), 'first-outbound');
        }));
        return {
            reset: (streamId) => {
                // If `streamId` is undefined, then the whole connection must be destroyed.
                if (streamId === undefined) {
                    killAllJs();
                }
                else {
                    const channel = dataChannels.get(streamId);
                    channel.channel.onopen = null;
                    channel.channel.onerror = null;
                    channel.channel.onclose = null;
                    channel.channel.onbufferedamountlow = null;
                    channel.channel.onmessage = null;
                    channel.channel.close();
                    dataChannels.delete(streamId);
                }
            },
            send: (data, streamId) => {
                const channel = dataChannels.get(streamId);
                channel.channel.send(data);
                channel.bufferedBytes += data.length;
            },
            closeSend: () => { throw new Error('Wrong connection type'); },
            openOutSubstream: () => {
                // `openOutSubstream` can only be called after we have called `config.onOpen`, therefore
                // `pc` is guaranteed to be non-null.
                // As explained above, we open a data channel ahead of time. If this data channel is still
                // there, we report it.
                if (handshakeDataChannel) {
                    // Do this asynchronously because calling callbacks within callbacks is error-prone.
                    (() => __awaiter(this, void 0, void 0, function* () {
                        // We need to check again if `handshakeDataChannel` is still defined, as the
                        // connection might have been closed.
                        if (handshakeDataChannel) {
                            config.onStreamOpened(handshakeDataChannel.id, 'outbound', 1024 * 1024);
                            dataChannels.set(handshakeDataChannel.id, { channel: handshakeDataChannel, bufferedBytes: 0 });
                            handshakeDataChannel = undefined;
                        }
                    }))();
                }
                else {
                    // Note that the label passed to `createDataChannel` is required to be empty as per the
                    // libp2p WebRTC specification.
                    addChannel(pc.createDataChannel(""), 'outbound');
                }
            }
        };
    }
    else {
        throw new _instance_instance_js__WEBPACK_IMPORTED_MODULE_1__.ConnectionError('Unrecognized multiaddr format');
    }
}
/// Parses a multihash-multibase-encoded string into a SHA256 hash.
///
/// Throws an exception if the multihash algorithm isn't SHA256.
const multihashToSha256 = (certMultihash) => {
    if (certMultihash.length != 34 || certMultihash[0] != 0x12 || certMultihash[1] != 32) {
        throw new Error('Certificate multihash is not SHA-256');
    }
    return new Uint8Array(certMultihash.slice(2));
};


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfc21vbGRvdF9kaXN0X21qc19pbmRleC1icm93c2VyX2pzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFJLElBQUksU0FBSTtBQUM3Qiw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNrRDtBQUNPO0FBQ1U7QUFDcEM7QUFDb0M7QUFDeUU7QUFDNUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyw2Q0FBTyxDQUFDLHlEQUFhLENBQUMsaUVBQVU7QUFDM0UsV0FBVyxpREFBVTtBQUNyQjtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSxvRUFBb0Usb0VBQW9FO0FBQ3hJLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVCQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtFQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYiwrQkFBK0IsMkNBQTJDO0FBQzFFLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtFQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsaUVBQXFCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Qsd0NBQXdDO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELG9DQUFvQztBQUNyRixnREFBZ0QscURBQXFEO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxrQ0FBa0M7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtQkFBbUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0SUFBNEksRUFBRSxNQUFNLEdBQUc7QUFDdko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsOEJBQThCO0FBQzdFLDJFQUEyRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGdDQUFnQztBQUNoRixhQUFhO0FBQ2Isa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELHlCQUF5QjtBQUMzRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsK0JBQStCLDJDQUEyQztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsaURBQWlEO0FBQ3pIO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0VBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BzdWJ3YWxsZXQvZXh0ZW5zaW9uLWtvbmkvLi4vLi4vbm9kZV9tb2R1bGVzL3Ntb2xkb3QvZGlzdC9tanMvaW5kZXgtYnJvd3Nlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTbW9sZG90XG4vLyBDb3B5cmlnaHQgKEMpIDIwMTktMjAyMiAgUGFyaXR5IFRlY2hub2xvZ2llcyAoVUspIEx0ZC5cbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBHUEwtMy4wLW9yLWxhdGVyIFdJVEggQ2xhc3NwYXRoLWV4Y2VwdGlvbi0yLjBcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuLy8gKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW0uICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4vLy8gPHJlZmVyZW5jZSBsaWI9XCJkb21cIiAvPlxuaW1wb3J0IHsgc3RhcnQgYXMgaW5uZXJTdGFydCB9IGZyb20gJy4vY2xpZW50LmpzJztcbmltcG9ydCB7IENvbm5lY3Rpb25FcnJvciB9IGZyb20gJy4vaW5zdGFuY2UvaW5zdGFuY2UuanMnO1xuaW1wb3J0IHsgY2xhc3NpY0RlY29kZSwgbXVsdGliYXNlQmFzZTY0RGVjb2RlIH0gZnJvbSAnLi9iYXNlNjQuanMnO1xuaW1wb3J0IHsgaW5mbGF0ZSB9IGZyb20gJ3Bha28nO1xuaW1wb3J0IHsgZGVmYXVsdCBhcyB3YXNtQmFzZTY0IH0gZnJvbSAnLi9pbnN0YW5jZS9hdXRvZ2VuL3dhc20uanMnO1xuZXhwb3J0IHsgQWRkQ2hhaW5FcnJvciwgQWxyZWFkeURlc3Ryb3llZEVycm9yLCBDcmFzaEVycm9yLCBKc29uUnBjRGlzYWJsZWRFcnJvciwgTWFsZm9ybWVkSnNvblJwY0Vycm9yLCBRdWV1ZUZ1bGxFcnJvciB9IGZyb20gJy4vY2xpZW50LmpzJztcbi8qKlxuICogSW5pdGlhbGl6ZXMgYSBuZXcgY2xpZW50LiBUaGlzIGlzIGEgcHJlLXJlcXVpc2l0ZSB0byBjb25uZWN0aW5nIHRvIGEgYmxvY2tjaGFpbi5cbiAqXG4gKiBDYW4gbmV2ZXIgZmFpbC5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyBDb25maWd1cmF0aW9uIG9mIHRoZSBjbGllbnQuIERlZmF1bHRzIHRvIGB7fWAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGFydChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgLy8gVGhlIGFjdHVhbCBXYXNtIGJ5dGVjb2RlIGlzIGJhc2U2NC1kZWNvZGVkIHRoZW4gZGVmbGF0ZS1kZWNvZGVkIGZyb20gYSBjb25zdGFudCBmb3VuZCBpbiBhXG4gICAgLy8gZGlmZmVyZW50IGZpbGUuXG4gICAgLy8gVGhpcyBpcyBzdWJvcHRpbWFsIGNvbXBhcmVkIHRvIHVzaW5nIGBpbnN0YW50aWF0ZVN0cmVhbWluZ2AsIGJ1dCBpdCBpcyB0aGUgbW9zdFxuICAgIC8vIGNyb3NzLXBsYXRmb3JtIGNyb3NzLWJ1bmRsZXIgYXBwcm9hY2guXG4gICAgY29uc3Qgd2FzbU1vZHVsZSA9IFdlYkFzc2VtYmx5LmNvbXBpbGUoaW5mbGF0ZShjbGFzc2ljRGVjb2RlKHdhc21CYXNlNjQpKSk7XG4gICAgcmV0dXJuIGlubmVyU3RhcnQob3B0aW9ucywgd2FzbU1vZHVsZSwge1xuICAgICAgICByZWdpc3RlclNob3VsZFBlcmlvZGljYWxseVlpZWxkOiAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSAvLyBXZSBtaWdodCBiZSBpbiBhIHdlYiB3b3JrZXIuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtmYWxzZSwgKCkgPT4geyB9XTtcbiAgICAgICAgICAgIGNvbnN0IHdyYXBwZWRDYWxsYmFjayA9ICgpID0+IGNhbGxiYWNrKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ3Zpc2libGUnKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCB3cmFwcGVkQ2FsbGJhY2spO1xuICAgICAgICAgICAgcmV0dXJuIFtkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09ICd2aXNpYmxlJywgKCkgPT4geyBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgd3JhcHBlZENhbGxiYWNrKTsgfV07XG4gICAgICAgIH0sXG4gICAgICAgIHBlcmZvcm1hbmNlTm93OiAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFJhbmRvbVZhbHVlczogKGJ1ZmZlcikgPT4ge1xuICAgICAgICAgICAgY29uc3QgY3J5cHRvID0gZ2xvYmFsVGhpcy5jcnlwdG87XG4gICAgICAgICAgICBpZiAoIWNyeXB0bylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhbmRvbW5lc3Mgbm90IGF2YWlsYWJsZScpO1xuICAgICAgICAgICAgLy8gQnJvd3NlcnMgaGF2ZSB0aGlzIGNvbXBsZXRlbHkgdW5kb2N1bWVudGVkIGJlaGF2aW9yIChpdCdzIG5vdCBldmVuIHBhcnQgb2YgYSBzcGVjKVxuICAgICAgICAgICAgLy8gdGhhdCBmb3Igc29tZSByZWFzb24gYGdldFJhbmRvbVZhbHVlc2AgY2FuJ3QgYmUgY2FsbGVkIG9uIGFycmF5dmlld3MgYmFjayBieVxuICAgICAgICAgICAgLy8gYFNoYXJlZEFycmF5QnVmZmVyYHMgYW5kIHRoZXkgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIHlvdSB0cnkuXG4gICAgICAgICAgICBpZiAoYnVmZmVyLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKVxuICAgICAgICAgICAgICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYnVmZmVyKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRtcEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyh0bXBBcnJheSk7XG4gICAgICAgICAgICAgICAgYnVmZmVyLnNldCh0bXBBcnJheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbm5lY3Q6IChjb25maWcpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjb25uZWN0KGNvbmZpZywgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5mb3JiaWRXcykgfHwgZmFsc2UsIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZm9yYmlkTm9uTG9jYWxXcykgfHwgZmFsc2UsIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZm9yYmlkV3NzKSB8fCBmYWxzZSwgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5mb3JiaWRXZWJSdGMpIHx8IGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLyoqXG4gKiBUcmllcyB0byBvcGVuIGEgbmV3IGNvbm5lY3Rpb24gdXNpbmcgdGhlIGdpdmVuIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQHNlZSBDb25uZWN0aW9uXG4gKiBAdGhyb3dzIHtAbGluayBDb25uZWN0aW9uRXJyb3J9IElmIHRoZSBtdWx0aWFkZHJlc3MgY291bGRuJ3QgYmUgcGFyc2VkIG9yIGNvbnRhaW5zIGFuIGludmFsaWQgcHJvdG9jb2wuXG4gKi9cbmZ1bmN0aW9uIGNvbm5lY3QoY29uZmlnLCBmb3JiaWRXcywgZm9yYmlkTm9uTG9jYWxXcywgZm9yYmlkV3NzLCBmb3JiaWRXZWJSVEMpIHtcbiAgICAvLyBBdHRlbXB0IHRvIHBhcnNlIHRoZSBtdWx0aWFkZHJlc3MuXG4gICAgLy8gVE9ETzogcmVtb3ZlIHN1cHBvcnQgZm9yIGAvd3NzYCBpbiBhIGxvbmcgdGltZSAoaHR0cHM6Ly9naXRodWIuY29tL3Bhcml0eXRlY2gvc21vbGRvdC9pc3N1ZXMvMTk0MClcbiAgICBjb25zdCB3c1BhcnNlZCA9IGNvbmZpZy5hZGRyZXNzLm1hdGNoKC9eXFwvKGlwNHxpcDZ8ZG5zNHxkbnM2fGRucylcXC8oLio/KVxcL3RjcFxcLyguKj8pXFwvKHdzfHdzc3x0bHNcXC93cykkLyk7XG4gICAgY29uc3Qgd2ViUlRDUGFyc2VkID0gY29uZmlnLmFkZHJlc3MubWF0Y2goL15cXC8oaXA0fGlwNilcXC8oLio/KVxcL3VkcFxcLyguKj8pXFwvd2VicnRjLWRpcmVjdFxcL2NlcnRoYXNoXFwvKC4qPykkLyk7XG4gICAgaWYgKHdzUGFyc2VkICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgcHJvdG8gPSAod3NQYXJzZWRbNF0gPT0gJ3dzJykgPyAnd3MnIDogJ3dzcyc7XG4gICAgICAgIGlmICgocHJvdG8gPT0gJ3dzJyAmJiBmb3JiaWRXcykgfHxcbiAgICAgICAgICAgIChwcm90byA9PSAnd3MnICYmIHdzUGFyc2VkWzJdICE9ICdsb2NhbGhvc3QnICYmIHdzUGFyc2VkWzJdICE9ICcxMjcuMC4wLjEnICYmIGZvcmJpZE5vbkxvY2FsV3MpIHx8XG4gICAgICAgICAgICAocHJvdG8gPT0gJ3dzcycgJiYgZm9yYmlkV3NzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IENvbm5lY3Rpb25FcnJvcignQ29ubmVjdGlvbiB0eXBlIG5vdCBhbGxvd2VkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJsID0gKHdzUGFyc2VkWzFdID09ICdpcDYnKSA/XG4gICAgICAgICAgICAocHJvdG8gKyBcIjovL1tcIiArIHdzUGFyc2VkWzJdICsgXCJdOlwiICsgd3NQYXJzZWRbM10pIDpcbiAgICAgICAgICAgIChwcm90byArIFwiOi8vXCIgKyB3c1BhcnNlZFsyXSArIFwiOlwiICsgd3NQYXJzZWRbM10pO1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gbmV3IFdlYlNvY2tldCh1cmwpO1xuICAgICAgICBjb25uZWN0aW9uLmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICBjb25zdCBidWZmZXJlZEFtb3VudENoZWNrID0geyBxdWVuZWRVbnJlcG9ydGVkQnl0ZXM6IDAsIG5leHRUaW1lb3V0OiAxMCB9O1xuICAgICAgICBjb25zdCBjaGVja0J1ZmZlcmVkQW1vdW50ID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb24ucmVhZHlTdGF0ZSAhPSAxKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB3ZSBtaWdodCBleHBlY3QgYGJ1ZmZlcmVkQW1vdW50YCB0byBhbHdheXMgYmUgPD0gdGhlIHN1bSBvZiB0aGUgbGVuZ3Roc1xuICAgICAgICAgICAgLy8gb2YgYWxsIHRoZSBkYXRhIHRoYXQgaGFzIGJlZW4gc2VudCwgYnV0IHRoYXQgbWlnaHQgbm90IGJlIHRoZSBjYXNlLiBGb3IgdGhpc1xuICAgICAgICAgICAgLy8gcmVhc29uLCB3ZSB1c2UgYGJ1ZmZlcmVkQW1vdW50YCBhcyBhIGhpbnQgcmF0aGVyIHRoYW4gYSBjb3JyZWN0IHZhbHVlLlxuICAgICAgICAgICAgY29uc3QgYnVmZmVyZWRBbW91bnQgPSBjb25uZWN0aW9uLmJ1ZmZlcmVkQW1vdW50O1xuICAgICAgICAgICAgbGV0IHdhc1NlbnQgPSBidWZmZXJlZEFtb3VudENoZWNrLnF1ZW5lZFVucmVwb3J0ZWRCeXRlcyAtIGJ1ZmZlcmVkQW1vdW50O1xuICAgICAgICAgICAgaWYgKHdhc1NlbnQgPCAwKVxuICAgICAgICAgICAgICAgIHdhc1NlbnQgPSAwO1xuICAgICAgICAgICAgYnVmZmVyZWRBbW91bnRDaGVjay5xdWVuZWRVbnJlcG9ydGVkQnl0ZXMgLT0gd2FzU2VudDtcbiAgICAgICAgICAgIGlmIChidWZmZXJlZEFtb3VudENoZWNrLnF1ZW5lZFVucmVwb3J0ZWRCeXRlcyAhPSAwKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChjaGVja0J1ZmZlcmVkQW1vdW50LCBidWZmZXJlZEFtb3VudENoZWNrLm5leHRUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICBidWZmZXJlZEFtb3VudENoZWNrLm5leHRUaW1lb3V0ICo9IDI7XG4gICAgICAgICAgICAgICAgaWYgKGJ1ZmZlcmVkQW1vdW50Q2hlY2submV4dFRpbWVvdXQgPiA1MDApXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcmVkQW1vdW50Q2hlY2submV4dFRpbWVvdXQgPSA1MDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3RlOiBpdCBpcyBpbXBvcnRhbnQgdG8gY2FsbCBgb25Xcml0YWJsZUJ5dGVzYCBhdCB0aGUgdmVyeSBlbmQsIGFzIGl0IG1pZ2h0XG4gICAgICAgICAgICAvLyB0cmlnZ2VyIGEgY2FsbCB0byBgc2VuZGAuXG4gICAgICAgICAgICBpZiAod2FzU2VudCAhPSAwKVxuICAgICAgICAgICAgICAgIGNvbmZpZy5vbldyaXRhYmxlQnl0ZXMod2FzU2VudCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbm5lY3Rpb24ub25vcGVuID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uZmlnLm9uT3Blbih7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3NpbmdsZS1zdHJlYW0nLCBoYW5kc2hha2U6ICdtdWx0aXN0cmVhbS1zZWxlY3Qtbm9pc2UteWFtdXgnLFxuICAgICAgICAgICAgICAgIGluaXRpYWxXcml0YWJsZUJ5dGVzOiAxMDI0ICogMTAyNCwgd3JpdGVDbG9zYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29ubmVjdGlvbi5vbmNsb3NlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gXCJFcnJvciBjb2RlIFwiICsgZXZlbnQuY29kZSArICghIWV2ZW50LnJlYXNvbiA/IChcIjogXCIgKyBldmVudC5yZWFzb24pIDogXCJcIik7XG4gICAgICAgICAgICBjb25maWcub25Db25uZWN0aW9uUmVzZXQobWVzc2FnZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbm5lY3Rpb24ub25tZXNzYWdlID0gKG1zZykgPT4ge1xuICAgICAgICAgICAgY29uZmlnLm9uTWVzc2FnZShuZXcgVWludDhBcnJheShtc2cuZGF0YSkpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzZXQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uLm9ub3BlbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbi5vbmNsb3NlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uLm9ubWVzc2FnZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbi5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VuZDogKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uLnNlbmQoZGF0YSk7XG4gICAgICAgICAgICAgICAgaWYgKGJ1ZmZlcmVkQW1vdW50Q2hlY2sucXVlbmVkVW5yZXBvcnRlZEJ5dGVzID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyZWRBbW91bnRDaGVjay5uZXh0VGltZW91dCA9IDEwO1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGNoZWNrQnVmZmVyZWRBbW91bnQsIDEwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnVmZmVyZWRBbW91bnRDaGVjay5xdWVuZWRVbnJlcG9ydGVkQnl0ZXMgKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xvc2VTZW5kOiAoKSA9PiB7IHRocm93IG5ldyBFcnJvcignV3JvbmcgY29ubmVjdGlvbiB0eXBlJyk7IH0sXG4gICAgICAgICAgICBvcGVuT3V0U3Vic3RyZWFtOiAoKSA9PiB7IHRocm93IG5ldyBFcnJvcignV3JvbmcgY29ubmVjdGlvbiB0eXBlJyk7IH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAod2ViUlRDUGFyc2VkICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0UG9ydCA9IHdlYlJUQ1BhcnNlZFszXTtcbiAgICAgICAgaWYgKGZvcmJpZFdlYlJUQyB8fCB0YXJnZXRQb3J0ID09PSAnMCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDb25uZWN0aW9uRXJyb3IoJ0Nvbm5lY3Rpb24gdHlwZSBub3QgYWxsb3dlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlwVmVyc2lvbiA9IHdlYlJUQ1BhcnNlZFsxXSA9PSAnaXA0JyA/ICc0JyA6ICc2JztcbiAgICAgICAgY29uc3QgdGFyZ2V0SXAgPSB3ZWJSVENQYXJzZWRbMl07XG4gICAgICAgIGNvbnN0IHJlbW90ZUNlcnRNdWx0aWJhc2UgPSB3ZWJSVENQYXJzZWRbNF07XG4gICAgICAgIC8vIFRoZSBwYXlsb2FkIG9mIGAvY2VydGhhc2hgIGlzIHRoZSBoYXNoIG9mIHRoZSBzZWxmLWdlbmVyYXRlZCBjZXJ0aWZpY2F0ZSB0aGF0IHRoZVxuICAgICAgICAvLyBzZXJ2ZXIgcHJlc2VudHMuXG4gICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gdGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiB0aGUgY2VydGhhc2ggaXNuJ3QgY29ycmVjdC4gRm9yIHRoaXMgcmVhc29uLCB0aGlzIGNhbGxcbiAgICAgICAgLy8gaXMgcGVyZm9ybWVkIGFzIHBhcnQgb2YgdGhlIHBhcnNpbmcgb2YgdGhlIG11bHRpYWRkci5cbiAgICAgICAgY29uc3QgcmVtb3RlQ2VydE11bHRpaGFzaCA9IG11bHRpYmFzZUJhc2U2NERlY29kZShyZW1vdGVDZXJ0TXVsdGliYXNlKTtcbiAgICAgICAgY29uc3QgcmVtb3RlQ2VydFNoYTI1Nkhhc2ggPSBtdWx0aWhhc2hUb1NoYTI1NihyZW1vdGVDZXJ0TXVsdGloYXNoKTtcbiAgICAgICAgLy8gVE9ETzogZGV0ZWN0IGxvY2FsaG9zdCBmb3IgRmlyZWZveD8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTY1OTY3MlxuICAgICAgICAvLyBOb3RlIHRoYXQgYHBjYCBjYW4gYmUgdGhlIGNvbm5lY3Rpb24sIGJ1dCBhbHNvIG51bGwgb3IgdW5kZWZpbmVkLlxuICAgICAgICAvLyBgdW5kZWZpbmVkYCBtZWFucyBcImNlcnRpZmljYXRlIGdlbmVyYXRpb24gaW4gcHJvZ3Jlc3NcIiwgd2hpbGUgYG51bGxgIG1lYW5zIFwib3BlbmluZyBtdXN0XG4gICAgICAgIC8vIGJlIGNhbmNlbGxlZFwiLlxuICAgICAgICAvLyBXaGlsZSBpdCB3b3VsZCBiZSBiZXR0ZXIgdG8gdXNlIGZvciBleGFtcGxlIGEgc3RyaW5nIGluc3RlYWQgb2YgYG51bGxgLCB1c2luZyBgbnVsbGAgbGV0c1xuICAgICAgICAvLyB1cyB1c2UgdGhlIGAhYCBvcGVyYXRvciBtb3JlIGVhc2lseSBhbmQgbGVhZHMgdG8gbW9yZSByZWFkYWJsZSBjb2RlLlxuICAgICAgICBsZXQgcGMgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8vIENvbnRhaW5zIHRoZSBkYXRhIGNoYW5uZWxzIHRoYXQgYXJlIG9wZW4gYW5kIGhhdmUgYmVlbiByZXBvcnRlZCB0byBzbW9sZG90LlxuICAgICAgICBjb25zdCBkYXRhQ2hhbm5lbHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIEZvciB2YXJpb3VzIHJlYXNvbnMgZXhwbGFpbmVkIGJlbG93LCB3ZSBvcGVuIGEgZGF0YSBjaGFubmVsIGluIGFkdmFuY2Ugd2l0aG91dCByZXBvcnRpbmcgaXRcbiAgICAgICAgLy8gdG8gc21vbGRvdC4gVGhpcyBkYXRhIGNoYW5uZWwgaXMgc3RvcmVkIGluIHRoaXMgdmFyaWFibGUuIE9uY2UgaXQgaXMgcmVwb3J0ZWQgdG8gc21vbGRvdCxcbiAgICAgICAgLy8gaXQgaXMgaW5zZXJ0ZWQgaW4gYGRhdGFDaGFubmVsc2AuXG4gICAgICAgIGxldCBoYW5kc2hha2VEYXRhQ2hhbm5lbDtcbiAgICAgICAgLy8gTXVsdGloYXNoLWVuY29kZWQgRFRMUyBjZXJ0aWZpY2F0ZSBvZiB0aGUgbG9jYWwgbm9kZS4gVW5rbm93biBhcyBsb25nIGFzIGl0IGhhc24ndCBiZWVuXG4gICAgICAgIC8vIGdlbmVyYXRlZC5cbiAgICAgICAgLy8gVE9ETzogY291bGQgYmUgbWVyZ2VkIHdpdGggYHBjYCBpbiBvbmUgdmFyaWFibGUsIGFuZCBtYXliZSBldmVuIHRoZSBvdGhlciBmaWVsZHMgYXMgd2VsbFxuICAgICAgICBsZXQgbG9jYWxUbHNDZXJ0aWZpY2F0ZU11bHRpaGFzaDtcbiAgICAgICAgLy8gS2lsbHMgYWxsIHRoZSBKYXZhU2NyaXB0IG9iamVjdHMgKHRoZSBjb25uZWN0aW9uIGFuZCBhbGwgaXRzIHN1YnN0cmVhbXMpLCBlbnN1cmluZyB0aGF0IG5vXG4gICAgICAgIC8vIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFnYWluLiBEb2Vzbid0IHJlcG9ydCBhbnl0aGluZyB0byBzbW9sZG90LCBhcyB0aGlzIHNob3VsZCBiZSBkb25lXG4gICAgICAgIC8vIGJ5IHRoZSBjYWxsZXIuXG4gICAgICAgIGNvbnN0IGtpbGxBbGxKcyA9ICgpID0+IHtcbiAgICAgICAgICAgIC8vIFRoZSBgUlRDUGVlckNvbm5lY3Rpb25gIGlzIGNyZWF0ZWQgcHJldHR5IHF1aWNrbHkuIEl0IGlzIGhvd2V2ZXIgc3RpbGwgcG9zc2libGUgZm9yXG4gICAgICAgICAgICAvLyBzbW9sZG90IHRvIGNhbmNlbCB0aGUgb3BlbmluZywgaW4gd2hpY2ggY2FzZSBgcGNgIHdpbGwgc3RpbGwgYmUgdW5kZWZpbmVkLlxuICAgICAgICAgICAgaWYgKCFwYykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KGRhdGFDaGFubmVscy5zaXplID09PSAwICYmICFoYW5kc2hha2VEYXRhQ2hhbm5lbCwgXCJzdWJzdHJlYW1zIGV4aXN0IHdoaWxlIHBjIGlzIHVuZGVmXCIpO1xuICAgICAgICAgICAgICAgIHBjID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYy5vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICBwYy5vbm5lZ290aWF0aW9ubmVlZGVkID0gbnVsbDtcbiAgICAgICAgICAgIHBjLm9uZGF0YWNoYW5uZWwgPSBudWxsO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjaGFubmVsIG9mIEFycmF5LmZyb20oZGF0YUNoYW5uZWxzLnZhbHVlcygpKSkge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2hhbm5lbC5vbm9wZW4gPSBudWxsO1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2hhbm5lbC5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjaGFubmVsLmNoYW5uZWwub25jbG9zZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5jaGFubmVsLm9uYnVmZmVyZWRhbW91bnRsb3cgPSBudWxsO1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2hhbm5lbC5vbm1lc3NhZ2UgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YUNoYW5uZWxzLmNsZWFyKCk7XG4gICAgICAgICAgICBpZiAoaGFuZHNoYWtlRGF0YUNoYW5uZWwpIHtcbiAgICAgICAgICAgICAgICBoYW5kc2hha2VEYXRhQ2hhbm5lbC5vbm9wZW4gPSBudWxsO1xuICAgICAgICAgICAgICAgIGhhbmRzaGFrZURhdGFDaGFubmVsLm9uZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgICAgIGhhbmRzaGFrZURhdGFDaGFubmVsLm9uY2xvc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGhhbmRzaGFrZURhdGFDaGFubmVsLm9uYnVmZmVyZWRhbW91bnRsb3cgPSBudWxsO1xuICAgICAgICAgICAgICAgIGhhbmRzaGFrZURhdGFDaGFubmVsLm9ubWVzc2FnZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYW5kc2hha2VEYXRhQ2hhbm5lbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHBjLmNsb3NlKCk7IC8vIE5vdCBuZWNlc3NhcmlseSBuZWNlc3NhcnksIGJ1dCBpdCBkb2Vzbid0IGh1cnQgdG8gZG8gc28uXG4gICAgICAgIH07XG4gICAgICAgIC8vIEZ1bmN0aW9uIHRoYXQgY29uZmlndXJlcyBhIG5ld2x5LW9wZW5lZCBjaGFubmVsIGFuZCBhZGRzIGl0IHRvIHRoZSBtYXAuIFVzZWQgZm9yIGJvdGhcbiAgICAgICAgLy8gaW5ib3VuZCBhbmQgb3V0Ym91bmQgc3Vic3RyZWFtcy5cbiAgICAgICAgY29uc3QgYWRkQ2hhbm5lbCA9IChkYXRhQ2hhbm5lbCwgZGlyZWN0aW9uKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkYXRhQ2hhbm5lbElkID0gZGF0YUNoYW5uZWwuaWQ7XG4gICAgICAgICAgICBkYXRhQ2hhbm5lbC5iaW5hcnlUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgICAgICAgIGxldCBpc09wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIGRhdGFDaGFubmVsLm9ub3BlbiA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydCghaXNPcGVuLCBcInN1YnN0cmVhbSBvcGVuZWQgdHdpY2VcIik7XG4gICAgICAgICAgICAgICAgaXNPcGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAnZmlyc3Qtb3V0Ym91bmQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KGRhdGFDaGFubmVscy5zaXplID09PSAwLCBcImRhdGFDaGFubmVscyBub3QgZW1wdHkgd2hlbiBvcGVuaW5nXCIpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydChoYW5kc2hha2VEYXRhQ2hhbm5lbCA9PT0gZGF0YUNoYW5uZWwsIFwiaGFuZHNoYWtlIHN1YnN0cmVhbSBtaXNtYXRjaFwiKTtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLm9uT3Blbih7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbXVsdGktc3RyZWFtJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRzaGFrZTogJ3dlYnJ0YycsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBgYWRkQ2hhbm5lbGAgY2FuIG5ldmVyIGJlIGNhbGxlZCBiZWZvcmUgdGhlIGxvY2FsIGNlcnRpZmljYXRlIGlzIGdlbmVyYXRlZCwgc28gdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmFsdWUgaXMgYWx3YXlzIGRlZmluZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFRsc0NlcnRpZmljYXRlTXVsdGloYXNoOiBsb2NhbFRsc0NlcnRpZmljYXRlTXVsdGloYXNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3RlVGxzQ2VydGlmaWNhdGVNdWx0aWhhc2g6IHJlbW90ZUNlcnRNdWx0aWhhc2hcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydChkaXJlY3Rpb24gIT09ICdvdXRib3VuZCcgfHwgIWhhbmRzaGFrZURhdGFDaGFubmVsLCBcImhhbmRzaGFrZURhdGFDaGFubmVsIHN0aWxsIGRlZmluZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5vblN0cmVhbU9wZW5lZChkYXRhQ2hhbm5lbElkLCBkaXJlY3Rpb24sIDY1NTM2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZGF0YUNoYW5uZWwub25lcnJvciA9IGRhdGFDaGFubmVsLm9uY2xvc2UgPSAoX2Vycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gQSBjb3VwbGUgb2YgZGlmZmVyZW50IHRoaW5ncyBjb3VsZCBiZSBoYXBwZW5pbmcgaGVyZS5cbiAgICAgICAgICAgICAgICBpZiAoaGFuZHNoYWtlRGF0YUNoYW5uZWwgPT09IGRhdGFDaGFubmVsICYmICFpc09wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGhhbmRzaGFrZSBkYXRhIGNoYW5uZWwgdGhhdCB3ZSBoYXZlIG9wZW5lZCBhaGVhZCBvZiB0aW1lIGZhaWxlZCB0byBvcGVuLiBBcyB0aGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIGhhcHBlbnMgYmVmb3JlIHdlIGhhdmUgcmVwb3J0ZWQgdGhlIFdlYlJUQyBjb25uZWN0aW9uIGFzIGEgd2hvbGUgYXMgYmVpbmcgb3Blbiwgd2VcbiAgICAgICAgICAgICAgICAgICAgLy8gbmVlZCB0byByZXBvcnQgdGhhdCB0aGUgY29ubmVjdGlvbiBoYXMgZmFpbGVkIHRvIG9wZW4uXG4gICAgICAgICAgICAgICAgICAgIGtpbGxBbGxKcygpO1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3RlIHRoYXQgdGhlIGV2ZW50IGRvZXNuJ3QgZ2l2ZSBhbnkgYWRkaXRpb25hbCByZWFzb24gZm9yIHRoZSBmYWlsdXJlLlxuICAgICAgICAgICAgICAgICAgICBjb25maWcub25Db25uZWN0aW9uUmVzZXQoXCJoYW5kc2hha2UgZGF0YSBjaGFubmVsIGZhaWxlZCB0byBvcGVuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChoYW5kc2hha2VEYXRhQ2hhbm5lbCA9PT0gZGF0YUNoYW5uZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGhhbmRzaGFrZSBkYXRhIGNoYW5uZWwgaGFzIGJlZW4gY2xvc2VkIGJlZm9yZSB3ZSByZXBvcnRlZCBpdCB0byBzbW9sZG90LiBUaGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIGlzbid0IHJlYWxseSBhIHByb2JsZW0uIFdlIGp1c3QgdXBkYXRlIHRoZSBzdGF0ZSBhbmQgY29udGludWUgcnVubmluZy4gSWYgc21vbGRvdFxuICAgICAgICAgICAgICAgICAgICAvLyByZXF1ZXN0cyBhIHN1YnN0cmVhbSwgYW5vdGhlciBvbmUgd2lsbCBiZSBvcGVuZWQuIEl0IGNvdWxkIGJlIGEgdmFsaWQgaW1wbGVtZW50YXRpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gYWxzbyBqdXN0IGtpbGwgdGhlIGVudGlyZSBjb25uZWN0aW9uLCBob3dldmVyIGRvaW5nIHNvIGlzIGEgYml0IHRvbyBpbnRydXNpdmUgYW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIHB1bmNoZXMgdGhyb3VnaCBhYnN0cmFjdGlvbiBsYXllcnMuXG4gICAgICAgICAgICAgICAgICAgIGhhbmRzaGFrZURhdGFDaGFubmVsLm9ub3BlbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRzaGFrZURhdGFDaGFubmVsLm9uZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBoYW5kc2hha2VEYXRhQ2hhbm5lbC5vbmNsb3NlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaGFuZHNoYWtlRGF0YUNoYW5uZWwub25idWZmZXJlZGFtb3VudGxvdyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRzaGFrZURhdGFDaGFubmVsLm9ubWVzc2FnZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRzaGFrZURhdGFDaGFubmVsID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghaXNPcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN1YnN0cmVhbSB3YXNuJ3Qgb3BlbmVkIHlldCBhbmQgdGh1cyBoYXMgZmFpbGVkIHRvIG9wZW4uIFRoZSBBUEkgaGFzIG5vIG1lY2hhbmlzbSB0b1xuICAgICAgICAgICAgICAgICAgICAvLyByZXBvcnQgc3Vic3RyZWFtIG9wZW5pbmdzIGZhaWx1cmVzLiBXZSBjb3VsZCB0cnkgb3BlbmluZyBpdCBhZ2FpbiwgYnV0IGdpdmVuIHRoYXRcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQncyB1bmxpa2VseSB0byBzdWNjZWVkLCB3ZSBzaW1wbHkgb3B0IHRvIGtpbGwgdGhlIGVudGlyZSBjb25uZWN0aW9uLlxuICAgICAgICAgICAgICAgICAgICBraWxsQWxsSnMoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHRoZSBldmVudCBkb2Vzbid0IGdpdmUgYW55IGFkZGl0aW9uYWwgcmVhc29uIGZvciB0aGUgZmFpbHVyZS5cbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLm9uQ29ubmVjdGlvblJlc2V0KFwiZGF0YSBjaGFubmVsIGZhaWxlZCB0byBvcGVuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3Vic3RyZWFtIHdhcyBvcGVuIGFuZCBpcyBub3cgY2xvc2VkLiBOb3JtYWwgc2l0dWF0aW9uLlxuICAgICAgICAgICAgICAgICAgICBjb25maWcub25TdHJlYW1SZXNldChkYXRhQ2hhbm5lbElkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZGF0YUNoYW5uZWwub25idWZmZXJlZGFtb3VudGxvdyA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFubmVsID0gZGF0YUNoYW5uZWxzLmdldChkYXRhQ2hhbm5lbElkKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSBjaGFubmVsLmJ1ZmZlcmVkQnl0ZXM7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5idWZmZXJlZEJ5dGVzID0gMDtcbiAgICAgICAgICAgICAgICBjb25maWcub25Xcml0YWJsZUJ5dGVzKHZhbCwgZGF0YUNoYW5uZWxJZCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZGF0YUNoYW5uZWwub25tZXNzYWdlID0gKG0pID0+IHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgYGRhdGFgIGZpZWxkIGlzIGFuIGBBcnJheUJ1ZmZlcmAuXG4gICAgICAgICAgICAgICAgY29uZmlnLm9uTWVzc2FnZShuZXcgVWludDhBcnJheShtLmRhdGEpLCBkYXRhQ2hhbm5lbElkKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uICE9PSAnZmlyc3Qtb3V0Ym91bmQnKVxuICAgICAgICAgICAgICAgIGRhdGFDaGFubmVscy5zZXQoZGF0YUNoYW5uZWxJZCwgeyBjaGFubmVsOiBkYXRhQ2hhbm5lbCwgYnVmZmVyZWRCeXRlczogMCB9KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBoYW5kc2hha2VEYXRhQ2hhbm5lbCA9IGRhdGFDaGFubmVsO1xuICAgICAgICB9O1xuICAgICAgICAvLyBJdCBpcyBwb3NzaWJsZSBmb3IgdGhlIGJyb3dzZXIgdG8gdXNlIG11bHRpcGxlIGRpZmZlcmVudCBjZXJ0aWZpY2F0ZXMuXG4gICAgICAgIC8vIEluIG9yZGVyIGZvciBvdXIgbG9jYWwgY2VydGlmaWNhdGUgdG8gYmUgZGV0ZXJtaW5pc3RpYywgd2UgbmVlZCB0byBnZW5lcmF0ZSBpdCBtYW51YWxseSBhbmRcbiAgICAgICAgLy8gc2V0IGl0IGV4cGxpY2l0bHkgYXMgcGFydCBvZiB0aGUgY29uZmlndXJhdGlvbi5cbiAgICAgICAgLy8gQWNjb3JkaW5nIHRvIDxodHRwczovL3czYy5naXRodWIuaW8vd2VicnRjLXBjLyNkb20tcnRjcGVlcmNvbm5lY3Rpb24tZ2VuZXJhdGVjZXJ0aWZpY2F0ZT4sXG4gICAgICAgIC8vIGJyb3dzZXJzIGFyZSBndWFyYW50ZWVkIHRvIHN1cHBvcnQgYHsgbmFtZTogXCJFQ0RTQVwiLCBuYW1lZEN1cnZlOiBcIlAtMjU2XCIgfWAuXG4gICAgICAgIFJUQ1BlZXJDb25uZWN0aW9uLmdlbmVyYXRlQ2VydGlmaWNhdGUoeyBuYW1lOiBcIkVDRFNBXCIsIG5hbWVkQ3VydmU6IFwiUC0yNTZcIiwgaGFzaDogXCJTSEEtMjU2XCIgfSkudGhlbigobG9jYWxDZXJ0aWZpY2F0ZSkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHBjID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBXZWJSVEMgY29ubmVjdGlvbi5cbiAgICAgICAgICAgIHBjID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKHsgY2VydGlmaWNhdGVzOiBbbG9jYWxDZXJ0aWZpY2F0ZV0gfSk7XG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGJ1aWxkIHRoZSBtdWx0aWhhc2ggY29ycmVzcG9uZGluZyB0byB0aGUgbG9jYWwgY2VydGlmaWNhdGUuXG4gICAgICAgICAgICAvLyBXaGlsZSB0aGVyZSBleGlzdHMgYSBgUlRDUGVlckNvbm5lY3Rpb24uZ2V0RmluZ2VycHJpbnRzYCBmdW5jdGlvbiwgRmlyZWZveCBub3RhYmx5XG4gICAgICAgICAgICAvLyBkb2Vzbid0IHN1cHBvcnQgaXQuXG4gICAgICAgICAgICAvLyBTZWUgPGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9SVENDZXJ0aWZpY2F0ZSNicm93c2VyX2NvbXBhdGliaWxpdHk+XG4gICAgICAgICAgICAvLyBBbiBhbHRlcm5hdGl2ZSB0byBgZ2V0RmluZ2VycHJpbnRzYCBpcyB0byBhc2sgdGhlIGJyb3dzZXIgdG8gZ2VuZXJhdGUgYW4gU0RQIG9mZmVyIGFuZFxuICAgICAgICAgICAgLy8gZXh0cmFjdCBmcm9tIGZpbmdlcnByaW50IGZyb20gaXQuIEJlY2F1c2Ugd2UgZXhwbGljaXRseSBwcm92aWRlIGEgY2VydGlmaWNhdGUsIHdlIGhhdmVcbiAgICAgICAgICAgIC8vIHRoZSBndWFyYW50ZWUgdGhhdCB0aGUgbGlzdCBvZiBjZXJ0aWZpY2F0ZXMgd2lsbCBhbHdheXMgYmUgdGhlIHNhbWUgd2hlbmV2ZXIgYW4gU0RQIG9mZmVyXG4gICAgICAgICAgICAvLyBpcyBnZW5lcmF0ZWQgYnkgdGhlIGJyb3dzZXIuIEhvd2V2ZXIsIHdoaWxlIHRoaXMgYWx0ZXJuYXRpdmUgZG9lcyB3b3JrIG9uIEZpcmVmb3gsIGl0XG4gICAgICAgICAgICAvLyBkb2Vzbid0IG9uIENocm9tZSwgYXMgdGhlIFNEUCBvZmZlciBpcyBmb3Igc29tZSByZWFzb24gbWlzc2luZyB0aGUgZmluZ2VycHJpbnRzLlxuICAgICAgICAgICAgLy8gVGhlcmVmb3JlLCBvdXIgc3RyYXRlZ3kgaXMgdG8gdXNlIGBnZXRGaW5nZXJwcmludHNgIHdoZW4gaXQgaXMgYXZhaWxhYmxlIChpLmUuIGV2ZXJ5XG4gICAgICAgICAgICAvLyBicm93c2VyIGV4Y2VwdCBGaXJlZm94KSwgYW5kIHBhcnNlIHRoZSBTRFAgb2ZmZXIgd2hlbiBpdCBpcyBub3QgKGkuZS4gRmlyZWZveCkuIEluIHRoZVxuICAgICAgICAgICAgLy8gZnV0dXJlLCBvbmx5IGBnZXRGaW5nZXJwcmludHNgIHdvdWxkIGJlIHVzZWQuXG4gICAgICAgICAgICBsZXQgbG9jYWxUbHNDZXJ0aWZpY2F0ZUhleDtcbiAgICAgICAgICAgIGlmIChsb2NhbENlcnRpZmljYXRlLmdldEZpbmdlcnByaW50cykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgeyBhbGdvcml0aG0sIHZhbHVlIH0gb2YgbG9jYWxDZXJ0aWZpY2F0ZS5nZXRGaW5nZXJwcmludHMoKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWxnb3JpdGhtID09PSAnc2hhLTI1NicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsVGxzQ2VydGlmaWNhdGVIZXggPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTZHBPZmZlciA9IHlpZWxkIHBjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgcmVnZXggaXMgbm90IHN0cmljdC4gVGhlIGJyb3dzZXIgaXNuJ3QgYSBtYWxpY2lvdXMgYWN0b3IsIGFuZCB0aGVcbiAgICAgICAgICAgICAgICAvLyBvYmplY3RpdmUgb2YgdGhpcyByZWdleCBpcyBub3QgdG8gZGV0ZWN0IGludmFsaWQgaW5wdXQuXG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTZHBPZmZlckZpbmdlcnByaW50TWF0Y2ggPSBsb2NhbFNkcE9mZmVyLnNkcC5tYXRjaCgvYShcXHMqKT0oXFxzKilmaW5nZXJwcmludDooXFxzKikoc2hhfFNIQSktMjU2KFxccyopKChbYS1mQS1GMC05XXsyfSg6KSopezMyfSkvKTtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxTZHBPZmZlckZpbmdlcnByaW50TWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxUbHNDZXJ0aWZpY2F0ZUhleCA9IGxvY2FsU2RwT2ZmZXJGaW5nZXJwcmludE1hdGNoWzZdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsb2NhbFRsc0NlcnRpZmljYXRlSGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBCZWNhdXNlIHdlJ3ZlIGFscmVhZHkgcmV0dXJuZWQgZnJvbSB0aGUgYGNvbm5lY3RgIGZ1bmN0aW9uIGF0IHRoaXMgcG9pbnQsIHdlIHByZXRlbmRcbiAgICAgICAgICAgICAgICAvLyB0aGF0IHRoZSBjb25uZWN0aW9uIGhhcyBmYWlsZWQgdG8gb3Blbi5cbiAgICAgICAgICAgICAgICBjb25maWcub25Db25uZWN0aW9uUmVzZXQoJ0ZhaWxlZCB0byBvYnRhaW4gdGhlIGJyb3dzZXIgY2VydGlmaWNhdGUgZmluZ2VycHJpbnQnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2NhbFRsc0NlcnRpZmljYXRlTXVsdGloYXNoID0gbmV3IFVpbnQ4QXJyYXkoMzQpO1xuICAgICAgICAgICAgbG9jYWxUbHNDZXJ0aWZpY2F0ZU11bHRpaGFzaC5zZXQoWzB4MTIsIDMyXSwgMCk7XG4gICAgICAgICAgICBsb2NhbFRsc0NlcnRpZmljYXRlTXVsdGloYXNoLnNldChsb2NhbFRsc0NlcnRpZmljYXRlSGV4LnNwbGl0KCc6JykubWFwKChzKSA9PiBwYXJzZUludChzLCAxNikpLCAyKTtcbiAgICAgICAgICAgIC8vIGBvbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZWAgaXMgdXNlZCB0byBkZXRlY3Qgd2hlbiB0aGUgY29ubmVjdGlvbiBoYXMgY2xvc2VkIG9yIGhhcyBmYWlsZWRcbiAgICAgICAgICAgIC8vIHRvIG9wZW4uXG4gICAgICAgICAgICAvLyBOb3RlIHRoYXQgc21vbGRvdCB3aWxsIHRoaW5rIHRoYXQgdGhlIGNvbm5lY3Rpb24gaXMgb3BlbiBldmVuIHdoZW4gaXQgaXMgc3RpbGwgb3BlbmluZy5cbiAgICAgICAgICAgIC8vIFRoZXJlZm9yZSB3ZSBkb24ndCBjYXJlIGFib3V0IGV2ZW50cyBjb25jZXJuaW5nIHRoZSBmYWN0IHRoYXQgdGhlIGNvbm5lY3Rpb24gaXMgbm93IGZ1bGx5XG4gICAgICAgICAgICAvLyBvcGVuLlxuICAgICAgICAgICAgcGMub25jb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSAoX2V2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHBjLmNvbm5lY3Rpb25TdGF0ZSA9PSBcImNsb3NlZFwiIHx8IHBjLmNvbm5lY3Rpb25TdGF0ZSA9PSBcImRpc2Nvbm5lY3RlZFwiIHx8IHBjLmNvbm5lY3Rpb25TdGF0ZSA9PSBcImZhaWxlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGtpbGxBbGxKcygpO1xuICAgICAgICAgICAgICAgICAgICBjb25maWcub25Db25uZWN0aW9uUmVzZXQoXCJXZWJSVEMgc3RhdGUgdHJhbnNpdGlvbmVkIHRvIFwiICsgcGMuY29ubmVjdGlvblN0YXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcGMub25uZWdvdGlhdGlvbm5lZWRlZCA9IChfZXZlbnQpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IG9mZmVyIGFuZCBzZXQgaXQgYXMgbG9jYWwgZGVzY3JpcHRpb24uXG4gICAgICAgICAgICAgICAgbGV0IHNkcE9mZmVyID0gKHlpZWxkIHBjLmNyZWF0ZU9mZmVyKCkpLnNkcDtcbiAgICAgICAgICAgICAgICAvLyBXZSBjaGVjayB0aGF0IHRoZSBsb2NhbGx5LWdlbmVyYXRlZCBTRFAgb2ZmZXIgaGFzIGEgZGF0YSBjaGFubmVsIHdpdGggdGhlIFVEUFxuICAgICAgICAgICAgICAgIC8vIHByb3RvY29sLiBJZiB0aGF0IGlzbid0IHRoZSBjYXNlLCB0aGUgY29ubmVjdGlvbiB3aWxsIGxpa2VseSBmYWlsLlxuICAgICAgICAgICAgICAgIGlmIChzZHBPZmZlci5tYXRjaCgvXm09YXBwbGljYXRpb24oXFxzKykoXFxkKykoXFxzKylVRFBcXC9EVExTXFwvU0NUUChcXHMrKXdlYnJ0Yy1kYXRhY2hhbm5lbCQvbSkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkxvY2FsIG9mZmVyIGRvZXNuJ3QgY29udGFpbiBVRFAgZGF0YSBjaGFubmVsLiBXZWJSVEMgY29ubmVjdGlvbnMgd2lsbCBsaWtlbHkgZmFpbC4gUGxlYXNlIHJlcG9ydCB0aGlzIGlzc3VlLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQWNjb3JkaW5nIHRvIHRoZSBsaWJwMnAgV2ViUlRDIHNwZWMsIHRoZSB1ZnJhZyBhbmQgcHdkIGFyZSB0aGUgc2FtZVxuICAgICAgICAgICAgICAgIC8vIHJhbmRvbWx5LWdlbmVyYXRlZCBzdHJpbmcgb24gYm90aCBzaWRlcywgYW5kIG11c3QgYmUgcHJlZml4ZWQgd2l0aFxuICAgICAgICAgICAgICAgIC8vIGBsaWJwMnAtd2VicnRjLXYxOmAuIFdlIG1vZGlmeSB0aGUgbG9jYWwgZGVzY3JpcHRpb24gdG8gZW5zdXJlIHRoYXQuXG4gICAgICAgICAgICAgICAgLy8gV2hpbGUgd2UgY291bGQgcmFuZG9tbHkgZ2VuZXJhdGUgYSBuZXcgc3RyaW5nLCB3ZSBqdXN0IGdyYWIgdGhlIG9uZSB0aGF0IHRoZVxuICAgICAgICAgICAgICAgIC8vIGJyb3dzZXIgaGFzIGdlbmVyYXRlZCwgaW4gb3JkZXIgdG8gbWFrZSBzdXJlIHRoYXQgaXQgcmVzcGVjdHMgdGhlIGNvbnN0cmFpbnRzXG4gICAgICAgICAgICAgICAgLy8gb2YgdGhlIElDRSBwcm90b2NvbC5cbiAgICAgICAgICAgICAgICBjb25zdCBicm93c2VyR2VuZXJhdGVkUHdkID0gKF9hID0gc2RwT2ZmZXIubWF0Y2goL15hPWljZS1wd2Q6KC4rKSQvbSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hdCgxKTtcbiAgICAgICAgICAgICAgICBpZiAoYnJvd3NlckdlbmVyYXRlZFB3ZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gc2V0IHVmcmFnIHRvIHB3ZC4gV2ViUlRDIGNvbm5lY3Rpb25zIHdpbGwgbGlrZWx5IGZhaWwuIFBsZWFzZSByZXBvcnQgdGhpcyBpc3N1ZS5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHVmcmFnUHdkID0gXCJsaWJwMnArd2VicnRjK3YxL1wiICsgYnJvd3NlckdlbmVyYXRlZFB3ZDtcbiAgICAgICAgICAgICAgICBzZHBPZmZlciA9IHNkcE9mZmVyLnJlcGxhY2UoL15hPWljZS11ZnJhZy4qJC9tLCAnYT1pY2UtdWZyYWc6JyArIHVmcmFnUHdkKTtcbiAgICAgICAgICAgICAgICBzZHBPZmZlciA9IHNkcE9mZmVyLnJlcGxhY2UoL15hPWljZS1wd2QuKiQvbSwgJ2E9aWNlLXB3ZDonICsgdWZyYWdQd2QpO1xuICAgICAgICAgICAgICAgIHlpZWxkIHBjLnNldExvY2FsRGVzY3JpcHRpb24oeyB0eXBlOiAnb2ZmZXInLCBzZHA6IHNkcE9mZmVyIH0pO1xuICAgICAgICAgICAgICAgIC8vIFRyYW5zZm9ybSBjZXJ0aWZpY2F0ZSBoYXNoIGludG8gZmluZ2VycHJpbnQgKHVwcGVyLWhleDsgZWFjaCBieXRlIHNlcGFyYXRlZCBieSBcIjpcIikuXG4gICAgICAgICAgICAgICAgY29uc3QgZmluZ2VycHJpbnQgPSBBcnJheS5mcm9tKHJlbW90ZUNlcnRTaGEyNTZIYXNoKS5tYXAoKG4pID0+IChcIjBcIiArIG4udG9TdHJpbmcoMTYpKS5zbGljZSgtMikudG9VcHBlckNhc2UoKSkuam9pbignOicpO1xuICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGUgdHJhaWxpbmcgbGluZSBmZWVkIGlzIGltcG9ydGFudCwgYXMgb3RoZXJ3aXNlIENocm9tZVxuICAgICAgICAgICAgICAgIC8vIGZhaWxzIHRvIHBhcnNlIHRoZSBwYXlsb2FkLlxuICAgICAgICAgICAgICAgIGNvbnN0IHJlbW90ZVNkcCA9IFxuICAgICAgICAgICAgICAgIC8vIFZlcnNpb24gb2YgdGhlIFNEUCBwcm90b2NvbC4gQWx3YXlzIDAuIChSRkM4ODY2KVxuICAgICAgICAgICAgICAgIFwidj0wXCIgKyBcIlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWRlbnRpZmllcyB0aGUgY3JlYXRvciBvZiB0aGUgU0RQIGRvY3VtZW50LiBXZSBhcmUgYWxsb3dlZCB0byB1c2UgZHVtbXkgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgIC8vIChgLWAgYW5kIGAwLjAuMC4wYCkgdG8gcmVtYWluIGFub255bW91cywgd2hpY2ggd2UgZG8uIE5vdGUgdGhhdCBcIklOXCIgbWVhbnNcbiAgICAgICAgICAgICAgICAgICAgLy8gXCJJbnRlcm5ldFwiIChhbmQgbm90IFwiaW5wdXRcIikuIChSRkM4ODY2KVxuICAgICAgICAgICAgICAgICAgICBcIm89LSAwIDAgSU4gSVBcIiArIGlwVmVyc2lvbiArIFwiIFwiICsgdGFyZ2V0SXAgKyBcIlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgLy8gTmFtZSBmb3IgdGhlIHNlc3Npb24uIFdlIGFyZSBhbGxvd2VkIHRvIHBhc3MgYSBkdW1teSBgLWAuIChSRkM4ODY2KVxuICAgICAgICAgICAgICAgICAgICBcInM9LVwiICsgXCJcXG5cIiArXG4gICAgICAgICAgICAgICAgICAgIC8vIFN0YXJ0IGFuZCBlbmQgb2YgdGhlIHZhbGlkaXR5IG9mIHRoZSBzZXNzaW9uLiBgMCAwYCBtZWFucyB0aGF0IHRoZSBzZXNzaW9uIG5ldmVyXG4gICAgICAgICAgICAgICAgICAgIC8vIGV4cGlyZXMuIChSRkM4ODY2KVxuICAgICAgICAgICAgICAgICAgICBcInQ9MCAwXCIgKyBcIlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBsaXRlIGltcGxlbWVudGF0aW9uIGlzIG9ubHkgYXBwcm9wcmlhdGUgZm9yIGRldmljZXMgdGhhdCB3aWxsXG4gICAgICAgICAgICAgICAgICAgIC8vIGFsd2F5cyBiZSBjb25uZWN0ZWQgdG8gdGhlIHB1YmxpYyBJbnRlcm5ldCBhbmQgaGF2ZSBhIHB1YmxpY1xuICAgICAgICAgICAgICAgICAgICAvLyBJUCBhZGRyZXNzIGF0IHdoaWNoIGl0IGNhbiByZWNlaXZlIHBhY2tldHMgZnJvbSBhbnlcbiAgICAgICAgICAgICAgICAgICAgLy8gY29ycmVzcG9uZGVudC4gIElDRSB3aWxsIG5vdCBmdW5jdGlvbiB3aGVuIGEgbGl0ZSBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgICAgICAgICAvLyBpcyBwbGFjZWQgYmVoaW5kIGEgTkFUIChSRkM4NDQ1KS5cbiAgICAgICAgICAgICAgICAgICAgXCJhPWljZS1saXRlXCIgKyBcIlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBgbT1gIGxpbmUgZGVzY3JpYmVzIGEgcmVxdWVzdCB0byBlc3RhYmxpc2ggYSBjZXJ0YWluIHByb3RvY29sLlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcHJvdG9jb2wgaW4gdGhpcyBsaW5lIChpLmUuIGBUQ1AvRFRMUy9TQ1RQYCBvciBgVURQL0RUTFMvU0NUUGApIG11c3QgYWx3YXlzIGJlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBzYW1lIGFzIHRoZSBvbmUgaW4gdGhlIG9mZmVyLiBXZSBrbm93IHRoYXQgdGhpcyBpcyB0cnVlIGJlY2F1c2UgY2hlY2tlZCBhYm92ZS5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGA8Zm10PmAgY29tcG9uZW50IG11c3QgYWx3YXlzIGJlIGB3ZWJydGMtZGF0YWNoYW5uZWxgIGZvciBXZWJSVEMuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZXN0IG9mIHRoZSBTRFAgcGF5bG9hZCBhZGRzIGF0dHJpYnV0ZXMgdG8gdGhpcyBzcGVjaWZpYyBtZWRpYSBzdHJlYW0uXG4gICAgICAgICAgICAgICAgICAgIC8vIFJGQ3M6IDg4MzksIDg4NjYsIDg4NDFcbiAgICAgICAgICAgICAgICAgICAgXCJtPWFwcGxpY2F0aW9uIFwiICsgdGFyZ2V0UG9ydCArIFwiIFwiICsgXCJVRFAvRFRMUy9TQ1RQIHdlYnJ0Yy1kYXRhY2hhbm5lbFwiICsgXCJcXG5cIiArXG4gICAgICAgICAgICAgICAgICAgIC8vIEluZGljYXRlcyB0aGUgSVAgYWRkcmVzcyBvZiB0aGUgcmVtb3RlLlxuICAgICAgICAgICAgICAgICAgICAvLyBOb3RlIHRoYXQgXCJJTlwiIG1lYW5zIFwiSW50ZXJuZXRcIiAoYW5kIG5vdCBcImlucHV0XCIpLlxuICAgICAgICAgICAgICAgICAgICBcImM9SU4gSVBcIiArIGlwVmVyc2lvbiArIFwiIFwiICsgdGFyZ2V0SXAgKyBcIlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWVkaWEgSUQgLSB1bmlxdWVseSBpZGVudGlmaWVzIHRoaXMgbWVkaWEgc3RyZWFtIChSRkM5MTQzKS5cbiAgICAgICAgICAgICAgICAgICAgXCJhPW1pZDowXCIgKyBcIlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW5kaWNhdGVzIHRoYXQgd2UgYXJlIGNvbXBseWluZyB3aXRoIFJGQzg4MzkgKGFzIG9wcHBvc2VkIHRvIHRoZSBsZWdhY3kgUkZDNTI0NSkuXG4gICAgICAgICAgICAgICAgICAgIFwiYT1pY2Utb3B0aW9uczppY2UyXCIgKyBcIlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgLy8gSUNFIHVzZXJuYW1lIGFuZCBwYXNzd29yZCwgd2hpY2ggYXJlIHVzZWQgZm9yIGVzdGFibGlzaGluZyBhbmRcbiAgICAgICAgICAgICAgICAgICAgLy8gbWFpbnRhaW5pbmcgdGhlIElDRSBjb25uZWN0aW9uLiAoUkZDODgzOSlcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlc2UgdmFsdWVzIGFyZSBzZXQgYWNjb3JkaW5nIHRvIHRoZSBsaWJwMnAgV2ViUlRDIHNwZWNpZmljYXRpb24uXG4gICAgICAgICAgICAgICAgICAgIFwiYT1pY2UtdWZyYWc6XCIgKyB1ZnJhZ1B3ZCArIFwiXFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICBcImE9aWNlLXB3ZDpcIiArIHVmcmFnUHdkICsgXCJcXG5cIiArXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbmdlcnByaW50IG9mIHRoZSBjZXJ0aWZpY2F0ZSB0aGF0IHRoZSBzZXJ2ZXIgd2lsbCB1c2UgZHVyaW5nIHRoZSBUTFNcbiAgICAgICAgICAgICAgICAgICAgLy8gaGFuZHNoYWtlLiAoUkZDODEyMilcbiAgICAgICAgICAgICAgICAgICAgLy8gTVVTVCBiZSBkZXJpdmVkIGZyb20gdGhlIGNlcnRpZmljYXRlIHVzZWQgYnkgdGhlIGFuc3dlcmVyIChzZXJ2ZXIpLlxuICAgICAgICAgICAgICAgICAgICBcImE9ZmluZ2VycHJpbnQ6c2hhLTI1NiBcIiArIGZpbmdlcnByaW50ICsgXCJcXG5cIiArXG4gICAgICAgICAgICAgICAgICAgIC8vIEluZGljYXRlcyB0aGF0IHRoZSByZW1vdGUgRFRMUyBzZXJ2ZXIgd2lsbCBvbmx5IGxpc3RlbiBmb3IgaW5jb21pbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gY29ubmVjdGlvbnMuIChSRkM1NzYzKVxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgYW5zd2VyZXIgKHNlcnZlcikgTVVTVCBub3QgYmUgbG9jYXRlZCBiZWhpbmQgYSBOQVQgKFJGQzYxMzUpLlxuICAgICAgICAgICAgICAgICAgICBcImE9c2V0dXA6cGFzc2l2ZVwiICsgXCJcXG5cIiArXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBTQ1RQIHBvcnQgKFJGQzg4NDEpXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGUgaXQncyBkaWZmZXJlbnQgZnJvbSB0aGUgXCJtPVwiIGxpbmUgcG9ydCB2YWx1ZSwgd2hpY2hcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5kaWNhdGVzIHRoZSBwb3J0IG9mIHRoZSB1bmRlcmx5aW5nIHRyYW5zcG9ydC1sYXllciBwcm90b2NvbFxuICAgICAgICAgICAgICAgICAgICAvLyAoVURQIG9yIFRDUClcbiAgICAgICAgICAgICAgICAgICAgXCJhPXNjdHAtcG9ydDo1MDAwXCIgKyBcIlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG1heGltdW0gU0NUUCB1c2VyIG1lc3NhZ2Ugc2l6ZSAoaW4gYnl0ZXMpIChSRkM4ODQxKVxuICAgICAgICAgICAgICAgICAgICAvLyBTZXR0aW5nIHRoaXMgZmllbGQgaXMgcGFydCBvZiB0aGUgbGlicDJwIHNwZWMuXG4gICAgICAgICAgICAgICAgICAgIFwiYT1tYXgtbWVzc2FnZS1zaXplOjE2Mzg0XCIgKyBcIlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSB0cmFuc3BvcnQgYWRkcmVzcyBmb3IgYSBjYW5kaWRhdGUgdGhhdCBjYW4gYmUgdXNlZCBmb3IgY29ubmVjdGl2aXR5XG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrcyAoUkZDODgzOSkuXG4gICAgICAgICAgICAgICAgICAgIFwiYT1jYW5kaWRhdGU6MSAxIFVEUCAxIFwiICsgdGFyZ2V0SXAgKyBcIiBcIiArIHRhcmdldFBvcnQgKyBcIiB0eXAgaG9zdFwiICsgXCJcXG5cIjtcbiAgICAgICAgICAgICAgICB5aWVsZCBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbih7IHR5cGU6IFwiYW5zd2VyXCIsIHNkcDogcmVtb3RlU2RwIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwYy5vbmRhdGFjaGFubmVsID0gKHsgY2hhbm5lbCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogaXMgdGhlIHN1YnN0cmVhbSBtYXliZSBhbHJlYWR5IG9wZW4/IGFjY29yZGluZyB0byB0aGUgSW50ZXJuZXQgaXQgc2VlbXMgdGhhdCBubyBidXQgaXQncyB1bmNsZWFyXG4gICAgICAgICAgICAgICAgYWRkQ2hhbm5lbChjaGFubmVsLCAnaW5ib3VuZCcpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIENyZWF0aW5nIGEgYFJUQ1BlZXJDb25uZWN0aW9uYCBkb2Vzbid0IGFjdHVhbGx5IGRvIGFueXRoaW5nIGJlZm9yZSBgY3JlYXRlRGF0YUNoYW5uZWxgIGlzXG4gICAgICAgICAgICAvLyBjYWxsZWQuIFNtb2xkb3QncyBBUEksIGhvd2V2ZXIsIHJlcXVpcmVzIHlvdSB0byB0cmVhdCBlbnRpcmUgY29ubmVjdGlvbnMgYXMgb3BlbiBvclxuICAgICAgICAgICAgLy8gY2xvc2VkLiBXZSBrbm93LCBhY2NvcmRpbmcgdG8gdGhlIGxpYnAycCBXZWJSVEMgc3BlY2lmaWNhdGlvbiwgdGhhdCBldmVyeSBjb25uZWN0aW9uXG4gICAgICAgICAgICAvLyBhbHdheXMgc3RhcnRzIHdpdGggYSBzdWJzdHJlYW0gd2hlcmUgYSBoYW5kc2hha2UgaXMgcGVyZm9ybWVkLiBBZnRlciB3ZSd2ZSByZXBvcnRlZCB0aGF0XG4gICAgICAgICAgICAvLyB0aGUgY29ubmVjdGlvbiBpcyBvcGVuLCBzbW9sZG90IHdpbGwgb3BlbiBhIHN1YnN0cmVhbSBpbiBvcmRlciB0byBwZXJmb3JtIHRoZSBoYW5kc2hha2UuXG4gICAgICAgICAgICAvLyBJbnN0ZWFkIG9mIGZvbGxvd2luZyB0aGlzIEFQSSwgd2Ugb3BlbiB0aGlzIHN1YnN0cmVhbSBpbiBhZHZhbmNlLCBhbmQgd2lsbCBub3RpZnkgc21vbGRvdFxuICAgICAgICAgICAgLy8gdGhhdCB0aGUgY29ubmVjdGlvbiBpcyBvcGVuIHdoZW4gdGhlIHN1YnN0cmVhbSBpcyBvcGVuLlxuICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHRoZSBsYWJlbCBwYXNzZWQgdG8gYGNyZWF0ZURhdGFDaGFubmVsYCBpcyByZXF1aXJlZCB0byBiZSBlbXB0eSBhcyBwZXIgdGhlXG4gICAgICAgICAgICAvLyBsaWJwMnAgV2ViUlRDIHNwZWNpZmljYXRpb24uXG4gICAgICAgICAgICBhZGRDaGFubmVsKHBjLmNyZWF0ZURhdGFDaGFubmVsKFwiXCIsIHsgaWQ6IDAsIG5lZ290aWF0ZWQ6IHRydWUgfSksICdmaXJzdC1vdXRib3VuZCcpO1xuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXNldDogKHN0cmVhbUlkKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gSWYgYHN0cmVhbUlkYCBpcyB1bmRlZmluZWQsIHRoZW4gdGhlIHdob2xlIGNvbm5lY3Rpb24gbXVzdCBiZSBkZXN0cm95ZWQuXG4gICAgICAgICAgICAgICAgaWYgKHN0cmVhbUlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAga2lsbEFsbEpzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGFubmVsID0gZGF0YUNoYW5uZWxzLmdldChzdHJlYW1JZCk7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWwuY2hhbm5lbC5vbm9wZW4gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsLmNoYW5uZWwub25lcnJvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWwuY2hhbm5lbC5vbmNsb3NlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC5jaGFubmVsLm9uYnVmZmVyZWRhbW91bnRsb3cgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsLmNoYW5uZWwub25tZXNzYWdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC5jaGFubmVsLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFDaGFubmVscy5kZWxldGUoc3RyZWFtSWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZW5kOiAoZGF0YSwgc3RyZWFtSWQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFubmVsID0gZGF0YUNoYW5uZWxzLmdldChzdHJlYW1JZCk7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5jaGFubmVsLnNlbmQoZGF0YSk7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5idWZmZXJlZEJ5dGVzICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsb3NlU2VuZDogKCkgPT4geyB0aHJvdyBuZXcgRXJyb3IoJ1dyb25nIGNvbm5lY3Rpb24gdHlwZScpOyB9LFxuICAgICAgICAgICAgb3Blbk91dFN1YnN0cmVhbTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGBvcGVuT3V0U3Vic3RyZWFtYCBjYW4gb25seSBiZSBjYWxsZWQgYWZ0ZXIgd2UgaGF2ZSBjYWxsZWQgYGNvbmZpZy5vbk9wZW5gLCB0aGVyZWZvcmVcbiAgICAgICAgICAgICAgICAvLyBgcGNgIGlzIGd1YXJhbnRlZWQgdG8gYmUgbm9uLW51bGwuXG4gICAgICAgICAgICAgICAgLy8gQXMgZXhwbGFpbmVkIGFib3ZlLCB3ZSBvcGVuIGEgZGF0YSBjaGFubmVsIGFoZWFkIG9mIHRpbWUuIElmIHRoaXMgZGF0YSBjaGFubmVsIGlzIHN0aWxsXG4gICAgICAgICAgICAgICAgLy8gdGhlcmUsIHdlIHJlcG9ydCBpdC5cbiAgICAgICAgICAgICAgICBpZiAoaGFuZHNoYWtlRGF0YUNoYW5uZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRG8gdGhpcyBhc3luY2hyb25vdXNseSBiZWNhdXNlIGNhbGxpbmcgY2FsbGJhY2tzIHdpdGhpbiBjYWxsYmFja3MgaXMgZXJyb3ItcHJvbmUuXG4gICAgICAgICAgICAgICAgICAgICgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGFnYWluIGlmIGBoYW5kc2hha2VEYXRhQ2hhbm5lbGAgaXMgc3RpbGwgZGVmaW5lZCwgYXMgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25uZWN0aW9uIG1pZ2h0IGhhdmUgYmVlbiBjbG9zZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZHNoYWtlRGF0YUNoYW5uZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcub25TdHJlYW1PcGVuZWQoaGFuZHNoYWtlRGF0YUNoYW5uZWwuaWQsICdvdXRib3VuZCcsIDEwMjQgKiAxMDI0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhQ2hhbm5lbHMuc2V0KGhhbmRzaGFrZURhdGFDaGFubmVsLmlkLCB7IGNoYW5uZWw6IGhhbmRzaGFrZURhdGFDaGFubmVsLCBidWZmZXJlZEJ5dGVzOiAwIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRzaGFrZURhdGFDaGFubmVsID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KSkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGUgbGFiZWwgcGFzc2VkIHRvIGBjcmVhdGVEYXRhQ2hhbm5lbGAgaXMgcmVxdWlyZWQgdG8gYmUgZW1wdHkgYXMgcGVyIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBsaWJwMnAgV2ViUlRDIHNwZWNpZmljYXRpb24uXG4gICAgICAgICAgICAgICAgICAgIGFkZENoYW5uZWwocGMuY3JlYXRlRGF0YUNoYW5uZWwoXCJcIiksICdvdXRib3VuZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBDb25uZWN0aW9uRXJyb3IoJ1VucmVjb2duaXplZCBtdWx0aWFkZHIgZm9ybWF0Jyk7XG4gICAgfVxufVxuLy8vIFBhcnNlcyBhIG11bHRpaGFzaC1tdWx0aWJhc2UtZW5jb2RlZCBzdHJpbmcgaW50byBhIFNIQTI1NiBoYXNoLlxuLy8vXG4vLy8gVGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiB0aGUgbXVsdGloYXNoIGFsZ29yaXRobSBpc24ndCBTSEEyNTYuXG5jb25zdCBtdWx0aWhhc2hUb1NoYTI1NiA9IChjZXJ0TXVsdGloYXNoKSA9PiB7XG4gICAgaWYgKGNlcnRNdWx0aWhhc2gubGVuZ3RoICE9IDM0IHx8IGNlcnRNdWx0aWhhc2hbMF0gIT0gMHgxMiB8fCBjZXJ0TXVsdGloYXNoWzFdICE9IDMyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2VydGlmaWNhdGUgbXVsdGloYXNoIGlzIG5vdCBTSEEtMjU2Jyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShjZXJ0TXVsdGloYXNoLnNsaWNlKDIpKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=