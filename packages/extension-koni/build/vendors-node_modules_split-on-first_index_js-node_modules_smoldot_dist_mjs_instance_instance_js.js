"use strict";
((typeof self !== 'undefined' ? self : this)["webpackChunk_subwallet_extension_koni"] = (typeof self !== 'undefined' ? self : this)["webpackChunk_subwallet_extension_koni"] || []).push([["vendors-node_modules_split-on-first_index_js-node_modules_smoldot_dist_mjs_instance_instance_js"],{

/***/ "../../node_modules/split-on-first/index.js":
/*!**************************************************!*\
  !*** ../../node_modules/split-on-first/index.js ***!
  \**************************************************/
/***/ ((module) => {



module.exports = (string, separator) => {
	if (!(typeof string === 'string' && typeof separator === 'string')) {
		throw new TypeError('Expected the arguments to be of type `string`');
	}

	if (separator === '') {
		return [string];
	}

	const separatorIndex = string.indexOf(separator);

	if (separatorIndex === -1) {
		return [string];
	}

	return [
		string.slice(0, separatorIndex),
		string.slice(separatorIndex + separator.length)
	];
};


/***/ }),

/***/ "../../node_modules/smoldot/dist/mjs/instance/buffer.js":
/*!**************************************************************!*\
  !*** ../../node_modules/smoldot/dist/mjs/instance/buffer.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "readUInt32LE": () => (/* binding */ readUInt32LE),
/* harmony export */   "utf8BytesToString": () => (/* binding */ utf8BytesToString),
/* harmony export */   "writeUInt32LE": () => (/* binding */ writeUInt32LE),
/* harmony export */   "writeUInt64LE": () => (/* binding */ writeUInt64LE),
/* harmony export */   "writeUInt8": () => (/* binding */ writeUInt8)
/* harmony export */ });
// Smoldot
// Copyright (C) 2019-2022  Parity Technologies (UK) Ltd.
// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
function utf8BytesToString(buffer, offset, length) {
    checkRange(buffer, offset, length);
    // The `TextDecoder` API is supported by all major browsers and by NodeJS.
    // <https://developer.mozilla.org/en-US/docs/Web/API/TextDecoder>
    return new TextDecoder().decode(buffer.slice(offset, offset + length));
}
function readUInt32LE(buffer, offset) {
    checkRange(buffer, offset, 4);
    return (buffer[offset] | (buffer[offset + 1] << 8) | (buffer[offset + 2] << 16)) + (buffer[offset + 3] * 0x1000000);
}
/**
 * Sets the value of a given byte in the buffer.
 *
 * This function is equivalent to `buffer[offset] = value`, except that an exception is thrown
 * if `offset` is out of range.
 */
function writeUInt8(buffer, offset, value) {
    checkRange(buffer, offset, 1);
    buffer[offset] = value & 0xff;
}
function writeUInt32LE(buffer, offset, value) {
    checkRange(buffer, offset, 4);
    buffer[offset + 3] = (value >>> 24) & 0xff;
    buffer[offset + 2] = (value >>> 16) & 0xff;
    buffer[offset + 1] = (value >>> 8) & 0xff;
    buffer[offset] = value & 0xff;
}
function writeUInt64LE(buffer, offset, value) {
    checkRange(buffer, offset, 8);
    buffer[offset + 7] = Number((value >> BigInt(56)) & BigInt(0xff));
    buffer[offset + 6] = Number((value >> BigInt(48)) & BigInt(0xff));
    buffer[offset + 5] = Number((value >> BigInt(40)) & BigInt(0xff));
    buffer[offset + 4] = Number((value >> BigInt(32)) & BigInt(0xff));
    buffer[offset + 3] = Number((value >> BigInt(24)) & BigInt(0xff));
    buffer[offset + 2] = Number((value >> BigInt(16)) & BigInt(0xff));
    buffer[offset + 1] = Number((value >> BigInt(8)) & BigInt(0xff));
    buffer[offset] = Number(value & BigInt(0xff));
}
function checkRange(buffer, offset, length) {
    if (!Number.isInteger(offset) || offset < 0)
        throw new RangeError();
    if (offset + length > buffer.length)
        throw new RangeError();
}


/***/ }),

/***/ "../../node_modules/smoldot/dist/mjs/instance/instance.js":
/*!****************************************************************!*\
  !*** ../../node_modules/smoldot/dist/mjs/instance/instance.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConnectionError": () => (/* reexport safe */ _raw_instance_js__WEBPACK_IMPORTED_MODULE_1__.ConnectionError),
/* harmony export */   "CrashError": () => (/* binding */ CrashError),
/* harmony export */   "MalformedJsonRpcError": () => (/* binding */ MalformedJsonRpcError),
/* harmony export */   "QueueFullError": () => (/* binding */ QueueFullError),
/* harmony export */   "start": () => (/* binding */ start)
/* harmony export */ });
/* harmony import */ var _buffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./buffer.js */ "../../node_modules/smoldot/dist/mjs/instance/buffer.js");
/* harmony import */ var _raw_instance_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./raw-instance.js */ "../../node_modules/smoldot/dist/mjs/instance/raw-instance.js");
/* harmony import */ var _client_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../client.js */ "../../node_modules/smoldot/dist/mjs/client.js");
// Smoldot
// Copyright (C) 2019-2022  Parity Technologies (UK) Ltd.
// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.




/**
 * Thrown in case the underlying client encounters an unexpected crash.
 *
 * This is always an internal bug in smoldot and is never supposed to happen.
 */
class CrashError extends Error {
    constructor(message) {
        super(message);
    }
}
/**
 * Thrown in case a malformed JSON-RPC request is sent.
 */
class MalformedJsonRpcError extends Error {
    constructor() {
        super("JSON-RPC request is malformed");
    }
}
/**
 * Thrown in case the buffer of JSON-RPC requests is full and cannot accept any more request.
 */
class QueueFullError extends Error {
    constructor() {
        super("JSON-RPC requests queue is full");
    }
}
function start(configMessage, platformBindings) {
    // This variable represents the state of the instance, and serves two different purposes:
    //
    // - At initialization, it is a Promise containing the Wasm VM is still initializing.
    // - After the Wasm VM has finished initialization, contains the `WebAssembly.Instance` object.
    //
    let state;
    const crashError = {};
    const currentTask = { name: null };
    const printError = { printError: true };
    // Contains the information of each chain that is currently alive.
    let chains = new Map();
    const initPromise = (() => __awaiter(this, void 0, void 0, function* () {
        const module = yield configMessage.wasmModule;
        // Start initialization of the Wasm VM.
        const config = {
            onWasmPanic: (message) => {
                // TODO: consider obtaining a backtrace here
                crashError.error = new CrashError(message);
                if (!printError.printError)
                    return;
                console.error("Smoldot has panicked" +
                    (currentTask.name ? (" while executing task `" + currentTask.name + "`") : "") +
                    ". This is a bug in smoldot. Please open an issue at " +
                    "https://github.com/smol-dot/smoldot/issues with the following message:\n" +
                    message);
                for (const chain of Array.from(chains.values())) {
                    for (const promise of chain.jsonRpcResponsesPromises) {
                        promise.reject(crashError.error);
                    }
                    chain.jsonRpcResponsesPromises = [];
                }
            },
            logCallback: (level, target, message) => {
                configMessage.logCallback(level, target, message);
            },
            wasmModule: module,
            jsonRpcResponsesNonEmptyCallback: (chainId) => {
                // Notify every single promise found in `jsonRpcResponsesPromises`.
                const promises = chains.get(chainId).jsonRpcResponsesPromises;
                while (promises.length !== 0) {
                    promises.shift().resolve();
                }
            },
            currentTaskCallback: (taskName) => {
                currentTask.name = taskName;
            },
            cpuRateLimit: configMessage.cpuRateLimit,
            maxLogLevel: configMessage.maxLogLevel,
        };
        return yield _raw_instance_js__WEBPACK_IMPORTED_MODULE_1__.startInstance(config, platformBindings);
    }))();
    state = {
        initialized: false, promise: initPromise.then(([instance, bufferIndices]) => {
            state = { initialized: true, instance, bufferIndices };
            return [instance, bufferIndices];
        })
    };
    function queueOperation(operation) {
        return __awaiter(this, void 0, void 0, function* () {
            // What to do depends on the type of `state`.
            // See the documentation of the `state` variable for information.
            if (!state.initialized) {
                // A message has been received while the Wasm VM is still initializing. Queue it for when
                // initialization is over.
                return state.promise.then(([instance, bufferIndices]) => operation(instance, bufferIndices));
            }
            else {
                // Everything is already initialized. Process the message synchronously.
                return operation(state.instance, state.bufferIndices);
            }
        });
    }
    return {
        request: (request, chainId) => {
            // Because `request` is passed as parameter an identifier returned by `addChain`, it is
            // always the case that the Wasm instance is already initialized. The only possibility for
            // it to not be the case is if the user completely invented the `chainId`.
            if (!state.initialized)
                throw new Error("Internal error");
            if (crashError.error)
                throw crashError.error;
            let retVal;
            try {
                state.bufferIndices[0] = new TextEncoder().encode(request);
                retVal = state.instance.exports.json_rpc_send(0, chainId) >>> 0;
            }
            catch (_error) {
                console.assert(crashError.error);
                throw crashError.error;
            }
            switch (retVal) {
                case 0: break;
                case 1: throw new MalformedJsonRpcError();
                case 2: throw new QueueFullError();
                default: throw new Error("Internal error: unknown json_rpc_send error code: " + retVal);
            }
        },
        nextJsonRpcResponse: (chainId) => __awaiter(this, void 0, void 0, function* () {
            // Because `nextJsonRpcResponse` is passed as parameter an identifier returned by `addChain`,
            // it is always the case that the Wasm instance is already initialized. The only possibility
            // for it to not be the case is if the user completely invented the `chainId`.
            if (!state.initialized)
                throw new Error("Internal error");
            while (true) {
                if (crashError.error)
                    throw crashError.error;
                // Try to pop a message from the queue.
                try {
                    const mem = new Uint8Array(state.instance.exports.memory.buffer);
                    const responseInfo = state.instance.exports.json_rpc_responses_peek(chainId) >>> 0;
                    const ptr = _buffer_js__WEBPACK_IMPORTED_MODULE_0__.readUInt32LE(mem, responseInfo) >>> 0;
                    const len = _buffer_js__WEBPACK_IMPORTED_MODULE_0__.readUInt32LE(mem, responseInfo + 4) >>> 0;
                    // `len === 0` means "queue is empty" according to the API.
                    // In that situation, queue the resolve/reject.
                    if (len !== 0) {
                        const message = _buffer_js__WEBPACK_IMPORTED_MODULE_0__.utf8BytesToString(mem, ptr, len);
                        state.instance.exports.json_rpc_responses_pop(chainId);
                        return message;
                    }
                }
                catch (_error) {
                    console.assert(crashError.error);
                    throw crashError.error;
                }
                // If no message is available, wait for one to be.
                yield new Promise((resolve, reject) => {
                    chains.get(chainId).jsonRpcResponsesPromises.push({ resolve: () => resolve(undefined), reject });
                });
            }
        }),
        addChain: (chainSpec, databaseContent, potentialRelayChains, disableJsonRpc) => {
            return queueOperation((instance, bufferIndices) => {
                if (crashError.error)
                    throw crashError.error;
                try {
                    // `add_chain` unconditionally allocates a chain id. If an error occurs, however, this chain
                    // id will refer to an *erroneous* chain. `chain_is_ok` is used below to determine whether it
                    // has succeeeded or not.
                    // Note that `add_chain` properly de-allocates buffers even if it failed.
                    bufferIndices[0] = new TextEncoder().encode(chainSpec);
                    bufferIndices[1] = new TextEncoder().encode(databaseContent);
                    const potentialRelayChainsEncoded = new Uint8Array(potentialRelayChains.length * 4);
                    for (let idx = 0; idx < potentialRelayChains.length; ++idx) {
                        _buffer_js__WEBPACK_IMPORTED_MODULE_0__.writeUInt32LE(potentialRelayChainsEncoded, idx * 4, potentialRelayChains[idx]);
                    }
                    bufferIndices[2] = potentialRelayChainsEncoded;
                    const chainId = instance.exports.add_chain(0, 1, disableJsonRpc ? 0 : 1, 2);
                    delete bufferIndices[0];
                    delete bufferIndices[1];
                    delete bufferIndices[2];
                    if (instance.exports.chain_is_ok(chainId) != 0) {
                        console.assert(!chains.has(chainId));
                        chains.set(chainId, {
                            jsonRpcResponsesPromises: new Array()
                        });
                        return { success: true, chainId };
                    }
                    else {
                        const errorMsgLen = instance.exports.chain_error_len(chainId) >>> 0;
                        const errorMsgPtr = instance.exports.chain_error_ptr(chainId) >>> 0;
                        const errorMsg = _buffer_js__WEBPACK_IMPORTED_MODULE_0__.utf8BytesToString(new Uint8Array(instance.exports.memory.buffer), errorMsgPtr, errorMsgLen);
                        instance.exports.remove_chain(chainId);
                        return { success: false, error: errorMsg };
                    }
                }
                catch (_error) {
                    console.assert(crashError.error);
                    throw crashError.error;
                }
            });
        },
        removeChain: (chainId) => {
            // Because `removeChain` is passed as parameter an identifier returned by `addChain`, it is
            // always the case that the Wasm instance is already initialized. The only possibility for
            // it to not be the case is if the user completely invented the `chainId`.
            if (!state.initialized)
                throw new Error("Internal error");
            if (crashError.error)
                throw crashError.error;
            // Removing the chain synchronously avoids having to deal with race conditions such as a
            // JSON-RPC response corresponding to a chain that is going to be deleted but hasn't been yet.
            // These kind of race conditions are already delt with within smoldot.
            console.assert(chains.has(chainId));
            for (const { reject } of chains.get(chainId).jsonRpcResponsesPromises) {
                reject(new _client_js__WEBPACK_IMPORTED_MODULE_2__.AlreadyDestroyedError());
            }
            chains.delete(chainId);
            try {
                state.instance.exports.remove_chain(chainId);
            }
            catch (_error) {
                console.assert(crashError.error);
                throw crashError.error;
            }
        },
        startShutdown: () => {
            return queueOperation((instance) => {
                // `startShutdown` is a bit special in its handling of crashes.
                // Shutting down will lead to `onWasmPanic` being called at some point, possibly during
                // the call to `start_shutdown` itself. As such, we move into "don't print errors anymore"
                // mode even before calling `start_shutdown`.
                //
                // Furthermore, if a crash happened in the past, there is no point in throwing an
                // exception when the user wants the shutdown to happen.
                if (crashError.error)
                    return;
                try {
                    printError.printError = false;
                    instance.exports.start_shutdown();
                }
                catch (_error) {
                }
            });
        }
    };
}


/***/ }),

/***/ "../../node_modules/smoldot/dist/mjs/instance/raw-instance.js":
/*!********************************************************************!*\
  !*** ../../node_modules/smoldot/dist/mjs/instance/raw-instance.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConnectionError": () => (/* reexport safe */ _bindings_smoldot_light_js__WEBPACK_IMPORTED_MODULE_0__.ConnectionError),
/* harmony export */   "startInstance": () => (/* binding */ startInstance)
/* harmony export */ });
/* harmony import */ var _bindings_smoldot_light_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bindings-smoldot-light.js */ "../../node_modules/smoldot/dist/mjs/instance/bindings-smoldot-light.js");
/* harmony import */ var _bindings_wasi_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bindings-wasi.js */ "../../node_modules/smoldot/dist/mjs/instance/bindings-wasi.js");
// Smoldot
// Copyright (C) 2019-2022  Parity Technologies (UK) Ltd.
// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.



function startInstance(config, platformBindings) {
    return __awaiter(this, void 0, void 0, function* () {
        let killAll;
        const bufferIndices = new Array;
        // Callback called when `advance_execution_ready` is called by the Rust code, if any.
        const advanceExecutionPromise = { value: null };
        // Used to bind with the smoldot-light bindings. See the `bindings-smoldot-light.js` file.
        const smoldotJsConfig = Object.assign({ bufferIndices, connect: platformBindings.connect, onPanic: (message) => {
                killAll();
                config.onWasmPanic(message);
                throw new Error();
            }, advanceExecutionReadyCallback: () => {
                if (advanceExecutionPromise.value)
                    advanceExecutionPromise.value();
                advanceExecutionPromise.value = null;
            } }, config);
        // Used to bind with the Wasi bindings. See the `bindings-wasi.js` file.
        const wasiConfig = {
            envVars: [],
            getRandomValues: platformBindings.getRandomValues,
            performanceNow: platformBindings.performanceNow,
            onProcExit: (retCode) => {
                killAll();
                config.onWasmPanic(`proc_exit called: ${retCode}`);
                throw new Error();
            }
        };
        const { imports: smoldotBindings, killAll: smoldotBindingsKillAll } = (0,_bindings_smoldot_light_js__WEBPACK_IMPORTED_MODULE_0__["default"])(smoldotJsConfig);
        killAll = smoldotBindingsKillAll;
        // Start the Wasm virtual machine.
        // The Rust code defines a list of imports that must be fulfilled by the environment. The second
        // parameter provides their implementations.
        const result = yield WebAssembly.instantiate(config.wasmModule, {
            // The functions with the "smoldot" prefix are specific to smoldot.
            "smoldot": smoldotBindings,
            // As the Rust code is compiled for wasi, some more wasi-specific imports exist.
            "wasi_snapshot_preview1": (0,_bindings_wasi_js__WEBPACK_IMPORTED_MODULE_1__["default"])(wasiConfig),
        });
        const instance = result;
        smoldotJsConfig.instance = instance;
        wasiConfig.instance = instance;
        // Smoldot requires an initial call to the `init` function in order to do its internal
        // configuration.
        instance.exports.init(config.maxLogLevel);
        (() => __awaiter(this, void 0, void 0, function* () {
            // In order to avoid calling `setTimeout` too often, we accumulate sleep up until
            // a certain threshold.
            let missingSleep = 0;
            // Extract (to make sure the value doesn't change) and sanitize `cpuRateLimit`.
            let cpuRateLimit = config.cpuRateLimit;
            if (isNaN(cpuRateLimit))
                cpuRateLimit = 1.0;
            if (cpuRateLimit > 1.0)
                cpuRateLimit = 1.0;
            if (cpuRateLimit < 0.0)
                cpuRateLimit = 0.0;
            const periodicallyYield = { value: false };
            const [periodicallyYieldInit, unregisterCallback] = platformBindings.registerShouldPeriodicallyYield((newValue) => {
                periodicallyYield.value = newValue;
            });
            periodicallyYield.value = periodicallyYieldInit;
            let now = platformBindings.performanceNow();
            while (true) {
                const whenReadyAgain = new Promise((resolve) => advanceExecutionPromise.value = resolve);
                const outcome = instance.exports.advance_execution();
                if (outcome === 0) {
                    unregisterCallback();
                    break;
                }
                const afterExec = platformBindings.performanceNow();
                const elapsed = afterExec - now;
                now = afterExec;
                // In order to enforce the rate limiting, we stop executing for a certain
                // amount of time.
                // The base equation here is: `(sleep + elapsed) * rateLimit == elapsed`,
                // from which the calculation below is derived.
                const sleep = elapsed * (1.0 / cpuRateLimit - 1.0);
                missingSleep += sleep;
                if (missingSleep > (periodicallyYield ? 5 : 1000)) {
                    // `setTimeout` has a maximum value, after which it will overflow. 🤦
                    // See <https://developer.mozilla.org/en-US/docs/Web/API/setTimeout#maximum_delay_value>
                    // While adding a cap technically skews the CPU rate limiting algorithm, we don't
                    // really care for such extreme values.
                    if (missingSleep > 2147483646) // Doc says `> 2147483647`, but I don't really trust their pedanticism so let's be safe
                        missingSleep = 2147483646;
                    yield new Promise((resolve) => setTimeout(resolve, missingSleep));
                    missingSleep = 0;
                }
                yield whenReadyAgain;
                const afterWait = platformBindings.performanceNow();
                missingSleep -= (afterWait - now);
                if (missingSleep < 0)
                    missingSleep = 0;
                now = afterWait;
            }
        }))();
        return [instance, bufferIndices];
    });
}


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfc3BsaXQtb24tZmlyc3RfaW5kZXhfanMtbm9kZV9tb2R1bGVzX3Ntb2xkb3RfZGlzdF9tanNfaW5zdGFuY2VfaW5zdGFuY2VfanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeERBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFJLElBQUksU0FBSTtBQUM3Qiw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDc0M7QUFDUTtBQUNPO0FBQ0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMkRBQXNCO0FBQzNDLEtBQUs7QUFDTDtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msb0RBQW1CO0FBQ25ELGdDQUFnQyxvREFBbUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHlEQUF3QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSwyQ0FBMkM7QUFDbkgsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxtQ0FBbUM7QUFDekUsd0JBQXdCLHFEQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMseURBQXdCO0FBQ2pFO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFNBQVM7QUFDbEMsMkJBQTJCLDZEQUFxQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzVRQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBSSxJQUFJLFNBQUk7QUFDN0IsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ3FGO0FBQ2pCO0FBQ047QUFDdkQ7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFFBQVE7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDREQUE0RCxFQUFFLHNFQUEyQjtBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDZEQUFtQjtBQUN6RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTCIsInNvdXJjZXMiOlsid2VicGFjazovL0BzdWJ3YWxsZXQvZXh0ZW5zaW9uLWtvbmkvLi4vLi4vbm9kZV9tb2R1bGVzL3NwbGl0LW9uLWZpcnN0L2luZGV4LmpzIiwid2VicGFjazovL0BzdWJ3YWxsZXQvZXh0ZW5zaW9uLWtvbmkvLi4vLi4vbm9kZV9tb2R1bGVzL3Ntb2xkb3QvZGlzdC9tanMvaW5zdGFuY2UvYnVmZmVyLmpzIiwid2VicGFjazovL0BzdWJ3YWxsZXQvZXh0ZW5zaW9uLWtvbmkvLi4vLi4vbm9kZV9tb2R1bGVzL3Ntb2xkb3QvZGlzdC9tanMvaW5zdGFuY2UvaW5zdGFuY2UuanMiLCJ3ZWJwYWNrOi8vQHN1YndhbGxldC9leHRlbnNpb24ta29uaS8uLi8uLi9ub2RlX21vZHVsZXMvc21vbGRvdC9kaXN0L21qcy9pbnN0YW5jZS9yYXctaW5zdGFuY2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChzdHJpbmcsIHNlcGFyYXRvcikgPT4ge1xuXHRpZiAoISh0eXBlb2Ygc3RyaW5nID09PSAnc3RyaW5nJyAmJiB0eXBlb2Ygc2VwYXJhdG9yID09PSAnc3RyaW5nJykpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCB0aGUgYXJndW1lbnRzIHRvIGJlIG9mIHR5cGUgYHN0cmluZ2AnKTtcblx0fVxuXG5cdGlmIChzZXBhcmF0b3IgPT09ICcnKSB7XG5cdFx0cmV0dXJuIFtzdHJpbmddO1xuXHR9XG5cblx0Y29uc3Qgc2VwYXJhdG9ySW5kZXggPSBzdHJpbmcuaW5kZXhPZihzZXBhcmF0b3IpO1xuXG5cdGlmIChzZXBhcmF0b3JJbmRleCA9PT0gLTEpIHtcblx0XHRyZXR1cm4gW3N0cmluZ107XG5cdH1cblxuXHRyZXR1cm4gW1xuXHRcdHN0cmluZy5zbGljZSgwLCBzZXBhcmF0b3JJbmRleCksXG5cdFx0c3RyaW5nLnNsaWNlKHNlcGFyYXRvckluZGV4ICsgc2VwYXJhdG9yLmxlbmd0aClcblx0XTtcbn07XG4iLCIvLyBTbW9sZG90XG4vLyBDb3B5cmlnaHQgKEMpIDIwMTktMjAyMiAgUGFyaXR5IFRlY2hub2xvZ2llcyAoVUspIEx0ZC5cbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBHUEwtMy4wLW9yLWxhdGVyIFdJVEggQ2xhc3NwYXRoLWV4Y2VwdGlvbi0yLjBcbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3Jcbi8vIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhCeXRlc1RvU3RyaW5nKGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICBjaGVja1JhbmdlKGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgpO1xuICAgIC8vIFRoZSBgVGV4dERlY29kZXJgIEFQSSBpcyBzdXBwb3J0ZWQgYnkgYWxsIG1ham9yIGJyb3dzZXJzIGFuZCBieSBOb2RlSlMuXG4gICAgLy8gPGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9UZXh0RGVjb2Rlcj5cbiAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGxlbmd0aCkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlYWRVSW50MzJMRShidWZmZXIsIG9mZnNldCkge1xuICAgIGNoZWNrUmFuZ2UoYnVmZmVyLCBvZmZzZXQsIDQpO1xuICAgIHJldHVybiAoYnVmZmVyW29mZnNldF0gfCAoYnVmZmVyW29mZnNldCArIDFdIDw8IDgpIHwgKGJ1ZmZlcltvZmZzZXQgKyAyXSA8PCAxNikpICsgKGJ1ZmZlcltvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMCk7XG59XG4vKipcbiAqIFNldHMgdGhlIHZhbHVlIG9mIGEgZ2l2ZW4gYnl0ZSBpbiB0aGUgYnVmZmVyLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgZXF1aXZhbGVudCB0byBgYnVmZmVyW29mZnNldF0gPSB2YWx1ZWAsIGV4Y2VwdCB0aGF0IGFuIGV4Y2VwdGlvbiBpcyB0aHJvd25cbiAqIGlmIGBvZmZzZXRgIGlzIG91dCBvZiByYW5nZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdyaXRlVUludDgoYnVmZmVyLCBvZmZzZXQsIHZhbHVlKSB7XG4gICAgY2hlY2tSYW5nZShidWZmZXIsIG9mZnNldCwgMSk7XG4gICAgYnVmZmVyW29mZnNldF0gPSB2YWx1ZSAmIDB4ZmY7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JpdGVVSW50MzJMRShidWZmZXIsIG9mZnNldCwgdmFsdWUpIHtcbiAgICBjaGVja1JhbmdlKGJ1ZmZlciwgb2Zmc2V0LCA0KTtcbiAgICBidWZmZXJbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KSAmIDB4ZmY7XG4gICAgYnVmZmVyW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNikgJiAweGZmO1xuICAgIGJ1ZmZlcltvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOCkgJiAweGZmO1xuICAgIGJ1ZmZlcltvZmZzZXRdID0gdmFsdWUgJiAweGZmO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyaXRlVUludDY0TEUoYnVmZmVyLCBvZmZzZXQsIHZhbHVlKSB7XG4gICAgY2hlY2tSYW5nZShidWZmZXIsIG9mZnNldCwgOCk7XG4gICAgYnVmZmVyW29mZnNldCArIDddID0gTnVtYmVyKCh2YWx1ZSA+PiBCaWdJbnQoNTYpKSAmIEJpZ0ludCgweGZmKSk7XG4gICAgYnVmZmVyW29mZnNldCArIDZdID0gTnVtYmVyKCh2YWx1ZSA+PiBCaWdJbnQoNDgpKSAmIEJpZ0ludCgweGZmKSk7XG4gICAgYnVmZmVyW29mZnNldCArIDVdID0gTnVtYmVyKCh2YWx1ZSA+PiBCaWdJbnQoNDApKSAmIEJpZ0ludCgweGZmKSk7XG4gICAgYnVmZmVyW29mZnNldCArIDRdID0gTnVtYmVyKCh2YWx1ZSA+PiBCaWdJbnQoMzIpKSAmIEJpZ0ludCgweGZmKSk7XG4gICAgYnVmZmVyW29mZnNldCArIDNdID0gTnVtYmVyKCh2YWx1ZSA+PiBCaWdJbnQoMjQpKSAmIEJpZ0ludCgweGZmKSk7XG4gICAgYnVmZmVyW29mZnNldCArIDJdID0gTnVtYmVyKCh2YWx1ZSA+PiBCaWdJbnQoMTYpKSAmIEJpZ0ludCgweGZmKSk7XG4gICAgYnVmZmVyW29mZnNldCArIDFdID0gTnVtYmVyKCh2YWx1ZSA+PiBCaWdJbnQoOCkpICYgQmlnSW50KDB4ZmYpKTtcbiAgICBidWZmZXJbb2Zmc2V0XSA9IE51bWJlcih2YWx1ZSAmIEJpZ0ludCgweGZmKSk7XG59XG5mdW5jdGlvbiBjaGVja1JhbmdlKGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIob2Zmc2V0KSB8fCBvZmZzZXQgPCAwKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigpO1xuICAgIGlmIChvZmZzZXQgKyBsZW5ndGggPiBidWZmZXIubGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigpO1xufVxuIiwiLy8gU21vbGRvdFxuLy8gQ29weXJpZ2h0IChDKSAyMDE5LTIwMjIgIFBhcml0eSBUZWNobm9sb2dpZXMgKFVLKSBMdGQuXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogR1BMLTMuMC1vci1sYXRlciBXSVRIIENsYXNzcGF0aC1leGNlcHRpb24tMi4wXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3Jcbi8vIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuaW1wb3J0ICogYXMgYnVmZmVyIGZyb20gJy4vYnVmZmVyLmpzJztcbmltcG9ydCAqIGFzIGluc3RhbmNlIGZyb20gJy4vcmF3LWluc3RhbmNlLmpzJztcbmltcG9ydCB7IEFscmVhZHlEZXN0cm95ZWRFcnJvciB9IGZyb20gJy4uL2NsaWVudC5qcyc7XG5leHBvcnQgeyBDb25uZWN0aW9uRXJyb3IgfSBmcm9tICcuL3Jhdy1pbnN0YW5jZS5qcyc7XG4vKipcbiAqIFRocm93biBpbiBjYXNlIHRoZSB1bmRlcmx5aW5nIGNsaWVudCBlbmNvdW50ZXJzIGFuIHVuZXhwZWN0ZWQgY3Jhc2guXG4gKlxuICogVGhpcyBpcyBhbHdheXMgYW4gaW50ZXJuYWwgYnVnIGluIHNtb2xkb3QgYW5kIGlzIG5ldmVyIHN1cHBvc2VkIHRvIGhhcHBlbi5cbiAqL1xuZXhwb3J0IGNsYXNzIENyYXNoRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biBpbiBjYXNlIGEgbWFsZm9ybWVkIEpTT04tUlBDIHJlcXVlc3QgaXMgc2VudC5cbiAqL1xuZXhwb3J0IGNsYXNzIE1hbGZvcm1lZEpzb25ScGNFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJKU09OLVJQQyByZXF1ZXN0IGlzIG1hbGZvcm1lZFwiKTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biBpbiBjYXNlIHRoZSBidWZmZXIgb2YgSlNPTi1SUEMgcmVxdWVzdHMgaXMgZnVsbCBhbmQgY2Fubm90IGFjY2VwdCBhbnkgbW9yZSByZXF1ZXN0LlxuICovXG5leHBvcnQgY2xhc3MgUXVldWVGdWxsRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFwiSlNPTi1SUEMgcmVxdWVzdHMgcXVldWUgaXMgZnVsbFwiKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gc3RhcnQoY29uZmlnTWVzc2FnZSwgcGxhdGZvcm1CaW5kaW5ncykge1xuICAgIC8vIFRoaXMgdmFyaWFibGUgcmVwcmVzZW50cyB0aGUgc3RhdGUgb2YgdGhlIGluc3RhbmNlLCBhbmQgc2VydmVzIHR3byBkaWZmZXJlbnQgcHVycG9zZXM6XG4gICAgLy9cbiAgICAvLyAtIEF0IGluaXRpYWxpemF0aW9uLCBpdCBpcyBhIFByb21pc2UgY29udGFpbmluZyB0aGUgV2FzbSBWTSBpcyBzdGlsbCBpbml0aWFsaXppbmcuXG4gICAgLy8gLSBBZnRlciB0aGUgV2FzbSBWTSBoYXMgZmluaXNoZWQgaW5pdGlhbGl6YXRpb24sIGNvbnRhaW5zIHRoZSBgV2ViQXNzZW1ibHkuSW5zdGFuY2VgIG9iamVjdC5cbiAgICAvL1xuICAgIGxldCBzdGF0ZTtcbiAgICBjb25zdCBjcmFzaEVycm9yID0ge307XG4gICAgY29uc3QgY3VycmVudFRhc2sgPSB7IG5hbWU6IG51bGwgfTtcbiAgICBjb25zdCBwcmludEVycm9yID0geyBwcmludEVycm9yOiB0cnVlIH07XG4gICAgLy8gQ29udGFpbnMgdGhlIGluZm9ybWF0aW9uIG9mIGVhY2ggY2hhaW4gdGhhdCBpcyBjdXJyZW50bHkgYWxpdmUuXG4gICAgbGV0IGNoYWlucyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBpbml0UHJvbWlzZSA9ICgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IG1vZHVsZSA9IHlpZWxkIGNvbmZpZ01lc3NhZ2Uud2FzbU1vZHVsZTtcbiAgICAgICAgLy8gU3RhcnQgaW5pdGlhbGl6YXRpb24gb2YgdGhlIFdhc20gVk0uXG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgICAgIG9uV2FzbVBhbmljOiAobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGNvbnNpZGVyIG9idGFpbmluZyBhIGJhY2t0cmFjZSBoZXJlXG4gICAgICAgICAgICAgICAgY3Jhc2hFcnJvci5lcnJvciA9IG5ldyBDcmFzaEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGlmICghcHJpbnRFcnJvci5wcmludEVycm9yKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlNtb2xkb3QgaGFzIHBhbmlja2VkXCIgK1xuICAgICAgICAgICAgICAgICAgICAoY3VycmVudFRhc2submFtZSA/IChcIiB3aGlsZSBleGVjdXRpbmcgdGFzayBgXCIgKyBjdXJyZW50VGFzay5uYW1lICsgXCJgXCIpIDogXCJcIikgK1xuICAgICAgICAgICAgICAgICAgICBcIi4gVGhpcyBpcyBhIGJ1ZyBpbiBzbW9sZG90LiBQbGVhc2Ugb3BlbiBhbiBpc3N1ZSBhdCBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiaHR0cHM6Ly9naXRodWIuY29tL3Ntb2wtZG90L3Ntb2xkb3QvaXNzdWVzIHdpdGggdGhlIGZvbGxvd2luZyBtZXNzYWdlOlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjaGFpbiBvZiBBcnJheS5mcm9tKGNoYWlucy52YWx1ZXMoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBwcm9taXNlIG9mIGNoYWluLmpzb25ScGNSZXNwb25zZXNQcm9taXNlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5yZWplY3QoY3Jhc2hFcnJvci5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2hhaW4uanNvblJwY1Jlc3BvbnNlc1Byb21pc2VzID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxvZ0NhbGxiYWNrOiAobGV2ZWwsIHRhcmdldCwgbWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbmZpZ01lc3NhZ2UubG9nQ2FsbGJhY2sobGV2ZWwsIHRhcmdldCwgbWVzc2FnZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgd2FzbU1vZHVsZTogbW9kdWxlLFxuICAgICAgICAgICAganNvblJwY1Jlc3BvbnNlc05vbkVtcHR5Q2FsbGJhY2s6IChjaGFpbklkKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gTm90aWZ5IGV2ZXJ5IHNpbmdsZSBwcm9taXNlIGZvdW5kIGluIGBqc29uUnBjUmVzcG9uc2VzUHJvbWlzZXNgLlxuICAgICAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gY2hhaW5zLmdldChjaGFpbklkKS5qc29uUnBjUmVzcG9uc2VzUHJvbWlzZXM7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHByb21pc2VzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5zaGlmdCgpLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY3VycmVudFRhc2tDYWxsYmFjazogKHRhc2tOYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgY3VycmVudFRhc2submFtZSA9IHRhc2tOYW1lO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNwdVJhdGVMaW1pdDogY29uZmlnTWVzc2FnZS5jcHVSYXRlTGltaXQsXG4gICAgICAgICAgICBtYXhMb2dMZXZlbDogY29uZmlnTWVzc2FnZS5tYXhMb2dMZXZlbCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHlpZWxkIGluc3RhbmNlLnN0YXJ0SW5zdGFuY2UoY29uZmlnLCBwbGF0Zm9ybUJpbmRpbmdzKTtcbiAgICB9KSkoKTtcbiAgICBzdGF0ZSA9IHtcbiAgICAgICAgaW5pdGlhbGl6ZWQ6IGZhbHNlLCBwcm9taXNlOiBpbml0UHJvbWlzZS50aGVuKChbaW5zdGFuY2UsIGJ1ZmZlckluZGljZXNdKSA9PiB7XG4gICAgICAgICAgICBzdGF0ZSA9IHsgaW5pdGlhbGl6ZWQ6IHRydWUsIGluc3RhbmNlLCBidWZmZXJJbmRpY2VzIH07XG4gICAgICAgICAgICByZXR1cm4gW2luc3RhbmNlLCBidWZmZXJJbmRpY2VzXTtcbiAgICAgICAgfSlcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHF1ZXVlT3BlcmF0aW9uKG9wZXJhdGlvbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gV2hhdCB0byBkbyBkZXBlbmRzIG9uIHRoZSB0eXBlIG9mIGBzdGF0ZWAuXG4gICAgICAgICAgICAvLyBTZWUgdGhlIGRvY3VtZW50YXRpb24gb2YgdGhlIGBzdGF0ZWAgdmFyaWFibGUgZm9yIGluZm9ybWF0aW9uLlxuICAgICAgICAgICAgaWYgKCFzdGF0ZS5pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICAgIC8vIEEgbWVzc2FnZSBoYXMgYmVlbiByZWNlaXZlZCB3aGlsZSB0aGUgV2FzbSBWTSBpcyBzdGlsbCBpbml0aWFsaXppbmcuIFF1ZXVlIGl0IGZvciB3aGVuXG4gICAgICAgICAgICAgICAgLy8gaW5pdGlhbGl6YXRpb24gaXMgb3Zlci5cbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGUucHJvbWlzZS50aGVuKChbaW5zdGFuY2UsIGJ1ZmZlckluZGljZXNdKSA9PiBvcGVyYXRpb24oaW5zdGFuY2UsIGJ1ZmZlckluZGljZXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEV2ZXJ5dGhpbmcgaXMgYWxyZWFkeSBpbml0aWFsaXplZC4gUHJvY2VzcyB0aGUgbWVzc2FnZSBzeW5jaHJvbm91c2x5LlxuICAgICAgICAgICAgICAgIHJldHVybiBvcGVyYXRpb24oc3RhdGUuaW5zdGFuY2UsIHN0YXRlLmJ1ZmZlckluZGljZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVxdWVzdDogKHJlcXVlc3QsIGNoYWluSWQpID0+IHtcbiAgICAgICAgICAgIC8vIEJlY2F1c2UgYHJlcXVlc3RgIGlzIHBhc3NlZCBhcyBwYXJhbWV0ZXIgYW4gaWRlbnRpZmllciByZXR1cm5lZCBieSBgYWRkQ2hhaW5gLCBpdCBpc1xuICAgICAgICAgICAgLy8gYWx3YXlzIHRoZSBjYXNlIHRoYXQgdGhlIFdhc20gaW5zdGFuY2UgaXMgYWxyZWFkeSBpbml0aWFsaXplZC4gVGhlIG9ubHkgcG9zc2liaWxpdHkgZm9yXG4gICAgICAgICAgICAvLyBpdCB0byBub3QgYmUgdGhlIGNhc2UgaXMgaWYgdGhlIHVzZXIgY29tcGxldGVseSBpbnZlbnRlZCB0aGUgYGNoYWluSWRgLlxuICAgICAgICAgICAgaWYgKCFzdGF0ZS5pbml0aWFsaXplZClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnRlcm5hbCBlcnJvclwiKTtcbiAgICAgICAgICAgIGlmIChjcmFzaEVycm9yLmVycm9yKVxuICAgICAgICAgICAgICAgIHRocm93IGNyYXNoRXJyb3IuZXJyb3I7XG4gICAgICAgICAgICBsZXQgcmV0VmFsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5idWZmZXJJbmRpY2VzWzBdID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgIHJldFZhbCA9IHN0YXRlLmluc3RhbmNlLmV4cG9ydHMuanNvbl9ycGNfc2VuZCgwLCBjaGFpbklkKSA+Pj4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydChjcmFzaEVycm9yLmVycm9yKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBjcmFzaEVycm9yLmVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChyZXRWYWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTogdGhyb3cgbmV3IE1hbGZvcm1lZEpzb25ScGNFcnJvcigpO1xuICAgICAgICAgICAgICAgIGNhc2UgMjogdGhyb3cgbmV3IFF1ZXVlRnVsbEVycm9yKCk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKFwiSW50ZXJuYWwgZXJyb3I6IHVua25vd24ganNvbl9ycGNfc2VuZCBlcnJvciBjb2RlOiBcIiArIHJldFZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG5leHRKc29uUnBjUmVzcG9uc2U6IChjaGFpbklkKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBCZWNhdXNlIGBuZXh0SnNvblJwY1Jlc3BvbnNlYCBpcyBwYXNzZWQgYXMgcGFyYW1ldGVyIGFuIGlkZW50aWZpZXIgcmV0dXJuZWQgYnkgYGFkZENoYWluYCxcbiAgICAgICAgICAgIC8vIGl0IGlzIGFsd2F5cyB0aGUgY2FzZSB0aGF0IHRoZSBXYXNtIGluc3RhbmNlIGlzIGFscmVhZHkgaW5pdGlhbGl6ZWQuIFRoZSBvbmx5IHBvc3NpYmlsaXR5XG4gICAgICAgICAgICAvLyBmb3IgaXQgdG8gbm90IGJlIHRoZSBjYXNlIGlzIGlmIHRoZSB1c2VyIGNvbXBsZXRlbHkgaW52ZW50ZWQgdGhlIGBjaGFpbklkYC5cbiAgICAgICAgICAgIGlmICghc3RhdGUuaW5pdGlhbGl6ZWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW50ZXJuYWwgZXJyb3JcIik7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChjcmFzaEVycm9yLmVycm9yKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBjcmFzaEVycm9yLmVycm9yO1xuICAgICAgICAgICAgICAgIC8vIFRyeSB0byBwb3AgYSBtZXNzYWdlIGZyb20gdGhlIHF1ZXVlLlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lbSA9IG5ldyBVaW50OEFycmF5KHN0YXRlLmluc3RhbmNlLmV4cG9ydHMubWVtb3J5LmJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlSW5mbyA9IHN0YXRlLmluc3RhbmNlLmV4cG9ydHMuanNvbl9ycGNfcmVzcG9uc2VzX3BlZWsoY2hhaW5JZCkgPj4+IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHB0ciA9IGJ1ZmZlci5yZWFkVUludDMyTEUobWVtLCByZXNwb25zZUluZm8pID4+PiAwO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsZW4gPSBidWZmZXIucmVhZFVJbnQzMkxFKG1lbSwgcmVzcG9uc2VJbmZvICsgNCkgPj4+IDA7XG4gICAgICAgICAgICAgICAgICAgIC8vIGBsZW4gPT09IDBgIG1lYW5zIFwicXVldWUgaXMgZW1wdHlcIiBhY2NvcmRpbmcgdG8gdGhlIEFQSS5cbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gdGhhdCBzaXR1YXRpb24sIHF1ZXVlIHRoZSByZXNvbHZlL3JlamVjdC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlbiAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGJ1ZmZlci51dGY4Qnl0ZXNUb1N0cmluZyhtZW0sIHB0ciwgbGVuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmluc3RhbmNlLmV4cG9ydHMuanNvbl9ycGNfcmVzcG9uc2VzX3BvcChjaGFpbklkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQoY3Jhc2hFcnJvci5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGNyYXNoRXJyb3IuZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIG5vIG1lc3NhZ2UgaXMgYXZhaWxhYmxlLCB3YWl0IGZvciBvbmUgdG8gYmUuXG4gICAgICAgICAgICAgICAgeWllbGQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjaGFpbnMuZ2V0KGNoYWluSWQpLmpzb25ScGNSZXNwb25zZXNQcm9taXNlcy5wdXNoKHsgcmVzb2x2ZTogKCkgPT4gcmVzb2x2ZSh1bmRlZmluZWQpLCByZWplY3QgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBhZGRDaGFpbjogKGNoYWluU3BlYywgZGF0YWJhc2VDb250ZW50LCBwb3RlbnRpYWxSZWxheUNoYWlucywgZGlzYWJsZUpzb25ScGMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBxdWV1ZU9wZXJhdGlvbigoaW5zdGFuY2UsIGJ1ZmZlckluZGljZXMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY3Jhc2hFcnJvci5lcnJvcilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgY3Jhc2hFcnJvci5lcnJvcjtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBgYWRkX2NoYWluYCB1bmNvbmRpdGlvbmFsbHkgYWxsb2NhdGVzIGEgY2hhaW4gaWQuIElmIGFuIGVycm9yIG9jY3VycywgaG93ZXZlciwgdGhpcyBjaGFpblxuICAgICAgICAgICAgICAgICAgICAvLyBpZCB3aWxsIHJlZmVyIHRvIGFuICplcnJvbmVvdXMqIGNoYWluLiBgY2hhaW5faXNfb2tgIGlzIHVzZWQgYmVsb3cgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gaGFzIHN1Y2NlZWVkZWQgb3Igbm90LlxuICAgICAgICAgICAgICAgICAgICAvLyBOb3RlIHRoYXQgYGFkZF9jaGFpbmAgcHJvcGVybHkgZGUtYWxsb2NhdGVzIGJ1ZmZlcnMgZXZlbiBpZiBpdCBmYWlsZWQuXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlckluZGljZXNbMF0gPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoY2hhaW5TcGVjKTtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVySW5kaWNlc1sxXSA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShkYXRhYmFzZUNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3RlbnRpYWxSZWxheUNoYWluc0VuY29kZWQgPSBuZXcgVWludDhBcnJheShwb3RlbnRpYWxSZWxheUNoYWlucy5sZW5ndGggKiA0KTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgcG90ZW50aWFsUmVsYXlDaGFpbnMubGVuZ3RoOyArK2lkeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVUludDMyTEUocG90ZW50aWFsUmVsYXlDaGFpbnNFbmNvZGVkLCBpZHggKiA0LCBwb3RlbnRpYWxSZWxheUNoYWluc1tpZHhdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBidWZmZXJJbmRpY2VzWzJdID0gcG90ZW50aWFsUmVsYXlDaGFpbnNFbmNvZGVkO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGFpbklkID0gaW5zdGFuY2UuZXhwb3J0cy5hZGRfY2hhaW4oMCwgMSwgZGlzYWJsZUpzb25ScGMgPyAwIDogMSwgMik7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBidWZmZXJJbmRpY2VzWzBdO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgYnVmZmVySW5kaWNlc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGJ1ZmZlckluZGljZXNbMl07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5leHBvcnRzLmNoYWluX2lzX29rKGNoYWluSWQpICE9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KCFjaGFpbnMuaGFzKGNoYWluSWQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWlucy5zZXQoY2hhaW5JZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb25ScGNSZXNwb25zZXNQcm9taXNlczogbmV3IEFycmF5KClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgY2hhaW5JZCB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JNc2dMZW4gPSBpbnN0YW5jZS5leHBvcnRzLmNoYWluX2Vycm9yX2xlbihjaGFpbklkKSA+Pj4gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yTXNnUHRyID0gaW5zdGFuY2UuZXhwb3J0cy5jaGFpbl9lcnJvcl9wdHIoY2hhaW5JZCkgPj4+IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvck1zZyA9IGJ1ZmZlci51dGY4Qnl0ZXNUb1N0cmluZyhuZXcgVWludDhBcnJheShpbnN0YW5jZS5leHBvcnRzLm1lbW9yeS5idWZmZXIpLCBlcnJvck1zZ1B0ciwgZXJyb3JNc2dMZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UuZXhwb3J0cy5yZW1vdmVfY2hhaW4oY2hhaW5JZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yTXNnIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydChjcmFzaEVycm9yLmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgY3Jhc2hFcnJvci5lcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlQ2hhaW46IChjaGFpbklkKSA9PiB7XG4gICAgICAgICAgICAvLyBCZWNhdXNlIGByZW1vdmVDaGFpbmAgaXMgcGFzc2VkIGFzIHBhcmFtZXRlciBhbiBpZGVudGlmaWVyIHJldHVybmVkIGJ5IGBhZGRDaGFpbmAsIGl0IGlzXG4gICAgICAgICAgICAvLyBhbHdheXMgdGhlIGNhc2UgdGhhdCB0aGUgV2FzbSBpbnN0YW5jZSBpcyBhbHJlYWR5IGluaXRpYWxpemVkLiBUaGUgb25seSBwb3NzaWJpbGl0eSBmb3JcbiAgICAgICAgICAgIC8vIGl0IHRvIG5vdCBiZSB0aGUgY2FzZSBpcyBpZiB0aGUgdXNlciBjb21wbGV0ZWx5IGludmVudGVkIHRoZSBgY2hhaW5JZGAuXG4gICAgICAgICAgICBpZiAoIXN0YXRlLmluaXRpYWxpemVkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludGVybmFsIGVycm9yXCIpO1xuICAgICAgICAgICAgaWYgKGNyYXNoRXJyb3IuZXJyb3IpXG4gICAgICAgICAgICAgICAgdGhyb3cgY3Jhc2hFcnJvci5lcnJvcjtcbiAgICAgICAgICAgIC8vIFJlbW92aW5nIHRoZSBjaGFpbiBzeW5jaHJvbm91c2x5IGF2b2lkcyBoYXZpbmcgdG8gZGVhbCB3aXRoIHJhY2UgY29uZGl0aW9ucyBzdWNoIGFzIGFcbiAgICAgICAgICAgIC8vIEpTT04tUlBDIHJlc3BvbnNlIGNvcnJlc3BvbmRpbmcgdG8gYSBjaGFpbiB0aGF0IGlzIGdvaW5nIHRvIGJlIGRlbGV0ZWQgYnV0IGhhc24ndCBiZWVuIHlldC5cbiAgICAgICAgICAgIC8vIFRoZXNlIGtpbmQgb2YgcmFjZSBjb25kaXRpb25zIGFyZSBhbHJlYWR5IGRlbHQgd2l0aCB3aXRoaW4gc21vbGRvdC5cbiAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KGNoYWlucy5oYXMoY2hhaW5JZCkpO1xuICAgICAgICAgICAgZm9yIChjb25zdCB7IHJlamVjdCB9IG9mIGNoYWlucy5nZXQoY2hhaW5JZCkuanNvblJwY1Jlc3BvbnNlc1Byb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBBbHJlYWR5RGVzdHJveWVkRXJyb3IoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGFpbnMuZGVsZXRlKGNoYWluSWQpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5pbnN0YW5jZS5leHBvcnRzLnJlbW92ZV9jaGFpbihjaGFpbklkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydChjcmFzaEVycm9yLmVycm9yKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBjcmFzaEVycm9yLmVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzdGFydFNodXRkb3duOiAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcXVldWVPcGVyYXRpb24oKGluc3RhbmNlKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gYHN0YXJ0U2h1dGRvd25gIGlzIGEgYml0IHNwZWNpYWwgaW4gaXRzIGhhbmRsaW5nIG9mIGNyYXNoZXMuXG4gICAgICAgICAgICAgICAgLy8gU2h1dHRpbmcgZG93biB3aWxsIGxlYWQgdG8gYG9uV2FzbVBhbmljYCBiZWluZyBjYWxsZWQgYXQgc29tZSBwb2ludCwgcG9zc2libHkgZHVyaW5nXG4gICAgICAgICAgICAgICAgLy8gdGhlIGNhbGwgdG8gYHN0YXJ0X3NodXRkb3duYCBpdHNlbGYuIEFzIHN1Y2gsIHdlIG1vdmUgaW50byBcImRvbid0IHByaW50IGVycm9ycyBhbnltb3JlXCJcbiAgICAgICAgICAgICAgICAvLyBtb2RlIGV2ZW4gYmVmb3JlIGNhbGxpbmcgYHN0YXJ0X3NodXRkb3duYC5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIEZ1cnRoZXJtb3JlLCBpZiBhIGNyYXNoIGhhcHBlbmVkIGluIHRoZSBwYXN0LCB0aGVyZSBpcyBubyBwb2ludCBpbiB0aHJvd2luZyBhblxuICAgICAgICAgICAgICAgIC8vIGV4Y2VwdGlvbiB3aGVuIHRoZSB1c2VyIHdhbnRzIHRoZSBzaHV0ZG93biB0byBoYXBwZW4uXG4gICAgICAgICAgICAgICAgaWYgKGNyYXNoRXJyb3IuZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBwcmludEVycm9yLnByaW50RXJyb3IgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UuZXhwb3J0cy5zdGFydF9zaHV0ZG93bigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuIiwiLy8gU21vbGRvdFxuLy8gQ29weXJpZ2h0IChDKSAyMDE5LTIwMjIgIFBhcml0eSBUZWNobm9sb2dpZXMgKFVLKSBMdGQuXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogR1BMLTMuMC1vci1sYXRlciBXSVRIIENsYXNzcGF0aC1leGNlcHRpb24tMi4wXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3Jcbi8vIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuaW1wb3J0IHsgZGVmYXVsdCBhcyBzbW9sZG90TGlnaHRCaW5kaW5nc0J1aWxkZXIgfSBmcm9tICcuL2JpbmRpbmdzLXNtb2xkb3QtbGlnaHQuanMnO1xuaW1wb3J0IHsgZGVmYXVsdCBhcyB3YXNpQmluZGluZ3NCdWlsZGVyIH0gZnJvbSAnLi9iaW5kaW5ncy13YXNpLmpzJztcbmV4cG9ydCB7IENvbm5lY3Rpb25FcnJvciB9IGZyb20gJy4vYmluZGluZ3Mtc21vbGRvdC1saWdodC5qcyc7XG5leHBvcnQgZnVuY3Rpb24gc3RhcnRJbnN0YW5jZShjb25maWcsIHBsYXRmb3JtQmluZGluZ3MpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBsZXQga2lsbEFsbDtcbiAgICAgICAgY29uc3QgYnVmZmVySW5kaWNlcyA9IG5ldyBBcnJheTtcbiAgICAgICAgLy8gQ2FsbGJhY2sgY2FsbGVkIHdoZW4gYGFkdmFuY2VfZXhlY3V0aW9uX3JlYWR5YCBpcyBjYWxsZWQgYnkgdGhlIFJ1c3QgY29kZSwgaWYgYW55LlxuICAgICAgICBjb25zdCBhZHZhbmNlRXhlY3V0aW9uUHJvbWlzZSA9IHsgdmFsdWU6IG51bGwgfTtcbiAgICAgICAgLy8gVXNlZCB0byBiaW5kIHdpdGggdGhlIHNtb2xkb3QtbGlnaHQgYmluZGluZ3MuIFNlZSB0aGUgYGJpbmRpbmdzLXNtb2xkb3QtbGlnaHQuanNgIGZpbGUuXG4gICAgICAgIGNvbnN0IHNtb2xkb3RKc0NvbmZpZyA9IE9iamVjdC5hc3NpZ24oeyBidWZmZXJJbmRpY2VzLCBjb25uZWN0OiBwbGF0Zm9ybUJpbmRpbmdzLmNvbm5lY3QsIG9uUGFuaWM6IChtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICAgICAga2lsbEFsbCgpO1xuICAgICAgICAgICAgICAgIGNvbmZpZy5vbldhc21QYW5pYyhtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgICAgIH0sIGFkdmFuY2VFeGVjdXRpb25SZWFkeUNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGFkdmFuY2VFeGVjdXRpb25Qcm9taXNlLnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICBhZHZhbmNlRXhlY3V0aW9uUHJvbWlzZS52YWx1ZSgpO1xuICAgICAgICAgICAgICAgIGFkdmFuY2VFeGVjdXRpb25Qcm9taXNlLnZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIH0gfSwgY29uZmlnKTtcbiAgICAgICAgLy8gVXNlZCB0byBiaW5kIHdpdGggdGhlIFdhc2kgYmluZGluZ3MuIFNlZSB0aGUgYGJpbmRpbmdzLXdhc2kuanNgIGZpbGUuXG4gICAgICAgIGNvbnN0IHdhc2lDb25maWcgPSB7XG4gICAgICAgICAgICBlbnZWYXJzOiBbXSxcbiAgICAgICAgICAgIGdldFJhbmRvbVZhbHVlczogcGxhdGZvcm1CaW5kaW5ncy5nZXRSYW5kb21WYWx1ZXMsXG4gICAgICAgICAgICBwZXJmb3JtYW5jZU5vdzogcGxhdGZvcm1CaW5kaW5ncy5wZXJmb3JtYW5jZU5vdyxcbiAgICAgICAgICAgIG9uUHJvY0V4aXQ6IChyZXRDb2RlKSA9PiB7XG4gICAgICAgICAgICAgICAga2lsbEFsbCgpO1xuICAgICAgICAgICAgICAgIGNvbmZpZy5vbldhc21QYW5pYyhgcHJvY19leGl0IGNhbGxlZDogJHtyZXRDb2RlfWApO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB7IGltcG9ydHM6IHNtb2xkb3RCaW5kaW5ncywga2lsbEFsbDogc21vbGRvdEJpbmRpbmdzS2lsbEFsbCB9ID0gc21vbGRvdExpZ2h0QmluZGluZ3NCdWlsZGVyKHNtb2xkb3RKc0NvbmZpZyk7XG4gICAgICAgIGtpbGxBbGwgPSBzbW9sZG90QmluZGluZ3NLaWxsQWxsO1xuICAgICAgICAvLyBTdGFydCB0aGUgV2FzbSB2aXJ0dWFsIG1hY2hpbmUuXG4gICAgICAgIC8vIFRoZSBSdXN0IGNvZGUgZGVmaW5lcyBhIGxpc3Qgb2YgaW1wb3J0cyB0aGF0IG11c3QgYmUgZnVsZmlsbGVkIGJ5IHRoZSBlbnZpcm9ubWVudC4gVGhlIHNlY29uZFxuICAgICAgICAvLyBwYXJhbWV0ZXIgcHJvdmlkZXMgdGhlaXIgaW1wbGVtZW50YXRpb25zLlxuICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShjb25maWcud2FzbU1vZHVsZSwge1xuICAgICAgICAgICAgLy8gVGhlIGZ1bmN0aW9ucyB3aXRoIHRoZSBcInNtb2xkb3RcIiBwcmVmaXggYXJlIHNwZWNpZmljIHRvIHNtb2xkb3QuXG4gICAgICAgICAgICBcInNtb2xkb3RcIjogc21vbGRvdEJpbmRpbmdzLFxuICAgICAgICAgICAgLy8gQXMgdGhlIFJ1c3QgY29kZSBpcyBjb21waWxlZCBmb3Igd2FzaSwgc29tZSBtb3JlIHdhc2ktc3BlY2lmaWMgaW1wb3J0cyBleGlzdC5cbiAgICAgICAgICAgIFwid2FzaV9zbmFwc2hvdF9wcmV2aWV3MVwiOiB3YXNpQmluZGluZ3NCdWlsZGVyKHdhc2lDb25maWcpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSByZXN1bHQ7XG4gICAgICAgIHNtb2xkb3RKc0NvbmZpZy5pbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgICAgICB3YXNpQ29uZmlnLmluc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgICAgIC8vIFNtb2xkb3QgcmVxdWlyZXMgYW4gaW5pdGlhbCBjYWxsIHRvIHRoZSBgaW5pdGAgZnVuY3Rpb24gaW4gb3JkZXIgdG8gZG8gaXRzIGludGVybmFsXG4gICAgICAgIC8vIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgIGluc3RhbmNlLmV4cG9ydHMuaW5pdChjb25maWcubWF4TG9nTGV2ZWwpO1xuICAgICAgICAoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gSW4gb3JkZXIgdG8gYXZvaWQgY2FsbGluZyBgc2V0VGltZW91dGAgdG9vIG9mdGVuLCB3ZSBhY2N1bXVsYXRlIHNsZWVwIHVwIHVudGlsXG4gICAgICAgICAgICAvLyBhIGNlcnRhaW4gdGhyZXNob2xkLlxuICAgICAgICAgICAgbGV0IG1pc3NpbmdTbGVlcCA9IDA7XG4gICAgICAgICAgICAvLyBFeHRyYWN0ICh0byBtYWtlIHN1cmUgdGhlIHZhbHVlIGRvZXNuJ3QgY2hhbmdlKSBhbmQgc2FuaXRpemUgYGNwdVJhdGVMaW1pdGAuXG4gICAgICAgICAgICBsZXQgY3B1UmF0ZUxpbWl0ID0gY29uZmlnLmNwdVJhdGVMaW1pdDtcbiAgICAgICAgICAgIGlmIChpc05hTihjcHVSYXRlTGltaXQpKVxuICAgICAgICAgICAgICAgIGNwdVJhdGVMaW1pdCA9IDEuMDtcbiAgICAgICAgICAgIGlmIChjcHVSYXRlTGltaXQgPiAxLjApXG4gICAgICAgICAgICAgICAgY3B1UmF0ZUxpbWl0ID0gMS4wO1xuICAgICAgICAgICAgaWYgKGNwdVJhdGVMaW1pdCA8IDAuMClcbiAgICAgICAgICAgICAgICBjcHVSYXRlTGltaXQgPSAwLjA7XG4gICAgICAgICAgICBjb25zdCBwZXJpb2RpY2FsbHlZaWVsZCA9IHsgdmFsdWU6IGZhbHNlIH07XG4gICAgICAgICAgICBjb25zdCBbcGVyaW9kaWNhbGx5WWllbGRJbml0LCB1bnJlZ2lzdGVyQ2FsbGJhY2tdID0gcGxhdGZvcm1CaW5kaW5ncy5yZWdpc3RlclNob3VsZFBlcmlvZGljYWxseVlpZWxkKChuZXdWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHBlcmlvZGljYWxseVlpZWxkLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBlcmlvZGljYWxseVlpZWxkLnZhbHVlID0gcGVyaW9kaWNhbGx5WWllbGRJbml0O1xuICAgICAgICAgICAgbGV0IG5vdyA9IHBsYXRmb3JtQmluZGluZ3MucGVyZm9ybWFuY2VOb3coKTtcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2hlblJlYWR5QWdhaW4gPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gYWR2YW5jZUV4ZWN1dGlvblByb21pc2UudmFsdWUgPSByZXNvbHZlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRjb21lID0gaW5zdGFuY2UuZXhwb3J0cy5hZHZhbmNlX2V4ZWN1dGlvbigpO1xuICAgICAgICAgICAgICAgIGlmIChvdXRjb21lID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHVucmVnaXN0ZXJDYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgYWZ0ZXJFeGVjID0gcGxhdGZvcm1CaW5kaW5ncy5wZXJmb3JtYW5jZU5vdygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVsYXBzZWQgPSBhZnRlckV4ZWMgLSBub3c7XG4gICAgICAgICAgICAgICAgbm93ID0gYWZ0ZXJFeGVjO1xuICAgICAgICAgICAgICAgIC8vIEluIG9yZGVyIHRvIGVuZm9yY2UgdGhlIHJhdGUgbGltaXRpbmcsIHdlIHN0b3AgZXhlY3V0aW5nIGZvciBhIGNlcnRhaW5cbiAgICAgICAgICAgICAgICAvLyBhbW91bnQgb2YgdGltZS5cbiAgICAgICAgICAgICAgICAvLyBUaGUgYmFzZSBlcXVhdGlvbiBoZXJlIGlzOiBgKHNsZWVwICsgZWxhcHNlZCkgKiByYXRlTGltaXQgPT0gZWxhcHNlZGAsXG4gICAgICAgICAgICAgICAgLy8gZnJvbSB3aGljaCB0aGUgY2FsY3VsYXRpb24gYmVsb3cgaXMgZGVyaXZlZC5cbiAgICAgICAgICAgICAgICBjb25zdCBzbGVlcCA9IGVsYXBzZWQgKiAoMS4wIC8gY3B1UmF0ZUxpbWl0IC0gMS4wKTtcbiAgICAgICAgICAgICAgICBtaXNzaW5nU2xlZXAgKz0gc2xlZXA7XG4gICAgICAgICAgICAgICAgaWYgKG1pc3NpbmdTbGVlcCA+IChwZXJpb2RpY2FsbHlZaWVsZCA/IDUgOiAxMDAwKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBgc2V0VGltZW91dGAgaGFzIGEgbWF4aW11bSB2YWx1ZSwgYWZ0ZXIgd2hpY2ggaXQgd2lsbCBvdmVyZmxvdy4g8J+kplxuICAgICAgICAgICAgICAgICAgICAvLyBTZWUgPGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9zZXRUaW1lb3V0I21heGltdW1fZGVsYXlfdmFsdWU+XG4gICAgICAgICAgICAgICAgICAgIC8vIFdoaWxlIGFkZGluZyBhIGNhcCB0ZWNobmljYWxseSBza2V3cyB0aGUgQ1BVIHJhdGUgbGltaXRpbmcgYWxnb3JpdGhtLCB3ZSBkb24ndFxuICAgICAgICAgICAgICAgICAgICAvLyByZWFsbHkgY2FyZSBmb3Igc3VjaCBleHRyZW1lIHZhbHVlcy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pc3NpbmdTbGVlcCA+IDIxNDc0ODM2NDYpIC8vIERvYyBzYXlzIGA+IDIxNDc0ODM2NDdgLCBidXQgSSBkb24ndCByZWFsbHkgdHJ1c3QgdGhlaXIgcGVkYW50aWNpc20gc28gbGV0J3MgYmUgc2FmZVxuICAgICAgICAgICAgICAgICAgICAgICAgbWlzc2luZ1NsZWVwID0gMjE0NzQ4MzY0NjtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbWlzc2luZ1NsZWVwKSk7XG4gICAgICAgICAgICAgICAgICAgIG1pc3NpbmdTbGVlcCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHlpZWxkIHdoZW5SZWFkeUFnYWluO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFmdGVyV2FpdCA9IHBsYXRmb3JtQmluZGluZ3MucGVyZm9ybWFuY2VOb3coKTtcbiAgICAgICAgICAgICAgICBtaXNzaW5nU2xlZXAgLT0gKGFmdGVyV2FpdCAtIG5vdyk7XG4gICAgICAgICAgICAgICAgaWYgKG1pc3NpbmdTbGVlcCA8IDApXG4gICAgICAgICAgICAgICAgICAgIG1pc3NpbmdTbGVlcCA9IDA7XG4gICAgICAgICAgICAgICAgbm93ID0gYWZ0ZXJXYWl0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSkoKTtcbiAgICAgICAgcmV0dXJuIFtpbnN0YW5jZSwgYnVmZmVySW5kaWNlc107XG4gICAgfSk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=