"use strict";
((typeof self !== 'undefined' ? self : this)["webpackChunk_subwallet_extension_koni"] = (typeof self !== 'undefined' ? self : this)["webpackChunk_subwallet_extension_koni"] || []).push([["vendors-node_modules_smoldot_dist_mjs_instance_bindings-smoldot-light_js-node_modules_smoldot-c899be"],{

/***/ "../../node_modules/smoldot/dist/mjs/instance/bindings-smoldot-light.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/smoldot/dist/mjs/instance/bindings-smoldot-light.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConnectionError": () => (/* binding */ ConnectionError),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _buffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./buffer.js */ "../../node_modules/smoldot/dist/mjs/instance/buffer.js");
// Smoldot
// Copyright (C) 2019-2022  Parity Technologies (UK) Ltd.
// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//! Exports a function that provides bindings for the bindings found in the Rust part of the code.
//!
//! In order to use this code, call the function passing an object, then fill the `instance` field
//! of that object with the Wasm instance.

/**
 * Emitted by `connect` if the multiaddress couldn't be parsed or contains an invalid protocol.
 *
 * @see connect
 */
class ConnectionError extends Error {
    constructor(message) {
        super(message);
    }
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(config) {
    // Used below to store the list of all connections.
    // The indices within this array are chosen by the Rust code.
    let connections = {};
    // Object containing a boolean indicating whether the `killAll` function has been invoked by
    // the user.
    const killedTracked = { killed: false };
    const killAll = () => {
        killedTracked.killed = true;
        // TODO: kill timers as well?
        for (const connection in connections) {
            connections[connection].reset();
            delete connections[connection];
        }
    };
    const imports = {
        // Must exit with an error. A human-readable message can be found in the WebAssembly
        // memory in the given buffer.
        panic: (ptr, len) => {
            const instance = config.instance;
            ptr >>>= 0;
            len >>>= 0;
            const message = _buffer_js__WEBPACK_IMPORTED_MODULE_0__.utf8BytesToString(new Uint8Array(instance.exports.memory.buffer), ptr, len);
            config.onPanic(message);
        },
        buffer_size: (bufferIndex) => {
            const buf = config.bufferIndices[bufferIndex];
            return buf.byteLength;
        },
        buffer_copy: (bufferIndex, targetPtr) => {
            const instance = config.instance;
            targetPtr = targetPtr >>> 0;
            const buf = config.bufferIndices[bufferIndex];
            new Uint8Array(instance.exports.memory.buffer).set(buf, targetPtr);
        },
        advance_execution_ready: () => {
            config.advanceExecutionReadyCallback();
        },
        // Used by the Rust side to notify that a JSON-RPC response or subscription notification
        // is available in the queue of JSON-RPC responses.
        json_rpc_responses_non_empty: (chainId) => {
            if (killedTracked.killed)
                return;
            config.jsonRpcResponsesNonEmptyCallback(chainId);
        },
        // Used by the Rust side to emit a log entry.
        // See also the `max_log_level` parameter in the configuration.
        log: (level, targetPtr, targetLen, messagePtr, messageLen) => {
            if (killedTracked.killed)
                return;
            const instance = config.instance;
            targetPtr >>>= 0;
            targetLen >>>= 0;
            messagePtr >>>= 0;
            messageLen >>>= 0;
            if (config.logCallback) {
                const mem = new Uint8Array(instance.exports.memory.buffer);
                let target = _buffer_js__WEBPACK_IMPORTED_MODULE_0__.utf8BytesToString(mem, targetPtr, targetLen);
                let message = _buffer_js__WEBPACK_IMPORTED_MODULE_0__.utf8BytesToString(mem, messagePtr, messageLen);
                config.logCallback(level, target, message);
            }
        },
        // Must call `timer_finished` after the given number of milliseconds has elapsed.
        start_timer: (ms) => {
            if (killedTracked.killed)
                return;
            const instance = config.instance;
            // In both NodeJS and browsers, if `setTimeout` is called with a value larger than
            // 2147483647, the delay is for some reason instead set to 1.
            // As mentioned in the documentation of `start_timer`, it is acceptable to end the
            // timer before the given number of milliseconds has passed.
            if (ms > 2147483647)
                ms = 2147483647;
            // In browsers, `setTimeout` works as expected when `ms` equals 0. However, NodeJS
            // requires a minimum of 1 millisecond (if `0` is passed, it is automatically replaced
            // with `1`) and wants you to use `setImmediate` instead.
            if (ms < 1 && typeof setImmediate === "function") {
                setImmediate(() => {
                    if (killedTracked.killed)
                        return;
                    try {
                        instance.exports.timer_finished();
                    }
                    catch (_error) { }
                });
            }
            else {
                setTimeout(() => {
                    if (killedTracked.killed)
                        return;
                    try {
                        instance.exports.timer_finished();
                    }
                    catch (_error) { }
                }, ms);
            }
        },
        // Must create a new connection object. This implementation stores the created object in
        // `connections`.
        connection_new: (connectionId, addrPtr, addrLen, errorBufferIndexPtr) => {
            const instance = config.instance;
            addrPtr >>>= 0;
            addrLen >>>= 0;
            errorBufferIndexPtr >>>= 0;
            if (!!connections[connectionId]) {
                throw new Error("internal error: connection already allocated");
            }
            try {
                if (killedTracked.killed)
                    throw new Error("killAll invoked");
                const address = _buffer_js__WEBPACK_IMPORTED_MODULE_0__.utf8BytesToString(new Uint8Array(instance.exports.memory.buffer), addrPtr, addrLen);
                const connec = config.connect({
                    address,
                    onOpen: (info) => {
                        if (killedTracked.killed)
                            return;
                        try {
                            switch (info.type) {
                                case 'single-stream': {
                                    instance.exports.connection_open_single_stream(connectionId, 0, info.initialWritableBytes, info.writeClosable ? 1 : 0);
                                    break;
                                }
                                case 'multi-stream': {
                                    const handshakeTy = new Uint8Array(1 + info.localTlsCertificateMultihash.length + info.remoteTlsCertificateMultihash.length);
                                    _buffer_js__WEBPACK_IMPORTED_MODULE_0__.writeUInt8(handshakeTy, 0, 0);
                                    handshakeTy.set(info.localTlsCertificateMultihash, 1);
                                    handshakeTy.set(info.remoteTlsCertificateMultihash, 1 + info.localTlsCertificateMultihash.length);
                                    config.bufferIndices[0] = handshakeTy;
                                    instance.exports.connection_open_multi_stream(connectionId, 0);
                                    delete config.bufferIndices[0];
                                    break;
                                }
                            }
                        }
                        catch (_error) { }
                    },
                    onConnectionReset: (message) => {
                        if (killedTracked.killed)
                            return;
                        try {
                            config.bufferIndices[0] = new TextEncoder().encode(message);
                            instance.exports.connection_reset(connectionId, 0);
                            delete config.bufferIndices[0];
                        }
                        catch (_error) { }
                    },
                    onWritableBytes: (numExtra, streamId) => {
                        if (killedTracked.killed)
                            return;
                        try {
                            instance.exports.stream_writable_bytes(connectionId, streamId || 0, numExtra);
                        }
                        catch (_error) { }
                    },
                    onMessage: (message, streamId) => {
                        if (killedTracked.killed)
                            return;
                        try {
                            config.bufferIndices[0] = message;
                            instance.exports.stream_message(connectionId, streamId || 0, 0);
                            delete config.bufferIndices[0];
                        }
                        catch (_error) { }
                    },
                    onStreamOpened: (streamId, direction, initialWritableBytes) => {
                        if (killedTracked.killed)
                            return;
                        try {
                            instance.exports.connection_stream_opened(connectionId, streamId, direction === 'outbound' ? 1 : 0, initialWritableBytes);
                        }
                        catch (_error) { }
                    },
                    onStreamReset: (streamId) => {
                        if (killedTracked.killed)
                            return;
                        try {
                            instance.exports.stream_reset(connectionId, streamId);
                        }
                        catch (_error) { }
                    }
                });
                connections[connectionId] = connec;
                return 0;
            }
            catch (error) {
                const isBadAddress = error instanceof ConnectionError;
                let errorStr = "Unknown error";
                if (error instanceof Error) {
                    errorStr = error.toString();
                }
                const mem = new Uint8Array(instance.exports.memory.buffer);
                config.bufferIndices[0] = new TextEncoder().encode(errorStr);
                _buffer_js__WEBPACK_IMPORTED_MODULE_0__.writeUInt32LE(mem, errorBufferIndexPtr, 0);
                _buffer_js__WEBPACK_IMPORTED_MODULE_0__.writeUInt8(mem, errorBufferIndexPtr + 4, isBadAddress ? 1 : 0);
                return 1;
            }
        },
        // Must close and destroy the connection object.
        reset_connection: (connectionId) => {
            if (killedTracked.killed)
                return;
            const connection = connections[connectionId];
            connection.reset();
            delete connections[connectionId];
        },
        // Opens a new substream on a multi-stream connection.
        connection_stream_open: (connectionId) => {
            const connection = connections[connectionId];
            connection.openOutSubstream();
        },
        // Closes a substream on a multi-stream connection.
        connection_stream_reset: (connectionId, streamId) => {
            const connection = connections[connectionId];
            connection.reset(streamId);
        },
        // Must queue the data found in the WebAssembly memory at the given pointer. It is assumed
        // that this function is called only when the connection is in an open state.
        stream_send: (connectionId, streamId, ptr, len) => {
            if (killedTracked.killed)
                return;
            const instance = config.instance;
            ptr >>>= 0;
            len >>>= 0;
            const data = new Uint8Array(instance.exports.memory.buffer).slice(ptr, ptr + len);
            const connection = connections[connectionId];
            connection.send(data, streamId); // TODO: docs says the streamId is provided only for multi-stream connections, but here it's always provided
        },
        stream_send_close: (connectionId, streamId) => {
            if (killedTracked.killed)
                return;
            const connection = connections[connectionId];
            connection.closeSend(streamId); // TODO: docs says the streamId is provided only for multi-stream connections, but here it's always provided
        },
        current_task_entered: (ptr, len) => {
            if (killedTracked.killed)
                return;
            const instance = config.instance;
            ptr >>>= 0;
            len >>>= 0;
            const taskName = _buffer_js__WEBPACK_IMPORTED_MODULE_0__.utf8BytesToString(new Uint8Array(instance.exports.memory.buffer), ptr, len);
            if (config.currentTaskCallback)
                config.currentTaskCallback(taskName);
        },
        current_task_exit: () => {
            if (killedTracked.killed)
                return;
            if (config.currentTaskCallback)
                config.currentTaskCallback(null);
        }
    };
    return { imports, killAll };
}


/***/ }),

/***/ "../../node_modules/smoldot/dist/mjs/instance/bindings-wasi.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/smoldot/dist/mjs/instance/bindings-wasi.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _buffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./buffer.js */ "../../node_modules/smoldot/dist/mjs/instance/buffer.js");
// Smoldot
// Copyright (C) 2019-2022  Parity Technologies (UK) Ltd.
// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//! Exports a function that provides bindings for the Wasi interface.
//!
//! These bindings can then be used by the Wasm virtual machine to invoke Wasi-related functions.
//! See <https://wasi.dev/>.
//!
//! In order to use this code, call the function passing an object, then fill the `instance` field
//! of that object with the Wasm instance.

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((config) => {
    // Buffers holding temporary data being written by the Rust code to respectively stdout and
    // stderr.
    let stdoutBuffer = "";
    let stderrBuffer = "";
    return {
        // Need to fill the buffer described by `ptr` and `len` with random data.
        // This data will be used in order to generate secrets. Do not use a dummy implementation!
        random_get: (ptr, len) => {
            const instance = config.instance;
            ptr >>>= 0;
            len >>>= 0;
            const baseBuffer = new Uint8Array(instance.exports.memory.buffer)
                .subarray(ptr, ptr + len);
            for (let iter = 0; iter < len; iter += 65536) {
                // `baseBuffer.subarray` automatically saturates at the end of the buffer
                config.getRandomValues(baseBuffer.subarray(iter, iter + 65536));
            }
            return 0;
        },
        clock_time_get: (clockId, _precision, outPtr) => {
            // See <https://github.com/rust-lang/rust/blob/master/library/std/src/sys/wasi/time.rs>
            // and <docs.rs/wasi/> for help.
            const instance = config.instance;
            const mem = new Uint8Array(instance.exports.memory.buffer);
            outPtr >>>= 0;
            // We ignore the precision, as it can't be implemented anyway.
            switch (clockId) {
                case 0: {
                    // Realtime clock.
                    const now = BigInt(Math.floor(Date.now())) * BigInt(1000000);
                    _buffer_js__WEBPACK_IMPORTED_MODULE_0__.writeUInt64LE(mem, outPtr, now);
                    // Success.
                    return 0;
                }
                case 1: {
                    // Monotonic clock.
                    const nowMs = config.performanceNow();
                    const nowMsInt = Math.floor(nowMs);
                    const now = BigInt(nowMsInt) * BigInt(1000000) +
                        BigInt(Math.floor(((nowMs - nowMsInt) * 1000000)));
                    _buffer_js__WEBPACK_IMPORTED_MODULE_0__.writeUInt64LE(mem, outPtr, now);
                    // Success.
                    return 0;
                }
                default:
                    // Return an `EINVAL` error.
                    return 28;
            }
        },
        // Writing to a file descriptor is used in order to write to stdout/stderr.
        fd_write: (fd, addr, num, outPtr) => {
            const instance = config.instance;
            outPtr >>>= 0;
            // Only stdout and stderr are open for writing.
            if (fd != 1 && fd != 2) {
                return 8;
            }
            const mem = new Uint8Array(instance.exports.memory.buffer);
            // `fd_write` passes a buffer containing itself a list of pointers and lengths to the
            // actual buffers. See writev(2).
            let toWrite = "";
            let totalLength = 0;
            for (let i = 0; i < num; i++) {
                const buf = _buffer_js__WEBPACK_IMPORTED_MODULE_0__.readUInt32LE(mem, addr + 4 * i * 2);
                const bufLen = _buffer_js__WEBPACK_IMPORTED_MODULE_0__.readUInt32LE(mem, addr + 4 * (i * 2 + 1));
                toWrite += _buffer_js__WEBPACK_IMPORTED_MODULE_0__.utf8BytesToString(mem, buf, bufLen);
                totalLength += bufLen;
            }
            const flushBuffer = (string) => {
                // As documented in the documentation of `println!`, lines are always split by a
                // single `\n` in Rust.
                while (true) {
                    const index = string.indexOf('\n');
                    if (index != -1) {
                        // Note that it is questionnable to use `console.log` from within a
                        // library. However this simply reflects the usage of `println!` in the
                        // Rust code. In other words, it is `println!` that shouldn't be used in
                        // the first place. The harm of not showing text printed with `println!`
                        // at all is greater than the harm possibly caused by accidentally leaving
                        // a `println!` in the code.
                        console.log(string.substring(0, index));
                        string = string.substring(index + 1);
                    }
                    else {
                        return string;
                    }
                }
            };
            // Append the newly-written data to either `stdout_buffer` or `stderr_buffer`, and
            // print their content if necessary.
            if (fd == 1) {
                stdoutBuffer += toWrite;
                stdoutBuffer = flushBuffer(stdoutBuffer);
            }
            else if (fd == 2) {
                stderrBuffer += toWrite;
                stderrBuffer = flushBuffer(stderrBuffer);
            }
            // Need to write in `out_ptr` how much data was "written".
            _buffer_js__WEBPACK_IMPORTED_MODULE_0__.writeUInt32LE(mem, outPtr, totalLength);
            return 0;
        },
        // It's unclear how to properly implement yielding, but a no-op works fine as well.
        sched_yield: () => {
            return 0;
        },
        // Used by Rust in catastrophic situations, such as a double panic.
        proc_exit: (retCode) => {
            config.onProcExit(retCode);
        },
        // Return the number of environment variables and the total size of all environment
        // variables. This is called in order to initialize buffers before `environ_get`.
        environ_sizes_get: (argcOut, argvBufSizeOut) => {
            const instance = config.instance;
            argcOut >>>= 0;
            argvBufSizeOut >>>= 0;
            let totalLen = 0;
            config.envVars.forEach(e => totalLen += new TextEncoder().encode(e).length + 1); // +1 for trailing \0
            const mem = new Uint8Array(instance.exports.memory.buffer);
            _buffer_js__WEBPACK_IMPORTED_MODULE_0__.writeUInt32LE(mem, argcOut, config.envVars.length);
            _buffer_js__WEBPACK_IMPORTED_MODULE_0__.writeUInt32LE(mem, argvBufSizeOut, totalLen);
            return 0;
        },
        // Write the environment variables to the given pointers.
        // `argv` is a pointer to a buffer that must be overwritten with a list of pointers to
        // environment variables, and `argvBuf` is a pointer to a buffer where to actually store
        // the environment variables.
        // The sizes of the buffers were determined by calling `environ_sizes_get`.
        environ_get: (argv, argvBuf) => {
            const instance = config.instance;
            argv >>>= 0;
            argvBuf >>>= 0;
            const mem = new Uint8Array(instance.exports.memory.buffer);
            let argvPos = 0;
            let argvBufPos = 0;
            config.envVars.forEach(envVar => {
                const encoded = new TextEncoder().encode(envVar);
                _buffer_js__WEBPACK_IMPORTED_MODULE_0__.writeUInt32LE(mem, argv + argvPos, argvBuf + argvBufPos);
                argvPos += 4;
                mem.set(encoded, argvBuf + argvBufPos);
                argvBufPos += encoded.length;
                _buffer_js__WEBPACK_IMPORTED_MODULE_0__.writeUInt8(mem, argvBuf + argvBufPos, 0);
                argvBufPos += 1;
            });
            return 0;
        },
    };
});


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfc21vbGRvdF9kaXN0X21qc19pbnN0YW5jZV9iaW5kaW5ncy1zbW9sZG90LWxpZ2h0X2pzLW5vZGVfbW9kdWxlc19zbW9sZG90LWM4OTliZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBZSxvQ0FBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5REFBd0I7QUFDcEQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHlEQUF3QjtBQUNyRCw4QkFBOEIseURBQXdCO0FBQ3REO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0Es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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGO0FBQzdGO0FBQ0EsWUFBWSxxREFBb0I7QUFDaEMsWUFBWSxxREFBb0I7QUFDaEM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxREFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtEQUFpQjtBQUNqQztBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBLENBQUMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BzdWJ3YWxsZXQvZXh0ZW5zaW9uLWtvbmkvLi4vLi4vbm9kZV9tb2R1bGVzL3Ntb2xkb3QvZGlzdC9tanMvaW5zdGFuY2UvYmluZGluZ3Mtc21vbGRvdC1saWdodC5qcyIsIndlYnBhY2s6Ly9Ac3Vid2FsbGV0L2V4dGVuc2lvbi1rb25pLy4uLy4uL25vZGVfbW9kdWxlcy9zbW9sZG90L2Rpc3QvbWpzL2luc3RhbmNlL2JpbmRpbmdzLXdhc2kuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gU21vbGRvdFxuLy8gQ29weXJpZ2h0IChDKSAyMDE5LTIwMjIgIFBhcml0eSBUZWNobm9sb2dpZXMgKFVLKSBMdGQuXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogR1BMLTMuMC1vci1sYXRlciBXSVRIIENsYXNzcGF0aC1leGNlcHRpb24tMi4wXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4vLyAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbi8vISBFeHBvcnRzIGEgZnVuY3Rpb24gdGhhdCBwcm92aWRlcyBiaW5kaW5ncyBmb3IgdGhlIGJpbmRpbmdzIGZvdW5kIGluIHRoZSBSdXN0IHBhcnQgb2YgdGhlIGNvZGUuXG4vLyFcbi8vISBJbiBvcmRlciB0byB1c2UgdGhpcyBjb2RlLCBjYWxsIHRoZSBmdW5jdGlvbiBwYXNzaW5nIGFuIG9iamVjdCwgdGhlbiBmaWxsIHRoZSBgaW5zdGFuY2VgIGZpZWxkXG4vLyEgb2YgdGhhdCBvYmplY3Qgd2l0aCB0aGUgV2FzbSBpbnN0YW5jZS5cbmltcG9ydCAqIGFzIGJ1ZmZlciBmcm9tICcuL2J1ZmZlci5qcyc7XG4vKipcbiAqIEVtaXR0ZWQgYnkgYGNvbm5lY3RgIGlmIHRoZSBtdWx0aWFkZHJlc3MgY291bGRuJ3QgYmUgcGFyc2VkIG9yIGNvbnRhaW5zIGFuIGludmFsaWQgcHJvdG9jb2wuXG4gKlxuICogQHNlZSBjb25uZWN0XG4gKi9cbmV4cG9ydCBjbGFzcyBDb25uZWN0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB9XG59XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgLy8gVXNlZCBiZWxvdyB0byBzdG9yZSB0aGUgbGlzdCBvZiBhbGwgY29ubmVjdGlvbnMuXG4gICAgLy8gVGhlIGluZGljZXMgd2l0aGluIHRoaXMgYXJyYXkgYXJlIGNob3NlbiBieSB0aGUgUnVzdCBjb2RlLlxuICAgIGxldCBjb25uZWN0aW9ucyA9IHt9O1xuICAgIC8vIE9iamVjdCBjb250YWluaW5nIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGBraWxsQWxsYCBmdW5jdGlvbiBoYXMgYmVlbiBpbnZva2VkIGJ5XG4gICAgLy8gdGhlIHVzZXIuXG4gICAgY29uc3Qga2lsbGVkVHJhY2tlZCA9IHsga2lsbGVkOiBmYWxzZSB9O1xuICAgIGNvbnN0IGtpbGxBbGwgPSAoKSA9PiB7XG4gICAgICAgIGtpbGxlZFRyYWNrZWQua2lsbGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gVE9ETzoga2lsbCB0aW1lcnMgYXMgd2VsbD9cbiAgICAgICAgZm9yIChjb25zdCBjb25uZWN0aW9uIGluIGNvbm5lY3Rpb25zKSB7XG4gICAgICAgICAgICBjb25uZWN0aW9uc1tjb25uZWN0aW9uXS5yZXNldCgpO1xuICAgICAgICAgICAgZGVsZXRlIGNvbm5lY3Rpb25zW2Nvbm5lY3Rpb25dO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpbXBvcnRzID0ge1xuICAgICAgICAvLyBNdXN0IGV4aXQgd2l0aCBhbiBlcnJvci4gQSBodW1hbi1yZWFkYWJsZSBtZXNzYWdlIGNhbiBiZSBmb3VuZCBpbiB0aGUgV2ViQXNzZW1ibHlcbiAgICAgICAgLy8gbWVtb3J5IGluIHRoZSBnaXZlbiBidWZmZXIuXG4gICAgICAgIHBhbmljOiAocHRyLCBsZW4pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gY29uZmlnLmluc3RhbmNlO1xuICAgICAgICAgICAgcHRyID4+Pj0gMDtcbiAgICAgICAgICAgIGxlbiA+Pj49IDA7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYnVmZmVyLnV0ZjhCeXRlc1RvU3RyaW5nKG5ldyBVaW50OEFycmF5KGluc3RhbmNlLmV4cG9ydHMubWVtb3J5LmJ1ZmZlciksIHB0ciwgbGVuKTtcbiAgICAgICAgICAgIGNvbmZpZy5vblBhbmljKG1lc3NhZ2UpO1xuICAgICAgICB9LFxuICAgICAgICBidWZmZXJfc2l6ZTogKGJ1ZmZlckluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBidWYgPSBjb25maWcuYnVmZmVySW5kaWNlc1tidWZmZXJJbmRleF07XG4gICAgICAgICAgICByZXR1cm4gYnVmLmJ5dGVMZW5ndGg7XG4gICAgICAgIH0sXG4gICAgICAgIGJ1ZmZlcl9jb3B5OiAoYnVmZmVySW5kZXgsIHRhcmdldFB0cikgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBjb25maWcuaW5zdGFuY2U7XG4gICAgICAgICAgICB0YXJnZXRQdHIgPSB0YXJnZXRQdHIgPj4+IDA7XG4gICAgICAgICAgICBjb25zdCBidWYgPSBjb25maWcuYnVmZmVySW5kaWNlc1tidWZmZXJJbmRleF07XG4gICAgICAgICAgICBuZXcgVWludDhBcnJheShpbnN0YW5jZS5leHBvcnRzLm1lbW9yeS5idWZmZXIpLnNldChidWYsIHRhcmdldFB0cik7XG4gICAgICAgIH0sXG4gICAgICAgIGFkdmFuY2VfZXhlY3V0aW9uX3JlYWR5OiAoKSA9PiB7XG4gICAgICAgICAgICBjb25maWcuYWR2YW5jZUV4ZWN1dGlvblJlYWR5Q2FsbGJhY2soKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gVXNlZCBieSB0aGUgUnVzdCBzaWRlIHRvIG5vdGlmeSB0aGF0IGEgSlNPTi1SUEMgcmVzcG9uc2Ugb3Igc3Vic2NyaXB0aW9uIG5vdGlmaWNhdGlvblxuICAgICAgICAvLyBpcyBhdmFpbGFibGUgaW4gdGhlIHF1ZXVlIG9mIEpTT04tUlBDIHJlc3BvbnNlcy5cbiAgICAgICAganNvbl9ycGNfcmVzcG9uc2VzX25vbl9lbXB0eTogKGNoYWluSWQpID0+IHtcbiAgICAgICAgICAgIGlmIChraWxsZWRUcmFja2VkLmtpbGxlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25maWcuanNvblJwY1Jlc3BvbnNlc05vbkVtcHR5Q2FsbGJhY2soY2hhaW5JZCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFVzZWQgYnkgdGhlIFJ1c3Qgc2lkZSB0byBlbWl0IGEgbG9nIGVudHJ5LlxuICAgICAgICAvLyBTZWUgYWxzbyB0aGUgYG1heF9sb2dfbGV2ZWxgIHBhcmFtZXRlciBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAgICAgICAgbG9nOiAobGV2ZWwsIHRhcmdldFB0ciwgdGFyZ2V0TGVuLCBtZXNzYWdlUHRyLCBtZXNzYWdlTGVuKSA9PiB7XG4gICAgICAgICAgICBpZiAoa2lsbGVkVHJhY2tlZC5raWxsZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBjb25maWcuaW5zdGFuY2U7XG4gICAgICAgICAgICB0YXJnZXRQdHIgPj4+PSAwO1xuICAgICAgICAgICAgdGFyZ2V0TGVuID4+Pj0gMDtcbiAgICAgICAgICAgIG1lc3NhZ2VQdHIgPj4+PSAwO1xuICAgICAgICAgICAgbWVzc2FnZUxlbiA+Pj49IDA7XG4gICAgICAgICAgICBpZiAoY29uZmlnLmxvZ0NhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVtID0gbmV3IFVpbnQ4QXJyYXkoaW5zdGFuY2UuZXhwb3J0cy5tZW1vcnkuYnVmZmVyKTtcbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0ID0gYnVmZmVyLnV0ZjhCeXRlc1RvU3RyaW5nKG1lbSwgdGFyZ2V0UHRyLCB0YXJnZXRMZW4pO1xuICAgICAgICAgICAgICAgIGxldCBtZXNzYWdlID0gYnVmZmVyLnV0ZjhCeXRlc1RvU3RyaW5nKG1lbSwgbWVzc2FnZVB0ciwgbWVzc2FnZUxlbik7XG4gICAgICAgICAgICAgICAgY29uZmlnLmxvZ0NhbGxiYWNrKGxldmVsLCB0YXJnZXQsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBNdXN0IGNhbGwgYHRpbWVyX2ZpbmlzaGVkYCBhZnRlciB0aGUgZ2l2ZW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBoYXMgZWxhcHNlZC5cbiAgICAgICAgc3RhcnRfdGltZXI6IChtcykgPT4ge1xuICAgICAgICAgICAgaWYgKGtpbGxlZFRyYWNrZWQua2lsbGVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gY29uZmlnLmluc3RhbmNlO1xuICAgICAgICAgICAgLy8gSW4gYm90aCBOb2RlSlMgYW5kIGJyb3dzZXJzLCBpZiBgc2V0VGltZW91dGAgaXMgY2FsbGVkIHdpdGggYSB2YWx1ZSBsYXJnZXIgdGhhblxuICAgICAgICAgICAgLy8gMjE0NzQ4MzY0NywgdGhlIGRlbGF5IGlzIGZvciBzb21lIHJlYXNvbiBpbnN0ZWFkIHNldCB0byAxLlxuICAgICAgICAgICAgLy8gQXMgbWVudGlvbmVkIGluIHRoZSBkb2N1bWVudGF0aW9uIG9mIGBzdGFydF90aW1lcmAsIGl0IGlzIGFjY2VwdGFibGUgdG8gZW5kIHRoZVxuICAgICAgICAgICAgLy8gdGltZXIgYmVmb3JlIHRoZSBnaXZlbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGhhcyBwYXNzZWQuXG4gICAgICAgICAgICBpZiAobXMgPiAyMTQ3NDgzNjQ3KVxuICAgICAgICAgICAgICAgIG1zID0gMjE0NzQ4MzY0NztcbiAgICAgICAgICAgIC8vIEluIGJyb3dzZXJzLCBgc2V0VGltZW91dGAgd29ya3MgYXMgZXhwZWN0ZWQgd2hlbiBgbXNgIGVxdWFscyAwLiBIb3dldmVyLCBOb2RlSlNcbiAgICAgICAgICAgIC8vIHJlcXVpcmVzIGEgbWluaW11bSBvZiAxIG1pbGxpc2Vjb25kIChpZiBgMGAgaXMgcGFzc2VkLCBpdCBpcyBhdXRvbWF0aWNhbGx5IHJlcGxhY2VkXG4gICAgICAgICAgICAvLyB3aXRoIGAxYCkgYW5kIHdhbnRzIHlvdSB0byB1c2UgYHNldEltbWVkaWF0ZWAgaW5zdGVhZC5cbiAgICAgICAgICAgIGlmIChtcyA8IDEgJiYgdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtpbGxlZFRyYWNrZWQua2lsbGVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UuZXhwb3J0cy50aW1lcl9maW5pc2hlZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChfZXJyb3IpIHsgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChraWxsZWRUcmFja2VkLmtpbGxlZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmV4cG9ydHMudGltZXJfZmluaXNoZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoX2Vycm9yKSB7IH1cbiAgICAgICAgICAgICAgICB9LCBtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIE11c3QgY3JlYXRlIGEgbmV3IGNvbm5lY3Rpb24gb2JqZWN0LiBUaGlzIGltcGxlbWVudGF0aW9uIHN0b3JlcyB0aGUgY3JlYXRlZCBvYmplY3QgaW5cbiAgICAgICAgLy8gYGNvbm5lY3Rpb25zYC5cbiAgICAgICAgY29ubmVjdGlvbl9uZXc6IChjb25uZWN0aW9uSWQsIGFkZHJQdHIsIGFkZHJMZW4sIGVycm9yQnVmZmVySW5kZXhQdHIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gY29uZmlnLmluc3RhbmNlO1xuICAgICAgICAgICAgYWRkclB0ciA+Pj49IDA7XG4gICAgICAgICAgICBhZGRyTGVuID4+Pj0gMDtcbiAgICAgICAgICAgIGVycm9yQnVmZmVySW5kZXhQdHIgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKCEhY29ubmVjdGlvbnNbY29ubmVjdGlvbklkXSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludGVybmFsIGVycm9yOiBjb25uZWN0aW9uIGFscmVhZHkgYWxsb2NhdGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoa2lsbGVkVHJhY2tlZC5raWxsZWQpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImtpbGxBbGwgaW52b2tlZFwiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhZGRyZXNzID0gYnVmZmVyLnV0ZjhCeXRlc1RvU3RyaW5nKG5ldyBVaW50OEFycmF5KGluc3RhbmNlLmV4cG9ydHMubWVtb3J5LmJ1ZmZlciksIGFkZHJQdHIsIGFkZHJMZW4pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbm5lYyA9IGNvbmZpZy5jb25uZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgb25PcGVuOiAoaW5mbykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtpbGxlZFRyYWNrZWQua2lsbGVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChpbmZvLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2luZ2xlLXN0cmVhbSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmV4cG9ydHMuY29ubmVjdGlvbl9vcGVuX3NpbmdsZV9zdHJlYW0oY29ubmVjdGlvbklkLCAwLCBpbmZvLmluaXRpYWxXcml0YWJsZUJ5dGVzLCBpbmZvLndyaXRlQ2xvc2FibGUgPyAxIDogMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdtdWx0aS1zdHJlYW0nOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBoYW5kc2hha2VUeSA9IG5ldyBVaW50OEFycmF5KDEgKyBpbmZvLmxvY2FsVGxzQ2VydGlmaWNhdGVNdWx0aWhhc2gubGVuZ3RoICsgaW5mby5yZW1vdGVUbHNDZXJ0aWZpY2F0ZU11bHRpaGFzaC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVUludDgoaGFuZHNoYWtlVHksIDAsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZHNoYWtlVHkuc2V0KGluZm8ubG9jYWxUbHNDZXJ0aWZpY2F0ZU11bHRpaGFzaCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kc2hha2VUeS5zZXQoaW5mby5yZW1vdGVUbHNDZXJ0aWZpY2F0ZU11bHRpaGFzaCwgMSArIGluZm8ubG9jYWxUbHNDZXJ0aWZpY2F0ZU11bHRpaGFzaC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLmJ1ZmZlckluZGljZXNbMF0gPSBoYW5kc2hha2VUeTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmV4cG9ydHMuY29ubmVjdGlvbl9vcGVuX211bHRpX3N0cmVhbShjb25uZWN0aW9uSWQsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5idWZmZXJJbmRpY2VzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoX2Vycm9yKSB7IH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25Db25uZWN0aW9uUmVzZXQ6IChtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2lsbGVkVHJhY2tlZC5raWxsZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuYnVmZmVySW5kaWNlc1swXSA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5leHBvcnRzLmNvbm5lY3Rpb25fcmVzZXQoY29ubmVjdGlvbklkLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgY29uZmlnLmJ1ZmZlckluZGljZXNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoX2Vycm9yKSB7IH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25Xcml0YWJsZUJ5dGVzOiAobnVtRXh0cmEsIHN0cmVhbUlkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2lsbGVkVHJhY2tlZC5raWxsZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5leHBvcnRzLnN0cmVhbV93cml0YWJsZV9ieXRlcyhjb25uZWN0aW9uSWQsIHN0cmVhbUlkIHx8IDAsIG51bUV4dHJhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChfZXJyb3IpIHsgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvbk1lc3NhZ2U6IChtZXNzYWdlLCBzdHJlYW1JZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtpbGxlZFRyYWNrZWQua2lsbGVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLmJ1ZmZlckluZGljZXNbMF0gPSBtZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmV4cG9ydHMuc3RyZWFtX21lc3NhZ2UoY29ubmVjdGlvbklkLCBzdHJlYW1JZCB8fCAwLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgY29uZmlnLmJ1ZmZlckluZGljZXNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoX2Vycm9yKSB7IH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25TdHJlYW1PcGVuZWQ6IChzdHJlYW1JZCwgZGlyZWN0aW9uLCBpbml0aWFsV3JpdGFibGVCeXRlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtpbGxlZFRyYWNrZWQua2lsbGVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UuZXhwb3J0cy5jb25uZWN0aW9uX3N0cmVhbV9vcGVuZWQoY29ubmVjdGlvbklkLCBzdHJlYW1JZCwgZGlyZWN0aW9uID09PSAnb3V0Ym91bmQnID8gMSA6IDAsIGluaXRpYWxXcml0YWJsZUJ5dGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChfZXJyb3IpIHsgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvblN0cmVhbVJlc2V0OiAoc3RyZWFtSWQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChraWxsZWRUcmFja2VkLmtpbGxlZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmV4cG9ydHMuc3RyZWFtX3Jlc2V0KGNvbm5lY3Rpb25JZCwgc3RyZWFtSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKF9lcnJvcikgeyB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uc1tjb25uZWN0aW9uSWRdID0gY29ubmVjO1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNCYWRBZGRyZXNzID0gZXJyb3IgaW5zdGFuY2VvZiBDb25uZWN0aW9uRXJyb3I7XG4gICAgICAgICAgICAgICAgbGV0IGVycm9yU3RyID0gXCJVbmtub3duIGVycm9yXCI7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JTdHIgPSBlcnJvci50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBtZW0gPSBuZXcgVWludDhBcnJheShpbnN0YW5jZS5leHBvcnRzLm1lbW9yeS5idWZmZXIpO1xuICAgICAgICAgICAgICAgIGNvbmZpZy5idWZmZXJJbmRpY2VzWzBdID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKGVycm9yU3RyKTtcbiAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVVSW50MzJMRShtZW0sIGVycm9yQnVmZmVySW5kZXhQdHIsIDApO1xuICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVVJbnQ4KG1lbSwgZXJyb3JCdWZmZXJJbmRleFB0ciArIDQsIGlzQmFkQWRkcmVzcyA/IDEgOiAwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gTXVzdCBjbG9zZSBhbmQgZGVzdHJveSB0aGUgY29ubmVjdGlvbiBvYmplY3QuXG4gICAgICAgIHJlc2V0X2Nvbm5lY3Rpb246IChjb25uZWN0aW9uSWQpID0+IHtcbiAgICAgICAgICAgIGlmIChraWxsZWRUcmFja2VkLmtpbGxlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gY29ubmVjdGlvbnNbY29ubmVjdGlvbklkXTtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24ucmVzZXQoKTtcbiAgICAgICAgICAgIGRlbGV0ZSBjb25uZWN0aW9uc1tjb25uZWN0aW9uSWRdO1xuICAgICAgICB9LFxuICAgICAgICAvLyBPcGVucyBhIG5ldyBzdWJzdHJlYW0gb24gYSBtdWx0aS1zdHJlYW0gY29ubmVjdGlvbi5cbiAgICAgICAgY29ubmVjdGlvbl9zdHJlYW1fb3BlbjogKGNvbm5lY3Rpb25JZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IGNvbm5lY3Rpb25zW2Nvbm5lY3Rpb25JZF07XG4gICAgICAgICAgICBjb25uZWN0aW9uLm9wZW5PdXRTdWJzdHJlYW0oKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gQ2xvc2VzIGEgc3Vic3RyZWFtIG9uIGEgbXVsdGktc3RyZWFtIGNvbm5lY3Rpb24uXG4gICAgICAgIGNvbm5lY3Rpb25fc3RyZWFtX3Jlc2V0OiAoY29ubmVjdGlvbklkLCBzdHJlYW1JZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IGNvbm5lY3Rpb25zW2Nvbm5lY3Rpb25JZF07XG4gICAgICAgICAgICBjb25uZWN0aW9uLnJlc2V0KHN0cmVhbUlkKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gTXVzdCBxdWV1ZSB0aGUgZGF0YSBmb3VuZCBpbiB0aGUgV2ViQXNzZW1ibHkgbWVtb3J5IGF0IHRoZSBnaXZlbiBwb2ludGVyLiBJdCBpcyBhc3N1bWVkXG4gICAgICAgIC8vIHRoYXQgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb25seSB3aGVuIHRoZSBjb25uZWN0aW9uIGlzIGluIGFuIG9wZW4gc3RhdGUuXG4gICAgICAgIHN0cmVhbV9zZW5kOiAoY29ubmVjdGlvbklkLCBzdHJlYW1JZCwgcHRyLCBsZW4pID0+IHtcbiAgICAgICAgICAgIGlmIChraWxsZWRUcmFja2VkLmtpbGxlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGNvbmZpZy5pbnN0YW5jZTtcbiAgICAgICAgICAgIHB0ciA+Pj49IDA7XG4gICAgICAgICAgICBsZW4gPj4+PSAwO1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KGluc3RhbmNlLmV4cG9ydHMubWVtb3J5LmJ1ZmZlcikuc2xpY2UocHRyLCBwdHIgKyBsZW4pO1xuICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IGNvbm5lY3Rpb25zW2Nvbm5lY3Rpb25JZF07XG4gICAgICAgICAgICBjb25uZWN0aW9uLnNlbmQoZGF0YSwgc3RyZWFtSWQpOyAvLyBUT0RPOiBkb2NzIHNheXMgdGhlIHN0cmVhbUlkIGlzIHByb3ZpZGVkIG9ubHkgZm9yIG11bHRpLXN0cmVhbSBjb25uZWN0aW9ucywgYnV0IGhlcmUgaXQncyBhbHdheXMgcHJvdmlkZWRcbiAgICAgICAgfSxcbiAgICAgICAgc3RyZWFtX3NlbmRfY2xvc2U6IChjb25uZWN0aW9uSWQsIHN0cmVhbUlkKSA9PiB7XG4gICAgICAgICAgICBpZiAoa2lsbGVkVHJhY2tlZC5raWxsZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IGNvbm5lY3Rpb25zW2Nvbm5lY3Rpb25JZF07XG4gICAgICAgICAgICBjb25uZWN0aW9uLmNsb3NlU2VuZChzdHJlYW1JZCk7IC8vIFRPRE86IGRvY3Mgc2F5cyB0aGUgc3RyZWFtSWQgaXMgcHJvdmlkZWQgb25seSBmb3IgbXVsdGktc3RyZWFtIGNvbm5lY3Rpb25zLCBidXQgaGVyZSBpdCdzIGFsd2F5cyBwcm92aWRlZFxuICAgICAgICB9LFxuICAgICAgICBjdXJyZW50X3Rhc2tfZW50ZXJlZDogKHB0ciwgbGVuKSA9PiB7XG4gICAgICAgICAgICBpZiAoa2lsbGVkVHJhY2tlZC5raWxsZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBjb25maWcuaW5zdGFuY2U7XG4gICAgICAgICAgICBwdHIgPj4+PSAwO1xuICAgICAgICAgICAgbGVuID4+Pj0gMDtcbiAgICAgICAgICAgIGNvbnN0IHRhc2tOYW1lID0gYnVmZmVyLnV0ZjhCeXRlc1RvU3RyaW5nKG5ldyBVaW50OEFycmF5KGluc3RhbmNlLmV4cG9ydHMubWVtb3J5LmJ1ZmZlciksIHB0ciwgbGVuKTtcbiAgICAgICAgICAgIGlmIChjb25maWcuY3VycmVudFRhc2tDYWxsYmFjaylcbiAgICAgICAgICAgICAgICBjb25maWcuY3VycmVudFRhc2tDYWxsYmFjayh0YXNrTmFtZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGN1cnJlbnRfdGFza19leGl0OiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoa2lsbGVkVHJhY2tlZC5raWxsZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5jdXJyZW50VGFza0NhbGxiYWNrKVxuICAgICAgICAgICAgICAgIGNvbmZpZy5jdXJyZW50VGFza0NhbGxiYWNrKG51bGwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4geyBpbXBvcnRzLCBraWxsQWxsIH07XG59XG4iLCIvLyBTbW9sZG90XG4vLyBDb3B5cmlnaHQgKEMpIDIwMTktMjAyMiAgUGFyaXR5IFRlY2hub2xvZ2llcyAoVUspIEx0ZC5cbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBHUEwtMy4wLW9yLWxhdGVyIFdJVEggQ2xhc3NwYXRoLWV4Y2VwdGlvbi0yLjBcbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3Jcbi8vIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuLy8hIEV4cG9ydHMgYSBmdW5jdGlvbiB0aGF0IHByb3ZpZGVzIGJpbmRpbmdzIGZvciB0aGUgV2FzaSBpbnRlcmZhY2UuXG4vLyFcbi8vISBUaGVzZSBiaW5kaW5ncyBjYW4gdGhlbiBiZSB1c2VkIGJ5IHRoZSBXYXNtIHZpcnR1YWwgbWFjaGluZSB0byBpbnZva2UgV2FzaS1yZWxhdGVkIGZ1bmN0aW9ucy5cbi8vISBTZWUgPGh0dHBzOi8vd2FzaS5kZXYvPi5cbi8vIVxuLy8hIEluIG9yZGVyIHRvIHVzZSB0aGlzIGNvZGUsIGNhbGwgdGhlIGZ1bmN0aW9uIHBhc3NpbmcgYW4gb2JqZWN0LCB0aGVuIGZpbGwgdGhlIGBpbnN0YW5jZWAgZmllbGRcbi8vISBvZiB0aGF0IG9iamVjdCB3aXRoIHRoZSBXYXNtIGluc3RhbmNlLlxuaW1wb3J0ICogYXMgYnVmZmVyIGZyb20gJy4vYnVmZmVyLmpzJztcbmV4cG9ydCBkZWZhdWx0IChjb25maWcpID0+IHtcbiAgICAvLyBCdWZmZXJzIGhvbGRpbmcgdGVtcG9yYXJ5IGRhdGEgYmVpbmcgd3JpdHRlbiBieSB0aGUgUnVzdCBjb2RlIHRvIHJlc3BlY3RpdmVseSBzdGRvdXQgYW5kXG4gICAgLy8gc3RkZXJyLlxuICAgIGxldCBzdGRvdXRCdWZmZXIgPSBcIlwiO1xuICAgIGxldCBzdGRlcnJCdWZmZXIgPSBcIlwiO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8vIE5lZWQgdG8gZmlsbCB0aGUgYnVmZmVyIGRlc2NyaWJlZCBieSBgcHRyYCBhbmQgYGxlbmAgd2l0aCByYW5kb20gZGF0YS5cbiAgICAgICAgLy8gVGhpcyBkYXRhIHdpbGwgYmUgdXNlZCBpbiBvcmRlciB0byBnZW5lcmF0ZSBzZWNyZXRzLiBEbyBub3QgdXNlIGEgZHVtbXkgaW1wbGVtZW50YXRpb24hXG4gICAgICAgIHJhbmRvbV9nZXQ6IChwdHIsIGxlbikgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBjb25maWcuaW5zdGFuY2U7XG4gICAgICAgICAgICBwdHIgPj4+PSAwO1xuICAgICAgICAgICAgbGVuID4+Pj0gMDtcbiAgICAgICAgICAgIGNvbnN0IGJhc2VCdWZmZXIgPSBuZXcgVWludDhBcnJheShpbnN0YW5jZS5leHBvcnRzLm1lbW9yeS5idWZmZXIpXG4gICAgICAgICAgICAgICAgLnN1YmFycmF5KHB0ciwgcHRyICsgbGVuKTtcbiAgICAgICAgICAgIGZvciAobGV0IGl0ZXIgPSAwOyBpdGVyIDwgbGVuOyBpdGVyICs9IDY1NTM2KSB7XG4gICAgICAgICAgICAgICAgLy8gYGJhc2VCdWZmZXIuc3ViYXJyYXlgIGF1dG9tYXRpY2FsbHkgc2F0dXJhdGVzIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICAgICAgICAgICAgICAgIGNvbmZpZy5nZXRSYW5kb21WYWx1ZXMoYmFzZUJ1ZmZlci5zdWJhcnJheShpdGVyLCBpdGVyICsgNjU1MzYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9LFxuICAgICAgICBjbG9ja190aW1lX2dldDogKGNsb2NrSWQsIF9wcmVjaXNpb24sIG91dFB0cikgPT4ge1xuICAgICAgICAgICAgLy8gU2VlIDxodHRwczovL2dpdGh1Yi5jb20vcnVzdC1sYW5nL3J1c3QvYmxvYi9tYXN0ZXIvbGlicmFyeS9zdGQvc3JjL3N5cy93YXNpL3RpbWUucnM+XG4gICAgICAgICAgICAvLyBhbmQgPGRvY3MucnMvd2FzaS8+IGZvciBoZWxwLlxuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBjb25maWcuaW5zdGFuY2U7XG4gICAgICAgICAgICBjb25zdCBtZW0gPSBuZXcgVWludDhBcnJheShpbnN0YW5jZS5leHBvcnRzLm1lbW9yeS5idWZmZXIpO1xuICAgICAgICAgICAgb3V0UHRyID4+Pj0gMDtcbiAgICAgICAgICAgIC8vIFdlIGlnbm9yZSB0aGUgcHJlY2lzaW9uLCBhcyBpdCBjYW4ndCBiZSBpbXBsZW1lbnRlZCBhbnl3YXkuXG4gICAgICAgICAgICBzd2l0Y2ggKGNsb2NrSWQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVhbHRpbWUgY2xvY2suXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vdyA9IEJpZ0ludChNYXRoLmZsb29yKERhdGUubm93KCkpKSAqIEJpZ0ludCgxMDAwMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVUludDY0TEUobWVtLCBvdXRQdHIsIG5vdyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN1Y2Nlc3MuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTW9ub3RvbmljIGNsb2NrLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBub3dNcyA9IGNvbmZpZy5wZXJmb3JtYW5jZU5vdygpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBub3dNc0ludCA9IE1hdGguZmxvb3Iobm93TXMpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBub3cgPSBCaWdJbnQobm93TXNJbnQpICogQmlnSW50KDEwMDAwMDApICtcbiAgICAgICAgICAgICAgICAgICAgICAgIEJpZ0ludChNYXRoLmZsb29yKCgobm93TXMgLSBub3dNc0ludCkgKiAxMDAwMDAwKSkpO1xuICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVVSW50NjRMRShtZW0sIG91dFB0ciwgbm93KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3VjY2Vzcy5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiBhbiBgRUlOVkFMYCBlcnJvci5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDI4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBXcml0aW5nIHRvIGEgZmlsZSBkZXNjcmlwdG9yIGlzIHVzZWQgaW4gb3JkZXIgdG8gd3JpdGUgdG8gc3Rkb3V0L3N0ZGVyci5cbiAgICAgICAgZmRfd3JpdGU6IChmZCwgYWRkciwgbnVtLCBvdXRQdHIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gY29uZmlnLmluc3RhbmNlO1xuICAgICAgICAgICAgb3V0UHRyID4+Pj0gMDtcbiAgICAgICAgICAgIC8vIE9ubHkgc3Rkb3V0IGFuZCBzdGRlcnIgYXJlIG9wZW4gZm9yIHdyaXRpbmcuXG4gICAgICAgICAgICBpZiAoZmQgIT0gMSAmJiBmZCAhPSAyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtZW0gPSBuZXcgVWludDhBcnJheShpbnN0YW5jZS5leHBvcnRzLm1lbW9yeS5idWZmZXIpO1xuICAgICAgICAgICAgLy8gYGZkX3dyaXRlYCBwYXNzZXMgYSBidWZmZXIgY29udGFpbmluZyBpdHNlbGYgYSBsaXN0IG9mIHBvaW50ZXJzIGFuZCBsZW5ndGhzIHRvIHRoZVxuICAgICAgICAgICAgLy8gYWN0dWFsIGJ1ZmZlcnMuIFNlZSB3cml0ZXYoMikuXG4gICAgICAgICAgICBsZXQgdG9Xcml0ZSA9IFwiXCI7XG4gICAgICAgICAgICBsZXQgdG90YWxMZW5ndGggPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW07IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZiA9IGJ1ZmZlci5yZWFkVUludDMyTEUobWVtLCBhZGRyICsgNCAqIGkgKiAyKTtcbiAgICAgICAgICAgICAgICBjb25zdCBidWZMZW4gPSBidWZmZXIucmVhZFVJbnQzMkxFKG1lbSwgYWRkciArIDQgKiAoaSAqIDIgKyAxKSk7XG4gICAgICAgICAgICAgICAgdG9Xcml0ZSArPSBidWZmZXIudXRmOEJ5dGVzVG9TdHJpbmcobWVtLCBidWYsIGJ1Zkxlbik7XG4gICAgICAgICAgICAgICAgdG90YWxMZW5ndGggKz0gYnVmTGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZmx1c2hCdWZmZXIgPSAoc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gQXMgZG9jdW1lbnRlZCBpbiB0aGUgZG9jdW1lbnRhdGlvbiBvZiBgcHJpbnRsbiFgLCBsaW5lcyBhcmUgYWx3YXlzIHNwbGl0IGJ5IGFcbiAgICAgICAgICAgICAgICAvLyBzaW5nbGUgYFxcbmAgaW4gUnVzdC5cbiAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHN0cmluZy5pbmRleE9mKCdcXG4nKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3RlIHRoYXQgaXQgaXMgcXVlc3Rpb25uYWJsZSB0byB1c2UgYGNvbnNvbGUubG9nYCBmcm9tIHdpdGhpbiBhXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsaWJyYXJ5LiBIb3dldmVyIHRoaXMgc2ltcGx5IHJlZmxlY3RzIHRoZSB1c2FnZSBvZiBgcHJpbnRsbiFgIGluIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUnVzdCBjb2RlLiBJbiBvdGhlciB3b3JkcywgaXQgaXMgYHByaW50bG4hYCB0aGF0IHNob3VsZG4ndCBiZSB1c2VkIGluXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgZmlyc3QgcGxhY2UuIFRoZSBoYXJtIG9mIG5vdCBzaG93aW5nIHRleHQgcHJpbnRlZCB3aXRoIGBwcmludGxuIWBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGF0IGFsbCBpcyBncmVhdGVyIHRoYW4gdGhlIGhhcm0gcG9zc2libHkgY2F1c2VkIGJ5IGFjY2lkZW50YWxseSBsZWF2aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhIGBwcmludGxuIWAgaW4gdGhlIGNvZGUuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhzdHJpbmcuc3Vic3RyaW5nKDAsIGluZGV4KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcuc3Vic3RyaW5nKGluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIEFwcGVuZCB0aGUgbmV3bHktd3JpdHRlbiBkYXRhIHRvIGVpdGhlciBgc3Rkb3V0X2J1ZmZlcmAgb3IgYHN0ZGVycl9idWZmZXJgLCBhbmRcbiAgICAgICAgICAgIC8vIHByaW50IHRoZWlyIGNvbnRlbnQgaWYgbmVjZXNzYXJ5LlxuICAgICAgICAgICAgaWYgKGZkID09IDEpIHtcbiAgICAgICAgICAgICAgICBzdGRvdXRCdWZmZXIgKz0gdG9Xcml0ZTtcbiAgICAgICAgICAgICAgICBzdGRvdXRCdWZmZXIgPSBmbHVzaEJ1ZmZlcihzdGRvdXRCdWZmZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZmQgPT0gMikge1xuICAgICAgICAgICAgICAgIHN0ZGVyckJ1ZmZlciArPSB0b1dyaXRlO1xuICAgICAgICAgICAgICAgIHN0ZGVyckJ1ZmZlciA9IGZsdXNoQnVmZmVyKHN0ZGVyckJ1ZmZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOZWVkIHRvIHdyaXRlIGluIGBvdXRfcHRyYCBob3cgbXVjaCBkYXRhIHdhcyBcIndyaXR0ZW5cIi5cbiAgICAgICAgICAgIGJ1ZmZlci53cml0ZVVJbnQzMkxFKG1lbSwgb3V0UHRyLCB0b3RhbExlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gSXQncyB1bmNsZWFyIGhvdyB0byBwcm9wZXJseSBpbXBsZW1lbnQgeWllbGRpbmcsIGJ1dCBhIG5vLW9wIHdvcmtzIGZpbmUgYXMgd2VsbC5cbiAgICAgICAgc2NoZWRfeWllbGQ6ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9LFxuICAgICAgICAvLyBVc2VkIGJ5IFJ1c3QgaW4gY2F0YXN0cm9waGljIHNpdHVhdGlvbnMsIHN1Y2ggYXMgYSBkb3VibGUgcGFuaWMuXG4gICAgICAgIHByb2NfZXhpdDogKHJldENvZGUpID0+IHtcbiAgICAgICAgICAgIGNvbmZpZy5vblByb2NFeGl0KHJldENvZGUpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBSZXR1cm4gdGhlIG51bWJlciBvZiBlbnZpcm9ubWVudCB2YXJpYWJsZXMgYW5kIHRoZSB0b3RhbCBzaXplIG9mIGFsbCBlbnZpcm9ubWVudFxuICAgICAgICAvLyB2YXJpYWJsZXMuIFRoaXMgaXMgY2FsbGVkIGluIG9yZGVyIHRvIGluaXRpYWxpemUgYnVmZmVycyBiZWZvcmUgYGVudmlyb25fZ2V0YC5cbiAgICAgICAgZW52aXJvbl9zaXplc19nZXQ6IChhcmdjT3V0LCBhcmd2QnVmU2l6ZU91dCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBjb25maWcuaW5zdGFuY2U7XG4gICAgICAgICAgICBhcmdjT3V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGFyZ3ZCdWZTaXplT3V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGxldCB0b3RhbExlbiA9IDA7XG4gICAgICAgICAgICBjb25maWcuZW52VmFycy5mb3JFYWNoKGUgPT4gdG90YWxMZW4gKz0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKGUpLmxlbmd0aCArIDEpOyAvLyArMSBmb3IgdHJhaWxpbmcgXFwwXG4gICAgICAgICAgICBjb25zdCBtZW0gPSBuZXcgVWludDhBcnJheShpbnN0YW5jZS5leHBvcnRzLm1lbW9yeS5idWZmZXIpO1xuICAgICAgICAgICAgYnVmZmVyLndyaXRlVUludDMyTEUobWVtLCBhcmdjT3V0LCBjb25maWcuZW52VmFycy5sZW5ndGgpO1xuICAgICAgICAgICAgYnVmZmVyLndyaXRlVUludDMyTEUobWVtLCBhcmd2QnVmU2l6ZU91dCwgdG90YWxMZW4pO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFdyaXRlIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgdG8gdGhlIGdpdmVuIHBvaW50ZXJzLlxuICAgICAgICAvLyBgYXJndmAgaXMgYSBwb2ludGVyIHRvIGEgYnVmZmVyIHRoYXQgbXVzdCBiZSBvdmVyd3JpdHRlbiB3aXRoIGEgbGlzdCBvZiBwb2ludGVycyB0b1xuICAgICAgICAvLyBlbnZpcm9ubWVudCB2YXJpYWJsZXMsIGFuZCBgYXJndkJ1ZmAgaXMgYSBwb2ludGVyIHRvIGEgYnVmZmVyIHdoZXJlIHRvIGFjdHVhbGx5IHN0b3JlXG4gICAgICAgIC8vIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gICAgICAgIC8vIFRoZSBzaXplcyBvZiB0aGUgYnVmZmVycyB3ZXJlIGRldGVybWluZWQgYnkgY2FsbGluZyBgZW52aXJvbl9zaXplc19nZXRgLlxuICAgICAgICBlbnZpcm9uX2dldDogKGFyZ3YsIGFyZ3ZCdWYpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gY29uZmlnLmluc3RhbmNlO1xuICAgICAgICAgICAgYXJndiA+Pj49IDA7XG4gICAgICAgICAgICBhcmd2QnVmID4+Pj0gMDtcbiAgICAgICAgICAgIGNvbnN0IG1lbSA9IG5ldyBVaW50OEFycmF5KGluc3RhbmNlLmV4cG9ydHMubWVtb3J5LmJ1ZmZlcik7XG4gICAgICAgICAgICBsZXQgYXJndlBvcyA9IDA7XG4gICAgICAgICAgICBsZXQgYXJndkJ1ZlBvcyA9IDA7XG4gICAgICAgICAgICBjb25maWcuZW52VmFycy5mb3JFYWNoKGVudlZhciA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5jb2RlZCA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShlbnZWYXIpO1xuICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVVJbnQzMkxFKG1lbSwgYXJndiArIGFyZ3ZQb3MsIGFyZ3ZCdWYgKyBhcmd2QnVmUG9zKTtcbiAgICAgICAgICAgICAgICBhcmd2UG9zICs9IDQ7XG4gICAgICAgICAgICAgICAgbWVtLnNldChlbmNvZGVkLCBhcmd2QnVmICsgYXJndkJ1ZlBvcyk7XG4gICAgICAgICAgICAgICAgYXJndkJ1ZlBvcyArPSBlbmNvZGVkLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVVSW50OChtZW0sIGFyZ3ZCdWYgKyBhcmd2QnVmUG9zLCAwKTtcbiAgICAgICAgICAgICAgICBhcmd2QnVmUG9zICs9IDE7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9