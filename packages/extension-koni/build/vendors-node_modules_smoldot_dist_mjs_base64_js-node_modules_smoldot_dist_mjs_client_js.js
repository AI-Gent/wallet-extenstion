"use strict";
((typeof self !== 'undefined' ? self : this)["webpackChunk_subwallet_extension_koni"] = (typeof self !== 'undefined' ? self : this)["webpackChunk_subwallet_extension_koni"] || []).push([["vendors-node_modules_smoldot_dist_mjs_base64_js-node_modules_smoldot_dist_mjs_client_js"],{

/***/ "../../node_modules/smoldot/dist/mjs/base64.js":
/*!*****************************************************!*\
  !*** ../../node_modules/smoldot/dist/mjs/base64.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "base64Decode": () => (/* binding */ base64Decode),
/* harmony export */   "classicDecode": () => (/* binding */ classicDecode),
/* harmony export */   "multibaseBase64Decode": () => (/* binding */ multibaseBase64Decode),
/* harmony export */   "urlSafeDecode": () => (/* binding */ urlSafeDecode)
/* harmony export */ });
// Smoldot
// Copyright (C) 2019-2022  Parity Technologies (UK) Ltd.
// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
let rfc4648Alphabet = new Map();
const rfc4648AlphabetAsStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (let i = 0; i < rfc4648AlphabetAsStr.length; ++i) {
    rfc4648Alphabet.set(rfc4648AlphabetAsStr[i], i);
}
let urlSafeAlphabet = new Map();
const urlSafeAlphabetAsStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
for (let i = 0; i < urlSafeAlphabetAsStr.length; ++i) {
    urlSafeAlphabet.set(urlSafeAlphabetAsStr[i], i);
}
/**
 * Decodes a multibase-encoded string.
 *
 * Throws an exception if the encoding isn't base64 or one of its variants.
 */
function multibaseBase64Decode(input) {
    if (input.length === 0)
        throw new Error("Invalid multibase");
    switch (input[0]) {
        case 'm':
        case 'M':
            return classicDecode(input.slice(1));
        case 'u':
        case 'U':
            return urlSafeDecode(input.slice(1));
        default:
            throw new Error('Unknown multibase prefix: ' + input[0]);
    }
}
/**
 * Decodes a base64-encoded string into bytes using the original alphabet from RFC4648.
 *
 * See <https://datatracker.ietf.org/doc/html/rfc4648#section-4>.
 */
function classicDecode(input) {
    return base64Decode(input, rfc4648Alphabet);
}
/**
 * Decodes a base64-encoded string into bytes using the URL-safe alphabet.
 *
 * See <https://datatracker.ietf.org/doc/html/rfc4648#section-5>.
 */
function urlSafeDecode(input) {
    return base64Decode(input, urlSafeAlphabet);
}
/**
 * Decodes a base64-encoded string into bytes using the given alphabet.
 */
function base64Decode(input, alphabet) {
    // Remove the padding bytes at the end of the string. We don't check whether the padding is
    // accurate.
    while (input.length !== 0 && input[input.length - 1] === '=')
        input = input.slice(0, -1);
    // Contains the output data.
    const out = new Uint8Array(Math.floor(input.length * 6 / 8));
    // Position within `out` of the next byte to write.
    let outPos = 0;
    // The bits decoded from the input are added to the right of this value.
    let currentByte = 0;
    // The left-most `validBitsInCurrentByte` bits of `currentByte` must be written out.
    let validBitsInCurrentByte = 0;
    for (let i = 0; i < input.length; ++i) {
        const inputChr = input[i];
        const bitsToAppend = alphabet.get(inputChr);
        if (bitsToAppend === undefined)
            throw new Error('Invalid base64 character: ' + inputChr);
        console.assert(bitsToAppend < (1 << 6));
        currentByte = (currentByte << 6) | bitsToAppend;
        validBitsInCurrentByte += 6;
        if (validBitsInCurrentByte >= 8) {
            let outByte = currentByte >> (validBitsInCurrentByte - 8);
            out[outPos] = outByte;
            outPos += 1;
            validBitsInCurrentByte -= 8;
        }
        console.assert(validBitsInCurrentByte < 8);
        currentByte &= 0xff;
    }
    if ((currentByte & ((1 << validBitsInCurrentByte) - 1)) !== 0)
        throw new Error("Unexpected EOF");
    if (validBitsInCurrentByte >= 6)
        throw new Error("Unexpected EOF");
    return out;
}


/***/ }),

/***/ "../../node_modules/smoldot/dist/mjs/client.js":
/*!*****************************************************!*\
  !*** ../../node_modules/smoldot/dist/mjs/client.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AddChainError": () => (/* binding */ AddChainError),
/* harmony export */   "AlreadyDestroyedError": () => (/* binding */ AlreadyDestroyedError),
/* harmony export */   "CrashError": () => (/* reexport safe */ _instance_instance_js__WEBPACK_IMPORTED_MODULE_0__.CrashError),
/* harmony export */   "JsonRpcDisabledError": () => (/* binding */ JsonRpcDisabledError),
/* harmony export */   "MalformedJsonRpcError": () => (/* reexport safe */ _instance_instance_js__WEBPACK_IMPORTED_MODULE_0__.MalformedJsonRpcError),
/* harmony export */   "QueueFullError": () => (/* reexport safe */ _instance_instance_js__WEBPACK_IMPORTED_MODULE_0__.QueueFullError),
/* harmony export */   "start": () => (/* binding */ start)
/* harmony export */ });
/* harmony import */ var _instance_instance_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instance/instance.js */ "../../node_modules/smoldot/dist/mjs/instance/instance.js");
// Smoldot
// Copyright (C) 2019-2022  Parity Technologies (UK) Ltd.
// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.


/**
 * Thrown in case of a problem when initializing the chain.
 */
class AddChainError extends Error {
    constructor(message) {
        super(message);
        this.name = "AddChainError";
    }
}
/**
 * Thrown in case the API user tries to use a chain or client that has already been destroyed.
 */
class AlreadyDestroyedError extends Error {
    constructor() {
        super();
        this.name = "AlreadyDestroyedError";
    }
}
/**
 * Thrown when trying to send a JSON-RPC message to a chain whose JSON-RPC system hasn't been
 * enabled.
 */
class JsonRpcDisabledError extends Error {
    constructor() {
        super();
        this.name = "JsonRpcDisabledError";
    }
}
// This function is similar to the `start` function found in `index.ts`, except with an extra
// parameter containing the platform-specific bindings.
// Contrary to the one within `index.js`, this function is not supposed to be directly used.
function start(options, wasmModule, platformBindings) {
    const logCallback = options.logCallback || ((level, target, message) => {
        // The first parameter of the methods of `console` has some printf-like substitution
        // capabilities. We don't really need to use this, but not using it means that the logs might
        // not get printed correctly if they contain `%`.
        if (level <= 1) {
            console.error("[%s] %s", target, message);
        }
        else if (level == 2) {
            console.warn("[%s] %s", target, message);
        }
        else if (level == 3) {
            console.info("[%s] %s", target, message);
        }
        else if (level == 4) {
            console.debug("[%s] %s", target, message);
        }
        else {
            console.trace("[%s] %s", target, message);
        }
    });
    // For each chain object returned by `addChain`, the associated internal chain id.
    //
    // Immediately cleared when `remove()` is called on a chain.
    const chainIds = new WeakMap();
    // If `Client.terminate()Ì€  is called, this error is set to a value.
    // All the functions of the public API check if this contains a value.
    const alreadyDestroyedError = { value: null };
    const instance = (0,_instance_instance_js__WEBPACK_IMPORTED_MODULE_0__.start)({
        wasmModule,
        // Maximum level of log entries sent by the client.
        // 0 = Logging disabled, 1 = Error, 2 = Warn, 3 = Info, 4 = Debug, 5 = Trace
        maxLogLevel: options.maxLogLevel || 3,
        logCallback,
        cpuRateLimit: options.cpuRateLimit || 1.0,
    }, platformBindings);
    return {
        addChain: (options) => __awaiter(this, void 0, void 0, function* () {
            if (alreadyDestroyedError.value)
                throw alreadyDestroyedError.value;
            // Passing a JSON object for the chain spec is an easy mistake, so we provide a more
            // readable error.
            if (!(typeof options.chainSpec === 'string'))
                throw new Error("Chain specification must be a string");
            let potentialRelayChainsIds = [];
            if (!!options.potentialRelayChains) {
                for (const chain of options.potentialRelayChains) {
                    // The content of `options.potentialRelayChains` are supposed to be chains earlier
                    // returned by `addChain`.
                    const id = chainIds.get(chain);
                    if (id === undefined) // It is possible for `id` to be missing if it has earlier been removed.
                        continue;
                    potentialRelayChainsIds.push(id);
                }
            }
            const outcome = yield instance.addChain(options.chainSpec, typeof options.databaseContent === 'string' ? options.databaseContent : "", potentialRelayChainsIds, !!options.disableJsonRpc);
            if (!outcome.success)
                throw new AddChainError(outcome.error);
            const chainId = outcome.chainId;
            const wasDestroyed = { destroyed: false };
            // `expected` was pushed by the `addChain` method.
            // Resolve the promise that `addChain` returned to the user.
            const newChain = {
                sendJsonRpc: (request) => {
                    if (alreadyDestroyedError.value)
                        throw alreadyDestroyedError.value;
                    if (wasDestroyed.destroyed)
                        throw new AlreadyDestroyedError();
                    if (options.disableJsonRpc)
                        throw new JsonRpcDisabledError();
                    if (request.length >= 64 * 1024 * 1024) {
                        throw new _instance_instance_js__WEBPACK_IMPORTED_MODULE_0__.MalformedJsonRpcError();
                    }
                    ;
                    instance.request(request, chainId);
                },
                nextJsonRpcResponse: () => {
                    if (alreadyDestroyedError.value)
                        return Promise.reject(alreadyDestroyedError.value);
                    if (wasDestroyed.destroyed)
                        return Promise.reject(new AlreadyDestroyedError());
                    if (options.disableJsonRpc)
                        return Promise.reject(new JsonRpcDisabledError());
                    return instance.nextJsonRpcResponse(chainId);
                },
                remove: () => {
                    if (alreadyDestroyedError.value)
                        throw alreadyDestroyedError.value;
                    if (wasDestroyed.destroyed)
                        throw new AlreadyDestroyedError();
                    wasDestroyed.destroyed = true;
                    console.assert(chainIds.has(newChain));
                    chainIds.delete(newChain);
                    instance.removeChain(chainId);
                },
            };
            chainIds.set(newChain, chainId);
            return newChain;
        }),
        terminate: () => __awaiter(this, void 0, void 0, function* () {
            if (alreadyDestroyedError.value)
                throw alreadyDestroyedError.value;
            alreadyDestroyedError.value = new AlreadyDestroyedError();
            instance.startShutdown();
        })
    };
}


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfc21vbGRvdF9kaXN0X21qc19iYXNlNjRfanMtbm9kZV9tb2R1bGVzX3Ntb2xkb3RfZGlzdF9tanNfY2xpZW50X2pzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQ0FBaUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUNBQWlDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFJLElBQUksU0FBSTtBQUM3Qiw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDdUY7QUFDSTtBQUMzRjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLHFCQUFxQiw0REFBYTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHdFQUFxQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BzdWJ3YWxsZXQvZXh0ZW5zaW9uLWtvbmkvLi4vLi4vbm9kZV9tb2R1bGVzL3Ntb2xkb3QvZGlzdC9tanMvYmFzZTY0LmpzIiwid2VicGFjazovL0BzdWJ3YWxsZXQvZXh0ZW5zaW9uLWtvbmkvLi4vLi4vbm9kZV9tb2R1bGVzL3Ntb2xkb3QvZGlzdC9tanMvY2xpZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFNtb2xkb3Rcbi8vIENvcHlyaWdodCAoQykgMjAxOS0yMDIyICBQYXJpdHkgVGVjaG5vbG9naWVzIChVSykgTHRkLlxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAtb3ItbGF0ZXIgV0lUSCBDbGFzc3BhdGgtZXhjZXB0aW9uLTIuMFxuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuLy8gKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW0uICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG5sZXQgcmZjNDY0OEFscGhhYmV0ID0gbmV3IE1hcCgpO1xuY29uc3QgcmZjNDY0OEFscGhhYmV0QXNTdHIgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIjtcbmZvciAobGV0IGkgPSAwOyBpIDwgcmZjNDY0OEFscGhhYmV0QXNTdHIubGVuZ3RoOyArK2kpIHtcbiAgICByZmM0NjQ4QWxwaGFiZXQuc2V0KHJmYzQ2NDhBbHBoYWJldEFzU3RyW2ldLCBpKTtcbn1cbmxldCB1cmxTYWZlQWxwaGFiZXQgPSBuZXcgTWFwKCk7XG5jb25zdCB1cmxTYWZlQWxwaGFiZXRBc1N0ciA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktX1wiO1xuZm9yIChsZXQgaSA9IDA7IGkgPCB1cmxTYWZlQWxwaGFiZXRBc1N0ci5sZW5ndGg7ICsraSkge1xuICAgIHVybFNhZmVBbHBoYWJldC5zZXQodXJsU2FmZUFscGhhYmV0QXNTdHJbaV0sIGkpO1xufVxuLyoqXG4gKiBEZWNvZGVzIGEgbXVsdGliYXNlLWVuY29kZWQgc3RyaW5nLlxuICpcbiAqIFRocm93cyBhbiBleGNlcHRpb24gaWYgdGhlIGVuY29kaW5nIGlzbid0IGJhc2U2NCBvciBvbmUgb2YgaXRzIHZhcmlhbnRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbXVsdGliYXNlQmFzZTY0RGVjb2RlKGlucHV0KSB7XG4gICAgaWYgKGlucHV0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBtdWx0aWJhc2VcIik7XG4gICAgc3dpdGNoIChpbnB1dFswXSkge1xuICAgICAgICBjYXNlICdtJzpcbiAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgICByZXR1cm4gY2xhc3NpY0RlY29kZShpbnB1dC5zbGljZSgxKSk7XG4gICAgICAgIGNhc2UgJ3UnOlxuICAgICAgICBjYXNlICdVJzpcbiAgICAgICAgICAgIHJldHVybiB1cmxTYWZlRGVjb2RlKGlucHV0LnNsaWNlKDEpKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBtdWx0aWJhc2UgcHJlZml4OiAnICsgaW5wdXRbMF0pO1xuICAgIH1cbn1cbi8qKlxuICogRGVjb2RlcyBhIGJhc2U2NC1lbmNvZGVkIHN0cmluZyBpbnRvIGJ5dGVzIHVzaW5nIHRoZSBvcmlnaW5hbCBhbHBoYWJldCBmcm9tIFJGQzQ2NDguXG4gKlxuICogU2VlIDxodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzQ2NDgjc2VjdGlvbi00Pi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsYXNzaWNEZWNvZGUoaW5wdXQpIHtcbiAgICByZXR1cm4gYmFzZTY0RGVjb2RlKGlucHV0LCByZmM0NjQ4QWxwaGFiZXQpO1xufVxuLyoqXG4gKiBEZWNvZGVzIGEgYmFzZTY0LWVuY29kZWQgc3RyaW5nIGludG8gYnl0ZXMgdXNpbmcgdGhlIFVSTC1zYWZlIGFscGhhYmV0LlxuICpcbiAqIFNlZSA8aHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM0NjQ4I3NlY3Rpb24tNT4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cmxTYWZlRGVjb2RlKGlucHV0KSB7XG4gICAgcmV0dXJuIGJhc2U2NERlY29kZShpbnB1dCwgdXJsU2FmZUFscGhhYmV0KTtcbn1cbi8qKlxuICogRGVjb2RlcyBhIGJhc2U2NC1lbmNvZGVkIHN0cmluZyBpbnRvIGJ5dGVzIHVzaW5nIHRoZSBnaXZlbiBhbHBoYWJldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJhc2U2NERlY29kZShpbnB1dCwgYWxwaGFiZXQpIHtcbiAgICAvLyBSZW1vdmUgdGhlIHBhZGRpbmcgYnl0ZXMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLiBXZSBkb24ndCBjaGVjayB3aGV0aGVyIHRoZSBwYWRkaW5nIGlzXG4gICAgLy8gYWNjdXJhdGUuXG4gICAgd2hpbGUgKGlucHV0Lmxlbmd0aCAhPT0gMCAmJiBpbnB1dFtpbnB1dC5sZW5ndGggLSAxXSA9PT0gJz0nKVxuICAgICAgICBpbnB1dCA9IGlucHV0LnNsaWNlKDAsIC0xKTtcbiAgICAvLyBDb250YWlucyB0aGUgb3V0cHV0IGRhdGEuXG4gICAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkoTWF0aC5mbG9vcihpbnB1dC5sZW5ndGggKiA2IC8gOCkpO1xuICAgIC8vIFBvc2l0aW9uIHdpdGhpbiBgb3V0YCBvZiB0aGUgbmV4dCBieXRlIHRvIHdyaXRlLlxuICAgIGxldCBvdXRQb3MgPSAwO1xuICAgIC8vIFRoZSBiaXRzIGRlY29kZWQgZnJvbSB0aGUgaW5wdXQgYXJlIGFkZGVkIHRvIHRoZSByaWdodCBvZiB0aGlzIHZhbHVlLlxuICAgIGxldCBjdXJyZW50Qnl0ZSA9IDA7XG4gICAgLy8gVGhlIGxlZnQtbW9zdCBgdmFsaWRCaXRzSW5DdXJyZW50Qnl0ZWAgYml0cyBvZiBgY3VycmVudEJ5dGVgIG11c3QgYmUgd3JpdHRlbiBvdXQuXG4gICAgbGV0IHZhbGlkQml0c0luQ3VycmVudEJ5dGUgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgaW5wdXRDaHIgPSBpbnB1dFtpXTtcbiAgICAgICAgY29uc3QgYml0c1RvQXBwZW5kID0gYWxwaGFiZXQuZ2V0KGlucHV0Q2hyKTtcbiAgICAgICAgaWYgKGJpdHNUb0FwcGVuZCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJhc2U2NCBjaGFyYWN0ZXI6ICcgKyBpbnB1dENocik7XG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KGJpdHNUb0FwcGVuZCA8ICgxIDw8IDYpKTtcbiAgICAgICAgY3VycmVudEJ5dGUgPSAoY3VycmVudEJ5dGUgPDwgNikgfCBiaXRzVG9BcHBlbmQ7XG4gICAgICAgIHZhbGlkQml0c0luQ3VycmVudEJ5dGUgKz0gNjtcbiAgICAgICAgaWYgKHZhbGlkQml0c0luQ3VycmVudEJ5dGUgPj0gOCkge1xuICAgICAgICAgICAgbGV0IG91dEJ5dGUgPSBjdXJyZW50Qnl0ZSA+PiAodmFsaWRCaXRzSW5DdXJyZW50Qnl0ZSAtIDgpO1xuICAgICAgICAgICAgb3V0W291dFBvc10gPSBvdXRCeXRlO1xuICAgICAgICAgICAgb3V0UG9zICs9IDE7XG4gICAgICAgICAgICB2YWxpZEJpdHNJbkN1cnJlbnRCeXRlIC09IDg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5hc3NlcnQodmFsaWRCaXRzSW5DdXJyZW50Qnl0ZSA8IDgpO1xuICAgICAgICBjdXJyZW50Qnl0ZSAmPSAweGZmO1xuICAgIH1cbiAgICBpZiAoKGN1cnJlbnRCeXRlICYgKCgxIDw8IHZhbGlkQml0c0luQ3VycmVudEJ5dGUpIC0gMSkpICE9PSAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIEVPRlwiKTtcbiAgICBpZiAodmFsaWRCaXRzSW5DdXJyZW50Qnl0ZSA+PSA2KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIEVPRlwiKTtcbiAgICByZXR1cm4gb3V0O1xufVxuIiwiLy8gU21vbGRvdFxuLy8gQ29weXJpZ2h0IChDKSAyMDE5LTIwMjIgIFBhcml0eSBUZWNobm9sb2dpZXMgKFVLKSBMdGQuXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogR1BMLTMuMC1vci1sYXRlciBXSVRIIENsYXNzcGF0aC1leGNlcHRpb24tMi4wXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3Jcbi8vIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuaW1wb3J0IHsgTWFsZm9ybWVkSnNvblJwY0Vycm9yLCBzdGFydCBhcyBzdGFydEluc3RhbmNlIH0gZnJvbSAnLi9pbnN0YW5jZS9pbnN0YW5jZS5qcyc7XG5leHBvcnQgeyBNYWxmb3JtZWRKc29uUnBjRXJyb3IsIFF1ZXVlRnVsbEVycm9yLCBDcmFzaEVycm9yIH0gZnJvbSAnLi9pbnN0YW5jZS9pbnN0YW5jZS5qcyc7XG4vKipcbiAqIFRocm93biBpbiBjYXNlIG9mIGEgcHJvYmxlbSB3aGVuIGluaXRpYWxpemluZyB0aGUgY2hhaW4uXG4gKi9cbmV4cG9ydCBjbGFzcyBBZGRDaGFpbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiQWRkQ2hhaW5FcnJvclwiO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3duIGluIGNhc2UgdGhlIEFQSSB1c2VyIHRyaWVzIHRvIHVzZSBhIGNoYWluIG9yIGNsaWVudCB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gZGVzdHJveWVkLlxuICovXG5leHBvcnQgY2xhc3MgQWxyZWFkeURlc3Ryb3llZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkFscmVhZHlEZXN0cm95ZWRFcnJvclwiO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3duIHdoZW4gdHJ5aW5nIHRvIHNlbmQgYSBKU09OLVJQQyBtZXNzYWdlIHRvIGEgY2hhaW4gd2hvc2UgSlNPTi1SUEMgc3lzdGVtIGhhc24ndCBiZWVuXG4gKiBlbmFibGVkLlxuICovXG5leHBvcnQgY2xhc3MgSnNvblJwY0Rpc2FibGVkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiSnNvblJwY0Rpc2FibGVkRXJyb3JcIjtcbiAgICB9XG59XG4vLyBUaGlzIGZ1bmN0aW9uIGlzIHNpbWlsYXIgdG8gdGhlIGBzdGFydGAgZnVuY3Rpb24gZm91bmQgaW4gYGluZGV4LnRzYCwgZXhjZXB0IHdpdGggYW4gZXh0cmFcbi8vIHBhcmFtZXRlciBjb250YWluaW5nIHRoZSBwbGF0Zm9ybS1zcGVjaWZpYyBiaW5kaW5ncy5cbi8vIENvbnRyYXJ5IHRvIHRoZSBvbmUgd2l0aGluIGBpbmRleC5qc2AsIHRoaXMgZnVuY3Rpb24gaXMgbm90IHN1cHBvc2VkIHRvIGJlIGRpcmVjdGx5IHVzZWQuXG5leHBvcnQgZnVuY3Rpb24gc3RhcnQob3B0aW9ucywgd2FzbU1vZHVsZSwgcGxhdGZvcm1CaW5kaW5ncykge1xuICAgIGNvbnN0IGxvZ0NhbGxiYWNrID0gb3B0aW9ucy5sb2dDYWxsYmFjayB8fCAoKGxldmVsLCB0YXJnZXQsIG1lc3NhZ2UpID0+IHtcbiAgICAgICAgLy8gVGhlIGZpcnN0IHBhcmFtZXRlciBvZiB0aGUgbWV0aG9kcyBvZiBgY29uc29sZWAgaGFzIHNvbWUgcHJpbnRmLWxpa2Ugc3Vic3RpdHV0aW9uXG4gICAgICAgIC8vIGNhcGFiaWxpdGllcy4gV2UgZG9uJ3QgcmVhbGx5IG5lZWQgdG8gdXNlIHRoaXMsIGJ1dCBub3QgdXNpbmcgaXQgbWVhbnMgdGhhdCB0aGUgbG9ncyBtaWdodFxuICAgICAgICAvLyBub3QgZ2V0IHByaW50ZWQgY29ycmVjdGx5IGlmIHRoZXkgY29udGFpbiBgJWAuXG4gICAgICAgIGlmIChsZXZlbCA8PSAxKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiWyVzXSAlc1wiLCB0YXJnZXQsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxldmVsID09IDIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlslc10gJXNcIiwgdGFyZ2V0LCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsZXZlbCA9PSAzKSB7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJbJXNdICVzXCIsIHRhcmdldCwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGV2ZWwgPT0gNCkge1xuICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhcIlslc10gJXNcIiwgdGFyZ2V0LCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUudHJhY2UoXCJbJXNdICVzXCIsIHRhcmdldCwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBGb3IgZWFjaCBjaGFpbiBvYmplY3QgcmV0dXJuZWQgYnkgYGFkZENoYWluYCwgdGhlIGFzc29jaWF0ZWQgaW50ZXJuYWwgY2hhaW4gaWQuXG4gICAgLy9cbiAgICAvLyBJbW1lZGlhdGVseSBjbGVhcmVkIHdoZW4gYHJlbW92ZSgpYCBpcyBjYWxsZWQgb24gYSBjaGFpbi5cbiAgICBjb25zdCBjaGFpbklkcyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgLy8gSWYgYENsaWVudC50ZXJtaW5hdGUoKcyAICBpcyBjYWxsZWQsIHRoaXMgZXJyb3IgaXMgc2V0IHRvIGEgdmFsdWUuXG4gICAgLy8gQWxsIHRoZSBmdW5jdGlvbnMgb2YgdGhlIHB1YmxpYyBBUEkgY2hlY2sgaWYgdGhpcyBjb250YWlucyBhIHZhbHVlLlxuICAgIGNvbnN0IGFscmVhZHlEZXN0cm95ZWRFcnJvciA9IHsgdmFsdWU6IG51bGwgfTtcbiAgICBjb25zdCBpbnN0YW5jZSA9IHN0YXJ0SW5zdGFuY2Uoe1xuICAgICAgICB3YXNtTW9kdWxlLFxuICAgICAgICAvLyBNYXhpbXVtIGxldmVsIG9mIGxvZyBlbnRyaWVzIHNlbnQgYnkgdGhlIGNsaWVudC5cbiAgICAgICAgLy8gMCA9IExvZ2dpbmcgZGlzYWJsZWQsIDEgPSBFcnJvciwgMiA9IFdhcm4sIDMgPSBJbmZvLCA0ID0gRGVidWcsIDUgPSBUcmFjZVxuICAgICAgICBtYXhMb2dMZXZlbDogb3B0aW9ucy5tYXhMb2dMZXZlbCB8fCAzLFxuICAgICAgICBsb2dDYWxsYmFjayxcbiAgICAgICAgY3B1UmF0ZUxpbWl0OiBvcHRpb25zLmNwdVJhdGVMaW1pdCB8fCAxLjAsXG4gICAgfSwgcGxhdGZvcm1CaW5kaW5ncyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkQ2hhaW46IChvcHRpb25zKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoYWxyZWFkeURlc3Ryb3llZEVycm9yLnZhbHVlKVxuICAgICAgICAgICAgICAgIHRocm93IGFscmVhZHlEZXN0cm95ZWRFcnJvci52YWx1ZTtcbiAgICAgICAgICAgIC8vIFBhc3NpbmcgYSBKU09OIG9iamVjdCBmb3IgdGhlIGNoYWluIHNwZWMgaXMgYW4gZWFzeSBtaXN0YWtlLCBzbyB3ZSBwcm92aWRlIGEgbW9yZVxuICAgICAgICAgICAgLy8gcmVhZGFibGUgZXJyb3IuXG4gICAgICAgICAgICBpZiAoISh0eXBlb2Ygb3B0aW9ucy5jaGFpblNwZWMgPT09ICdzdHJpbmcnKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDaGFpbiBzcGVjaWZpY2F0aW9uIG11c3QgYmUgYSBzdHJpbmdcIik7XG4gICAgICAgICAgICBsZXQgcG90ZW50aWFsUmVsYXlDaGFpbnNJZHMgPSBbXTtcbiAgICAgICAgICAgIGlmICghIW9wdGlvbnMucG90ZW50aWFsUmVsYXlDaGFpbnMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNoYWluIG9mIG9wdGlvbnMucG90ZW50aWFsUmVsYXlDaGFpbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGNvbnRlbnQgb2YgYG9wdGlvbnMucG90ZW50aWFsUmVsYXlDaGFpbnNgIGFyZSBzdXBwb3NlZCB0byBiZSBjaGFpbnMgZWFybGllclxuICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5lZCBieSBgYWRkQ2hhaW5gLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpZCA9IGNoYWluSWRzLmdldChjaGFpbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpZCA9PT0gdW5kZWZpbmVkKSAvLyBJdCBpcyBwb3NzaWJsZSBmb3IgYGlkYCB0byBiZSBtaXNzaW5nIGlmIGl0IGhhcyBlYXJsaWVyIGJlZW4gcmVtb3ZlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxSZWxheUNoYWluc0lkcy5wdXNoKGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvdXRjb21lID0geWllbGQgaW5zdGFuY2UuYWRkQ2hhaW4ob3B0aW9ucy5jaGFpblNwZWMsIHR5cGVvZiBvcHRpb25zLmRhdGFiYXNlQ29udGVudCA9PT0gJ3N0cmluZycgPyBvcHRpb25zLmRhdGFiYXNlQ29udGVudCA6IFwiXCIsIHBvdGVudGlhbFJlbGF5Q2hhaW5zSWRzLCAhIW9wdGlvbnMuZGlzYWJsZUpzb25ScGMpO1xuICAgICAgICAgICAgaWYgKCFvdXRjb21lLnN1Y2Nlc3MpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFkZENoYWluRXJyb3Iob3V0Y29tZS5lcnJvcik7XG4gICAgICAgICAgICBjb25zdCBjaGFpbklkID0gb3V0Y29tZS5jaGFpbklkO1xuICAgICAgICAgICAgY29uc3Qgd2FzRGVzdHJveWVkID0geyBkZXN0cm95ZWQ6IGZhbHNlIH07XG4gICAgICAgICAgICAvLyBgZXhwZWN0ZWRgIHdhcyBwdXNoZWQgYnkgdGhlIGBhZGRDaGFpbmAgbWV0aG9kLlxuICAgICAgICAgICAgLy8gUmVzb2x2ZSB0aGUgcHJvbWlzZSB0aGF0IGBhZGRDaGFpbmAgcmV0dXJuZWQgdG8gdGhlIHVzZXIuXG4gICAgICAgICAgICBjb25zdCBuZXdDaGFpbiA9IHtcbiAgICAgICAgICAgICAgICBzZW5kSnNvblJwYzogKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFscmVhZHlEZXN0cm95ZWRFcnJvci52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGFscmVhZHlEZXN0cm95ZWRFcnJvci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdhc0Rlc3Ryb3llZC5kZXN0cm95ZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQWxyZWFkeURlc3Ryb3llZEVycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmRpc2FibGVKc29uUnBjKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEpzb25ScGNEaXNhYmxlZEVycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0Lmxlbmd0aCA+PSA2NCAqIDEwMjQgKiAxMDI0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTWFsZm9ybWVkSnNvblJwY0Vycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5yZXF1ZXN0KHJlcXVlc3QsIGNoYWluSWQpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbmV4dEpzb25ScGNSZXNwb25zZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWxyZWFkeURlc3Ryb3llZEVycm9yLnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGFscmVhZHlEZXN0cm95ZWRFcnJvci52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3YXNEZXN0cm95ZWQuZGVzdHJveWVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBBbHJlYWR5RGVzdHJveWVkRXJyb3IoKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmRpc2FibGVKc29uUnBjKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBKc29uUnBjRGlzYWJsZWRFcnJvcigpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlLm5leHRKc29uUnBjUmVzcG9uc2UoY2hhaW5JZCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZW1vdmU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFscmVhZHlEZXN0cm95ZWRFcnJvci52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGFscmVhZHlEZXN0cm95ZWRFcnJvci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdhc0Rlc3Ryb3llZC5kZXN0cm95ZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQWxyZWFkeURlc3Ryb3llZEVycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgIHdhc0Rlc3Ryb3llZC5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydChjaGFpbklkcy5oYXMobmV3Q2hhaW4pKTtcbiAgICAgICAgICAgICAgICAgICAgY2hhaW5JZHMuZGVsZXRlKG5ld0NoYWluKTtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UucmVtb3ZlQ2hhaW4oY2hhaW5JZCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjaGFpbklkcy5zZXQobmV3Q2hhaW4sIGNoYWluSWQpO1xuICAgICAgICAgICAgcmV0dXJuIG5ld0NoYWluO1xuICAgICAgICB9KSxcbiAgICAgICAgdGVybWluYXRlOiAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoYWxyZWFkeURlc3Ryb3llZEVycm9yLnZhbHVlKVxuICAgICAgICAgICAgICAgIHRocm93IGFscmVhZHlEZXN0cm95ZWRFcnJvci52YWx1ZTtcbiAgICAgICAgICAgIGFscmVhZHlEZXN0cm95ZWRFcnJvci52YWx1ZSA9IG5ldyBBbHJlYWR5RGVzdHJveWVkRXJyb3IoKTtcbiAgICAgICAgICAgIGluc3RhbmNlLnN0YXJ0U2h1dGRvd24oKTtcbiAgICAgICAgfSlcbiAgICB9O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9