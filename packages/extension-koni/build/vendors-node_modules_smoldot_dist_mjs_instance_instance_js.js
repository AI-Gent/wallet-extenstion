"use strict";
((typeof self !== 'undefined' ? self : this)["webpackChunk_subwallet_extension_koni"] = (typeof self !== 'undefined' ? self : this)["webpackChunk_subwallet_extension_koni"] || []).push([["vendors-node_modules_smoldot_dist_mjs_instance_instance_js"],{

/***/ "../../node_modules/smoldot/dist/mjs/instance/buffer.js":
/*!**************************************************************!*\
  !*** ../../node_modules/smoldot/dist/mjs/instance/buffer.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "readUInt32LE": () => (/* binding */ readUInt32LE),
/* harmony export */   "utf8BytesToString": () => (/* binding */ utf8BytesToString),
/* harmony export */   "writeUInt32LE": () => (/* binding */ writeUInt32LE),
/* harmony export */   "writeUInt64LE": () => (/* binding */ writeUInt64LE),
/* harmony export */   "writeUInt8": () => (/* binding */ writeUInt8)
/* harmony export */ });
// Smoldot
// Copyright (C) 2019-2022  Parity Technologies (UK) Ltd.
// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
function utf8BytesToString(buffer, offset, length) {
    checkRange(buffer, offset, length);
    // The `TextDecoder` API is supported by all major browsers and by NodeJS.
    // <https://developer.mozilla.org/en-US/docs/Web/API/TextDecoder>
    return new TextDecoder().decode(buffer.slice(offset, offset + length));
}
function readUInt32LE(buffer, offset) {
    checkRange(buffer, offset, 4);
    return (buffer[offset] | (buffer[offset + 1] << 8) | (buffer[offset + 2] << 16)) + (buffer[offset + 3] * 0x1000000);
}
/**
 * Sets the value of a given byte in the buffer.
 *
 * This function is equivalent to `buffer[offset] = value`, except that an exception is thrown
 * if `offset` is out of range.
 */
function writeUInt8(buffer, offset, value) {
    checkRange(buffer, offset, 1);
    buffer[offset] = value & 0xff;
}
function writeUInt32LE(buffer, offset, value) {
    checkRange(buffer, offset, 4);
    buffer[offset + 3] = (value >>> 24) & 0xff;
    buffer[offset + 2] = (value >>> 16) & 0xff;
    buffer[offset + 1] = (value >>> 8) & 0xff;
    buffer[offset] = value & 0xff;
}
function writeUInt64LE(buffer, offset, value) {
    checkRange(buffer, offset, 8);
    buffer[offset + 7] = Number((value >> BigInt(56)) & BigInt(0xff));
    buffer[offset + 6] = Number((value >> BigInt(48)) & BigInt(0xff));
    buffer[offset + 5] = Number((value >> BigInt(40)) & BigInt(0xff));
    buffer[offset + 4] = Number((value >> BigInt(32)) & BigInt(0xff));
    buffer[offset + 3] = Number((value >> BigInt(24)) & BigInt(0xff));
    buffer[offset + 2] = Number((value >> BigInt(16)) & BigInt(0xff));
    buffer[offset + 1] = Number((value >> BigInt(8)) & BigInt(0xff));
    buffer[offset] = Number(value & BigInt(0xff));
}
function checkRange(buffer, offset, length) {
    if (!Number.isInteger(offset) || offset < 0)
        throw new RangeError();
    if (offset + length > buffer.length)
        throw new RangeError();
}


/***/ }),

/***/ "../../node_modules/smoldot/dist/mjs/instance/instance.js":
/*!****************************************************************!*\
  !*** ../../node_modules/smoldot/dist/mjs/instance/instance.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConnectionError": () => (/* reexport safe */ _raw_instance_js__WEBPACK_IMPORTED_MODULE_1__.ConnectionError),
/* harmony export */   "CrashError": () => (/* binding */ CrashError),
/* harmony export */   "MalformedJsonRpcError": () => (/* binding */ MalformedJsonRpcError),
/* harmony export */   "QueueFullError": () => (/* binding */ QueueFullError),
/* harmony export */   "start": () => (/* binding */ start)
/* harmony export */ });
/* harmony import */ var _buffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./buffer.js */ "../../node_modules/smoldot/dist/mjs/instance/buffer.js");
/* harmony import */ var _raw_instance_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./raw-instance.js */ "../../node_modules/smoldot/dist/mjs/instance/raw-instance.js");
/* harmony import */ var _client_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../client.js */ "../../node_modules/smoldot/dist/mjs/client.js");
// Smoldot
// Copyright (C) 2019-2022  Parity Technologies (UK) Ltd.
// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.




/**
 * Thrown in case the underlying client encounters an unexpected crash.
 *
 * This is always an internal bug in smoldot and is never supposed to happen.
 */
class CrashError extends Error {
    constructor(message) {
        super(message);
    }
}
/**
 * Thrown in case a malformed JSON-RPC request is sent.
 */
class MalformedJsonRpcError extends Error {
    constructor() {
        super("JSON-RPC request is malformed");
    }
}
/**
 * Thrown in case the buffer of JSON-RPC requests is full and cannot accept any more request.
 */
class QueueFullError extends Error {
    constructor() {
        super("JSON-RPC requests queue is full");
    }
}
function start(configMessage, platformBindings) {
    // This variable represents the state of the instance, and serves two different purposes:
    //
    // - At initialization, it is a Promise containing the Wasm VM is still initializing.
    // - After the Wasm VM has finished initialization, contains the `WebAssembly.Instance` object.
    //
    let state;
    const crashError = {};
    const currentTask = { name: null };
    const printError = { printError: true };
    // Contains the information of each chain that is currently alive.
    let chains = new Map();
    const initPromise = (() => __awaiter(this, void 0, void 0, function* () {
        const module = yield configMessage.wasmModule;
        // Start initialization of the Wasm VM.
        const config = {
            onWasmPanic: (message) => {
                // TODO: consider obtaining a backtrace here
                crashError.error = new CrashError(message);
                if (!printError.printError)
                    return;
                console.error("Smoldot has panicked" +
                    (currentTask.name ? (" while executing task `" + currentTask.name + "`") : "") +
                    ". This is a bug in smoldot. Please open an issue at " +
                    "https://github.com/smol-dot/smoldot/issues with the following message:\n" +
                    message);
                for (const chain of Array.from(chains.values())) {
                    for (const promise of chain.jsonRpcResponsesPromises) {
                        promise.reject(crashError.error);
                    }
                    chain.jsonRpcResponsesPromises = [];
                }
            },
            logCallback: (level, target, message) => {
                configMessage.logCallback(level, target, message);
            },
            wasmModule: module,
            jsonRpcResponsesNonEmptyCallback: (chainId) => {
                // Notify every single promise found in `jsonRpcResponsesPromises`.
                const promises = chains.get(chainId).jsonRpcResponsesPromises;
                while (promises.length !== 0) {
                    promises.shift().resolve();
                }
            },
            currentTaskCallback: (taskName) => {
                currentTask.name = taskName;
            },
            cpuRateLimit: configMessage.cpuRateLimit,
            maxLogLevel: configMessage.maxLogLevel,
        };
        return yield _raw_instance_js__WEBPACK_IMPORTED_MODULE_1__.startInstance(config, platformBindings);
    }))();
    state = {
        initialized: false, promise: initPromise.then(([instance, bufferIndices]) => {
            state = { initialized: true, instance, bufferIndices };
            return [instance, bufferIndices];
        })
    };
    function queueOperation(operation) {
        return __awaiter(this, void 0, void 0, function* () {
            // What to do depends on the type of `state`.
            // See the documentation of the `state` variable for information.
            if (!state.initialized) {
                // A message has been received while the Wasm VM is still initializing. Queue it for when
                // initialization is over.
                return state.promise.then(([instance, bufferIndices]) => operation(instance, bufferIndices));
            }
            else {
                // Everything is already initialized. Process the message synchronously.
                return operation(state.instance, state.bufferIndices);
            }
        });
    }
    return {
        request: (request, chainId) => {
            // Because `request` is passed as parameter an identifier returned by `addChain`, it is
            // always the case that the Wasm instance is already initialized. The only possibility for
            // it to not be the case is if the user completely invented the `chainId`.
            if (!state.initialized)
                throw new Error("Internal error");
            if (crashError.error)
                throw crashError.error;
            let retVal;
            try {
                state.bufferIndices[0] = new TextEncoder().encode(request);
                retVal = state.instance.exports.json_rpc_send(0, chainId) >>> 0;
            }
            catch (_error) {
                console.assert(crashError.error);
                throw crashError.error;
            }
            switch (retVal) {
                case 0: break;
                case 1: throw new MalformedJsonRpcError();
                case 2: throw new QueueFullError();
                default: throw new Error("Internal error: unknown json_rpc_send error code: " + retVal);
            }
        },
        nextJsonRpcResponse: (chainId) => __awaiter(this, void 0, void 0, function* () {
            // Because `nextJsonRpcResponse` is passed as parameter an identifier returned by `addChain`,
            // it is always the case that the Wasm instance is already initialized. The only possibility
            // for it to not be the case is if the user completely invented the `chainId`.
            if (!state.initialized)
                throw new Error("Internal error");
            while (true) {
                if (crashError.error)
                    throw crashError.error;
                // Try to pop a message from the queue.
                try {
                    const mem = new Uint8Array(state.instance.exports.memory.buffer);
                    const responseInfo = state.instance.exports.json_rpc_responses_peek(chainId) >>> 0;
                    const ptr = _buffer_js__WEBPACK_IMPORTED_MODULE_0__.readUInt32LE(mem, responseInfo) >>> 0;
                    const len = _buffer_js__WEBPACK_IMPORTED_MODULE_0__.readUInt32LE(mem, responseInfo + 4) >>> 0;
                    // `len === 0` means "queue is empty" according to the API.
                    // In that situation, queue the resolve/reject.
                    if (len !== 0) {
                        const message = _buffer_js__WEBPACK_IMPORTED_MODULE_0__.utf8BytesToString(mem, ptr, len);
                        state.instance.exports.json_rpc_responses_pop(chainId);
                        return message;
                    }
                }
                catch (_error) {
                    console.assert(crashError.error);
                    throw crashError.error;
                }
                // If no message is available, wait for one to be.
                yield new Promise((resolve, reject) => {
                    chains.get(chainId).jsonRpcResponsesPromises.push({ resolve: () => resolve(undefined), reject });
                });
            }
        }),
        addChain: (chainSpec, databaseContent, potentialRelayChains, disableJsonRpc) => {
            return queueOperation((instance, bufferIndices) => {
                if (crashError.error)
                    throw crashError.error;
                try {
                    // `add_chain` unconditionally allocates a chain id. If an error occurs, however, this chain
                    // id will refer to an *erroneous* chain. `chain_is_ok` is used below to determine whether it
                    // has succeeeded or not.
                    // Note that `add_chain` properly de-allocates buffers even if it failed.
                    bufferIndices[0] = new TextEncoder().encode(chainSpec);
                    bufferIndices[1] = new TextEncoder().encode(databaseContent);
                    const potentialRelayChainsEncoded = new Uint8Array(potentialRelayChains.length * 4);
                    for (let idx = 0; idx < potentialRelayChains.length; ++idx) {
                        _buffer_js__WEBPACK_IMPORTED_MODULE_0__.writeUInt32LE(potentialRelayChainsEncoded, idx * 4, potentialRelayChains[idx]);
                    }
                    bufferIndices[2] = potentialRelayChainsEncoded;
                    const chainId = instance.exports.add_chain(0, 1, disableJsonRpc ? 0 : 1, 2);
                    delete bufferIndices[0];
                    delete bufferIndices[1];
                    delete bufferIndices[2];
                    if (instance.exports.chain_is_ok(chainId) != 0) {
                        console.assert(!chains.has(chainId));
                        chains.set(chainId, {
                            jsonRpcResponsesPromises: new Array()
                        });
                        return { success: true, chainId };
                    }
                    else {
                        const errorMsgLen = instance.exports.chain_error_len(chainId) >>> 0;
                        const errorMsgPtr = instance.exports.chain_error_ptr(chainId) >>> 0;
                        const errorMsg = _buffer_js__WEBPACK_IMPORTED_MODULE_0__.utf8BytesToString(new Uint8Array(instance.exports.memory.buffer), errorMsgPtr, errorMsgLen);
                        instance.exports.remove_chain(chainId);
                        return { success: false, error: errorMsg };
                    }
                }
                catch (_error) {
                    console.assert(crashError.error);
                    throw crashError.error;
                }
            });
        },
        removeChain: (chainId) => {
            // Because `removeChain` is passed as parameter an identifier returned by `addChain`, it is
            // always the case that the Wasm instance is already initialized. The only possibility for
            // it to not be the case is if the user completely invented the `chainId`.
            if (!state.initialized)
                throw new Error("Internal error");
            if (crashError.error)
                throw crashError.error;
            // Removing the chain synchronously avoids having to deal with race conditions such as a
            // JSON-RPC response corresponding to a chain that is going to be deleted but hasn't been yet.
            // These kind of race conditions are already delt with within smoldot.
            console.assert(chains.has(chainId));
            for (const { reject } of chains.get(chainId).jsonRpcResponsesPromises) {
                reject(new _client_js__WEBPACK_IMPORTED_MODULE_2__.AlreadyDestroyedError());
            }
            chains.delete(chainId);
            try {
                state.instance.exports.remove_chain(chainId);
            }
            catch (_error) {
                console.assert(crashError.error);
                throw crashError.error;
            }
        },
        startShutdown: () => {
            return queueOperation((instance) => {
                // `startShutdown` is a bit special in its handling of crashes.
                // Shutting down will lead to `onWasmPanic` being called at some point, possibly during
                // the call to `start_shutdown` itself. As such, we move into "don't print errors anymore"
                // mode even before calling `start_shutdown`.
                //
                // Furthermore, if a crash happened in the past, there is no point in throwing an
                // exception when the user wants the shutdown to happen.
                if (crashError.error)
                    return;
                try {
                    printError.printError = false;
                    instance.exports.start_shutdown();
                }
                catch (_error) {
                }
            });
        }
    };
}


/***/ }),

/***/ "../../node_modules/smoldot/dist/mjs/instance/raw-instance.js":
/*!********************************************************************!*\
  !*** ../../node_modules/smoldot/dist/mjs/instance/raw-instance.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConnectionError": () => (/* reexport safe */ _bindings_smoldot_light_js__WEBPACK_IMPORTED_MODULE_0__.ConnectionError),
/* harmony export */   "startInstance": () => (/* binding */ startInstance)
/* harmony export */ });
/* harmony import */ var _bindings_smoldot_light_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bindings-smoldot-light.js */ "../../node_modules/smoldot/dist/mjs/instance/bindings-smoldot-light.js");
/* harmony import */ var _bindings_wasi_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bindings-wasi.js */ "../../node_modules/smoldot/dist/mjs/instance/bindings-wasi.js");
// Smoldot
// Copyright (C) 2019-2022  Parity Technologies (UK) Ltd.
// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.



function startInstance(config, platformBindings) {
    return __awaiter(this, void 0, void 0, function* () {
        let killAll;
        const bufferIndices = new Array;
        // Callback called when `advance_execution_ready` is called by the Rust code, if any.
        const advanceExecutionPromise = { value: null };
        // Used to bind with the smoldot-light bindings. See the `bindings-smoldot-light.js` file.
        const smoldotJsConfig = Object.assign({ bufferIndices, connect: platformBindings.connect, onPanic: (message) => {
                killAll();
                config.onWasmPanic(message);
                throw new Error();
            }, advanceExecutionReadyCallback: () => {
                if (advanceExecutionPromise.value)
                    advanceExecutionPromise.value();
                advanceExecutionPromise.value = null;
            } }, config);
        // Used to bind with the Wasi bindings. See the `bindings-wasi.js` file.
        const wasiConfig = {
            envVars: [],
            getRandomValues: platformBindings.getRandomValues,
            performanceNow: platformBindings.performanceNow,
            onProcExit: (retCode) => {
                killAll();
                config.onWasmPanic(`proc_exit called: ${retCode}`);
                throw new Error();
            }
        };
        const { imports: smoldotBindings, killAll: smoldotBindingsKillAll } = (0,_bindings_smoldot_light_js__WEBPACK_IMPORTED_MODULE_0__["default"])(smoldotJsConfig);
        killAll = smoldotBindingsKillAll;
        // Start the Wasm virtual machine.
        // The Rust code defines a list of imports that must be fulfilled by the environment. The second
        // parameter provides their implementations.
        const result = yield WebAssembly.instantiate(config.wasmModule, {
            // The functions with the "smoldot" prefix are specific to smoldot.
            "smoldot": smoldotBindings,
            // As the Rust code is compiled for wasi, some more wasi-specific imports exist.
            "wasi_snapshot_preview1": (0,_bindings_wasi_js__WEBPACK_IMPORTED_MODULE_1__["default"])(wasiConfig),
        });
        const instance = result;
        smoldotJsConfig.instance = instance;
        wasiConfig.instance = instance;
        // Smoldot requires an initial call to the `init` function in order to do its internal
        // configuration.
        instance.exports.init(config.maxLogLevel);
        (() => __awaiter(this, void 0, void 0, function* () {
            // In order to avoid calling `setTimeout` too often, we accumulate sleep up until
            // a certain threshold.
            let missingSleep = 0;
            // Extract (to make sure the value doesn't change) and sanitize `cpuRateLimit`.
            let cpuRateLimit = config.cpuRateLimit;
            if (isNaN(cpuRateLimit))
                cpuRateLimit = 1.0;
            if (cpuRateLimit > 1.0)
                cpuRateLimit = 1.0;
            if (cpuRateLimit < 0.0)
                cpuRateLimit = 0.0;
            const periodicallyYield = { value: false };
            const [periodicallyYieldInit, unregisterCallback] = platformBindings.registerShouldPeriodicallyYield((newValue) => {
                periodicallyYield.value = newValue;
            });
            periodicallyYield.value = periodicallyYieldInit;
            let now = platformBindings.performanceNow();
            while (true) {
                const whenReadyAgain = new Promise((resolve) => advanceExecutionPromise.value = resolve);
                const outcome = instance.exports.advance_execution();
                if (outcome === 0) {
                    unregisterCallback();
                    break;
                }
                const afterExec = platformBindings.performanceNow();
                const elapsed = afterExec - now;
                now = afterExec;
                // In order to enforce the rate limiting, we stop executing for a certain
                // amount of time.
                // The base equation here is: `(sleep + elapsed) * rateLimit == elapsed`,
                // from which the calculation below is derived.
                const sleep = elapsed * (1.0 / cpuRateLimit - 1.0);
                missingSleep += sleep;
                if (missingSleep > (periodicallyYield ? 5 : 1000)) {
                    // `setTimeout` has a maximum value, after which it will overflow. ðŸ¤¦
                    // See <https://developer.mozilla.org/en-US/docs/Web/API/setTimeout#maximum_delay_value>
                    // While adding a cap technically skews the CPU rate limiting algorithm, we don't
                    // really care for such extreme values.
                    if (missingSleep > 2147483646) // Doc says `> 2147483647`, but I don't really trust their pedanticism so let's be safe
                        missingSleep = 2147483646;
                    yield new Promise((resolve) => setTimeout(resolve, missingSleep));
                    missingSleep = 0;
                }
                yield whenReadyAgain;
                const afterWait = platformBindings.performanceNow();
                missingSleep -= (afterWait - now);
                if (missingSleep < 0)
                    missingSleep = 0;
                now = afterWait;
            }
        }))();
        return [instance, bufferIndices];
    });
}


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfc21vbGRvdF9kaXN0X21qc19pbnN0YW5jZV9pbnN0YW5jZV9qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeERBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFJLElBQUksU0FBSTtBQUM3Qiw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDc0M7QUFDUTtBQUNPO0FBQ0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMkRBQXNCO0FBQzNDLEtBQUs7QUFDTDtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msb0RBQW1CO0FBQ25ELGdDQUFnQyxvREFBbUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHlEQUF3QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSwyQ0FBMkM7QUFDbkgsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxtQ0FBbUM7QUFDekUsd0JBQXdCLHFEQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMseURBQXdCO0FBQ2pFO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFNBQVM7QUFDbEMsMkJBQTJCLDZEQUFxQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzVRQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBSSxJQUFJLFNBQUk7QUFDN0IsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ3FGO0FBQ2pCO0FBQ047QUFDdkQ7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFFBQVE7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDREQUE0RCxFQUFFLHNFQUEyQjtBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDZEQUFtQjtBQUN6RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTCIsInNvdXJjZXMiOlsid2VicGFjazovL0BzdWJ3YWxsZXQvZXh0ZW5zaW9uLWtvbmkvLi4vLi4vbm9kZV9tb2R1bGVzL3Ntb2xkb3QvZGlzdC9tanMvaW5zdGFuY2UvYnVmZmVyLmpzIiwid2VicGFjazovL0BzdWJ3YWxsZXQvZXh0ZW5zaW9uLWtvbmkvLi4vLi4vbm9kZV9tb2R1bGVzL3Ntb2xkb3QvZGlzdC9tanMvaW5zdGFuY2UvaW5zdGFuY2UuanMiLCJ3ZWJwYWNrOi8vQHN1YndhbGxldC9leHRlbnNpb24ta29uaS8uLi8uLi9ub2RlX21vZHVsZXMvc21vbGRvdC9kaXN0L21qcy9pbnN0YW5jZS9yYXctaW5zdGFuY2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gU21vbGRvdFxuLy8gQ29weXJpZ2h0IChDKSAyMDE5LTIwMjIgIFBhcml0eSBUZWNobm9sb2dpZXMgKFVLKSBMdGQuXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogR1BMLTMuMC1vci1sYXRlciBXSVRIIENsYXNzcGF0aC1leGNlcHRpb24tMi4wXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4vLyAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbmV4cG9ydCBmdW5jdGlvbiB1dGY4Qnl0ZXNUb1N0cmluZyhidWZmZXIsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgY2hlY2tSYW5nZShidWZmZXIsIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAvLyBUaGUgYFRleHREZWNvZGVyYCBBUEkgaXMgc3VwcG9ydGVkIGJ5IGFsbCBtYWpvciBicm93c2VycyBhbmQgYnkgTm9kZUpTLlxuICAgIC8vIDxodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVGV4dERlY29kZXI+XG4gICAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGgpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZWFkVUludDMyTEUoYnVmZmVyLCBvZmZzZXQpIHtcbiAgICBjaGVja1JhbmdlKGJ1ZmZlciwgb2Zmc2V0LCA0KTtcbiAgICByZXR1cm4gKGJ1ZmZlcltvZmZzZXRdIHwgKGJ1ZmZlcltvZmZzZXQgKyAxXSA8PCA4KSB8IChidWZmZXJbb2Zmc2V0ICsgMl0gPDwgMTYpKSArIChidWZmZXJbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApO1xufVxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBvZiBhIGdpdmVuIGJ5dGUgaW4gdGhlIGJ1ZmZlci5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGVxdWl2YWxlbnQgdG8gYGJ1ZmZlcltvZmZzZXRdID0gdmFsdWVgLCBleGNlcHQgdGhhdCBhbiBleGNlcHRpb24gaXMgdGhyb3duXG4gKiBpZiBgb2Zmc2V0YCBpcyBvdXQgb2YgcmFuZ2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3cml0ZVVJbnQ4KGJ1ZmZlciwgb2Zmc2V0LCB2YWx1ZSkge1xuICAgIGNoZWNrUmFuZ2UoYnVmZmVyLCBvZmZzZXQsIDEpO1xuICAgIGJ1ZmZlcltvZmZzZXRdID0gdmFsdWUgJiAweGZmO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUoYnVmZmVyLCBvZmZzZXQsIHZhbHVlKSB7XG4gICAgY2hlY2tSYW5nZShidWZmZXIsIG9mZnNldCwgNCk7XG4gICAgYnVmZmVyW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNCkgJiAweGZmO1xuICAgIGJ1ZmZlcltvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpICYgMHhmZjtcbiAgICBidWZmZXJbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpICYgMHhmZjtcbiAgICBidWZmZXJbb2Zmc2V0XSA9IHZhbHVlICYgMHhmZjtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cml0ZVVJbnQ2NExFKGJ1ZmZlciwgb2Zmc2V0LCB2YWx1ZSkge1xuICAgIGNoZWNrUmFuZ2UoYnVmZmVyLCBvZmZzZXQsIDgpO1xuICAgIGJ1ZmZlcltvZmZzZXQgKyA3XSA9IE51bWJlcigodmFsdWUgPj4gQmlnSW50KDU2KSkgJiBCaWdJbnQoMHhmZikpO1xuICAgIGJ1ZmZlcltvZmZzZXQgKyA2XSA9IE51bWJlcigodmFsdWUgPj4gQmlnSW50KDQ4KSkgJiBCaWdJbnQoMHhmZikpO1xuICAgIGJ1ZmZlcltvZmZzZXQgKyA1XSA9IE51bWJlcigodmFsdWUgPj4gQmlnSW50KDQwKSkgJiBCaWdJbnQoMHhmZikpO1xuICAgIGJ1ZmZlcltvZmZzZXQgKyA0XSA9IE51bWJlcigodmFsdWUgPj4gQmlnSW50KDMyKSkgJiBCaWdJbnQoMHhmZikpO1xuICAgIGJ1ZmZlcltvZmZzZXQgKyAzXSA9IE51bWJlcigodmFsdWUgPj4gQmlnSW50KDI0KSkgJiBCaWdJbnQoMHhmZikpO1xuICAgIGJ1ZmZlcltvZmZzZXQgKyAyXSA9IE51bWJlcigodmFsdWUgPj4gQmlnSW50KDE2KSkgJiBCaWdJbnQoMHhmZikpO1xuICAgIGJ1ZmZlcltvZmZzZXQgKyAxXSA9IE51bWJlcigodmFsdWUgPj4gQmlnSW50KDgpKSAmIEJpZ0ludCgweGZmKSk7XG4gICAgYnVmZmVyW29mZnNldF0gPSBOdW1iZXIodmFsdWUgJiBCaWdJbnQoMHhmZikpO1xufVxuZnVuY3Rpb24gY2hlY2tSYW5nZShidWZmZXIsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG9mZnNldCkgfHwgb2Zmc2V0IDwgMClcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoKTtcbiAgICBpZiAob2Zmc2V0ICsgbGVuZ3RoID4gYnVmZmVyLmxlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoKTtcbn1cbiIsIi8vIFNtb2xkb3Rcbi8vIENvcHlyaWdodCAoQykgMjAxOS0yMDIyICBQYXJpdHkgVGVjaG5vbG9naWVzIChVSykgTHRkLlxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAtb3ItbGF0ZXIgV0lUSCBDbGFzc3BhdGgtZXhjZXB0aW9uLTIuMFxudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4vLyAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbmltcG9ydCAqIGFzIGJ1ZmZlciBmcm9tICcuL2J1ZmZlci5qcyc7XG5pbXBvcnQgKiBhcyBpbnN0YW5jZSBmcm9tICcuL3Jhdy1pbnN0YW5jZS5qcyc7XG5pbXBvcnQgeyBBbHJlYWR5RGVzdHJveWVkRXJyb3IgfSBmcm9tICcuLi9jbGllbnQuanMnO1xuZXhwb3J0IHsgQ29ubmVjdGlvbkVycm9yIH0gZnJvbSAnLi9yYXctaW5zdGFuY2UuanMnO1xuLyoqXG4gKiBUaHJvd24gaW4gY2FzZSB0aGUgdW5kZXJseWluZyBjbGllbnQgZW5jb3VudGVycyBhbiB1bmV4cGVjdGVkIGNyYXNoLlxuICpcbiAqIFRoaXMgaXMgYWx3YXlzIGFuIGludGVybmFsIGJ1ZyBpbiBzbW9sZG90IGFuZCBpcyBuZXZlciBzdXBwb3NlZCB0byBoYXBwZW4uXG4gKi9cbmV4cG9ydCBjbGFzcyBDcmFzaEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gaW4gY2FzZSBhIG1hbGZvcm1lZCBKU09OLVJQQyByZXF1ZXN0IGlzIHNlbnQuXG4gKi9cbmV4cG9ydCBjbGFzcyBNYWxmb3JtZWRKc29uUnBjRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFwiSlNPTi1SUEMgcmVxdWVzdCBpcyBtYWxmb3JtZWRcIik7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gaW4gY2FzZSB0aGUgYnVmZmVyIG9mIEpTT04tUlBDIHJlcXVlc3RzIGlzIGZ1bGwgYW5kIGNhbm5vdCBhY2NlcHQgYW55IG1vcmUgcmVxdWVzdC5cbiAqL1xuZXhwb3J0IGNsYXNzIFF1ZXVlRnVsbEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcIkpTT04tUlBDIHJlcXVlc3RzIHF1ZXVlIGlzIGZ1bGxcIik7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0KGNvbmZpZ01lc3NhZ2UsIHBsYXRmb3JtQmluZGluZ3MpIHtcbiAgICAvLyBUaGlzIHZhcmlhYmxlIHJlcHJlc2VudHMgdGhlIHN0YXRlIG9mIHRoZSBpbnN0YW5jZSwgYW5kIHNlcnZlcyB0d28gZGlmZmVyZW50IHB1cnBvc2VzOlxuICAgIC8vXG4gICAgLy8gLSBBdCBpbml0aWFsaXphdGlvbiwgaXQgaXMgYSBQcm9taXNlIGNvbnRhaW5pbmcgdGhlIFdhc20gVk0gaXMgc3RpbGwgaW5pdGlhbGl6aW5nLlxuICAgIC8vIC0gQWZ0ZXIgdGhlIFdhc20gVk0gaGFzIGZpbmlzaGVkIGluaXRpYWxpemF0aW9uLCBjb250YWlucyB0aGUgYFdlYkFzc2VtYmx5Lkluc3RhbmNlYCBvYmplY3QuXG4gICAgLy9cbiAgICBsZXQgc3RhdGU7XG4gICAgY29uc3QgY3Jhc2hFcnJvciA9IHt9O1xuICAgIGNvbnN0IGN1cnJlbnRUYXNrID0geyBuYW1lOiBudWxsIH07XG4gICAgY29uc3QgcHJpbnRFcnJvciA9IHsgcHJpbnRFcnJvcjogdHJ1ZSB9O1xuICAgIC8vIENvbnRhaW5zIHRoZSBpbmZvcm1hdGlvbiBvZiBlYWNoIGNoYWluIHRoYXQgaXMgY3VycmVudGx5IGFsaXZlLlxuICAgIGxldCBjaGFpbnMgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgaW5pdFByb21pc2UgPSAoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBtb2R1bGUgPSB5aWVsZCBjb25maWdNZXNzYWdlLndhc21Nb2R1bGU7XG4gICAgICAgIC8vIFN0YXJ0IGluaXRpYWxpemF0aW9uIG9mIHRoZSBXYXNtIFZNLlxuICAgICAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICAgICAgICBvbldhc21QYW5pYzogKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBjb25zaWRlciBvYnRhaW5pbmcgYSBiYWNrdHJhY2UgaGVyZVxuICAgICAgICAgICAgICAgIGNyYXNoRXJyb3IuZXJyb3IgPSBuZXcgQ3Jhc2hFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBpZiAoIXByaW50RXJyb3IucHJpbnRFcnJvcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJTbW9sZG90IGhhcyBwYW5pY2tlZFwiICtcbiAgICAgICAgICAgICAgICAgICAgKGN1cnJlbnRUYXNrLm5hbWUgPyAoXCIgd2hpbGUgZXhlY3V0aW5nIHRhc2sgYFwiICsgY3VycmVudFRhc2submFtZSArIFwiYFwiKSA6IFwiXCIpICtcbiAgICAgICAgICAgICAgICAgICAgXCIuIFRoaXMgaXMgYSBidWcgaW4gc21vbGRvdC4gUGxlYXNlIG9wZW4gYW4gaXNzdWUgYXQgXCIgK1xuICAgICAgICAgICAgICAgICAgICBcImh0dHBzOi8vZ2l0aHViLmNvbS9zbW9sLWRvdC9zbW9sZG90L2lzc3VlcyB3aXRoIHRoZSBmb2xsb3dpbmcgbWVzc2FnZTpcXG5cIiArXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2hhaW4gb2YgQXJyYXkuZnJvbShjaGFpbnMudmFsdWVzKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcHJvbWlzZSBvZiBjaGFpbi5qc29uUnBjUmVzcG9uc2VzUHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UucmVqZWN0KGNyYXNoRXJyb3IuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNoYWluLmpzb25ScGNSZXNwb25zZXNQcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsb2dDYWxsYmFjazogKGxldmVsLCB0YXJnZXQsIG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25maWdNZXNzYWdlLmxvZ0NhbGxiYWNrKGxldmVsLCB0YXJnZXQsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHdhc21Nb2R1bGU6IG1vZHVsZSxcbiAgICAgICAgICAgIGpzb25ScGNSZXNwb25zZXNOb25FbXB0eUNhbGxiYWNrOiAoY2hhaW5JZCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIE5vdGlmeSBldmVyeSBzaW5nbGUgcHJvbWlzZSBmb3VuZCBpbiBganNvblJwY1Jlc3BvbnNlc1Byb21pc2VzYC5cbiAgICAgICAgICAgICAgICBjb25zdCBwcm9taXNlcyA9IGNoYWlucy5nZXQoY2hhaW5JZCkuanNvblJwY1Jlc3BvbnNlc1Byb21pc2VzO1xuICAgICAgICAgICAgICAgIHdoaWxlIChwcm9taXNlcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMuc2hpZnQoKS5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGN1cnJlbnRUYXNrQ2FsbGJhY2s6ICh0YXNrTmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRUYXNrLm5hbWUgPSB0YXNrTmFtZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjcHVSYXRlTGltaXQ6IGNvbmZpZ01lc3NhZ2UuY3B1UmF0ZUxpbWl0LFxuICAgICAgICAgICAgbWF4TG9nTGV2ZWw6IGNvbmZpZ01lc3NhZ2UubWF4TG9nTGV2ZWwsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB5aWVsZCBpbnN0YW5jZS5zdGFydEluc3RhbmNlKGNvbmZpZywgcGxhdGZvcm1CaW5kaW5ncyk7XG4gICAgfSkpKCk7XG4gICAgc3RhdGUgPSB7XG4gICAgICAgIGluaXRpYWxpemVkOiBmYWxzZSwgcHJvbWlzZTogaW5pdFByb21pc2UudGhlbigoW2luc3RhbmNlLCBidWZmZXJJbmRpY2VzXSkgPT4ge1xuICAgICAgICAgICAgc3RhdGUgPSB7IGluaXRpYWxpemVkOiB0cnVlLCBpbnN0YW5jZSwgYnVmZmVySW5kaWNlcyB9O1xuICAgICAgICAgICAgcmV0dXJuIFtpbnN0YW5jZSwgYnVmZmVySW5kaWNlc107XG4gICAgICAgIH0pXG4gICAgfTtcbiAgICBmdW5jdGlvbiBxdWV1ZU9wZXJhdGlvbihvcGVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIFdoYXQgdG8gZG8gZGVwZW5kcyBvbiB0aGUgdHlwZSBvZiBgc3RhdGVgLlxuICAgICAgICAgICAgLy8gU2VlIHRoZSBkb2N1bWVudGF0aW9uIG9mIHRoZSBgc3RhdGVgIHZhcmlhYmxlIGZvciBpbmZvcm1hdGlvbi5cbiAgICAgICAgICAgIGlmICghc3RhdGUuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBBIG1lc3NhZ2UgaGFzIGJlZW4gcmVjZWl2ZWQgd2hpbGUgdGhlIFdhc20gVk0gaXMgc3RpbGwgaW5pdGlhbGl6aW5nLiBRdWV1ZSBpdCBmb3Igd2hlblxuICAgICAgICAgICAgICAgIC8vIGluaXRpYWxpemF0aW9uIGlzIG92ZXIuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlLnByb21pc2UudGhlbigoW2luc3RhbmNlLCBidWZmZXJJbmRpY2VzXSkgPT4gb3BlcmF0aW9uKGluc3RhbmNlLCBidWZmZXJJbmRpY2VzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBFdmVyeXRoaW5nIGlzIGFscmVhZHkgaW5pdGlhbGl6ZWQuIFByb2Nlc3MgdGhlIG1lc3NhZ2Ugc3luY2hyb25vdXNseS5cbiAgICAgICAgICAgICAgICByZXR1cm4gb3BlcmF0aW9uKHN0YXRlLmluc3RhbmNlLCBzdGF0ZS5idWZmZXJJbmRpY2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHJlcXVlc3Q6IChyZXF1ZXN0LCBjaGFpbklkKSA9PiB7XG4gICAgICAgICAgICAvLyBCZWNhdXNlIGByZXF1ZXN0YCBpcyBwYXNzZWQgYXMgcGFyYW1ldGVyIGFuIGlkZW50aWZpZXIgcmV0dXJuZWQgYnkgYGFkZENoYWluYCwgaXQgaXNcbiAgICAgICAgICAgIC8vIGFsd2F5cyB0aGUgY2FzZSB0aGF0IHRoZSBXYXNtIGluc3RhbmNlIGlzIGFscmVhZHkgaW5pdGlhbGl6ZWQuIFRoZSBvbmx5IHBvc3NpYmlsaXR5IGZvclxuICAgICAgICAgICAgLy8gaXQgdG8gbm90IGJlIHRoZSBjYXNlIGlzIGlmIHRoZSB1c2VyIGNvbXBsZXRlbHkgaW52ZW50ZWQgdGhlIGBjaGFpbklkYC5cbiAgICAgICAgICAgIGlmICghc3RhdGUuaW5pdGlhbGl6ZWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW50ZXJuYWwgZXJyb3JcIik7XG4gICAgICAgICAgICBpZiAoY3Jhc2hFcnJvci5lcnJvcilcbiAgICAgICAgICAgICAgICB0aHJvdyBjcmFzaEVycm9yLmVycm9yO1xuICAgICAgICAgICAgbGV0IHJldFZhbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuYnVmZmVySW5kaWNlc1swXSA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShyZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICByZXRWYWwgPSBzdGF0ZS5pbnN0YW5jZS5leHBvcnRzLmpzb25fcnBjX3NlbmQoMCwgY2hhaW5JZCkgPj4+IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQoY3Jhc2hFcnJvci5lcnJvcik7XG4gICAgICAgICAgICAgICAgdGhyb3cgY3Jhc2hFcnJvci5lcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAocmV0VmFsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE6IHRocm93IG5ldyBNYWxmb3JtZWRKc29uUnBjRXJyb3IoKTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6IHRocm93IG5ldyBRdWV1ZUZ1bGxFcnJvcigpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcihcIkludGVybmFsIGVycm9yOiB1bmtub3duIGpzb25fcnBjX3NlbmQgZXJyb3IgY29kZTogXCIgKyByZXRWYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBuZXh0SnNvblJwY1Jlc3BvbnNlOiAoY2hhaW5JZCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gQmVjYXVzZSBgbmV4dEpzb25ScGNSZXNwb25zZWAgaXMgcGFzc2VkIGFzIHBhcmFtZXRlciBhbiBpZGVudGlmaWVyIHJldHVybmVkIGJ5IGBhZGRDaGFpbmAsXG4gICAgICAgICAgICAvLyBpdCBpcyBhbHdheXMgdGhlIGNhc2UgdGhhdCB0aGUgV2FzbSBpbnN0YW5jZSBpcyBhbHJlYWR5IGluaXRpYWxpemVkLiBUaGUgb25seSBwb3NzaWJpbGl0eVxuICAgICAgICAgICAgLy8gZm9yIGl0IHRvIG5vdCBiZSB0aGUgY2FzZSBpcyBpZiB0aGUgdXNlciBjb21wbGV0ZWx5IGludmVudGVkIHRoZSBgY2hhaW5JZGAuXG4gICAgICAgICAgICBpZiAoIXN0YXRlLmluaXRpYWxpemVkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludGVybmFsIGVycm9yXCIpO1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3Jhc2hFcnJvci5lcnJvcilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgY3Jhc2hFcnJvci5lcnJvcjtcbiAgICAgICAgICAgICAgICAvLyBUcnkgdG8gcG9wIGEgbWVzc2FnZSBmcm9tIHRoZSBxdWV1ZS5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZW0gPSBuZXcgVWludDhBcnJheShzdGF0ZS5pbnN0YW5jZS5leHBvcnRzLm1lbW9yeS5idWZmZXIpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZUluZm8gPSBzdGF0ZS5pbnN0YW5jZS5leHBvcnRzLmpzb25fcnBjX3Jlc3BvbnNlc19wZWVrKGNoYWluSWQpID4+PiAwO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwdHIgPSBidWZmZXIucmVhZFVJbnQzMkxFKG1lbSwgcmVzcG9uc2VJbmZvKSA+Pj4gMDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVuID0gYnVmZmVyLnJlYWRVSW50MzJMRShtZW0sIHJlc3BvbnNlSW5mbyArIDQpID4+PiAwO1xuICAgICAgICAgICAgICAgICAgICAvLyBgbGVuID09PSAwYCBtZWFucyBcInF1ZXVlIGlzIGVtcHR5XCIgYWNjb3JkaW5nIHRvIHRoZSBBUEkuXG4gICAgICAgICAgICAgICAgICAgIC8vIEluIHRoYXQgc2l0dWF0aW9uLCBxdWV1ZSB0aGUgcmVzb2x2ZS9yZWplY3QuXG4gICAgICAgICAgICAgICAgICAgIGlmIChsZW4gIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBidWZmZXIudXRmOEJ5dGVzVG9TdHJpbmcobWVtLCBwdHIsIGxlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5pbnN0YW5jZS5leHBvcnRzLmpzb25fcnBjX3Jlc3BvbnNlc19wb3AoY2hhaW5JZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KGNyYXNoRXJyb3IuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBjcmFzaEVycm9yLmVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiBubyBtZXNzYWdlIGlzIGF2YWlsYWJsZSwgd2FpdCBmb3Igb25lIHRvIGJlLlxuICAgICAgICAgICAgICAgIHlpZWxkIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2hhaW5zLmdldChjaGFpbklkKS5qc29uUnBjUmVzcG9uc2VzUHJvbWlzZXMucHVzaCh7IHJlc29sdmU6ICgpID0+IHJlc29sdmUodW5kZWZpbmVkKSwgcmVqZWN0IH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgYWRkQ2hhaW46IChjaGFpblNwZWMsIGRhdGFiYXNlQ29udGVudCwgcG90ZW50aWFsUmVsYXlDaGFpbnMsIGRpc2FibGVKc29uUnBjKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcXVldWVPcGVyYXRpb24oKGluc3RhbmNlLCBidWZmZXJJbmRpY2VzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNyYXNoRXJyb3IuZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGNyYXNoRXJyb3IuZXJyb3I7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYGFkZF9jaGFpbmAgdW5jb25kaXRpb25hbGx5IGFsbG9jYXRlcyBhIGNoYWluIGlkLiBJZiBhbiBlcnJvciBvY2N1cnMsIGhvd2V2ZXIsIHRoaXMgY2hhaW5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWQgd2lsbCByZWZlciB0byBhbiAqZXJyb25lb3VzKiBjaGFpbi4gYGNoYWluX2lzX29rYCBpcyB1c2VkIGJlbG93IHRvIGRldGVybWluZSB3aGV0aGVyIGl0XG4gICAgICAgICAgICAgICAgICAgIC8vIGhhcyBzdWNjZWVlZGVkIG9yIG5vdC5cbiAgICAgICAgICAgICAgICAgICAgLy8gTm90ZSB0aGF0IGBhZGRfY2hhaW5gIHByb3Blcmx5IGRlLWFsbG9jYXRlcyBidWZmZXJzIGV2ZW4gaWYgaXQgZmFpbGVkLlxuICAgICAgICAgICAgICAgICAgICBidWZmZXJJbmRpY2VzWzBdID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKGNoYWluU3BlYyk7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlckluZGljZXNbMV0gPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoZGF0YWJhc2VDb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG90ZW50aWFsUmVsYXlDaGFpbnNFbmNvZGVkID0gbmV3IFVpbnQ4QXJyYXkocG90ZW50aWFsUmVsYXlDaGFpbnMubGVuZ3RoICogNCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHBvdGVudGlhbFJlbGF5Q2hhaW5zLmxlbmd0aDsgKytpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVVJbnQzMkxFKHBvdGVudGlhbFJlbGF5Q2hhaW5zRW5jb2RlZCwgaWR4ICogNCwgcG90ZW50aWFsUmVsYXlDaGFpbnNbaWR4XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnVmZmVySW5kaWNlc1syXSA9IHBvdGVudGlhbFJlbGF5Q2hhaW5zRW5jb2RlZDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hhaW5JZCA9IGluc3RhbmNlLmV4cG9ydHMuYWRkX2NoYWluKDAsIDEsIGRpc2FibGVKc29uUnBjID8gMCA6IDEsIDIpO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgYnVmZmVySW5kaWNlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGJ1ZmZlckluZGljZXNbMV07XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBidWZmZXJJbmRpY2VzWzJdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UuZXhwb3J0cy5jaGFpbl9pc19vayhjaGFpbklkKSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydCghY2hhaW5zLmhhcyhjaGFpbklkKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFpbnMuc2V0KGNoYWluSWQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uUnBjUmVzcG9uc2VzUHJvbWlzZXM6IG5ldyBBcnJheSgpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIGNoYWluSWQgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yTXNnTGVuID0gaW5zdGFuY2UuZXhwb3J0cy5jaGFpbl9lcnJvcl9sZW4oY2hhaW5JZCkgPj4+IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvck1zZ1B0ciA9IGluc3RhbmNlLmV4cG9ydHMuY2hhaW5fZXJyb3JfcHRyKGNoYWluSWQpID4+PiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JNc2cgPSBidWZmZXIudXRmOEJ5dGVzVG9TdHJpbmcobmV3IFVpbnQ4QXJyYXkoaW5zdGFuY2UuZXhwb3J0cy5tZW1vcnkuYnVmZmVyKSwgZXJyb3JNc2dQdHIsIGVycm9yTXNnTGVuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmV4cG9ydHMucmVtb3ZlX2NoYWluKGNoYWluSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvck1zZyB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQoY3Jhc2hFcnJvci5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGNyYXNoRXJyb3IuZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUNoYWluOiAoY2hhaW5JZCkgPT4ge1xuICAgICAgICAgICAgLy8gQmVjYXVzZSBgcmVtb3ZlQ2hhaW5gIGlzIHBhc3NlZCBhcyBwYXJhbWV0ZXIgYW4gaWRlbnRpZmllciByZXR1cm5lZCBieSBgYWRkQ2hhaW5gLCBpdCBpc1xuICAgICAgICAgICAgLy8gYWx3YXlzIHRoZSBjYXNlIHRoYXQgdGhlIFdhc20gaW5zdGFuY2UgaXMgYWxyZWFkeSBpbml0aWFsaXplZC4gVGhlIG9ubHkgcG9zc2liaWxpdHkgZm9yXG4gICAgICAgICAgICAvLyBpdCB0byBub3QgYmUgdGhlIGNhc2UgaXMgaWYgdGhlIHVzZXIgY29tcGxldGVseSBpbnZlbnRlZCB0aGUgYGNoYWluSWRgLlxuICAgICAgICAgICAgaWYgKCFzdGF0ZS5pbml0aWFsaXplZClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnRlcm5hbCBlcnJvclwiKTtcbiAgICAgICAgICAgIGlmIChjcmFzaEVycm9yLmVycm9yKVxuICAgICAgICAgICAgICAgIHRocm93IGNyYXNoRXJyb3IuZXJyb3I7XG4gICAgICAgICAgICAvLyBSZW1vdmluZyB0aGUgY2hhaW4gc3luY2hyb25vdXNseSBhdm9pZHMgaGF2aW5nIHRvIGRlYWwgd2l0aCByYWNlIGNvbmRpdGlvbnMgc3VjaCBhcyBhXG4gICAgICAgICAgICAvLyBKU09OLVJQQyByZXNwb25zZSBjb3JyZXNwb25kaW5nIHRvIGEgY2hhaW4gdGhhdCBpcyBnb2luZyB0byBiZSBkZWxldGVkIGJ1dCBoYXNuJ3QgYmVlbiB5ZXQuXG4gICAgICAgICAgICAvLyBUaGVzZSBraW5kIG9mIHJhY2UgY29uZGl0aW9ucyBhcmUgYWxyZWFkeSBkZWx0IHdpdGggd2l0aGluIHNtb2xkb3QuXG4gICAgICAgICAgICBjb25zb2xlLmFzc2VydChjaGFpbnMuaGFzKGNoYWluSWQpKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgeyByZWplY3QgfSBvZiBjaGFpbnMuZ2V0KGNoYWluSWQpLmpzb25ScGNSZXNwb25zZXNQcm9taXNlcykge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgQWxyZWFkeURlc3Ryb3llZEVycm9yKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hhaW5zLmRlbGV0ZShjaGFpbklkKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuaW5zdGFuY2UuZXhwb3J0cy5yZW1vdmVfY2hhaW4oY2hhaW5JZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQoY3Jhc2hFcnJvci5lcnJvcik7XG4gICAgICAgICAgICAgICAgdGhyb3cgY3Jhc2hFcnJvci5lcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc3RhcnRTaHV0ZG93bjogKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHF1ZXVlT3BlcmF0aW9uKChpbnN0YW5jZSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGBzdGFydFNodXRkb3duYCBpcyBhIGJpdCBzcGVjaWFsIGluIGl0cyBoYW5kbGluZyBvZiBjcmFzaGVzLlxuICAgICAgICAgICAgICAgIC8vIFNodXR0aW5nIGRvd24gd2lsbCBsZWFkIHRvIGBvbldhc21QYW5pY2AgYmVpbmcgY2FsbGVkIGF0IHNvbWUgcG9pbnQsIHBvc3NpYmx5IGR1cmluZ1xuICAgICAgICAgICAgICAgIC8vIHRoZSBjYWxsIHRvIGBzdGFydF9zaHV0ZG93bmAgaXRzZWxmLiBBcyBzdWNoLCB3ZSBtb3ZlIGludG8gXCJkb24ndCBwcmludCBlcnJvcnMgYW55bW9yZVwiXG4gICAgICAgICAgICAgICAgLy8gbW9kZSBldmVuIGJlZm9yZSBjYWxsaW5nIGBzdGFydF9zaHV0ZG93bmAuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBGdXJ0aGVybW9yZSwgaWYgYSBjcmFzaCBoYXBwZW5lZCBpbiB0aGUgcGFzdCwgdGhlcmUgaXMgbm8gcG9pbnQgaW4gdGhyb3dpbmcgYW5cbiAgICAgICAgICAgICAgICAvLyBleGNlcHRpb24gd2hlbiB0aGUgdXNlciB3YW50cyB0aGUgc2h1dGRvd24gdG8gaGFwcGVuLlxuICAgICAgICAgICAgICAgIGlmIChjcmFzaEVycm9yLmVycm9yKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcHJpbnRFcnJvci5wcmludEVycm9yID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmV4cG9ydHMuc3RhcnRfc2h1dGRvd24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbn1cbiIsIi8vIFNtb2xkb3Rcbi8vIENvcHlyaWdodCAoQykgMjAxOS0yMDIyICBQYXJpdHkgVGVjaG5vbG9naWVzIChVSykgTHRkLlxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAtb3ItbGF0ZXIgV0lUSCBDbGFzc3BhdGgtZXhjZXB0aW9uLTIuMFxudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4vLyAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbmltcG9ydCB7IGRlZmF1bHQgYXMgc21vbGRvdExpZ2h0QmluZGluZ3NCdWlsZGVyIH0gZnJvbSAnLi9iaW5kaW5ncy1zbW9sZG90LWxpZ2h0LmpzJztcbmltcG9ydCB7IGRlZmF1bHQgYXMgd2FzaUJpbmRpbmdzQnVpbGRlciB9IGZyb20gJy4vYmluZGluZ3Mtd2FzaS5qcyc7XG5leHBvcnQgeyBDb25uZWN0aW9uRXJyb3IgfSBmcm9tICcuL2JpbmRpbmdzLXNtb2xkb3QtbGlnaHQuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0SW5zdGFuY2UoY29uZmlnLCBwbGF0Zm9ybUJpbmRpbmdzKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgbGV0IGtpbGxBbGw7XG4gICAgICAgIGNvbnN0IGJ1ZmZlckluZGljZXMgPSBuZXcgQXJyYXk7XG4gICAgICAgIC8vIENhbGxiYWNrIGNhbGxlZCB3aGVuIGBhZHZhbmNlX2V4ZWN1dGlvbl9yZWFkeWAgaXMgY2FsbGVkIGJ5IHRoZSBSdXN0IGNvZGUsIGlmIGFueS5cbiAgICAgICAgY29uc3QgYWR2YW5jZUV4ZWN1dGlvblByb21pc2UgPSB7IHZhbHVlOiBudWxsIH07XG4gICAgICAgIC8vIFVzZWQgdG8gYmluZCB3aXRoIHRoZSBzbW9sZG90LWxpZ2h0IGJpbmRpbmdzLiBTZWUgdGhlIGBiaW5kaW5ncy1zbW9sZG90LWxpZ2h0LmpzYCBmaWxlLlxuICAgICAgICBjb25zdCBzbW9sZG90SnNDb25maWcgPSBPYmplY3QuYXNzaWduKHsgYnVmZmVySW5kaWNlcywgY29ubmVjdDogcGxhdGZvcm1CaW5kaW5ncy5jb25uZWN0LCBvblBhbmljOiAobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgICAgIGtpbGxBbGwoKTtcbiAgICAgICAgICAgICAgICBjb25maWcub25XYXNtUGFuaWMobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgICAgICB9LCBhZHZhbmNlRXhlY3V0aW9uUmVhZHlDYWxsYmFjazogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChhZHZhbmNlRXhlY3V0aW9uUHJvbWlzZS52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgYWR2YW5jZUV4ZWN1dGlvblByb21pc2UudmFsdWUoKTtcbiAgICAgICAgICAgICAgICBhZHZhbmNlRXhlY3V0aW9uUHJvbWlzZS52YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB9IH0sIGNvbmZpZyk7XG4gICAgICAgIC8vIFVzZWQgdG8gYmluZCB3aXRoIHRoZSBXYXNpIGJpbmRpbmdzLiBTZWUgdGhlIGBiaW5kaW5ncy13YXNpLmpzYCBmaWxlLlxuICAgICAgICBjb25zdCB3YXNpQ29uZmlnID0ge1xuICAgICAgICAgICAgZW52VmFyczogW10sXG4gICAgICAgICAgICBnZXRSYW5kb21WYWx1ZXM6IHBsYXRmb3JtQmluZGluZ3MuZ2V0UmFuZG9tVmFsdWVzLFxuICAgICAgICAgICAgcGVyZm9ybWFuY2VOb3c6IHBsYXRmb3JtQmluZGluZ3MucGVyZm9ybWFuY2VOb3csXG4gICAgICAgICAgICBvblByb2NFeGl0OiAocmV0Q29kZSkgPT4ge1xuICAgICAgICAgICAgICAgIGtpbGxBbGwoKTtcbiAgICAgICAgICAgICAgICBjb25maWcub25XYXNtUGFuaWMoYHByb2NfZXhpdCBjYWxsZWQ6ICR7cmV0Q29kZX1gKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgeyBpbXBvcnRzOiBzbW9sZG90QmluZGluZ3MsIGtpbGxBbGw6IHNtb2xkb3RCaW5kaW5nc0tpbGxBbGwgfSA9IHNtb2xkb3RMaWdodEJpbmRpbmdzQnVpbGRlcihzbW9sZG90SnNDb25maWcpO1xuICAgICAgICBraWxsQWxsID0gc21vbGRvdEJpbmRpbmdzS2lsbEFsbDtcbiAgICAgICAgLy8gU3RhcnQgdGhlIFdhc20gdmlydHVhbCBtYWNoaW5lLlxuICAgICAgICAvLyBUaGUgUnVzdCBjb2RlIGRlZmluZXMgYSBsaXN0IG9mIGltcG9ydHMgdGhhdCBtdXN0IGJlIGZ1bGZpbGxlZCBieSB0aGUgZW52aXJvbm1lbnQuIFRoZSBzZWNvbmRcbiAgICAgICAgLy8gcGFyYW1ldGVyIHByb3ZpZGVzIHRoZWlyIGltcGxlbWVudGF0aW9ucy5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoY29uZmlnLndhc21Nb2R1bGUsIHtcbiAgICAgICAgICAgIC8vIFRoZSBmdW5jdGlvbnMgd2l0aCB0aGUgXCJzbW9sZG90XCIgcHJlZml4IGFyZSBzcGVjaWZpYyB0byBzbW9sZG90LlxuICAgICAgICAgICAgXCJzbW9sZG90XCI6IHNtb2xkb3RCaW5kaW5ncyxcbiAgICAgICAgICAgIC8vIEFzIHRoZSBSdXN0IGNvZGUgaXMgY29tcGlsZWQgZm9yIHdhc2ksIHNvbWUgbW9yZSB3YXNpLXNwZWNpZmljIGltcG9ydHMgZXhpc3QuXG4gICAgICAgICAgICBcIndhc2lfc25hcHNob3RfcHJldmlldzFcIjogd2FzaUJpbmRpbmdzQnVpbGRlcih3YXNpQ29uZmlnKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gcmVzdWx0O1xuICAgICAgICBzbW9sZG90SnNDb25maWcuaW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICAgICAgd2FzaUNvbmZpZy5pbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgICAgICAvLyBTbW9sZG90IHJlcXVpcmVzIGFuIGluaXRpYWwgY2FsbCB0byB0aGUgYGluaXRgIGZ1bmN0aW9uIGluIG9yZGVyIHRvIGRvIGl0cyBpbnRlcm5hbFxuICAgICAgICAvLyBjb25maWd1cmF0aW9uLlxuICAgICAgICBpbnN0YW5jZS5leHBvcnRzLmluaXQoY29uZmlnLm1heExvZ0xldmVsKTtcbiAgICAgICAgKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIEluIG9yZGVyIHRvIGF2b2lkIGNhbGxpbmcgYHNldFRpbWVvdXRgIHRvbyBvZnRlbiwgd2UgYWNjdW11bGF0ZSBzbGVlcCB1cCB1bnRpbFxuICAgICAgICAgICAgLy8gYSBjZXJ0YWluIHRocmVzaG9sZC5cbiAgICAgICAgICAgIGxldCBtaXNzaW5nU2xlZXAgPSAwO1xuICAgICAgICAgICAgLy8gRXh0cmFjdCAodG8gbWFrZSBzdXJlIHRoZSB2YWx1ZSBkb2Vzbid0IGNoYW5nZSkgYW5kIHNhbml0aXplIGBjcHVSYXRlTGltaXRgLlxuICAgICAgICAgICAgbGV0IGNwdVJhdGVMaW1pdCA9IGNvbmZpZy5jcHVSYXRlTGltaXQ7XG4gICAgICAgICAgICBpZiAoaXNOYU4oY3B1UmF0ZUxpbWl0KSlcbiAgICAgICAgICAgICAgICBjcHVSYXRlTGltaXQgPSAxLjA7XG4gICAgICAgICAgICBpZiAoY3B1UmF0ZUxpbWl0ID4gMS4wKVxuICAgICAgICAgICAgICAgIGNwdVJhdGVMaW1pdCA9IDEuMDtcbiAgICAgICAgICAgIGlmIChjcHVSYXRlTGltaXQgPCAwLjApXG4gICAgICAgICAgICAgICAgY3B1UmF0ZUxpbWl0ID0gMC4wO1xuICAgICAgICAgICAgY29uc3QgcGVyaW9kaWNhbGx5WWllbGQgPSB7IHZhbHVlOiBmYWxzZSB9O1xuICAgICAgICAgICAgY29uc3QgW3BlcmlvZGljYWxseVlpZWxkSW5pdCwgdW5yZWdpc3RlckNhbGxiYWNrXSA9IHBsYXRmb3JtQmluZGluZ3MucmVnaXN0ZXJTaG91bGRQZXJpb2RpY2FsbHlZaWVsZCgobmV3VmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBwZXJpb2RpY2FsbHlZaWVsZC52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwZXJpb2RpY2FsbHlZaWVsZC52YWx1ZSA9IHBlcmlvZGljYWxseVlpZWxkSW5pdDtcbiAgICAgICAgICAgIGxldCBub3cgPSBwbGF0Zm9ybUJpbmRpbmdzLnBlcmZvcm1hbmNlTm93KCk7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdoZW5SZWFkeUFnYWluID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IGFkdmFuY2VFeGVjdXRpb25Qcm9taXNlLnZhbHVlID0gcmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0Y29tZSA9IGluc3RhbmNlLmV4cG9ydHMuYWR2YW5jZV9leGVjdXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAob3V0Y29tZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB1bnJlZ2lzdGVyQ2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGFmdGVyRXhlYyA9IHBsYXRmb3JtQmluZGluZ3MucGVyZm9ybWFuY2VOb3coKTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbGFwc2VkID0gYWZ0ZXJFeGVjIC0gbm93O1xuICAgICAgICAgICAgICAgIG5vdyA9IGFmdGVyRXhlYztcbiAgICAgICAgICAgICAgICAvLyBJbiBvcmRlciB0byBlbmZvcmNlIHRoZSByYXRlIGxpbWl0aW5nLCB3ZSBzdG9wIGV4ZWN1dGluZyBmb3IgYSBjZXJ0YWluXG4gICAgICAgICAgICAgICAgLy8gYW1vdW50IG9mIHRpbWUuXG4gICAgICAgICAgICAgICAgLy8gVGhlIGJhc2UgZXF1YXRpb24gaGVyZSBpczogYChzbGVlcCArIGVsYXBzZWQpICogcmF0ZUxpbWl0ID09IGVsYXBzZWRgLFxuICAgICAgICAgICAgICAgIC8vIGZyb20gd2hpY2ggdGhlIGNhbGN1bGF0aW9uIGJlbG93IGlzIGRlcml2ZWQuXG4gICAgICAgICAgICAgICAgY29uc3Qgc2xlZXAgPSBlbGFwc2VkICogKDEuMCAvIGNwdVJhdGVMaW1pdCAtIDEuMCk7XG4gICAgICAgICAgICAgICAgbWlzc2luZ1NsZWVwICs9IHNsZWVwO1xuICAgICAgICAgICAgICAgIGlmIChtaXNzaW5nU2xlZXAgPiAocGVyaW9kaWNhbGx5WWllbGQgPyA1IDogMTAwMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYHNldFRpbWVvdXRgIGhhcyBhIG1heGltdW0gdmFsdWUsIGFmdGVyIHdoaWNoIGl0IHdpbGwgb3ZlcmZsb3cuIPCfpKZcbiAgICAgICAgICAgICAgICAgICAgLy8gU2VlIDxodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvc2V0VGltZW91dCNtYXhpbXVtX2RlbGF5X3ZhbHVlPlxuICAgICAgICAgICAgICAgICAgICAvLyBXaGlsZSBhZGRpbmcgYSBjYXAgdGVjaG5pY2FsbHkgc2tld3MgdGhlIENQVSByYXRlIGxpbWl0aW5nIGFsZ29yaXRobSwgd2UgZG9uJ3RcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVhbGx5IGNhcmUgZm9yIHN1Y2ggZXh0cmVtZSB2YWx1ZXMuXG4gICAgICAgICAgICAgICAgICAgIGlmIChtaXNzaW5nU2xlZXAgPiAyMTQ3NDgzNjQ2KSAvLyBEb2Mgc2F5cyBgPiAyMTQ3NDgzNjQ3YCwgYnV0IEkgZG9uJ3QgcmVhbGx5IHRydXN0IHRoZWlyIHBlZGFudGljaXNtIHNvIGxldCdzIGJlIHNhZmVcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pc3NpbmdTbGVlcCA9IDIxNDc0ODM2NDY7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1pc3NpbmdTbGVlcCkpO1xuICAgICAgICAgICAgICAgICAgICBtaXNzaW5nU2xlZXAgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB5aWVsZCB3aGVuUmVhZHlBZ2FpbjtcbiAgICAgICAgICAgICAgICBjb25zdCBhZnRlcldhaXQgPSBwbGF0Zm9ybUJpbmRpbmdzLnBlcmZvcm1hbmNlTm93KCk7XG4gICAgICAgICAgICAgICAgbWlzc2luZ1NsZWVwIC09IChhZnRlcldhaXQgLSBub3cpO1xuICAgICAgICAgICAgICAgIGlmIChtaXNzaW5nU2xlZXAgPCAwKVxuICAgICAgICAgICAgICAgICAgICBtaXNzaW5nU2xlZXAgPSAwO1xuICAgICAgICAgICAgICAgIG5vdyA9IGFmdGVyV2FpdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpKCk7XG4gICAgICAgIHJldHVybiBbaW5zdGFuY2UsIGJ1ZmZlckluZGljZXNdO1xuICAgIH0pO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9