((typeof self !== 'undefined' ? self : this)["webpackChunk_subwallet_extension_koni"] = (typeof self !== 'undefined' ? self : this)["webpackChunk_subwallet_extension_koni"] || []).push([["vendors-node_modules_emotion_is-prop-valid_dist_emotion-is-prop-valid_esm_js-node_modules_emo-1b9855"],{

/***/ "../../node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.esm.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.esm.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _emotion_memoize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @emotion/memoize */ "../../node_modules/@emotion/memoize/dist/emotion-memoize.esm.js");


var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/; // https://esbench.com/bench/5bfee68a4cd7e6009ef61d23

var isPropValid = /* #__PURE__ */(0,_emotion_memoize__WEBPACK_IMPORTED_MODULE_0__["default"])(function (prop) {
  return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111
  /* o */
  && prop.charCodeAt(1) === 110
  /* n */
  && prop.charCodeAt(2) < 91;
}
/* Z+1 */
);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isPropValid);


/***/ }),

/***/ "../../node_modules/@emotion/memoize/dist/emotion-memoize.esm.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/@emotion/memoize/dist/emotion-memoize.esm.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function memoize(fn) {
  var cache = Object.create(null);
  return function (arg) {
    if (cache[arg] === undefined) cache[arg] = fn(arg);
    return cache[arg];
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (memoize);


/***/ }),

/***/ "../../node_modules/@emotion/stylis/dist/stylis.browser.esm.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/@emotion/stylis/dist/stylis.browser.esm.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function stylis_min (W) {
  function M(d, c, e, h, a) {
    for (var m = 0, b = 0, v = 0, n = 0, q, g, x = 0, K = 0, k, u = k = q = 0, l = 0, r = 0, I = 0, t = 0, B = e.length, J = B - 1, y, f = '', p = '', F = '', G = '', C; l < B;) {
      g = e.charCodeAt(l);
      l === J && 0 !== b + n + v + m && (0 !== b && (g = 47 === b ? 10 : 47), n = v = m = 0, B++, J++);

      if (0 === b + n + v + m) {
        if (l === J && (0 < r && (f = f.replace(N, '')), 0 < f.trim().length)) {
          switch (g) {
            case 32:
            case 9:
            case 59:
            case 13:
            case 10:
              break;

            default:
              f += e.charAt(l);
          }

          g = 59;
        }

        switch (g) {
          case 123:
            f = f.trim();
            q = f.charCodeAt(0);
            k = 1;

            for (t = ++l; l < B;) {
              switch (g = e.charCodeAt(l)) {
                case 123:
                  k++;
                  break;

                case 125:
                  k--;
                  break;

                case 47:
                  switch (g = e.charCodeAt(l + 1)) {
                    case 42:
                    case 47:
                      a: {
                        for (u = l + 1; u < J; ++u) {
                          switch (e.charCodeAt(u)) {
                            case 47:
                              if (42 === g && 42 === e.charCodeAt(u - 1) && l + 2 !== u) {
                                l = u + 1;
                                break a;
                              }

                              break;

                            case 10:
                              if (47 === g) {
                                l = u + 1;
                                break a;
                              }

                          }
                        }

                        l = u;
                      }

                  }

                  break;

                case 91:
                  g++;

                case 40:
                  g++;

                case 34:
                case 39:
                  for (; l++ < J && e.charCodeAt(l) !== g;) {
                  }

              }

              if (0 === k) break;
              l++;
            }

            k = e.substring(t, l);
            0 === q && (q = (f = f.replace(ca, '').trim()).charCodeAt(0));

            switch (q) {
              case 64:
                0 < r && (f = f.replace(N, ''));
                g = f.charCodeAt(1);

                switch (g) {
                  case 100:
                  case 109:
                  case 115:
                  case 45:
                    r = c;
                    break;

                  default:
                    r = O;
                }

                k = M(c, r, k, g, a + 1);
                t = k.length;
                0 < A && (r = X(O, f, I), C = H(3, k, r, c, D, z, t, g, a, h), f = r.join(''), void 0 !== C && 0 === (t = (k = C.trim()).length) && (g = 0, k = ''));
                if (0 < t) switch (g) {
                  case 115:
                    f = f.replace(da, ea);

                  case 100:
                  case 109:
                  case 45:
                    k = f + '{' + k + '}';
                    break;

                  case 107:
                    f = f.replace(fa, '$1 $2');
                    k = f + '{' + k + '}';
                    k = 1 === w || 2 === w && L('@' + k, 3) ? '@-webkit-' + k + '@' + k : '@' + k;
                    break;

                  default:
                    k = f + k, 112 === h && (k = (p += k, ''));
                } else k = '';
                break;

              default:
                k = M(c, X(c, f, I), k, h, a + 1);
            }

            F += k;
            k = I = r = u = q = 0;
            f = '';
            g = e.charCodeAt(++l);
            break;

          case 125:
          case 59:
            f = (0 < r ? f.replace(N, '') : f).trim();
            if (1 < (t = f.length)) switch (0 === u && (q = f.charCodeAt(0), 45 === q || 96 < q && 123 > q) && (t = (f = f.replace(' ', ':')).length), 0 < A && void 0 !== (C = H(1, f, c, d, D, z, p.length, h, a, h)) && 0 === (t = (f = C.trim()).length) && (f = '\x00\x00'), q = f.charCodeAt(0), g = f.charCodeAt(1), q) {
              case 0:
                break;

              case 64:
                if (105 === g || 99 === g) {
                  G += f + e.charAt(l);
                  break;
                }

              default:
                58 !== f.charCodeAt(t - 1) && (p += P(f, q, g, f.charCodeAt(2)));
            }
            I = r = u = q = 0;
            f = '';
            g = e.charCodeAt(++l);
        }
      }

      switch (g) {
        case 13:
        case 10:
          47 === b ? b = 0 : 0 === 1 + q && 107 !== h && 0 < f.length && (r = 1, f += '\x00');
          0 < A * Y && H(0, f, c, d, D, z, p.length, h, a, h);
          z = 1;
          D++;
          break;

        case 59:
        case 125:
          if (0 === b + n + v + m) {
            z++;
            break;
          }

        default:
          z++;
          y = e.charAt(l);

          switch (g) {
            case 9:
            case 32:
              if (0 === n + m + b) switch (x) {
                case 44:
                case 58:
                case 9:
                case 32:
                  y = '';
                  break;

                default:
                  32 !== g && (y = ' ');
              }
              break;

            case 0:
              y = '\\0';
              break;

            case 12:
              y = '\\f';
              break;

            case 11:
              y = '\\v';
              break;

            case 38:
              0 === n + b + m && (r = I = 1, y = '\f' + y);
              break;

            case 108:
              if (0 === n + b + m + E && 0 < u) switch (l - u) {
                case 2:
                  112 === x && 58 === e.charCodeAt(l - 3) && (E = x);

                case 8:
                  111 === K && (E = K);
              }
              break;

            case 58:
              0 === n + b + m && (u = l);
              break;

            case 44:
              0 === b + v + n + m && (r = 1, y += '\r');
              break;

            case 34:
            case 39:
              0 === b && (n = n === g ? 0 : 0 === n ? g : n);
              break;

            case 91:
              0 === n + b + v && m++;
              break;

            case 93:
              0 === n + b + v && m--;
              break;

            case 41:
              0 === n + b + m && v--;
              break;

            case 40:
              if (0 === n + b + m) {
                if (0 === q) switch (2 * x + 3 * K) {
                  case 533:
                    break;

                  default:
                    q = 1;
                }
                v++;
              }

              break;

            case 64:
              0 === b + v + n + m + u + k && (k = 1);
              break;

            case 42:
            case 47:
              if (!(0 < n + m + v)) switch (b) {
                case 0:
                  switch (2 * g + 3 * e.charCodeAt(l + 1)) {
                    case 235:
                      b = 47;
                      break;

                    case 220:
                      t = l, b = 42;
                  }

                  break;

                case 42:
                  47 === g && 42 === x && t + 2 !== l && (33 === e.charCodeAt(t + 2) && (p += e.substring(t, l + 1)), y = '', b = 0);
              }
          }

          0 === b && (f += y);
      }

      K = x;
      x = g;
      l++;
    }

    t = p.length;

    if (0 < t) {
      r = c;
      if (0 < A && (C = H(2, p, r, d, D, z, t, h, a, h), void 0 !== C && 0 === (p = C).length)) return G + p + F;
      p = r.join(',') + '{' + p + '}';

      if (0 !== w * E) {
        2 !== w || L(p, 2) || (E = 0);

        switch (E) {
          case 111:
            p = p.replace(ha, ':-moz-$1') + p;
            break;

          case 112:
            p = p.replace(Q, '::-webkit-input-$1') + p.replace(Q, '::-moz-$1') + p.replace(Q, ':-ms-input-$1') + p;
        }

        E = 0;
      }
    }

    return G + p + F;
  }

  function X(d, c, e) {
    var h = c.trim().split(ia);
    c = h;
    var a = h.length,
        m = d.length;

    switch (m) {
      case 0:
      case 1:
        var b = 0;

        for (d = 0 === m ? '' : d[0] + ' '; b < a; ++b) {
          c[b] = Z(d, c[b], e).trim();
        }

        break;

      default:
        var v = b = 0;

        for (c = []; b < a; ++b) {
          for (var n = 0; n < m; ++n) {
            c[v++] = Z(d[n] + ' ', h[b], e).trim();
          }
        }

    }

    return c;
  }

  function Z(d, c, e) {
    var h = c.charCodeAt(0);
    33 > h && (h = (c = c.trim()).charCodeAt(0));

    switch (h) {
      case 38:
        return c.replace(F, '$1' + d.trim());

      case 58:
        return d.trim() + c.replace(F, '$1' + d.trim());

      default:
        if (0 < 1 * e && 0 < c.indexOf('\f')) return c.replace(F, (58 === d.charCodeAt(0) ? '' : '$1') + d.trim());
    }

    return d + c;
  }

  function P(d, c, e, h) {
    var a = d + ';',
        m = 2 * c + 3 * e + 4 * h;

    if (944 === m) {
      d = a.indexOf(':', 9) + 1;
      var b = a.substring(d, a.length - 1).trim();
      b = a.substring(0, d).trim() + b + ';';
      return 1 === w || 2 === w && L(b, 1) ? '-webkit-' + b + b : b;
    }

    if (0 === w || 2 === w && !L(a, 1)) return a;

    switch (m) {
      case 1015:
        return 97 === a.charCodeAt(10) ? '-webkit-' + a + a : a;

      case 951:
        return 116 === a.charCodeAt(3) ? '-webkit-' + a + a : a;

      case 963:
        return 110 === a.charCodeAt(5) ? '-webkit-' + a + a : a;

      case 1009:
        if (100 !== a.charCodeAt(4)) break;

      case 969:
      case 942:
        return '-webkit-' + a + a;

      case 978:
        return '-webkit-' + a + '-moz-' + a + a;

      case 1019:
      case 983:
        return '-webkit-' + a + '-moz-' + a + '-ms-' + a + a;

      case 883:
        if (45 === a.charCodeAt(8)) return '-webkit-' + a + a;
        if (0 < a.indexOf('image-set(', 11)) return a.replace(ja, '$1-webkit-$2') + a;
        break;

      case 932:
        if (45 === a.charCodeAt(4)) switch (a.charCodeAt(5)) {
          case 103:
            return '-webkit-box-' + a.replace('-grow', '') + '-webkit-' + a + '-ms-' + a.replace('grow', 'positive') + a;

          case 115:
            return '-webkit-' + a + '-ms-' + a.replace('shrink', 'negative') + a;

          case 98:
            return '-webkit-' + a + '-ms-' + a.replace('basis', 'preferred-size') + a;
        }
        return '-webkit-' + a + '-ms-' + a + a;

      case 964:
        return '-webkit-' + a + '-ms-flex-' + a + a;

      case 1023:
        if (99 !== a.charCodeAt(8)) break;
        b = a.substring(a.indexOf(':', 15)).replace('flex-', '').replace('space-between', 'justify');
        return '-webkit-box-pack' + b + '-webkit-' + a + '-ms-flex-pack' + b + a;

      case 1005:
        return ka.test(a) ? a.replace(aa, ':-webkit-') + a.replace(aa, ':-moz-') + a : a;

      case 1e3:
        b = a.substring(13).trim();
        c = b.indexOf('-') + 1;

        switch (b.charCodeAt(0) + b.charCodeAt(c)) {
          case 226:
            b = a.replace(G, 'tb');
            break;

          case 232:
            b = a.replace(G, 'tb-rl');
            break;

          case 220:
            b = a.replace(G, 'lr');
            break;

          default:
            return a;
        }

        return '-webkit-' + a + '-ms-' + b + a;

      case 1017:
        if (-1 === a.indexOf('sticky', 9)) break;

      case 975:
        c = (a = d).length - 10;
        b = (33 === a.charCodeAt(c) ? a.substring(0, c) : a).substring(d.indexOf(':', 7) + 1).trim();

        switch (m = b.charCodeAt(0) + (b.charCodeAt(7) | 0)) {
          case 203:
            if (111 > b.charCodeAt(8)) break;

          case 115:
            a = a.replace(b, '-webkit-' + b) + ';' + a;
            break;

          case 207:
          case 102:
            a = a.replace(b, '-webkit-' + (102 < m ? 'inline-' : '') + 'box') + ';' + a.replace(b, '-webkit-' + b) + ';' + a.replace(b, '-ms-' + b + 'box') + ';' + a;
        }

        return a + ';';

      case 938:
        if (45 === a.charCodeAt(5)) switch (a.charCodeAt(6)) {
          case 105:
            return b = a.replace('-items', ''), '-webkit-' + a + '-webkit-box-' + b + '-ms-flex-' + b + a;

          case 115:
            return '-webkit-' + a + '-ms-flex-item-' + a.replace(ba, '') + a;

          default:
            return '-webkit-' + a + '-ms-flex-line-pack' + a.replace('align-content', '').replace(ba, '') + a;
        }
        break;

      case 973:
      case 989:
        if (45 !== a.charCodeAt(3) || 122 === a.charCodeAt(4)) break;

      case 931:
      case 953:
        if (!0 === la.test(d)) return 115 === (b = d.substring(d.indexOf(':') + 1)).charCodeAt(0) ? P(d.replace('stretch', 'fill-available'), c, e, h).replace(':fill-available', ':stretch') : a.replace(b, '-webkit-' + b) + a.replace(b, '-moz-' + b.replace('fill-', '')) + a;
        break;

      case 962:
        if (a = '-webkit-' + a + (102 === a.charCodeAt(5) ? '-ms-' + a : '') + a, 211 === e + h && 105 === a.charCodeAt(13) && 0 < a.indexOf('transform', 10)) return a.substring(0, a.indexOf(';', 27) + 1).replace(ma, '$1-webkit-$2') + a;
    }

    return a;
  }

  function L(d, c) {
    var e = d.indexOf(1 === c ? ':' : '{'),
        h = d.substring(0, 3 !== c ? e : 10);
    e = d.substring(e + 1, d.length - 1);
    return R(2 !== c ? h : h.replace(na, '$1'), e, c);
  }

  function ea(d, c) {
    var e = P(c, c.charCodeAt(0), c.charCodeAt(1), c.charCodeAt(2));
    return e !== c + ';' ? e.replace(oa, ' or ($1)').substring(4) : '(' + c + ')';
  }

  function H(d, c, e, h, a, m, b, v, n, q) {
    for (var g = 0, x = c, w; g < A; ++g) {
      switch (w = S[g].call(B, d, x, e, h, a, m, b, v, n, q)) {
        case void 0:
        case !1:
        case !0:
        case null:
          break;

        default:
          x = w;
      }
    }

    if (x !== c) return x;
  }

  function T(d) {
    switch (d) {
      case void 0:
      case null:
        A = S.length = 0;
        break;

      default:
        if ('function' === typeof d) S[A++] = d;else if ('object' === typeof d) for (var c = 0, e = d.length; c < e; ++c) {
          T(d[c]);
        } else Y = !!d | 0;
    }

    return T;
  }

  function U(d) {
    d = d.prefix;
    void 0 !== d && (R = null, d ? 'function' !== typeof d ? w = 1 : (w = 2, R = d) : w = 0);
    return U;
  }

  function B(d, c) {
    var e = d;
    33 > e.charCodeAt(0) && (e = e.trim());
    V = e;
    e = [V];

    if (0 < A) {
      var h = H(-1, c, e, e, D, z, 0, 0, 0, 0);
      void 0 !== h && 'string' === typeof h && (c = h);
    }

    var a = M(O, e, c, 0, 0);
    0 < A && (h = H(-2, a, e, e, D, z, a.length, 0, 0, 0), void 0 !== h && (a = h));
    V = '';
    E = 0;
    z = D = 1;
    return a;
  }

  var ca = /^\0+/g,
      N = /[\0\r\f]/g,
      aa = /: */g,
      ka = /zoo|gra/,
      ma = /([,: ])(transform)/g,
      ia = /,\r+?/g,
      F = /([\t\r\n ])*\f?&/g,
      fa = /@(k\w+)\s*(\S*)\s*/,
      Q = /::(place)/g,
      ha = /:(read-only)/g,
      G = /[svh]\w+-[tblr]{2}/,
      da = /\(\s*(.*)\s*\)/g,
      oa = /([\s\S]*?);/g,
      ba = /-self|flex-/g,
      na = /[^]*?(:[rp][el]a[\w-]+)[^]*/,
      la = /stretch|:\s*\w+\-(?:conte|avail)/,
      ja = /([^-])(image-set\()/,
      z = 1,
      D = 1,
      E = 0,
      w = 1,
      O = [],
      S = [],
      A = 0,
      R = null,
      Y = 0,
      V = '';
  B.use = T;
  B.set = U;
  void 0 !== W && U(W);
  return B;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stylis_min);


/***/ }),

/***/ "../../node_modules/@emotion/unitless/dist/unitless.browser.esm.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/@emotion/unitless/dist/unitless.browser.esm.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var unitlessKeys = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (unitlessKeys);


/***/ }),

/***/ "../../node_modules/@ethersproject/abi/lib.esm/_version.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/@ethersproject/abi/lib.esm/_version.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "version": () => (/* binding */ version)
/* harmony export */ });
const version = "abi/5.7.0";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ "../../node_modules/@ethersproject/abi/lib.esm/abi-coder.js":
/*!******************************************************************!*\
  !*** ../../node_modules/@ethersproject/abi/lib.esm/abi-coder.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AbiCoder": () => (/* binding */ AbiCoder),
/* harmony export */   "defaultAbiCoder": () => (/* binding */ defaultAbiCoder)
/* harmony export */ });
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @ethersproject/bytes */ "../../node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/properties */ "../../node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "../../node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "../../node_modules/@ethersproject/abi/lib.esm/_version.js");
/* harmony import */ var _coders_abstract_coder__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./coders/abstract-coder */ "../../node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js");
/* harmony import */ var _coders_address__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./coders/address */ "../../node_modules/@ethersproject/abi/lib.esm/coders/address.js");
/* harmony import */ var _coders_array__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./coders/array */ "../../node_modules/@ethersproject/abi/lib.esm/coders/array.js");
/* harmony import */ var _coders_boolean__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./coders/boolean */ "../../node_modules/@ethersproject/abi/lib.esm/coders/boolean.js");
/* harmony import */ var _coders_bytes__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./coders/bytes */ "../../node_modules/@ethersproject/abi/lib.esm/coders/bytes.js");
/* harmony import */ var _coders_fixed_bytes__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./coders/fixed-bytes */ "../../node_modules/@ethersproject/abi/lib.esm/coders/fixed-bytes.js");
/* harmony import */ var _coders_null__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./coders/null */ "../../node_modules/@ethersproject/abi/lib.esm/coders/null.js");
/* harmony import */ var _coders_number__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./coders/number */ "../../node_modules/@ethersproject/abi/lib.esm/coders/number.js");
/* harmony import */ var _coders_string__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./coders/string */ "../../node_modules/@ethersproject/abi/lib.esm/coders/string.js");
/* harmony import */ var _coders_tuple__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./coders/tuple */ "../../node_modules/@ethersproject/abi/lib.esm/coders/tuple.js");
/* harmony import */ var _fragments__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./fragments */ "../../node_modules/@ethersproject/abi/lib.esm/fragments.js");

// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI




const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);











const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
class AbiCoder {
    constructor(coerceFunc) {
        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, "coerceFunc", coerceFunc || null);
    }
    _getCoder(param) {
        switch (param.baseType) {
            case "address":
                return new _coders_address__WEBPACK_IMPORTED_MODULE_3__.AddressCoder(param.name);
            case "bool":
                return new _coders_boolean__WEBPACK_IMPORTED_MODULE_4__.BooleanCoder(param.name);
            case "string":
                return new _coders_string__WEBPACK_IMPORTED_MODULE_5__.StringCoder(param.name);
            case "bytes":
                return new _coders_bytes__WEBPACK_IMPORTED_MODULE_6__.BytesCoder(param.name);
            case "array":
                return new _coders_array__WEBPACK_IMPORTED_MODULE_7__.ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);
            case "tuple":
                return new _coders_tuple__WEBPACK_IMPORTED_MODULE_8__.TupleCoder((param.components || []).map((component) => {
                    return this._getCoder(component);
                }), param.name);
            case "":
                return new _coders_null__WEBPACK_IMPORTED_MODULE_9__.NullCoder(param.name);
        }
        // u?int[0-9]*
        let match = param.type.match(paramTypeNumber);
        if (match) {
            let size = parseInt(match[2] || "256");
            if (size === 0 || size > 256 || (size % 8) !== 0) {
                logger.throwArgumentError("invalid " + match[1] + " bit length", "param", param);
            }
            return new _coders_number__WEBPACK_IMPORTED_MODULE_10__.NumberCoder(size / 8, (match[1] === "int"), param.name);
        }
        // bytes[0-9]+
        match = param.type.match(paramTypeBytes);
        if (match) {
            let size = parseInt(match[1]);
            if (size === 0 || size > 32) {
                logger.throwArgumentError("invalid bytes length", "param", param);
            }
            return new _coders_fixed_bytes__WEBPACK_IMPORTED_MODULE_11__.FixedBytesCoder(size, param.name);
        }
        return logger.throwArgumentError("invalid type", "type", param.type);
    }
    _getWordSize() { return 32; }
    _getReader(data, allowLoose) {
        return new _coders_abstract_coder__WEBPACK_IMPORTED_MODULE_12__.Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);
    }
    _getWriter() {
        return new _coders_abstract_coder__WEBPACK_IMPORTED_MODULE_12__.Writer(this._getWordSize());
    }
    getDefaultValue(types) {
        const coders = types.map((type) => this._getCoder(_fragments__WEBPACK_IMPORTED_MODULE_13__.ParamType.from(type)));
        const coder = new _coders_tuple__WEBPACK_IMPORTED_MODULE_8__.TupleCoder(coders, "_");
        return coder.defaultValue();
    }
    encode(types, values) {
        if (types.length !== values.length) {
            logger.throwError("types/values length mismatch", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INVALID_ARGUMENT, {
                count: { types: types.length, values: values.length },
                value: { types: types, values: values }
            });
        }
        const coders = types.map((type) => this._getCoder(_fragments__WEBPACK_IMPORTED_MODULE_13__.ParamType.from(type)));
        const coder = (new _coders_tuple__WEBPACK_IMPORTED_MODULE_8__.TupleCoder(coders, "_"));
        const writer = this._getWriter();
        coder.encode(writer, values);
        return writer.data;
    }
    decode(types, data, loose) {
        const coders = types.map((type) => this._getCoder(_fragments__WEBPACK_IMPORTED_MODULE_13__.ParamType.from(type)));
        const coder = new _coders_tuple__WEBPACK_IMPORTED_MODULE_8__.TupleCoder(coders, "_");
        return coder.decode(this._getReader((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_14__.arrayify)(data), loose));
    }
}
const defaultAbiCoder = new AbiCoder();
//# sourceMappingURL=abi-coder.js.map

/***/ }),

/***/ "../../node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Coder": () => (/* binding */ Coder),
/* harmony export */   "Reader": () => (/* binding */ Reader),
/* harmony export */   "Writer": () => (/* binding */ Writer),
/* harmony export */   "checkResultErrors": () => (/* binding */ checkResultErrors)
/* harmony export */ });
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/bytes */ "../../node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/bignumber */ "../../node_modules/@ethersproject/bignumber/lib.esm/bignumber.js");
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/properties */ "../../node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "../../node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_version */ "../../node_modules/@ethersproject/abi/lib.esm/_version.js");






const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);
function checkResultErrors(result) {
    // Find the first error (if any)
    const errors = [];
    const checkErrors = function (path, object) {
        if (!Array.isArray(object)) {
            return;
        }
        for (let key in object) {
            const childPath = path.slice();
            childPath.push(key);
            try {
                checkErrors(childPath, object[key]);
            }
            catch (error) {
                errors.push({ path: childPath, error: error });
            }
        }
    };
    checkErrors([], result);
    return errors;
}
class Coder {
    constructor(name, type, localName, dynamic) {
        // @TODO: defineReadOnly these
        this.name = name;
        this.type = type;
        this.localName = localName;
        this.dynamic = dynamic;
    }
    _throwError(message, value) {
        logger.throwArgumentError(message, this.localName, value);
    }
}
class Writer {
    constructor(wordSize) {
        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, "wordSize", wordSize || 32);
        this._data = [];
        this._dataLength = 0;
        this._padding = new Uint8Array(wordSize);
    }
    get data() {
        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)(this._data);
    }
    get length() { return this._dataLength; }
    _writeData(data) {
        this._data.push(data);
        this._dataLength += data.length;
        return data.length;
    }
    appendWriter(writer) {
        return this._writeData((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.concat)(writer._data));
    }
    // Arrayish items; padded on the right to wordSize
    writeBytes(value) {
        let bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(value);
        const paddingOffset = bytes.length % this.wordSize;
        if (paddingOffset) {
            bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.concat)([bytes, this._padding.slice(paddingOffset)]);
        }
        return this._writeData(bytes);
    }
    _getValue(value) {
        let bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(value));
        if (bytes.length > this.wordSize) {
            logger.throwError("value out-of-bounds", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {
                length: this.wordSize,
                offset: bytes.length
            });
        }
        if (bytes.length % this.wordSize) {
            bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.concat)([this._padding.slice(bytes.length % this.wordSize), bytes]);
        }
        return bytes;
    }
    // BigNumberish items; padded on the left to wordSize
    writeValue(value) {
        return this._writeData(this._getValue(value));
    }
    writeUpdatableValue() {
        const offset = this._data.length;
        this._data.push(this._padding);
        this._dataLength += this.wordSize;
        return (value) => {
            this._data[offset] = this._getValue(value);
        };
    }
}
class Reader {
    constructor(data, wordSize, coerceFunc, allowLoose) {
        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, "_data", (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(data));
        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, "wordSize", wordSize || 32);
        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, "_coerceFunc", coerceFunc);
        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, "allowLoose", allowLoose);
        this._offset = 0;
    }
    get data() { return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(this._data); }
    get consumed() { return this._offset; }
    // The default Coerce function
    static coerce(name, value) {
        let match = name.match("^u?int([0-9]+)$");
        if (match && parseInt(match[1]) <= 48) {
            value = value.toNumber();
        }
        return value;
    }
    coerce(name, value) {
        if (this._coerceFunc) {
            return this._coerceFunc(name, value);
        }
        return Reader.coerce(name, value);
    }
    _peekBytes(offset, length, loose) {
        let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;
        if (this._offset + alignedLength > this._data.length) {
            if (this.allowLoose && loose && this._offset + length <= this._data.length) {
                alignedLength = length;
            }
            else {
                logger.throwError("data out-of-bounds", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {
                    length: this._data.length,
                    offset: this._offset + alignedLength
                });
            }
        }
        return this._data.slice(this._offset, this._offset + alignedLength);
    }
    subReader(offset) {
        return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);
    }
    readBytes(length, loose) {
        let bytes = this._peekBytes(0, length, !!loose);
        this._offset += bytes.length;
        // @TODO: Make sure the length..end bytes are all 0?
        return bytes.slice(0, length);
    }
    readValue() {
        return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(this.readBytes(this.wordSize));
    }
}
//# sourceMappingURL=abstract-coder.js.map

/***/ }),

/***/ "../../node_modules/@ethersproject/abi/lib.esm/coders/address.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/@ethersproject/abi/lib.esm/coders/address.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AddressCoder": () => (/* binding */ AddressCoder)
/* harmony export */ });
/* harmony import */ var _ethersproject_address__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/address */ "../../node_modules/@ethersproject/address/lib.esm/index.js");
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bytes */ "../../node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder */ "../../node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js");




class AddressCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_0__.Coder {
    constructor(localName) {
        super("address", "address", localName, false);
    }
    defaultValue() {
        return "0x0000000000000000000000000000000000000000";
    }
    encode(writer, value) {
        try {
            value = (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_1__.getAddress)(value);
        }
        catch (error) {
            this._throwError(error.message, value);
        }
        return writer.writeValue(value);
    }
    decode(reader) {
        return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_1__.getAddress)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexZeroPad)(reader.readValue().toHexString(), 20));
    }
}
//# sourceMappingURL=address.js.map

/***/ }),

/***/ "../../node_modules/@ethersproject/abi/lib.esm/coders/anonymous.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/@ethersproject/abi/lib.esm/coders/anonymous.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnonymousCoder": () => (/* binding */ AnonymousCoder)
/* harmony export */ });
/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder */ "../../node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js");


// Clones the functionality of an existing Coder, but without a localName
class AnonymousCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_0__.Coder {
    constructor(coder) {
        super(coder.name, coder.type, undefined, coder.dynamic);
        this.coder = coder;
    }
    defaultValue() {
        return this.coder.defaultValue();
    }
    encode(writer, value) {
        return this.coder.encode(writer, value);
    }
    decode(reader) {
        return this.coder.decode(reader);
    }
}
//# sourceMappingURL=anonymous.js.map

/***/ }),

/***/ "../../node_modules/@ethersproject/abi/lib.esm/coders/array.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/@ethersproject/abi/lib.esm/coders/array.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ArrayCoder": () => (/* binding */ ArrayCoder),
/* harmony export */   "pack": () => (/* binding */ pack),
/* harmony export */   "unpack": () => (/* binding */ unpack)
/* harmony export */ });
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "../../node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_version */ "../../node_modules/@ethersproject/abi/lib.esm/_version.js");
/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract-coder */ "../../node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js");
/* harmony import */ var _anonymous__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./anonymous */ "../../node_modules/@ethersproject/abi/lib.esm/coders/anonymous.js");



const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);


function pack(writer, coders, values) {
    let arrayValues = null;
    if (Array.isArray(values)) {
        arrayValues = values;
    }
    else if (values && typeof (values) === "object") {
        let unique = {};
        arrayValues = coders.map((coder) => {
            const name = coder.localName;
            if (!name) {
                logger.throwError("cannot encode object for signature with missing names", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INVALID_ARGUMENT, {
                    argument: "values",
                    coder: coder,
                    value: values
                });
            }
            if (unique[name]) {
                logger.throwError("cannot encode object for signature with duplicate names", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INVALID_ARGUMENT, {
                    argument: "values",
                    coder: coder,
                    value: values
                });
            }
            unique[name] = true;
            return values[name];
        });
    }
    else {
        logger.throwArgumentError("invalid tuple value", "tuple", values);
    }
    if (coders.length !== arrayValues.length) {
        logger.throwArgumentError("types/value length mismatch", "tuple", values);
    }
    let staticWriter = new _abstract_coder__WEBPACK_IMPORTED_MODULE_2__.Writer(writer.wordSize);
    let dynamicWriter = new _abstract_coder__WEBPACK_IMPORTED_MODULE_2__.Writer(writer.wordSize);
    let updateFuncs = [];
    coders.forEach((coder, index) => {
        let value = arrayValues[index];
        if (coder.dynamic) {
            // Get current dynamic offset (for the future pointer)
            let dynamicOffset = dynamicWriter.length;
            // Encode the dynamic value into the dynamicWriter
            coder.encode(dynamicWriter, value);
            // Prepare to populate the correct offset once we are done
            let updateFunc = staticWriter.writeUpdatableValue();
            updateFuncs.push((baseOffset) => {
                updateFunc(baseOffset + dynamicOffset);
            });
        }
        else {
            coder.encode(staticWriter, value);
        }
    });
    // Backfill all the dynamic offsets, now that we know the static length
    updateFuncs.forEach((func) => { func(staticWriter.length); });
    let length = writer.appendWriter(staticWriter);
    length += writer.appendWriter(dynamicWriter);
    return length;
}
function unpack(reader, coders) {
    let values = [];
    // A reader anchored to this base
    let baseReader = reader.subReader(0);
    coders.forEach((coder) => {
        let value = null;
        if (coder.dynamic) {
            let offset = reader.readValue();
            let offsetReader = baseReader.subReader(offset.toNumber());
            try {
                value = coder.decode(offsetReader);
            }
            catch (error) {
                // Cannot recover from this
                if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN) {
                    throw error;
                }
                value = error;
                value.baseType = coder.name;
                value.name = coder.localName;
                value.type = coder.type;
            }
        }
        else {
            try {
                value = coder.decode(reader);
            }
            catch (error) {
                // Cannot recover from this
                if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN) {
                    throw error;
                }
                value = error;
                value.baseType = coder.name;
                value.name = coder.localName;
                value.type = coder.type;
            }
        }
        if (value != undefined) {
            values.push(value);
        }
    });
    // We only output named properties for uniquely named coders
    const uniqueNames = coders.reduce((accum, coder) => {
        const name = coder.localName;
        if (name) {
            if (!accum[name]) {
                accum[name] = 0;
            }
            accum[name]++;
        }
        return accum;
    }, {});
    // Add any named parameters (i.e. tuples)
    coders.forEach((coder, index) => {
        let name = coder.localName;
        if (!name || uniqueNames[name] !== 1) {
            return;
        }
        if (name === "length") {
            name = "_length";
        }
        if (values[name] != null) {
            return;
        }
        const value = values[index];
        if (value instanceof Error) {
            Object.defineProperty(values, name, {
                enumerable: true,
                get: () => { throw value; }
            });
        }
        else {
            values[name] = value;
        }
    });
    for (let i = 0; i < values.length; i++) {
        const value = values[i];
        if (value instanceof Error) {
            Object.defineProperty(values, i, {
                enumerable: true,
                get: () => { throw value; }
            });
        }
    }
    return Object.freeze(values);
}
class ArrayCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_2__.Coder {
    constructor(coder, length, localName) {
        const type = (coder.type + "[" + (length >= 0 ? length : "") + "]");
        const dynamic = (length === -1 || coder.dynamic);
        super("array", type, localName, dynamic);
        this.coder = coder;
        this.length = length;
    }
    defaultValue() {
        // Verifies the child coder is valid (even if the array is dynamic or 0-length)
        const defaultChild = this.coder.defaultValue();
        const result = [];
        for (let i = 0; i < this.length; i++) {
            result.push(defaultChild);
        }
        return result;
    }
    encode(writer, value) {
        if (!Array.isArray(value)) {
            this._throwError("expected array value", value);
        }
        let count = this.length;
        if (count === -1) {
            count = value.length;
            writer.writeValue(value.length);
        }
        logger.checkArgumentCount(value.length, count, "coder array" + (this.localName ? (" " + this.localName) : ""));
        let coders = [];
        for (let i = 0; i < value.length; i++) {
            coders.push(this.coder);
        }
        return pack(writer, coders, value);
    }
    decode(reader) {
        let count = this.length;
        if (count === -1) {
            count = reader.readValue().toNumber();
            // Check that there is *roughly* enough data to ensure
            // stray random data is not being read as a length. Each
            // slot requires at least 32 bytes for their value (or 32
            // bytes as a link to the data). This could use a much
            // tighter bound, but we are erroring on the side of safety.
            if (count * 32 > reader._data.length) {
                logger.throwError("insufficient data length", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {
                    length: reader._data.length,
                    count: count
                });
            }
        }
        let coders = [];
        for (let i = 0; i < count; i++) {
            coders.push(new _anonymous__WEBPACK_IMPORTED_MODULE_3__.AnonymousCoder(this.coder));
        }
        return reader.coerce(this.name, unpack(reader, coders));
    }
}
//# sourceMappingURL=array.js.map

/***/ }),

/***/ "../../node_modules/@ethersproject/abi/lib.esm/coders/boolean.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/@ethersproject/abi/lib.esm/coders/boolean.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BooleanCoder": () => (/* binding */ BooleanCoder)
/* harmony export */ });
/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder */ "../../node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js");


class BooleanCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_0__.Coder {
    constructor(localName) {
        super("bool", "bool", localName, false);
    }
    defaultValue() {
        return false;
    }
    encode(writer, value) {
        return writer.writeValue(value ? 1 : 0);
    }
    decode(reader) {
        return reader.coerce(this.type, !reader.readValue().isZero());
    }
}
//# sourceMappingURL=boolean.js.map

/***/ }),

/***/ "../../node_modules/@ethersproject/abi/lib.esm/coders/bytes.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/@ethersproject/abi/lib.esm/coders/bytes.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BytesCoder": () => (/* binding */ BytesCoder),
/* harmony export */   "DynamicBytesCoder": () => (/* binding */ DynamicBytesCoder)
/* harmony export */ });
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/bytes */ "../../node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder */ "../../node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js");



class DynamicBytesCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_0__.Coder {
    constructor(type, localName) {
        super(type, type, localName, true);
    }
    defaultValue() {
        return "0x";
    }
    encode(writer, value) {
        value = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__.arrayify)(value);
        let length = writer.writeValue(value.length);
        length += writer.writeBytes(value);
        return length;
    }
    decode(reader) {
        return reader.readBytes(reader.readValue().toNumber(), true);
    }
}
class BytesCoder extends DynamicBytesCoder {
    constructor(localName) {
        super("bytes", localName);
    }
    decode(reader) {
        return reader.coerce(this.name, (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__.hexlify)(super.decode(reader)));
    }
}
//# sourceMappingURL=bytes.js.map

/***/ }),

/***/ "../../node_modules/@ethersproject/abi/lib.esm/coders/fixed-bytes.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/@ethersproject/abi/lib.esm/coders/fixed-bytes.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FixedBytesCoder": () => (/* binding */ FixedBytesCoder)
/* harmony export */ });
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/bytes */ "../../node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder */ "../../node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js");



// @TODO: Merge this with bytes
class FixedBytesCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_0__.Coder {
    constructor(size, localName) {
        let name = "bytes" + String(size);
        super(name, name, localName, false);
        this.size = size;
    }
    defaultValue() {
        return ("0x0000000000000000000000000000000000000000000000000000000000000000").substring(0, 2 + this.size * 2);
    }
    encode(writer, value) {
        let data = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__.arrayify)(value);
        if (data.length !== this.size) {
            this._throwError("incorrect data length", value);
        }
        return writer.writeBytes(data);
    }
    decode(reader) {
        return reader.coerce(this.name, (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__.hexlify)(reader.readBytes(this.size)));
    }
}
//# sourceMappingURL=fixed-bytes.js.map

/***/ }),

/***/ "../../node_modules/@ethersproject/abi/lib.esm/coders/null.js":
/*!********************************************************************!*\
  !*** ../../node_modules/@ethersproject/abi/lib.esm/coders/null.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NullCoder": () => (/* binding */ NullCoder)
/* harmony export */ });
/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder */ "../../node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js");


class NullCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_0__.Coder {
    constructor(localName) {
        super("null", "", localName, false);
    }
    defaultValue() {
        return null;
    }
    encode(writer, value) {
        if (value != null) {
            this._throwError("not null", value);
        }
        return writer.writeBytes([]);
    }
    decode(reader) {
        reader.readBytes(0);
        return reader.coerce(this.name, null);
    }
}
//# sourceMappingURL=null.js.map

/***/ }),

/***/ "../../node_modules/@ethersproject/abi/lib.esm/coders/number.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/@ethersproject/abi/lib.esm/coders/number.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NumberCoder": () => (/* binding */ NumberCoder)
/* harmony export */ });
/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/bignumber */ "../../node_modules/@ethersproject/bignumber/lib.esm/bignumber.js");
/* harmony import */ var _ethersproject_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/constants */ "../../node_modules/@ethersproject/constants/lib.esm/bignumbers.js");
/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder */ "../../node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js");




class NumberCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_0__.Coder {
    constructor(size, signed, localName) {
        const name = ((signed ? "int" : "uint") + (size * 8));
        super(name, name, localName, false);
        this.size = size;
        this.signed = signed;
    }
    defaultValue() {
        return 0;
    }
    encode(writer, value) {
        let v = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__.BigNumber.from(value);
        // Check bounds are safe for encoding
        let maxUintValue = _ethersproject_constants__WEBPACK_IMPORTED_MODULE_2__.MaxUint256.mask(writer.wordSize * 8);
        if (this.signed) {
            let bounds = maxUintValue.mask(this.size * 8 - 1);
            if (v.gt(bounds) || v.lt(bounds.add(_ethersproject_constants__WEBPACK_IMPORTED_MODULE_2__.One).mul(_ethersproject_constants__WEBPACK_IMPORTED_MODULE_2__.NegativeOne))) {
                this._throwError("value out-of-bounds", value);
            }
        }
        else if (v.lt(_ethersproject_constants__WEBPACK_IMPORTED_MODULE_2__.Zero) || v.gt(maxUintValue.mask(this.size * 8))) {
            this._throwError("value out-of-bounds", value);
        }
        v = v.toTwos(this.size * 8).mask(this.size * 8);
        if (this.signed) {
            v = v.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);
        }
        return writer.writeValue(v);
    }
    decode(reader) {
        let value = reader.readValue().mask(this.size * 8);
        if (this.signed) {
            value = value.fromTwos(this.size * 8);
        }
        return reader.coerce(this.name, value);
    }
}
//# sourceMappingURL=number.js.map

/***/ }),

/***/ "../../node_modules/@ethersproject/abi/lib.esm/coders/string.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/@ethersproject/abi/lib.esm/coders/string.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StringCoder": () => (/* binding */ StringCoder)
/* harmony export */ });
/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/strings */ "../../node_modules/@ethersproject/strings/lib.esm/utf8.js");
/* harmony import */ var _bytes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bytes */ "../../node_modules/@ethersproject/abi/lib.esm/coders/bytes.js");



class StringCoder extends _bytes__WEBPACK_IMPORTED_MODULE_0__.DynamicBytesCoder {
    constructor(localName) {
        super("string", localName);
    }
    defaultValue() {
        return "";
    }
    encode(writer, value) {
        return super.encode(writer, (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_1__.toUtf8Bytes)(value));
    }
    decode(reader) {
        return (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_1__.toUtf8String)(super.decode(reader));
    }
}
//# sourceMappingURL=string.js.map

/***/ }),

/***/ "../../node_modules/@ethersproject/abi/lib.esm/coders/tuple.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/@ethersproject/abi/lib.esm/coders/tuple.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TupleCoder": () => (/* binding */ TupleCoder)
/* harmony export */ });
/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder */ "../../node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js");
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./array */ "../../node_modules/@ethersproject/abi/lib.esm/coders/array.js");



class TupleCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_0__.Coder {
    constructor(coders, localName) {
        let dynamic = false;
        const types = [];
        coders.forEach((coder) => {
            if (coder.dynamic) {
                dynamic = true;
            }
            types.push(coder.type);
        });
        const type = ("tuple(" + types.join(",") + ")");
        super("tuple", type, localName, dynamic);
        this.coders = coders;
    }
    defaultValue() {
        const values = [];
        this.coders.forEach((coder) => {
            values.push(coder.defaultValue());
        });
        // We only output named properties for uniquely named coders
        const uniqueNames = this.coders.reduce((accum, coder) => {
            const name = coder.localName;
            if (name) {
                if (!accum[name]) {
                    accum[name] = 0;
                }
                accum[name]++;
            }
            return accum;
        }, {});
        // Add named values
        this.coders.forEach((coder, index) => {
            let name = coder.localName;
            if (!name || uniqueNames[name] !== 1) {
                return;
            }
            if (name === "length") {
                name = "_length";
            }
            if (values[name] != null) {
                return;
            }
            values[name] = values[index];
        });
        return Object.freeze(values);
    }
    encode(writer, value) {
        return (0,_array__WEBPACK_IMPORTED_MODULE_1__.pack)(writer, this.coders, value);
    }
    decode(reader) {
        return reader.coerce(this.name, (0,_array__WEBPACK_IMPORTED_MODULE_1__.unpack)(reader, this.coders));
    }
}
//# sourceMappingURL=tuple.js.map

/***/ }),

/***/ "../../node_modules/@ethersproject/abi/lib.esm/fragments.js":
/*!******************************************************************!*\
  !*** ../../node_modules/@ethersproject/abi/lib.esm/fragments.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConstructorFragment": () => (/* binding */ ConstructorFragment),
/* harmony export */   "ErrorFragment": () => (/* binding */ ErrorFragment),
/* harmony export */   "EventFragment": () => (/* binding */ EventFragment),
/* harmony export */   "FormatTypes": () => (/* binding */ FormatTypes),
/* harmony export */   "Fragment": () => (/* binding */ Fragment),
/* harmony export */   "FunctionFragment": () => (/* binding */ FunctionFragment),
/* harmony export */   "ParamType": () => (/* binding */ ParamType)
/* harmony export */ });
/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/bignumber */ "../../node_modules/@ethersproject/bignumber/lib.esm/bignumber.js");
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/properties */ "../../node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "../../node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "../../node_modules/@ethersproject/abi/lib.esm/_version.js");





const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);
;
const _constructorGuard = {};
let ModifiersBytes = { calldata: true, memory: true, storage: true };
let ModifiersNest = { calldata: true, memory: true };
function checkModifier(type, name) {
    if (type === "bytes" || type === "string") {
        if (ModifiersBytes[name]) {
            return true;
        }
    }
    else if (type === "address") {
        if (name === "payable") {
            return true;
        }
    }
    else if (type.indexOf("[") >= 0 || type === "tuple") {
        if (ModifiersNest[name]) {
            return true;
        }
    }
    if (ModifiersBytes[name] || name === "payable") {
        logger.throwArgumentError("invalid modifier", "name", name);
    }
    return false;
}
// @TODO: Make sure that children of an indexed tuple are marked with a null indexed
function parseParamType(param, allowIndexed) {
    let originalParam = param;
    function throwError(i) {
        logger.throwArgumentError(`unexpected character at position ${i}`, "param", param);
    }
    param = param.replace(/\s/g, " ");
    function newNode(parent) {
        let node = { type: "", name: "", parent: parent, state: { allowType: true } };
        if (allowIndexed) {
            node.indexed = false;
        }
        return node;
    }
    let parent = { type: "", name: "", state: { allowType: true } };
    let node = parent;
    for (let i = 0; i < param.length; i++) {
        let c = param[i];
        switch (c) {
            case "(":
                if (node.state.allowType && node.type === "") {
                    node.type = "tuple";
                }
                else if (!node.state.allowParams) {
                    throwError(i);
                }
                node.state.allowType = false;
                node.type = verifyType(node.type);
                node.components = [newNode(node)];
                node = node.components[0];
                break;
            case ")":
                delete node.state;
                if (node.name === "indexed") {
                    if (!allowIndexed) {
                        throwError(i);
                    }
                    node.indexed = true;
                    node.name = "";
                }
                if (checkModifier(node.type, node.name)) {
                    node.name = "";
                }
                node.type = verifyType(node.type);
                let child = node;
                node = node.parent;
                if (!node) {
                    throwError(i);
                }
                delete child.parent;
                node.state.allowParams = false;
                node.state.allowName = true;
                node.state.allowArray = true;
                break;
            case ",":
                delete node.state;
                if (node.name === "indexed") {
                    if (!allowIndexed) {
                        throwError(i);
                    }
                    node.indexed = true;
                    node.name = "";
                }
                if (checkModifier(node.type, node.name)) {
                    node.name = "";
                }
                node.type = verifyType(node.type);
                let sibling = newNode(node.parent);
                //{ type: "", name: "", parent: node.parent, state: { allowType: true } };
                node.parent.components.push(sibling);
                delete node.parent;
                node = sibling;
                break;
            // Hit a space...
            case " ":
                // If reading type, the type is done and may read a param or name
                if (node.state.allowType) {
                    if (node.type !== "") {
                        node.type = verifyType(node.type);
                        delete node.state.allowType;
                        node.state.allowName = true;
                        node.state.allowParams = true;
                    }
                }
                // If reading name, the name is done
                if (node.state.allowName) {
                    if (node.name !== "") {
                        if (node.name === "indexed") {
                            if (!allowIndexed) {
                                throwError(i);
                            }
                            if (node.indexed) {
                                throwError(i);
                            }
                            node.indexed = true;
                            node.name = "";
                        }
                        else if (checkModifier(node.type, node.name)) {
                            node.name = "";
                        }
                        else {
                            node.state.allowName = false;
                        }
                    }
                }
                break;
            case "[":
                if (!node.state.allowArray) {
                    throwError(i);
                }
                node.type += c;
                node.state.allowArray = false;
                node.state.allowName = false;
                node.state.readArray = true;
                break;
            case "]":
                if (!node.state.readArray) {
                    throwError(i);
                }
                node.type += c;
                node.state.readArray = false;
                node.state.allowArray = true;
                node.state.allowName = true;
                break;
            default:
                if (node.state.allowType) {
                    node.type += c;
                    node.state.allowParams = true;
                    node.state.allowArray = true;
                }
                else if (node.state.allowName) {
                    node.name += c;
                    delete node.state.allowArray;
                }
                else if (node.state.readArray) {
                    node.type += c;
                }
                else {
                    throwError(i);
                }
        }
    }
    if (node.parent) {
        logger.throwArgumentError("unexpected eof", "param", param);
    }
    delete parent.state;
    if (node.name === "indexed") {
        if (!allowIndexed) {
            throwError(originalParam.length - 7);
        }
        if (node.indexed) {
            throwError(originalParam.length - 7);
        }
        node.indexed = true;
        node.name = "";
    }
    else if (checkModifier(node.type, node.name)) {
        node.name = "";
    }
    parent.type = verifyType(parent.type);
    return parent;
}
function populate(object, params) {
    for (let key in params) {
        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(object, key, params[key]);
    }
}
const FormatTypes = Object.freeze({
    // Bare formatting, as is needed for computing a sighash of an event or function
    sighash: "sighash",
    // Human-Readable with Minimal spacing and without names (compact human-readable)
    minimal: "minimal",
    // Human-Readable with nice spacing, including all names
    full: "full",
    // JSON-format a la Solidity
    json: "json"
});
const paramTypeArray = new RegExp(/^(.*)\[([0-9]*)\]$/);
class ParamType {
    constructor(constructorGuard, params) {
        if (constructorGuard !== _constructorGuard) {
            logger.throwError("use fromString", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "new ParamType()"
            });
        }
        populate(this, params);
        let match = this.type.match(paramTypeArray);
        if (match) {
            populate(this, {
                arrayLength: parseInt(match[2] || "-1"),
                arrayChildren: ParamType.fromObject({
                    type: match[1],
                    components: this.components
                }),
                baseType: "array"
            });
        }
        else {
            populate(this, {
                arrayLength: null,
                arrayChildren: null,
                baseType: ((this.components != null) ? "tuple" : this.type)
            });
        }
        this._isParamType = true;
        Object.freeze(this);
    }
    // Format the parameter fragment
    //   - sighash: "(uint256,address)"
    //   - minimal: "tuple(uint256,address) indexed"
    //   - full:    "tuple(uint256 foo, address bar) indexed baz"
    format(format) {
        if (!format) {
            format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
            logger.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
            let result = {
                type: ((this.baseType === "tuple") ? "tuple" : this.type),
                name: (this.name || undefined)
            };
            if (typeof (this.indexed) === "boolean") {
                result.indexed = this.indexed;
            }
            if (this.components) {
                result.components = this.components.map((comp) => JSON.parse(comp.format(format)));
            }
            return JSON.stringify(result);
        }
        let result = "";
        // Array
        if (this.baseType === "array") {
            result += this.arrayChildren.format(format);
            result += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]";
        }
        else {
            if (this.baseType === "tuple") {
                if (format !== FormatTypes.sighash) {
                    result += this.type;
                }
                result += "(" + this.components.map((comp) => comp.format(format)).join((format === FormatTypes.full) ? ", " : ",") + ")";
            }
            else {
                result += this.type;
            }
        }
        if (format !== FormatTypes.sighash) {
            if (this.indexed === true) {
                result += " indexed";
            }
            if (format === FormatTypes.full && this.name) {
                result += " " + this.name;
            }
        }
        return result;
    }
    static from(value, allowIndexed) {
        if (typeof (value) === "string") {
            return ParamType.fromString(value, allowIndexed);
        }
        return ParamType.fromObject(value);
    }
    static fromObject(value) {
        if (ParamType.isParamType(value)) {
            return value;
        }
        return new ParamType(_constructorGuard, {
            name: (value.name || null),
            type: verifyType(value.type),
            indexed: ((value.indexed == null) ? null : !!value.indexed),
            components: (value.components ? value.components.map(ParamType.fromObject) : null)
        });
    }
    static fromString(value, allowIndexed) {
        function ParamTypify(node) {
            return ParamType.fromObject({
                name: node.name,
                type: node.type,
                indexed: node.indexed,
                components: node.components
            });
        }
        return ParamTypify(parseParamType(value, !!allowIndexed));
    }
    static isParamType(value) {
        return !!(value != null && value._isParamType);
    }
}
;
function parseParams(value, allowIndex) {
    return splitNesting(value).map((param) => ParamType.fromString(param, allowIndex));
}
class Fragment {
    constructor(constructorGuard, params) {
        if (constructorGuard !== _constructorGuard) {
            logger.throwError("use a static from method", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "new Fragment()"
            });
        }
        populate(this, params);
        this._isFragment = true;
        Object.freeze(this);
    }
    static from(value) {
        if (Fragment.isFragment(value)) {
            return value;
        }
        if (typeof (value) === "string") {
            return Fragment.fromString(value);
        }
        return Fragment.fromObject(value);
    }
    static fromObject(value) {
        if (Fragment.isFragment(value)) {
            return value;
        }
        switch (value.type) {
            case "function":
                return FunctionFragment.fromObject(value);
            case "event":
                return EventFragment.fromObject(value);
            case "constructor":
                return ConstructorFragment.fromObject(value);
            case "error":
                return ErrorFragment.fromObject(value);
            case "fallback":
            case "receive":
                // @TODO: Something? Maybe return a FunctionFragment? A custom DefaultFunctionFragment?
                return null;
        }
        return logger.throwArgumentError("invalid fragment object", "value", value);
    }
    static fromString(value) {
        // Make sure the "returns" is surrounded by a space and all whitespace is exactly one space
        value = value.replace(/\s/g, " ");
        value = value.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ");
        value = value.trim();
        if (value.split(" ")[0] === "event") {
            return EventFragment.fromString(value.substring(5).trim());
        }
        else if (value.split(" ")[0] === "function") {
            return FunctionFragment.fromString(value.substring(8).trim());
        }
        else if (value.split("(")[0].trim() === "constructor") {
            return ConstructorFragment.fromString(value.trim());
        }
        else if (value.split(" ")[0] === "error") {
            return ErrorFragment.fromString(value.substring(5).trim());
        }
        return logger.throwArgumentError("unsupported fragment", "value", value);
    }
    static isFragment(value) {
        return !!(value && value._isFragment);
    }
}
class EventFragment extends Fragment {
    format(format) {
        if (!format) {
            format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
            logger.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
            return JSON.stringify({
                type: "event",
                anonymous: this.anonymous,
                name: this.name,
                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
            });
        }
        let result = "";
        if (format !== FormatTypes.sighash) {
            result += "event ";
        }
        result += this.name + "(" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? ", " : ",") + ") ";
        if (format !== FormatTypes.sighash) {
            if (this.anonymous) {
                result += "anonymous ";
            }
        }
        return result.trim();
    }
    static from(value) {
        if (typeof (value) === "string") {
            return EventFragment.fromString(value);
        }
        return EventFragment.fromObject(value);
    }
    static fromObject(value) {
        if (EventFragment.isEventFragment(value)) {
            return value;
        }
        if (value.type !== "event") {
            logger.throwArgumentError("invalid event object", "value", value);
        }
        const params = {
            name: verifyIdentifier(value.name),
            anonymous: value.anonymous,
            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),
            type: "event"
        };
        return new EventFragment(_constructorGuard, params);
    }
    static fromString(value) {
        let match = value.match(regexParen);
        if (!match) {
            logger.throwArgumentError("invalid event string", "value", value);
        }
        let anonymous = false;
        match[3].split(" ").forEach((modifier) => {
            switch (modifier.trim()) {
                case "anonymous":
                    anonymous = true;
                    break;
                case "":
                    break;
                default:
                    logger.warn("unknown modifier: " + modifier);
            }
        });
        return EventFragment.fromObject({
            name: match[1].trim(),
            anonymous: anonymous,
            inputs: parseParams(match[2], true),
            type: "event"
        });
    }
    static isEventFragment(value) {
        return (value && value._isFragment && value.type === "event");
    }
}
function parseGas(value, params) {
    params.gas = null;
    let comps = value.split("@");
    if (comps.length !== 1) {
        if (comps.length > 2) {
            logger.throwArgumentError("invalid human-readable ABI signature", "value", value);
        }
        if (!comps[1].match(/^[0-9]+$/)) {
            logger.throwArgumentError("invalid human-readable ABI signature gas", "value", value);
        }
        params.gas = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_3__.BigNumber.from(comps[1]);
        return comps[0];
    }
    return value;
}
function parseModifiers(value, params) {
    params.constant = false;
    params.payable = false;
    params.stateMutability = "nonpayable";
    value.split(" ").forEach((modifier) => {
        switch (modifier.trim()) {
            case "constant":
                params.constant = true;
                break;
            case "payable":
                params.payable = true;
                params.stateMutability = "payable";
                break;
            case "nonpayable":
                params.payable = false;
                params.stateMutability = "nonpayable";
                break;
            case "pure":
                params.constant = true;
                params.stateMutability = "pure";
                break;
            case "view":
                params.constant = true;
                params.stateMutability = "view";
                break;
            case "external":
            case "public":
            case "":
                break;
            default:
                console.log("unknown modifier: " + modifier);
        }
    });
}
function verifyState(value) {
    let result = {
        constant: false,
        payable: true,
        stateMutability: "payable"
    };
    if (value.stateMutability != null) {
        result.stateMutability = value.stateMutability;
        // Set (and check things are consistent) the constant property
        result.constant = (result.stateMutability === "view" || result.stateMutability === "pure");
        if (value.constant != null) {
            if ((!!value.constant) !== result.constant) {
                logger.throwArgumentError("cannot have constant function with mutability " + result.stateMutability, "value", value);
            }
        }
        // Set (and check things are consistent) the payable property
        result.payable = (result.stateMutability === "payable");
        if (value.payable != null) {
            if ((!!value.payable) !== result.payable) {
                logger.throwArgumentError("cannot have payable function with mutability " + result.stateMutability, "value", value);
            }
        }
    }
    else if (value.payable != null) {
        result.payable = !!value.payable;
        // If payable we can assume non-constant; otherwise we can't assume
        if (value.constant == null && !result.payable && value.type !== "constructor") {
            logger.throwArgumentError("unable to determine stateMutability", "value", value);
        }
        result.constant = !!value.constant;
        if (result.constant) {
            result.stateMutability = "view";
        }
        else {
            result.stateMutability = (result.payable ? "payable" : "nonpayable");
        }
        if (result.payable && result.constant) {
            logger.throwArgumentError("cannot have constant payable function", "value", value);
        }
    }
    else if (value.constant != null) {
        result.constant = !!value.constant;
        result.payable = !result.constant;
        result.stateMutability = (result.constant ? "view" : "payable");
    }
    else if (value.type !== "constructor") {
        logger.throwArgumentError("unable to determine stateMutability", "value", value);
    }
    return result;
}
class ConstructorFragment extends Fragment {
    format(format) {
        if (!format) {
            format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
            logger.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
            return JSON.stringify({
                type: "constructor",
                stateMutability: ((this.stateMutability !== "nonpayable") ? this.stateMutability : undefined),
                payable: this.payable,
                gas: (this.gas ? this.gas.toNumber() : undefined),
                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
            });
        }
        if (format === FormatTypes.sighash) {
            logger.throwError("cannot format a constructor for sighash", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "format(sighash)"
            });
        }
        let result = "constructor(" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? ", " : ",") + ") ";
        if (this.stateMutability && this.stateMutability !== "nonpayable") {
            result += this.stateMutability + " ";
        }
        return result.trim();
    }
    static from(value) {
        if (typeof (value) === "string") {
            return ConstructorFragment.fromString(value);
        }
        return ConstructorFragment.fromObject(value);
    }
    static fromObject(value) {
        if (ConstructorFragment.isConstructorFragment(value)) {
            return value;
        }
        if (value.type !== "constructor") {
            logger.throwArgumentError("invalid constructor object", "value", value);
        }
        let state = verifyState(value);
        if (state.constant) {
            logger.throwArgumentError("constructor cannot be constant", "value", value);
        }
        const params = {
            name: null,
            type: value.type,
            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),
            payable: state.payable,
            stateMutability: state.stateMutability,
            gas: (value.gas ? _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_3__.BigNumber.from(value.gas) : null)
        };
        return new ConstructorFragment(_constructorGuard, params);
    }
    static fromString(value) {
        let params = { type: "constructor" };
        value = parseGas(value, params);
        let parens = value.match(regexParen);
        if (!parens || parens[1].trim() !== "constructor") {
            logger.throwArgumentError("invalid constructor string", "value", value);
        }
        params.inputs = parseParams(parens[2].trim(), false);
        parseModifiers(parens[3].trim(), params);
        return ConstructorFragment.fromObject(params);
    }
    static isConstructorFragment(value) {
        return (value && value._isFragment && value.type === "constructor");
    }
}
class FunctionFragment extends ConstructorFragment {
    format(format) {
        if (!format) {
            format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
            logger.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
            return JSON.stringify({
                type: "function",
                name: this.name,
                constant: this.constant,
                stateMutability: ((this.stateMutability !== "nonpayable") ? this.stateMutability : undefined),
                payable: this.payable,
                gas: (this.gas ? this.gas.toNumber() : undefined),
                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),
                outputs: this.outputs.map((output) => JSON.parse(output.format(format))),
            });
        }
        let result = "";
        if (format !== FormatTypes.sighash) {
            result += "function ";
        }
        result += this.name + "(" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? ", " : ",") + ") ";
        if (format !== FormatTypes.sighash) {
            if (this.stateMutability) {
                if (this.stateMutability !== "nonpayable") {
                    result += (this.stateMutability + " ");
                }
            }
            else if (this.constant) {
                result += "view ";
            }
            if (this.outputs && this.outputs.length) {
                result += "returns (" + this.outputs.map((output) => output.format(format)).join(", ") + ") ";
            }
            if (this.gas != null) {
                result += "@" + this.gas.toString() + " ";
            }
        }
        return result.trim();
    }
    static from(value) {
        if (typeof (value) === "string") {
            return FunctionFragment.fromString(value);
        }
        return FunctionFragment.fromObject(value);
    }
    static fromObject(value) {
        if (FunctionFragment.isFunctionFragment(value)) {
            return value;
        }
        if (value.type !== "function") {
            logger.throwArgumentError("invalid function object", "value", value);
        }
        let state = verifyState(value);
        const params = {
            type: value.type,
            name: verifyIdentifier(value.name),
            constant: state.constant,
            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),
            outputs: (value.outputs ? value.outputs.map(ParamType.fromObject) : []),
            payable: state.payable,
            stateMutability: state.stateMutability,
            gas: (value.gas ? _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_3__.BigNumber.from(value.gas) : null)
        };
        return new FunctionFragment(_constructorGuard, params);
    }
    static fromString(value) {
        let params = { type: "function" };
        value = parseGas(value, params);
        let comps = value.split(" returns ");
        if (comps.length > 2) {
            logger.throwArgumentError("invalid function string", "value", value);
        }
        let parens = comps[0].match(regexParen);
        if (!parens) {
            logger.throwArgumentError("invalid function signature", "value", value);
        }
        params.name = parens[1].trim();
        if (params.name) {
            verifyIdentifier(params.name);
        }
        params.inputs = parseParams(parens[2], false);
        parseModifiers(parens[3].trim(), params);
        // We have outputs
        if (comps.length > 1) {
            let returns = comps[1].match(regexParen);
            if (returns[1].trim() != "" || returns[3].trim() != "") {
                logger.throwArgumentError("unexpected tokens", "value", value);
            }
            params.outputs = parseParams(returns[2], false);
        }
        else {
            params.outputs = [];
        }
        return FunctionFragment.fromObject(params);
    }
    static isFunctionFragment(value) {
        return (value && value._isFragment && value.type === "function");
    }
}
//export class StructFragment extends Fragment {
//}
function checkForbidden(fragment) {
    const sig = fragment.format();
    if (sig === "Error(string)" || sig === "Panic(uint256)") {
        logger.throwArgumentError(`cannot specify user defined ${sig} error`, "fragment", fragment);
    }
    return fragment;
}
class ErrorFragment extends Fragment {
    format(format) {
        if (!format) {
            format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
            logger.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
            return JSON.stringify({
                type: "error",
                name: this.name,
                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),
            });
        }
        let result = "";
        if (format !== FormatTypes.sighash) {
            result += "error ";
        }
        result += this.name + "(" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? ", " : ",") + ") ";
        return result.trim();
    }
    static from(value) {
        if (typeof (value) === "string") {
            return ErrorFragment.fromString(value);
        }
        return ErrorFragment.fromObject(value);
    }
    static fromObject(value) {
        if (ErrorFragment.isErrorFragment(value)) {
            return value;
        }
        if (value.type !== "error") {
            logger.throwArgumentError("invalid error object", "value", value);
        }
        const params = {
            type: value.type,
            name: verifyIdentifier(value.name),
            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : [])
        };
        return checkForbidden(new ErrorFragment(_constructorGuard, params));
    }
    static fromString(value) {
        let params = { type: "error" };
        let parens = value.match(regexParen);
        if (!parens) {
            logger.throwArgumentError("invalid error signature", "value", value);
        }
        params.name = parens[1].trim();
        if (params.name) {
            verifyIdentifier(params.name);
        }
        params.inputs = parseParams(parens[2], false);
        return checkForbidden(ErrorFragment.fromObject(params));
    }
    static isErrorFragment(value) {
        return (value && value._isFragment && value.type === "error");
    }
}
function verifyType(type) {
    // These need to be transformed to their full description
    if (type.match(/^uint($|[^1-9])/)) {
        type = "uint256" + type.substring(4);
    }
    else if (type.match(/^int($|[^1-9])/)) {
        type = "int256" + type.substring(3);
    }
    // @TODO: more verification
    return type;
}
// See: https://github.com/ethereum/solidity/blob/1f8f1a3db93a548d0555e3e14cfc55a10e25b60e/docs/grammar/SolidityLexer.g4#L234
const regexIdentifier = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
function verifyIdentifier(value) {
    if (!value || !value.match(regexIdentifier)) {
        logger.throwArgumentError(`invalid identifier "${value}"`, "value", value);
    }
    return value;
}
const regexParen = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
function splitNesting(value) {
    value = value.trim();
    let result = [];
    let accum = "";
    let depth = 0;
    for (let offset = 0; offset < value.length; offset++) {
        let c = value[offset];
        if (c === "," && depth === 0) {
            result.push(accum);
            accum = "";
        }
        else {
            accum += c;
            if (c === "(") {
                depth++;
            }
            else if (c === ")") {
                depth--;
                if (depth === -1) {
                    logger.throwArgumentError("unbalanced parenthesis", "value", value);
                }
            }
        }
    }
    if (accum) {
        result.push(accum);
    }
    return result;
}
//# sourceMappingURL=fragments.js.map

/***/ }),

/***/ "../../node_modules/@ethersproject/abi/lib.esm/interface.js":
/*!******************************************************************!*\
  !*** ../../node_modules/@ethersproject/abi/lib.esm/interface.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ErrorDescription": () => (/* binding */ ErrorDescription),
/* harmony export */   "Indexed": () => (/* binding */ Indexed),
/* harmony export */   "Interface": () => (/* binding */ Interface),
/* harmony export */   "LogDescription": () => (/* binding */ LogDescription),
/* harmony export */   "TransactionDescription": () => (/* binding */ TransactionDescription),
/* harmony export */   "checkResultErrors": () => (/* reexport safe */ _coders_abstract_coder__WEBPACK_IMPORTED_MODULE_2__.checkResultErrors)
/* harmony export */ });
/* harmony import */ var _ethersproject_address__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/address */ "../../node_modules/@ethersproject/address/lib.esm/index.js");
/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @ethersproject/bignumber */ "../../node_modules/@ethersproject/bignumber/lib.esm/bignumber.js");
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/bytes */ "../../node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_hash__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ethersproject/hash */ "../../node_modules/@ethersproject/hash/lib.esm/id.js");
/* harmony import */ var _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ethersproject/keccak256 */ "../../node_modules/@ethersproject/keccak256/lib.esm/index.js");
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/properties */ "../../node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _abi_coder__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./abi-coder */ "../../node_modules/@ethersproject/abi/lib.esm/abi-coder.js");
/* harmony import */ var _coders_abstract_coder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./coders/abstract-coder */ "../../node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js");
/* harmony import */ var _fragments__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./fragments */ "../../node_modules/@ethersproject/abi/lib.esm/fragments.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "../../node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "../../node_modules/@ethersproject/abi/lib.esm/_version.js");












const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);

class LogDescription extends _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.Description {
}
class TransactionDescription extends _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.Description {
}
class ErrorDescription extends _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.Description {
}
class Indexed extends _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.Description {
    static isIndexed(value) {
        return !!(value && value._isIndexed);
    }
}
const BuiltinErrors = {
    "0x08c379a0": { signature: "Error(string)", name: "Error", inputs: ["string"], reason: true },
    "0x4e487b71": { signature: "Panic(uint256)", name: "Panic", inputs: ["uint256"] }
};
function wrapAccessError(property, error) {
    const wrap = new Error(`deferred error during ABI decoding triggered accessing ${property}`);
    wrap.error = error;
    return wrap;
}
/*
function checkNames(fragment: Fragment, type: "input" | "output", params: Array<ParamType>): void {
    params.reduce((accum, param) => {
        if (param.name) {
            if (accum[param.name]) {
                logger.throwArgumentError(`duplicate ${ type } parameter ${ JSON.stringify(param.name) } in ${ fragment.format("full") }`, "fragment", fragment);
            }
            accum[param.name] = true;
        }
        return accum;
    }, <{ [ name: string ]: boolean }>{ });
}
*/
class Interface {
    constructor(fragments) {
        let abi = [];
        if (typeof (fragments) === "string") {
            abi = JSON.parse(fragments);
        }
        else {
            abi = fragments;
        }
        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "fragments", abi.map((fragment) => {
            return _fragments__WEBPACK_IMPORTED_MODULE_4__.Fragment.from(fragment);
        }).filter((fragment) => (fragment != null)));
        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "_abiCoder", (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.getStatic)(new.target, "getAbiCoder")());
        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "functions", {});
        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "errors", {});
        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "events", {});
        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "structs", {});
        // Add all fragments by their signature
        this.fragments.forEach((fragment) => {
            let bucket = null;
            switch (fragment.type) {
                case "constructor":
                    if (this.deploy) {
                        logger.warn("duplicate definition - constructor");
                        return;
                    }
                    //checkNames(fragment, "input", fragment.inputs);
                    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "deploy", fragment);
                    return;
                case "function":
                    //checkNames(fragment, "input", fragment.inputs);
                    //checkNames(fragment, "output", (<FunctionFragment>fragment).outputs);
                    bucket = this.functions;
                    break;
                case "event":
                    //checkNames(fragment, "input", fragment.inputs);
                    bucket = this.events;
                    break;
                case "error":
                    bucket = this.errors;
                    break;
                default:
                    return;
            }
            let signature = fragment.format();
            if (bucket[signature]) {
                logger.warn("duplicate definition - " + signature);
                return;
            }
            bucket[signature] = fragment;
        });
        // If we do not have a constructor add a default
        if (!this.deploy) {
            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "deploy", _fragments__WEBPACK_IMPORTED_MODULE_4__.ConstructorFragment.from({
                payable: false,
                type: "constructor"
            }));
        }
        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "_isInterface", true);
    }
    format(format) {
        if (!format) {
            format = _fragments__WEBPACK_IMPORTED_MODULE_4__.FormatTypes.full;
        }
        if (format === _fragments__WEBPACK_IMPORTED_MODULE_4__.FormatTypes.sighash) {
            logger.throwArgumentError("interface does not support formatting sighash", "format", format);
        }
        const abi = this.fragments.map((fragment) => fragment.format(format));
        // We need to re-bundle the JSON fragments a bit
        if (format === _fragments__WEBPACK_IMPORTED_MODULE_4__.FormatTypes.json) {
            return JSON.stringify(abi.map((j) => JSON.parse(j)));
        }
        return abi;
    }
    // Sub-classes can override these to handle other blockchains
    static getAbiCoder() {
        return _abi_coder__WEBPACK_IMPORTED_MODULE_5__.defaultAbiCoder;
    }
    static getAddress(address) {
        return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_6__.getAddress)(address);
    }
    static getSighash(fragment) {
        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexDataSlice)((0,_ethersproject_hash__WEBPACK_IMPORTED_MODULE_8__.id)(fragment.format()), 0, 4);
    }
    static getEventTopic(eventFragment) {
        return (0,_ethersproject_hash__WEBPACK_IMPORTED_MODULE_8__.id)(eventFragment.format());
    }
    // Find a function definition by any means necessary (unless it is ambiguous)
    getFunction(nameOrSignatureOrSighash) {
        if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.isHexString)(nameOrSignatureOrSighash)) {
            for (const name in this.functions) {
                if (nameOrSignatureOrSighash === this.getSighash(name)) {
                    return this.functions[name];
                }
            }
            logger.throwArgumentError("no matching function", "sighash", nameOrSignatureOrSighash);
        }
        // It is a bare name, look up the function (will return null if ambiguous)
        if (nameOrSignatureOrSighash.indexOf("(") === -1) {
            const name = nameOrSignatureOrSighash.trim();
            const matching = Object.keys(this.functions).filter((f) => (f.split("(" /* fix:) */)[0] === name));
            if (matching.length === 0) {
                logger.throwArgumentError("no matching function", "name", name);
            }
            else if (matching.length > 1) {
                logger.throwArgumentError("multiple matching functions", "name", name);
            }
            return this.functions[matching[0]];
        }
        // Normalize the signature and lookup the function
        const result = this.functions[_fragments__WEBPACK_IMPORTED_MODULE_4__.FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
        if (!result) {
            logger.throwArgumentError("no matching function", "signature", nameOrSignatureOrSighash);
        }
        return result;
    }
    // Find an event definition by any means necessary (unless it is ambiguous)
    getEvent(nameOrSignatureOrTopic) {
        if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.isHexString)(nameOrSignatureOrTopic)) {
            const topichash = nameOrSignatureOrTopic.toLowerCase();
            for (const name in this.events) {
                if (topichash === this.getEventTopic(name)) {
                    return this.events[name];
                }
            }
            logger.throwArgumentError("no matching event", "topichash", topichash);
        }
        // It is a bare name, look up the function (will return null if ambiguous)
        if (nameOrSignatureOrTopic.indexOf("(") === -1) {
            const name = nameOrSignatureOrTopic.trim();
            const matching = Object.keys(this.events).filter((f) => (f.split("(" /* fix:) */)[0] === name));
            if (matching.length === 0) {
                logger.throwArgumentError("no matching event", "name", name);
            }
            else if (matching.length > 1) {
                logger.throwArgumentError("multiple matching events", "name", name);
            }
            return this.events[matching[0]];
        }
        // Normalize the signature and lookup the function
        const result = this.events[_fragments__WEBPACK_IMPORTED_MODULE_4__.EventFragment.fromString(nameOrSignatureOrTopic).format()];
        if (!result) {
            logger.throwArgumentError("no matching event", "signature", nameOrSignatureOrTopic);
        }
        return result;
    }
    // Find a function definition by any means necessary (unless it is ambiguous)
    getError(nameOrSignatureOrSighash) {
        if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.isHexString)(nameOrSignatureOrSighash)) {
            const getSighash = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.getStatic)(this.constructor, "getSighash");
            for (const name in this.errors) {
                const error = this.errors[name];
                if (nameOrSignatureOrSighash === getSighash(error)) {
                    return this.errors[name];
                }
            }
            logger.throwArgumentError("no matching error", "sighash", nameOrSignatureOrSighash);
        }
        // It is a bare name, look up the function (will return null if ambiguous)
        if (nameOrSignatureOrSighash.indexOf("(") === -1) {
            const name = nameOrSignatureOrSighash.trim();
            const matching = Object.keys(this.errors).filter((f) => (f.split("(" /* fix:) */)[0] === name));
            if (matching.length === 0) {
                logger.throwArgumentError("no matching error", "name", name);
            }
            else if (matching.length > 1) {
                logger.throwArgumentError("multiple matching errors", "name", name);
            }
            return this.errors[matching[0]];
        }
        // Normalize the signature and lookup the function
        const result = this.errors[_fragments__WEBPACK_IMPORTED_MODULE_4__.FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
        if (!result) {
            logger.throwArgumentError("no matching error", "signature", nameOrSignatureOrSighash);
        }
        return result;
    }
    // Get the sighash (the bytes4 selector) used by Solidity to identify a function
    getSighash(fragment) {
        if (typeof (fragment) === "string") {
            try {
                fragment = this.getFunction(fragment);
            }
            catch (error) {
                try {
                    fragment = this.getError(fragment);
                }
                catch (_) {
                    throw error;
                }
            }
        }
        return (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.getStatic)(this.constructor, "getSighash")(fragment);
    }
    // Get the topic (the bytes32 hash) used by Solidity to identify an event
    getEventTopic(eventFragment) {
        if (typeof (eventFragment) === "string") {
            eventFragment = this.getEvent(eventFragment);
        }
        return (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.getStatic)(this.constructor, "getEventTopic")(eventFragment);
    }
    _decodeParams(params, data) {
        return this._abiCoder.decode(params, data);
    }
    _encodeParams(params, values) {
        return this._abiCoder.encode(params, values);
    }
    encodeDeploy(values) {
        return this._encodeParams(this.deploy.inputs, values || []);
    }
    decodeErrorResult(fragment, data) {
        if (typeof (fragment) === "string") {
            fragment = this.getError(fragment);
        }
        const bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.arrayify)(data);
        if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)(bytes.slice(0, 4)) !== this.getSighash(fragment)) {
            logger.throwArgumentError(`data signature does not match error ${fragment.name}.`, "data", (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)(bytes));
        }
        return this._decodeParams(fragment.inputs, bytes.slice(4));
    }
    encodeErrorResult(fragment, values) {
        if (typeof (fragment) === "string") {
            fragment = this.getError(fragment);
        }
        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.concat)([
            this.getSighash(fragment),
            this._encodeParams(fragment.inputs, values || [])
        ]));
    }
    // Decode the data for a function call (e.g. tx.data)
    decodeFunctionData(functionFragment, data) {
        if (typeof (functionFragment) === "string") {
            functionFragment = this.getFunction(functionFragment);
        }
        const bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.arrayify)(data);
        if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)(bytes.slice(0, 4)) !== this.getSighash(functionFragment)) {
            logger.throwArgumentError(`data signature does not match function ${functionFragment.name}.`, "data", (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)(bytes));
        }
        return this._decodeParams(functionFragment.inputs, bytes.slice(4));
    }
    // Encode the data for a function call (e.g. tx.data)
    encodeFunctionData(functionFragment, values) {
        if (typeof (functionFragment) === "string") {
            functionFragment = this.getFunction(functionFragment);
        }
        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.concat)([
            this.getSighash(functionFragment),
            this._encodeParams(functionFragment.inputs, values || [])
        ]));
    }
    // Decode the result from a function call (e.g. from eth_call)
    decodeFunctionResult(functionFragment, data) {
        if (typeof (functionFragment) === "string") {
            functionFragment = this.getFunction(functionFragment);
        }
        let bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.arrayify)(data);
        let reason = null;
        let message = "";
        let errorArgs = null;
        let errorName = null;
        let errorSignature = null;
        switch (bytes.length % this._abiCoder._getWordSize()) {
            case 0:
                try {
                    return this._abiCoder.decode(functionFragment.outputs, bytes);
                }
                catch (error) { }
                break;
            case 4: {
                const selector = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)(bytes.slice(0, 4));
                const builtin = BuiltinErrors[selector];
                if (builtin) {
                    errorArgs = this._abiCoder.decode(builtin.inputs, bytes.slice(4));
                    errorName = builtin.name;
                    errorSignature = builtin.signature;
                    if (builtin.reason) {
                        reason = errorArgs[0];
                    }
                    if (errorName === "Error") {
                        message = `; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(errorArgs[0])}`;
                    }
                    else if (errorName === "Panic") {
                        message = `; VM Exception while processing transaction: reverted with panic code ${errorArgs[0]}`;
                    }
                }
                else {
                    try {
                        const error = this.getError(selector);
                        errorArgs = this._abiCoder.decode(error.inputs, bytes.slice(4));
                        errorName = error.name;
                        errorSignature = error.format();
                    }
                    catch (error) { }
                }
                break;
            }
        }
        return logger.throwError("call revert exception" + message, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.CALL_EXCEPTION, {
            method: functionFragment.format(),
            data: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)(data), errorArgs, errorName, errorSignature, reason
        });
    }
    // Encode the result for a function call (e.g. for eth_call)
    encodeFunctionResult(functionFragment, values) {
        if (typeof (functionFragment) === "string") {
            functionFragment = this.getFunction(functionFragment);
        }
        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)(this._abiCoder.encode(functionFragment.outputs, values || []));
    }
    // Create the filter for the event with search criteria (e.g. for eth_filterLog)
    encodeFilterTopics(eventFragment, values) {
        if (typeof (eventFragment) === "string") {
            eventFragment = this.getEvent(eventFragment);
        }
        if (values.length > eventFragment.inputs.length) {
            logger.throwError("too many arguments for " + eventFragment.format(), _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNEXPECTED_ARGUMENT, {
                argument: "values",
                value: values
            });
        }
        let topics = [];
        if (!eventFragment.anonymous) {
            topics.push(this.getEventTopic(eventFragment));
        }
        const encodeTopic = (param, value) => {
            if (param.type === "string") {
                return (0,_ethersproject_hash__WEBPACK_IMPORTED_MODULE_8__.id)(value);
            }
            else if (param.type === "bytes") {
                return (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_9__.keccak256)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)(value));
            }
            if (param.type === "bool" && typeof (value) === "boolean") {
                value = (value ? "0x01" : "0x00");
            }
            if (param.type.match(/^u?int/)) {
                value = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_10__.BigNumber.from(value).toHexString();
            }
            // Check addresses are valid
            if (param.type === "address") {
                this._abiCoder.encode(["address"], [value]);
            }
            return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexZeroPad)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)(value), 32);
        };
        values.forEach((value, index) => {
            let param = eventFragment.inputs[index];
            if (!param.indexed) {
                if (value != null) {
                    logger.throwArgumentError("cannot filter non-indexed parameters; must be null", ("contract." + param.name), value);
                }
                return;
            }
            if (value == null) {
                topics.push(null);
            }
            else if (param.baseType === "array" || param.baseType === "tuple") {
                logger.throwArgumentError("filtering with tuples or arrays not supported", ("contract." + param.name), value);
            }
            else if (Array.isArray(value)) {
                topics.push(value.map((value) => encodeTopic(param, value)));
            }
            else {
                topics.push(encodeTopic(param, value));
            }
        });
        // Trim off trailing nulls
        while (topics.length && topics[topics.length - 1] === null) {
            topics.pop();
        }
        return topics;
    }
    encodeEventLog(eventFragment, values) {
        if (typeof (eventFragment) === "string") {
            eventFragment = this.getEvent(eventFragment);
        }
        const topics = [];
        const dataTypes = [];
        const dataValues = [];
        if (!eventFragment.anonymous) {
            topics.push(this.getEventTopic(eventFragment));
        }
        if (values.length !== eventFragment.inputs.length) {
            logger.throwArgumentError("event arguments/values mismatch", "values", values);
        }
        eventFragment.inputs.forEach((param, index) => {
            const value = values[index];
            if (param.indexed) {
                if (param.type === "string") {
                    topics.push((0,_ethersproject_hash__WEBPACK_IMPORTED_MODULE_8__.id)(value));
                }
                else if (param.type === "bytes") {
                    topics.push((0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_9__.keccak256)(value));
                }
                else if (param.baseType === "tuple" || param.baseType === "array") {
                    // @TODO
                    throw new Error("not implemented");
                }
                else {
                    topics.push(this._abiCoder.encode([param.type], [value]));
                }
            }
            else {
                dataTypes.push(param);
                dataValues.push(value);
            }
        });
        return {
            data: this._abiCoder.encode(dataTypes, dataValues),
            topics: topics
        };
    }
    // Decode a filter for the event and the search criteria
    decodeEventLog(eventFragment, data, topics) {
        if (typeof (eventFragment) === "string") {
            eventFragment = this.getEvent(eventFragment);
        }
        if (topics != null && !eventFragment.anonymous) {
            let topicHash = this.getEventTopic(eventFragment);
            if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.isHexString)(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {
                logger.throwError("fragment/topic mismatch", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INVALID_ARGUMENT, { argument: "topics[0]", expected: topicHash, value: topics[0] });
            }
            topics = topics.slice(1);
        }
        let indexed = [];
        let nonIndexed = [];
        let dynamic = [];
        eventFragment.inputs.forEach((param, index) => {
            if (param.indexed) {
                if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
                    indexed.push(_fragments__WEBPACK_IMPORTED_MODULE_4__.ParamType.fromObject({ type: "bytes32", name: param.name }));
                    dynamic.push(true);
                }
                else {
                    indexed.push(param);
                    dynamic.push(false);
                }
            }
            else {
                nonIndexed.push(param);
                dynamic.push(false);
            }
        });
        let resultIndexed = (topics != null) ? this._abiCoder.decode(indexed, (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.concat)(topics)) : null;
        let resultNonIndexed = this._abiCoder.decode(nonIndexed, data, true);
        let result = [];
        let nonIndexedIndex = 0, indexedIndex = 0;
        eventFragment.inputs.forEach((param, index) => {
            if (param.indexed) {
                if (resultIndexed == null) {
                    result[index] = new Indexed({ _isIndexed: true, hash: null });
                }
                else if (dynamic[index]) {
                    result[index] = new Indexed({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });
                }
                else {
                    try {
                        result[index] = resultIndexed[indexedIndex++];
                    }
                    catch (error) {
                        result[index] = error;
                    }
                }
            }
            else {
                try {
                    result[index] = resultNonIndexed[nonIndexedIndex++];
                }
                catch (error) {
                    result[index] = error;
                }
            }
            // Add the keyword argument if named and safe
            if (param.name && result[param.name] == null) {
                const value = result[index];
                // Make error named values throw on access
                if (value instanceof Error) {
                    Object.defineProperty(result, param.name, {
                        enumerable: true,
                        get: () => { throw wrapAccessError(`property ${JSON.stringify(param.name)}`, value); }
                    });
                }
                else {
                    result[param.name] = value;
                }
            }
        });
        // Make all error indexed values throw on access
        for (let i = 0; i < result.length; i++) {
            const value = result[i];
            if (value instanceof Error) {
                Object.defineProperty(result, i, {
                    enumerable: true,
                    get: () => { throw wrapAccessError(`index ${i}`, value); }
                });
            }
        }
        return Object.freeze(result);
    }
    // Given a transaction, find the matching function fragment (if any) and
    // determine all its properties and call parameters
    parseTransaction(tx) {
        let fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase());
        if (!fragment) {
            return null;
        }
        return new TransactionDescription({
            args: this._abiCoder.decode(fragment.inputs, "0x" + tx.data.substring(10)),
            functionFragment: fragment,
            name: fragment.name,
            signature: fragment.format(),
            sighash: this.getSighash(fragment),
            value: _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_10__.BigNumber.from(tx.value || "0"),
        });
    }
    // @TODO
    //parseCallResult(data: BytesLike): ??
    // Given an event log, find the matching event fragment (if any) and
    // determine all its properties and values
    parseLog(log) {
        let fragment = this.getEvent(log.topics[0]);
        if (!fragment || fragment.anonymous) {
            return null;
        }
        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?
        //        Probably not, because just because it is the only event in the ABI does
        //        not mean we have the full ABI; maybe just a fragment?
        return new LogDescription({
            eventFragment: fragment,
            name: fragment.name,
            signature: fragment.format(),
            topic: this.getEventTopic(fragment),
            args: this.decodeEventLog(fragment, log.data, log.topics)
        });
    }
    parseError(data) {
        const hexData = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)(data);
        let fragment = this.getError(hexData.substring(0, 10).toLowerCase());
        if (!fragment) {
            return null;
        }
        return new ErrorDescription({
            args: this._abiCoder.decode(fragment.inputs, "0x" + hexData.substring(10)),
            errorFragment: fragment,
            name: fragment.name,
            signature: fragment.format(),
            sighash: this.getSighash(fragment),
        });
    }
    /*
    static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {
        if (Interface.isInterface(value)) {
            return value;
        }
        if (typeof(value) === "string") {
            return new Interface(JSON.parse(value));
        }
        return new Interface(value);
    }
    */
    static isInterface(value) {
        return !!(value && value._isInterface);
    }
}
//# sourceMappingURL=interface.js.map

/***/ }),

/***/ "../../node_modules/@ethersproject/address/lib.esm/_version.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/@ethersproject/address/lib.esm/_version.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "version": () => (/* binding */ version)
/* harmony export */ });
const version = "address/5.7.0";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ "../../node_modules/@ethersproject/address/lib.esm/index.js":
/*!******************************************************************!*\
  !*** ../../node_modules/@ethersproject/address/lib.esm/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getAddress": () => (/* binding */ getAddress),
/* harmony export */   "getContractAddress": () => (/* binding */ getContractAddress),
/* harmony export */   "getCreate2Address": () => (/* binding */ getCreate2Address),
/* harmony export */   "getIcapAddress": () => (/* binding */ getIcapAddress),
/* harmony export */   "isAddress": () => (/* binding */ isAddress)
/* harmony export */ });
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bytes */ "../../node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/bignumber */ "../../node_modules/@ethersproject/bignumber/lib.esm/bignumber.js");
/* harmony import */ var _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/keccak256 */ "../../node_modules/@ethersproject/keccak256/lib.esm/index.js");
/* harmony import */ var _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/rlp */ "../../node_modules/@ethersproject/rlp/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "../../node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "../../node_modules/@ethersproject/address/lib.esm/_version.js");







const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);
function getChecksumAddress(address) {
    if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.isHexString)(address, 20)) {
        logger.throwArgumentError("invalid address", "address", address);
    }
    address = address.toLowerCase();
    const chars = address.substring(2).split("");
    const expanded = new Uint8Array(40);
    for (let i = 0; i < 40; i++) {
        expanded[i] = chars[i].charCodeAt(0);
    }
    const hashed = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.arrayify)((0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_3__.keccak256)(expanded));
    for (let i = 0; i < 40; i += 2) {
        if ((hashed[i >> 1] >> 4) >= 8) {
            chars[i] = chars[i].toUpperCase();
        }
        if ((hashed[i >> 1] & 0x0f) >= 8) {
            chars[i + 1] = chars[i + 1].toUpperCase();
        }
    }
    return "0x" + chars.join("");
}
// Shims for environments that are missing some required constants and functions
const MAX_SAFE_INTEGER = 0x1fffffffffffff;
function log10(x) {
    if (Math.log10) {
        return Math.log10(x);
    }
    return Math.log(x) / Math.LN10;
}
// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number
// Create lookup table
const ibanLookup = {};
for (let i = 0; i < 10; i++) {
    ibanLookup[String(i)] = String(i);
}
for (let i = 0; i < 26; i++) {
    ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);
}
// How many decimal digits can we process? (for 64-bit float, this is 15)
const safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));
function ibanChecksum(address) {
    address = address.toUpperCase();
    address = address.substring(4) + address.substring(0, 2) + "00";
    let expanded = address.split("").map((c) => { return ibanLookup[c]; }).join("");
    // Javascript can handle integers safely up to 15 (decimal) digits
    while (expanded.length >= safeDigits) {
        let block = expanded.substring(0, safeDigits);
        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
    }
    let checksum = String(98 - (parseInt(expanded, 10) % 97));
    while (checksum.length < 2) {
        checksum = "0" + checksum;
    }
    return checksum;
}
;
function getAddress(address) {
    let result = null;
    if (typeof (address) !== "string") {
        logger.throwArgumentError("invalid address", "address", address);
    }
    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
        // Missing the 0x prefix
        if (address.substring(0, 2) !== "0x") {
            address = "0x" + address;
        }
        result = getChecksumAddress(address);
        // It is a checksummed address with a bad checksum
        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
            logger.throwArgumentError("bad address checksum", "address", address);
        }
        // Maybe ICAP? (we only support direct mode)
    }
    else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
        // It is an ICAP address with a bad checksum
        if (address.substring(2, 4) !== ibanChecksum(address)) {
            logger.throwArgumentError("bad icap checksum", "address", address);
        }
        result = (0,_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__._base36To16)(address.substring(4));
        while (result.length < 40) {
            result = "0" + result;
        }
        result = getChecksumAddress("0x" + result);
    }
    else {
        logger.throwArgumentError("invalid address", "address", address);
    }
    return result;
}
function isAddress(address) {
    try {
        getAddress(address);
        return true;
    }
    catch (error) { }
    return false;
}
function getIcapAddress(address) {
    let base36 = (0,_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__._base16To36)(getAddress(address).substring(2)).toUpperCase();
    while (base36.length < 30) {
        base36 = "0" + base36;
    }
    return "XE" + ibanChecksum("XE00" + base36) + base36;
}
// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed
function getContractAddress(transaction) {
    let from = null;
    try {
        from = getAddress(transaction.from);
    }
    catch (error) {
        logger.throwArgumentError("missing from address", "transaction", transaction);
    }
    const nonce = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.stripZeros)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.arrayify)(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(transaction.nonce).toHexString()));
    return getAddress((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexDataSlice)((0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_3__.keccak256)((0,_ethersproject_rlp__WEBPACK_IMPORTED_MODULE_5__.encode)([from, nonce])), 12));
}
function getCreate2Address(from, salt, initCodeHash) {
    if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexDataLength)(salt) !== 32) {
        logger.throwArgumentError("salt must be 32 bytes", "salt", salt);
    }
    if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexDataLength)(initCodeHash) !== 32) {
        logger.throwArgumentError("initCodeHash must be 32 bytes", "initCodeHash", initCodeHash);
    }
    return getAddress((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexDataSlice)((0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_3__.keccak256)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.concat)(["0xff", getAddress(from), salt, initCodeHash])), 12));
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/@ethersproject/bignumber/lib.esm/_version.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/@ethersproject/bignumber/lib.esm/_version.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "version": () => (/* binding */ version)
/* harmony export */ });
const version = "bignumber/5.7.0";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ "../../node_modules/@ethersproject/bignumber/lib.esm/bignumber.js":
/*!************************************************************************!*\
  !*** ../../node_modules/@ethersproject/bignumber/lib.esm/bignumber.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BigNumber": () => (/* binding */ BigNumber),
/* harmony export */   "_base16To36": () => (/* binding */ _base16To36),
/* harmony export */   "_base36To16": () => (/* binding */ _base36To16),
/* harmony export */   "isBigNumberish": () => (/* binding */ isBigNumberish)
/* harmony export */ });
/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bn.js */ "../../node_modules/bn.js/lib/bn.js");
/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(bn_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/bytes */ "../../node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/logger */ "../../node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_version */ "../../node_modules/@ethersproject/bignumber/lib.esm/_version.js");

/**
 *  BigNumber
 *
 *  A wrapper around the BN.js object. We use the BN.js library
 *  because it is used by elliptic, so it is required regardless.
 *
 */

var BN = (bn_js__WEBPACK_IMPORTED_MODULE_0___default().BN);



const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger(_version__WEBPACK_IMPORTED_MODULE_2__.version);
const _constructorGuard = {};
const MAX_SAFE = 0x1fffffffffffff;
function isBigNumberish(value) {
    return (value != null) && (BigNumber.isBigNumber(value) ||
        (typeof (value) === "number" && (value % 1) === 0) ||
        (typeof (value) === "string" && !!value.match(/^-?[0-9]+$/)) ||
        (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(value) ||
        (typeof (value) === "bigint") ||
        (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isBytes)(value));
}
// Only warn about passing 10 into radix once
let _warnedToStringRadix = false;
class BigNumber {
    constructor(constructorGuard, hex) {
        if (constructorGuard !== _constructorGuard) {
            logger.throwError("cannot call constructor directly; use BigNumber.from", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "new (BigNumber)"
            });
        }
        this._hex = hex;
        this._isBigNumber = true;
        Object.freeze(this);
    }
    fromTwos(value) {
        return toBigNumber(toBN(this).fromTwos(value));
    }
    toTwos(value) {
        return toBigNumber(toBN(this).toTwos(value));
    }
    abs() {
        if (this._hex[0] === "-") {
            return BigNumber.from(this._hex.substring(1));
        }
        return this;
    }
    add(other) {
        return toBigNumber(toBN(this).add(toBN(other)));
    }
    sub(other) {
        return toBigNumber(toBN(this).sub(toBN(other)));
    }
    div(other) {
        const o = BigNumber.from(other);
        if (o.isZero()) {
            throwFault("division-by-zero", "div");
        }
        return toBigNumber(toBN(this).div(toBN(other)));
    }
    mul(other) {
        return toBigNumber(toBN(this).mul(toBN(other)));
    }
    mod(other) {
        const value = toBN(other);
        if (value.isNeg()) {
            throwFault("division-by-zero", "mod");
        }
        return toBigNumber(toBN(this).umod(value));
    }
    pow(other) {
        const value = toBN(other);
        if (value.isNeg()) {
            throwFault("negative-power", "pow");
        }
        return toBigNumber(toBN(this).pow(value));
    }
    and(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
            throwFault("unbound-bitwise-result", "and");
        }
        return toBigNumber(toBN(this).and(value));
    }
    or(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
            throwFault("unbound-bitwise-result", "or");
        }
        return toBigNumber(toBN(this).or(value));
    }
    xor(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
            throwFault("unbound-bitwise-result", "xor");
        }
        return toBigNumber(toBN(this).xor(value));
    }
    mask(value) {
        if (this.isNegative() || value < 0) {
            throwFault("negative-width", "mask");
        }
        return toBigNumber(toBN(this).maskn(value));
    }
    shl(value) {
        if (this.isNegative() || value < 0) {
            throwFault("negative-width", "shl");
        }
        return toBigNumber(toBN(this).shln(value));
    }
    shr(value) {
        if (this.isNegative() || value < 0) {
            throwFault("negative-width", "shr");
        }
        return toBigNumber(toBN(this).shrn(value));
    }
    eq(other) {
        return toBN(this).eq(toBN(other));
    }
    lt(other) {
        return toBN(this).lt(toBN(other));
    }
    lte(other) {
        return toBN(this).lte(toBN(other));
    }
    gt(other) {
        return toBN(this).gt(toBN(other));
    }
    gte(other) {
        return toBN(this).gte(toBN(other));
    }
    isNegative() {
        return (this._hex[0] === "-");
    }
    isZero() {
        return toBN(this).isZero();
    }
    toNumber() {
        try {
            return toBN(this).toNumber();
        }
        catch (error) {
            throwFault("overflow", "toNumber", this.toString());
        }
        return null;
    }
    toBigInt() {
        try {
            return BigInt(this.toString());
        }
        catch (e) { }
        return logger.throwError("this platform does not support BigInt", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNSUPPORTED_OPERATION, {
            value: this.toString()
        });
    }
    toString() {
        // Lots of people expect this, which we do not support, so check (See: #889)
        if (arguments.length > 0) {
            if (arguments[0] === 10) {
                if (!_warnedToStringRadix) {
                    _warnedToStringRadix = true;
                    logger.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
                }
            }
            else if (arguments[0] === 16) {
                logger.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNEXPECTED_ARGUMENT, {});
            }
            else {
                logger.throwError("BigNumber.toString does not accept parameters", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNEXPECTED_ARGUMENT, {});
            }
        }
        return toBN(this).toString(10);
    }
    toHexString() {
        return this._hex;
    }
    toJSON(key) {
        return { type: "BigNumber", hex: this.toHexString() };
    }
    static from(value) {
        if (value instanceof BigNumber) {
            return value;
        }
        if (typeof (value) === "string") {
            if (value.match(/^-?0x[0-9a-f]+$/i)) {
                return new BigNumber(_constructorGuard, toHex(value));
            }
            if (value.match(/^-?[0-9]+$/)) {
                return new BigNumber(_constructorGuard, toHex(new BN(value)));
            }
            return logger.throwArgumentError("invalid BigNumber string", "value", value);
        }
        if (typeof (value) === "number") {
            if (value % 1) {
                throwFault("underflow", "BigNumber.from", value);
            }
            if (value >= MAX_SAFE || value <= -MAX_SAFE) {
                throwFault("overflow", "BigNumber.from", value);
            }
            return BigNumber.from(String(value));
        }
        const anyValue = value;
        if (typeof (anyValue) === "bigint") {
            return BigNumber.from(anyValue.toString());
        }
        if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isBytes)(anyValue)) {
            return BigNumber.from((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(anyValue));
        }
        if (anyValue) {
            // Hexable interface (takes priority)
            if (anyValue.toHexString) {
                const hex = anyValue.toHexString();
                if (typeof (hex) === "string") {
                    return BigNumber.from(hex);
                }
            }
            else {
                // For now, handle legacy JSON-ified values (goes away in v6)
                let hex = anyValue._hex;
                // New-form JSON
                if (hex == null && anyValue.type === "BigNumber") {
                    hex = anyValue.hex;
                }
                if (typeof (hex) === "string") {
                    if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(hex) || (hex[0] === "-" && (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(hex.substring(1)))) {
                        return BigNumber.from(hex);
                    }
                }
            }
        }
        return logger.throwArgumentError("invalid BigNumber value", "value", value);
    }
    static isBigNumber(value) {
        return !!(value && value._isBigNumber);
    }
}
// Normalize the hex string
function toHex(value) {
    // For BN, call on the hex string
    if (typeof (value) !== "string") {
        return toHex(value.toString(16));
    }
    // If negative, prepend the negative sign to the normalized positive value
    if (value[0] === "-") {
        // Strip off the negative sign
        value = value.substring(1);
        // Cannot have multiple negative signs (e.g. "--0x04")
        if (value[0] === "-") {
            logger.throwArgumentError("invalid hex", "value", value);
        }
        // Call toHex on the positive component
        value = toHex(value);
        // Do not allow "-0x00"
        if (value === "0x00") {
            return value;
        }
        // Negate the value
        return "-" + value;
    }
    // Add a "0x" prefix if missing
    if (value.substring(0, 2) !== "0x") {
        value = "0x" + value;
    }
    // Normalize zero
    if (value === "0x") {
        return "0x00";
    }
    // Make the string even length
    if (value.length % 2) {
        value = "0x0" + value.substring(2);
    }
    // Trim to smallest even-length string
    while (value.length > 4 && value.substring(0, 4) === "0x00") {
        value = "0x" + value.substring(4);
    }
    return value;
}
function toBigNumber(value) {
    return BigNumber.from(toHex(value));
}
function toBN(value) {
    const hex = BigNumber.from(value).toHexString();
    if (hex[0] === "-") {
        return (new BN("-" + hex.substring(3), 16));
    }
    return new BN(hex.substring(2), 16);
}
function throwFault(fault, operation, value) {
    const params = { fault: fault, operation: operation };
    if (value != null) {
        params.value = value;
    }
    return logger.throwError(fault, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.NUMERIC_FAULT, params);
}
// value should have no prefix
function _base36To16(value) {
    return (new BN(value, 36)).toString(16);
}
// value should have no prefix
function _base16To36(value) {
    return (new BN(value, 16)).toString(36);
}
//# sourceMappingURL=bignumber.js.map

/***/ }),

/***/ "../../node_modules/@ethersproject/bytes/lib.esm/_version.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/@ethersproject/bytes/lib.esm/_version.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "version": () => (/* binding */ version)
/* harmony export */ });
const version = "bytes/5.7.0";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ "../../node_modules/@ethersproject/bytes/lib.esm/index.js":
/*!****************************************************************!*\
  !*** ../../node_modules/@ethersproject/bytes/lib.esm/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "arrayify": () => (/* binding */ arrayify),
/* harmony export */   "concat": () => (/* binding */ concat),
/* harmony export */   "hexConcat": () => (/* binding */ hexConcat),
/* harmony export */   "hexDataLength": () => (/* binding */ hexDataLength),
/* harmony export */   "hexDataSlice": () => (/* binding */ hexDataSlice),
/* harmony export */   "hexStripZeros": () => (/* binding */ hexStripZeros),
/* harmony export */   "hexValue": () => (/* binding */ hexValue),
/* harmony export */   "hexZeroPad": () => (/* binding */ hexZeroPad),
/* harmony export */   "hexlify": () => (/* binding */ hexlify),
/* harmony export */   "isBytes": () => (/* binding */ isBytes),
/* harmony export */   "isBytesLike": () => (/* binding */ isBytesLike),
/* harmony export */   "isHexString": () => (/* binding */ isHexString),
/* harmony export */   "joinSignature": () => (/* binding */ joinSignature),
/* harmony export */   "splitSignature": () => (/* binding */ splitSignature),
/* harmony export */   "stripZeros": () => (/* binding */ stripZeros),
/* harmony export */   "zeroPad": () => (/* binding */ zeroPad)
/* harmony export */ });
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "../../node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "../../node_modules/@ethersproject/bytes/lib.esm/_version.js");



const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);
///////////////////////////////
function isHexable(value) {
    return !!(value.toHexString);
}
function addSlice(array) {
    if (array.slice) {
        return array;
    }
    array.slice = function () {
        const args = Array.prototype.slice.call(arguments);
        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
    };
    return array;
}
function isBytesLike(value) {
    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));
}
function isInteger(value) {
    return (typeof (value) === "number" && value == value && (value % 1) === 0);
}
function isBytes(value) {
    if (value == null) {
        return false;
    }
    if (value.constructor === Uint8Array) {
        return true;
    }
    if (typeof (value) === "string") {
        return false;
    }
    if (!isInteger(value.length) || value.length < 0) {
        return false;
    }
    for (let i = 0; i < value.length; i++) {
        const v = value[i];
        if (!isInteger(v) || v < 0 || v >= 256) {
            return false;
        }
    }
    return true;
}
function arrayify(value, options) {
    if (!options) {
        options = {};
    }
    if (typeof (value) === "number") {
        logger.checkSafeUint53(value, "invalid arrayify value");
        const result = [];
        while (value) {
            result.unshift(value & 0xff);
            value = parseInt(String(value / 256));
        }
        if (result.length === 0) {
            result.push(0);
        }
        return addSlice(new Uint8Array(result));
    }
    if (options.allowMissingPrefix && typeof (value) === "string" && value.substring(0, 2) !== "0x") {
        value = "0x" + value;
    }
    if (isHexable(value)) {
        value = value.toHexString();
    }
    if (isHexString(value)) {
        let hex = value.substring(2);
        if (hex.length % 2) {
            if (options.hexPad === "left") {
                hex = "0" + hex;
            }
            else if (options.hexPad === "right") {
                hex += "0";
            }
            else {
                logger.throwArgumentError("hex data is odd-length", "value", value);
            }
        }
        const result = [];
        for (let i = 0; i < hex.length; i += 2) {
            result.push(parseInt(hex.substring(i, i + 2), 16));
        }
        return addSlice(new Uint8Array(result));
    }
    if (isBytes(value)) {
        return addSlice(new Uint8Array(value));
    }
    return logger.throwArgumentError("invalid arrayify value", "value", value);
}
function concat(items) {
    const objects = items.map(item => arrayify(item));
    const length = objects.reduce((accum, item) => (accum + item.length), 0);
    const result = new Uint8Array(length);
    objects.reduce((offset, object) => {
        result.set(object, offset);
        return offset + object.length;
    }, 0);
    return addSlice(result);
}
function stripZeros(value) {
    let result = arrayify(value);
    if (result.length === 0) {
        return result;
    }
    // Find the first non-zero entry
    let start = 0;
    while (start < result.length && result[start] === 0) {
        start++;
    }
    // If we started with zeros, strip them
    if (start) {
        result = result.slice(start);
    }
    return result;
}
function zeroPad(value, length) {
    value = arrayify(value);
    if (value.length > length) {
        logger.throwArgumentError("value out of range", "value", arguments[0]);
    }
    const result = new Uint8Array(length);
    result.set(value, length - value.length);
    return addSlice(result);
}
function isHexString(value, length) {
    if (typeof (value) !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
        return false;
    }
    if (length && value.length !== 2 + 2 * length) {
        return false;
    }
    return true;
}
const HexCharacters = "0123456789abcdef";
function hexlify(value, options) {
    if (!options) {
        options = {};
    }
    if (typeof (value) === "number") {
        logger.checkSafeUint53(value, "invalid hexlify value");
        let hex = "";
        while (value) {
            hex = HexCharacters[value & 0xf] + hex;
            value = Math.floor(value / 16);
        }
        if (hex.length) {
            if (hex.length % 2) {
                hex = "0" + hex;
            }
            return "0x" + hex;
        }
        return "0x00";
    }
    if (typeof (value) === "bigint") {
        value = value.toString(16);
        if (value.length % 2) {
            return ("0x0" + value);
        }
        return "0x" + value;
    }
    if (options.allowMissingPrefix && typeof (value) === "string" && value.substring(0, 2) !== "0x") {
        value = "0x" + value;
    }
    if (isHexable(value)) {
        return value.toHexString();
    }
    if (isHexString(value)) {
        if (value.length % 2) {
            if (options.hexPad === "left") {
                value = "0x0" + value.substring(2);
            }
            else if (options.hexPad === "right") {
                value += "0";
            }
            else {
                logger.throwArgumentError("hex data is odd-length", "value", value);
            }
        }
        return value.toLowerCase();
    }
    if (isBytes(value)) {
        let result = "0x";
        for (let i = 0; i < value.length; i++) {
            let v = value[i];
            result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];
        }
        return result;
    }
    return logger.throwArgumentError("invalid hexlify value", "value", value);
}
/*
function unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {
    if (typeof(value) === "string" && value.length % 2 && value.substring(0, 2) === "0x") {
        return "0x0" + value.substring(2);
    }
    return value;
}
*/
function hexDataLength(data) {
    if (typeof (data) !== "string") {
        data = hexlify(data);
    }
    else if (!isHexString(data) || (data.length % 2)) {
        return null;
    }
    return (data.length - 2) / 2;
}
function hexDataSlice(data, offset, endOffset) {
    if (typeof (data) !== "string") {
        data = hexlify(data);
    }
    else if (!isHexString(data) || (data.length % 2)) {
        logger.throwArgumentError("invalid hexData", "value", data);
    }
    offset = 2 + 2 * offset;
    if (endOffset != null) {
        return "0x" + data.substring(offset, 2 + 2 * endOffset);
    }
    return "0x" + data.substring(offset);
}
function hexConcat(items) {
    let result = "0x";
    items.forEach((item) => {
        result += hexlify(item).substring(2);
    });
    return result;
}
function hexValue(value) {
    const trimmed = hexStripZeros(hexlify(value, { hexPad: "left" }));
    if (trimmed === "0x") {
        return "0x0";
    }
    return trimmed;
}
function hexStripZeros(value) {
    if (typeof (value) !== "string") {
        value = hexlify(value);
    }
    if (!isHexString(value)) {
        logger.throwArgumentError("invalid hex string", "value", value);
    }
    value = value.substring(2);
    let offset = 0;
    while (offset < value.length && value[offset] === "0") {
        offset++;
    }
    return "0x" + value.substring(offset);
}
function hexZeroPad(value, length) {
    if (typeof (value) !== "string") {
        value = hexlify(value);
    }
    else if (!isHexString(value)) {
        logger.throwArgumentError("invalid hex string", "value", value);
    }
    if (value.length > 2 * length + 2) {
        logger.throwArgumentError("value out of range", "value", arguments[1]);
    }
    while (value.length < 2 * length + 2) {
        value = "0x0" + value.substring(2);
    }
    return value;
}
function splitSignature(signature) {
    const result = {
        r: "0x",
        s: "0x",
        _vs: "0x",
        recoveryParam: 0,
        v: 0,
        yParityAndS: "0x",
        compact: "0x"
    };
    if (isBytesLike(signature)) {
        let bytes = arrayify(signature);
        // Get the r, s and v
        if (bytes.length === 64) {
            // EIP-2098; pull the v from the top bit of s and clear it
            result.v = 27 + (bytes[32] >> 7);
            bytes[32] &= 0x7f;
            result.r = hexlify(bytes.slice(0, 32));
            result.s = hexlify(bytes.slice(32, 64));
        }
        else if (bytes.length === 65) {
            result.r = hexlify(bytes.slice(0, 32));
            result.s = hexlify(bytes.slice(32, 64));
            result.v = bytes[64];
        }
        else {
            logger.throwArgumentError("invalid signature string", "signature", signature);
        }
        // Allow a recid to be used as the v
        if (result.v < 27) {
            if (result.v === 0 || result.v === 1) {
                result.v += 27;
            }
            else {
                logger.throwArgumentError("signature invalid v byte", "signature", signature);
            }
        }
        // Compute recoveryParam from v
        result.recoveryParam = 1 - (result.v % 2);
        // Compute _vs from recoveryParam and s
        if (result.recoveryParam) {
            bytes[32] |= 0x80;
        }
        result._vs = hexlify(bytes.slice(32, 64));
    }
    else {
        result.r = signature.r;
        result.s = signature.s;
        result.v = signature.v;
        result.recoveryParam = signature.recoveryParam;
        result._vs = signature._vs;
        // If the _vs is available, use it to populate missing s, v and recoveryParam
        // and verify non-missing s, v and recoveryParam
        if (result._vs != null) {
            const vs = zeroPad(arrayify(result._vs), 32);
            result._vs = hexlify(vs);
            // Set or check the recid
            const recoveryParam = ((vs[0] >= 128) ? 1 : 0);
            if (result.recoveryParam == null) {
                result.recoveryParam = recoveryParam;
            }
            else if (result.recoveryParam !== recoveryParam) {
                logger.throwArgumentError("signature recoveryParam mismatch _vs", "signature", signature);
            }
            // Set or check the s
            vs[0] &= 0x7f;
            const s = hexlify(vs);
            if (result.s == null) {
                result.s = s;
            }
            else if (result.s !== s) {
                logger.throwArgumentError("signature v mismatch _vs", "signature", signature);
            }
        }
        // Use recid and v to populate each other
        if (result.recoveryParam == null) {
            if (result.v == null) {
                logger.throwArgumentError("signature missing v and recoveryParam", "signature", signature);
            }
            else if (result.v === 0 || result.v === 1) {
                result.recoveryParam = result.v;
            }
            else {
                result.recoveryParam = 1 - (result.v % 2);
            }
        }
        else {
            if (result.v == null) {
                result.v = 27 + result.recoveryParam;
            }
            else {
                const recId = (result.v === 0 || result.v === 1) ? result.v : (1 - (result.v % 2));
                if (result.recoveryParam !== recId) {
                    logger.throwArgumentError("signature recoveryParam mismatch v", "signature", signature);
                }
            }
        }
        if (result.r == null || !isHexString(result.r)) {
            logger.throwArgumentError("signature missing or invalid r", "signature", signature);
        }
        else {
            result.r = hexZeroPad(result.r, 32);
        }
        if (result.s == null || !isHexString(result.s)) {
            logger.throwArgumentError("signature missing or invalid s", "signature", signature);
        }
        else {
            result.s = hexZeroPad(result.s, 32);
        }
        const vs = arrayify(result.s);
        if (vs[0] >= 128) {
            logger.throwArgumentError("signature s out of range", "signature", signature);
        }
        if (result.recoveryParam) {
            vs[0] |= 0x80;
        }
        const _vs = hexlify(vs);
        if (result._vs) {
            if (!isHexString(result._vs)) {
                logger.throwArgumentError("signature invalid _vs", "signature", signature);
            }
            result._vs = hexZeroPad(result._vs, 32);
        }
        // Set or check the _vs
        if (result._vs == null) {
            result._vs = _vs;
        }
        else if (result._vs !== _vs) {
            logger.throwArgumentError("signature _vs mismatch v and s", "signature", signature);
        }
    }
    result.yParityAndS = result._vs;
    result.compact = result.r + result.yParityAndS.substring(2);
    return result;
}
function joinSignature(signature) {
    signature = splitSignature(signature);
    return hexlify(concat([
        signature.r,
        signature.s,
        (signature.recoveryParam ? "0x1c" : "0x1b")
    ]));
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/@ethersproject/constants/lib.esm/bignumbers.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/@ethersproject/constants/lib.esm/bignumbers.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MaxInt256": () => (/* binding */ MaxInt256),
/* harmony export */   "MaxUint256": () => (/* binding */ MaxUint256),
/* harmony export */   "MinInt256": () => (/* binding */ MinInt256),
/* harmony export */   "NegativeOne": () => (/* binding */ NegativeOne),
/* harmony export */   "One": () => (/* binding */ One),
/* harmony export */   "Two": () => (/* binding */ Two),
/* harmony export */   "WeiPerEther": () => (/* binding */ WeiPerEther),
/* harmony export */   "Zero": () => (/* binding */ Zero)
/* harmony export */ });
/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/bignumber */ "../../node_modules/@ethersproject/bignumber/lib.esm/bignumber.js");

const NegativeOne = ( /*#__PURE__*/_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__.BigNumber.from(-1));
const Zero = ( /*#__PURE__*/_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__.BigNumber.from(0));
const One = ( /*#__PURE__*/_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__.BigNumber.from(1));
const Two = ( /*#__PURE__*/_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__.BigNumber.from(2));
const WeiPerEther = ( /*#__PURE__*/_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__.BigNumber.from("1000000000000000000"));
const MaxUint256 = ( /*#__PURE__*/_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__.BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"));
const MinInt256 = ( /*#__PURE__*/_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__.BigNumber.from("-0x8000000000000000000000000000000000000000000000000000000000000000"));
const MaxInt256 = ( /*#__PURE__*/_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__.BigNumber.from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"));

//# sourceMappingURL=bignumbers.js.map

/***/ }),

/***/ "../../node_modules/@ethersproject/hash/lib.esm/id.js":
/*!************************************************************!*\
  !*** ../../node_modules/@ethersproject/hash/lib.esm/id.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "id": () => (/* binding */ id)
/* harmony export */ });
/* harmony import */ var _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/keccak256 */ "../../node_modules/@ethersproject/keccak256/lib.esm/index.js");
/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/strings */ "../../node_modules/@ethersproject/strings/lib.esm/utf8.js");


function id(text) {
    return (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_0__.keccak256)((0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_1__.toUtf8Bytes)(text));
}
//# sourceMappingURL=id.js.map

/***/ }),

/***/ "../../node_modules/@ethersproject/keccak256/lib.esm/index.js":
/*!********************************************************************!*\
  !*** ../../node_modules/@ethersproject/keccak256/lib.esm/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "keccak256": () => (/* binding */ keccak256)
/* harmony export */ });
/* harmony import */ var js_sha3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! js-sha3 */ "../../node_modules/js-sha3/src/sha3.js");
/* harmony import */ var js_sha3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(js_sha3__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/bytes */ "../../node_modules/@ethersproject/bytes/lib.esm/index.js");



function keccak256(data) {
    return '0x' + js_sha3__WEBPACK_IMPORTED_MODULE_0___default().keccak_256((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__.arrayify)(data));
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/@ethersproject/logger/lib.esm/_version.js":
/*!********************************************************************!*\
  !*** ../../node_modules/@ethersproject/logger/lib.esm/_version.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "version": () => (/* binding */ version)
/* harmony export */ });
const version = "logger/5.7.0";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ "../../node_modules/@ethersproject/logger/lib.esm/index.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/@ethersproject/logger/lib.esm/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ErrorCode": () => (/* binding */ ErrorCode),
/* harmony export */   "LogLevel": () => (/* binding */ LogLevel),
/* harmony export */   "Logger": () => (/* binding */ Logger)
/* harmony export */ });
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_version */ "../../node_modules/@ethersproject/logger/lib.esm/_version.js");

let _permanentCensorErrors = false;
let _censorErrors = false;
const LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
let _logLevel = LogLevels["default"];

let _globalLogger = null;
function _checkNormalize() {
    try {
        const missing = [];
        // Make sure all forms of normalization are supported
        ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
            try {
                if ("test".normalize(form) !== "test") {
                    throw new Error("bad normalize");
                }
                ;
            }
            catch (error) {
                missing.push(form);
            }
        });
        if (missing.length) {
            throw new Error("missing " + missing.join(", "));
        }
        if (String.fromCharCode(0xe9).normalize("NFD") !== String.fromCharCode(0x65, 0x0301)) {
            throw new Error("broken implementation");
        }
    }
    catch (error) {
        return error.message;
    }
    return null;
}
const _normalizeError = _checkNormalize();
var LogLevel;
(function (LogLevel) {
    LogLevel["DEBUG"] = "DEBUG";
    LogLevel["INFO"] = "INFO";
    LogLevel["WARNING"] = "WARNING";
    LogLevel["ERROR"] = "ERROR";
    LogLevel["OFF"] = "OFF";
})(LogLevel || (LogLevel = {}));
var ErrorCode;
(function (ErrorCode) {
    ///////////////////
    // Generic Errors
    // Unknown Error
    ErrorCode["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
    // Not Implemented
    ErrorCode["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
    // Unsupported Operation
    //   - operation
    ErrorCode["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)
    //   - event ("noNetwork" is not re-thrown in provider.ready; otherwise thrown)
    ErrorCode["NETWORK_ERROR"] = "NETWORK_ERROR";
    // Some sort of bad response from the server
    ErrorCode["SERVER_ERROR"] = "SERVER_ERROR";
    // Timeout
    ErrorCode["TIMEOUT"] = "TIMEOUT";
    ///////////////////
    // Operational  Errors
    // Buffer Overrun
    ErrorCode["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
    // Numeric Fault
    //   - operation: the operation being executed
    //   - fault: the reason this faulted
    ErrorCode["NUMERIC_FAULT"] = "NUMERIC_FAULT";
    ///////////////////
    // Argument Errors
    // Missing new operator to an object
    //  - name: The name of the class
    ErrorCode["MISSING_NEW"] = "MISSING_NEW";
    // Invalid argument (e.g. value is incompatible with type) to a function:
    //   - argument: The argument name that was invalid
    //   - value: The value of the argument
    ErrorCode["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
    // Missing argument to a function:
    //   - count: The number of arguments received
    //   - expectedCount: The number of arguments expected
    ErrorCode["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
    // Too many arguments
    //   - count: The number of arguments received
    //   - expectedCount: The number of arguments expected
    ErrorCode["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
    ///////////////////
    // Blockchain Errors
    // Call exception
    //  - transaction: the transaction
    //  - address?: the contract address
    //  - args?: The arguments passed into the function
    //  - method?: The Solidity method signature
    //  - errorSignature?: The EIP848 error signature
    //  - errorArgs?: The EIP848 error parameters
    //  - reason: The reason (only for EIP848 "Error(string)")
    ErrorCode["CALL_EXCEPTION"] = "CALL_EXCEPTION";
    // Insufficient funds (< value + gasLimit * gasPrice)
    //   - transaction: the transaction attempted
    ErrorCode["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
    // Nonce has already been used
    //   - transaction: the transaction attempted
    ErrorCode["NONCE_EXPIRED"] = "NONCE_EXPIRED";
    // The replacement fee for the transaction is too low
    //   - transaction: the transaction attempted
    ErrorCode["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
    // The gas limit could not be estimated
    //   - transaction: the transaction passed to estimateGas
    ErrorCode["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
    // The transaction was replaced by one with a higher gas price
    //   - reason: "cancelled", "replaced" or "repriced"
    //   - cancelled: true if reason == "cancelled" or reason == "replaced")
    //   - hash: original transaction hash
    //   - replacement: the full TransactionsResponse for the replacement
    //   - receipt: the receipt of the replacement
    ErrorCode["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
    ///////////////////
    // Interaction Errors
    // The user rejected the action, such as signing a message or sending
    // a transaction
    ErrorCode["ACTION_REJECTED"] = "ACTION_REJECTED";
})(ErrorCode || (ErrorCode = {}));
;
const HEX = "0123456789abcdef";
class Logger {
    constructor(version) {
        Object.defineProperty(this, "version", {
            enumerable: true,
            value: version,
            writable: false
        });
    }
    _log(logLevel, args) {
        const level = logLevel.toLowerCase();
        if (LogLevels[level] == null) {
            this.throwArgumentError("invalid log level name", "logLevel", logLevel);
        }
        if (_logLevel > LogLevels[level]) {
            return;
        }
        console.log.apply(console, args);
    }
    debug(...args) {
        this._log(Logger.levels.DEBUG, args);
    }
    info(...args) {
        this._log(Logger.levels.INFO, args);
    }
    warn(...args) {
        this._log(Logger.levels.WARNING, args);
    }
    makeError(message, code, params) {
        // Errors are being censored
        if (_censorErrors) {
            return this.makeError("censored error", code, {});
        }
        if (!code) {
            code = Logger.errors.UNKNOWN_ERROR;
        }
        if (!params) {
            params = {};
        }
        const messageDetails = [];
        Object.keys(params).forEach((key) => {
            const value = params[key];
            try {
                if (value instanceof Uint8Array) {
                    let hex = "";
                    for (let i = 0; i < value.length; i++) {
                        hex += HEX[value[i] >> 4];
                        hex += HEX[value[i] & 0x0f];
                    }
                    messageDetails.push(key + "=Uint8Array(0x" + hex + ")");
                }
                else {
                    messageDetails.push(key + "=" + JSON.stringify(value));
                }
            }
            catch (error) {
                messageDetails.push(key + "=" + JSON.stringify(params[key].toString()));
            }
        });
        messageDetails.push(`code=${code}`);
        messageDetails.push(`version=${this.version}`);
        const reason = message;
        let url = "";
        switch (code) {
            case ErrorCode.NUMERIC_FAULT: {
                url = "NUMERIC_FAULT";
                const fault = message;
                switch (fault) {
                    case "overflow":
                    case "underflow":
                    case "division-by-zero":
                        url += "-" + fault;
                        break;
                    case "negative-power":
                    case "negative-width":
                        url += "-unsupported";
                        break;
                    case "unbound-bitwise-result":
                        url += "-unbound-result";
                        break;
                }
                break;
            }
            case ErrorCode.CALL_EXCEPTION:
            case ErrorCode.INSUFFICIENT_FUNDS:
            case ErrorCode.MISSING_NEW:
            case ErrorCode.NONCE_EXPIRED:
            case ErrorCode.REPLACEMENT_UNDERPRICED:
            case ErrorCode.TRANSACTION_REPLACED:
            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
                url = code;
                break;
        }
        if (url) {
            message += " [ See: https:/\/links.ethers.org/v5-errors-" + url + " ]";
        }
        if (messageDetails.length) {
            message += " (" + messageDetails.join(", ") + ")";
        }
        // @TODO: Any??
        const error = new Error(message);
        error.reason = reason;
        error.code = code;
        Object.keys(params).forEach(function (key) {
            error[key] = params[key];
        });
        return error;
    }
    throwError(message, code, params) {
        throw this.makeError(message, code, params);
    }
    throwArgumentError(message, name, value) {
        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {
            argument: name,
            value: value
        });
    }
    assert(condition, message, code, params) {
        if (!!condition) {
            return;
        }
        this.throwError(message, code, params);
    }
    assertArgument(condition, message, name, value) {
        if (!!condition) {
            return;
        }
        this.throwArgumentError(message, name, value);
    }
    checkNormalize(message) {
        if (message == null) {
            message = "platform missing String.prototype.normalize";
        }
        if (_normalizeError) {
            this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "String.prototype.normalize", form: _normalizeError
            });
        }
    }
    checkSafeUint53(value, message) {
        if (typeof (value) !== "number") {
            return;
        }
        if (message == null) {
            message = "value not safe";
        }
        if (value < 0 || value >= 0x1fffffffffffff) {
            this.throwError(message, Logger.errors.NUMERIC_FAULT, {
                operation: "checkSafeInteger",
                fault: "out-of-safe-range",
                value: value
            });
        }
        if (value % 1) {
            this.throwError(message, Logger.errors.NUMERIC_FAULT, {
                operation: "checkSafeInteger",
                fault: "non-integer",
                value: value
            });
        }
    }
    checkArgumentCount(count, expectedCount, message) {
        if (message) {
            message = ": " + message;
        }
        else {
            message = "";
        }
        if (count < expectedCount) {
            this.throwError("missing argument" + message, Logger.errors.MISSING_ARGUMENT, {
                count: count,
                expectedCount: expectedCount
            });
        }
        if (count > expectedCount) {
            this.throwError("too many arguments" + message, Logger.errors.UNEXPECTED_ARGUMENT, {
                count: count,
                expectedCount: expectedCount
            });
        }
    }
    checkNew(target, kind) {
        if (target === Object || target == null) {
            this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
        }
    }
    checkAbstract(target, kind) {
        if (target === kind) {
            this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
        }
        else if (target === Object || target == null) {
            this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
        }
    }
    static globalLogger() {
        if (!_globalLogger) {
            _globalLogger = new Logger(_version__WEBPACK_IMPORTED_MODULE_0__.version);
        }
        return _globalLogger;
    }
    static setCensorship(censorship, permanent) {
        if (!censorship && permanent) {
            this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "setCensorship"
            });
        }
        if (_permanentCensorErrors) {
            if (!censorship) {
                return;
            }
            this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "setCensorship"
            });
        }
        _censorErrors = !!censorship;
        _permanentCensorErrors = !!permanent;
    }
    static setLogLevel(logLevel) {
        const level = LogLevels[logLevel.toLowerCase()];
        if (level == null) {
            Logger.globalLogger().warn("invalid log level - " + logLevel);
            return;
        }
        _logLevel = level;
    }
    static from(version) {
        return new Logger(version);
    }
}
Logger.errors = ErrorCode;
Logger.levels = LogLevel;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/@ethersproject/properties/lib.esm/_version.js":
/*!************************************************************************!*\
  !*** ../../node_modules/@ethersproject/properties/lib.esm/_version.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "version": () => (/* binding */ version)
/* harmony export */ });
const version = "properties/5.7.0";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ "../../node_modules/@ethersproject/properties/lib.esm/index.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/@ethersproject/properties/lib.esm/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Description": () => (/* binding */ Description),
/* harmony export */   "checkProperties": () => (/* binding */ checkProperties),
/* harmony export */   "deepCopy": () => (/* binding */ deepCopy),
/* harmony export */   "defineReadOnly": () => (/* binding */ defineReadOnly),
/* harmony export */   "getStatic": () => (/* binding */ getStatic),
/* harmony export */   "resolveProperties": () => (/* binding */ resolveProperties),
/* harmony export */   "shallowCopy": () => (/* binding */ shallowCopy)
/* harmony export */ });
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "../../node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "../../node_modules/@ethersproject/properties/lib.esm/_version.js");

var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);
function defineReadOnly(object, name, value) {
    Object.defineProperty(object, name, {
        enumerable: true,
        value: value,
        writable: false,
    });
}
// Crawl up the constructor chain to find a static method
function getStatic(ctor, key) {
    for (let i = 0; i < 32; i++) {
        if (ctor[key]) {
            return ctor[key];
        }
        if (!ctor.prototype || typeof (ctor.prototype) !== "object") {
            break;
        }
        ctor = Object.getPrototypeOf(ctor.prototype).constructor;
    }
    return null;
}
function resolveProperties(object) {
    return __awaiter(this, void 0, void 0, function* () {
        const promises = Object.keys(object).map((key) => {
            const value = object[key];
            return Promise.resolve(value).then((v) => ({ key: key, value: v }));
        });
        const results = yield Promise.all(promises);
        return results.reduce((accum, result) => {
            accum[(result.key)] = result.value;
            return accum;
        }, {});
    });
}
function checkProperties(object, properties) {
    if (!object || typeof (object) !== "object") {
        logger.throwArgumentError("invalid object", "object", object);
    }
    Object.keys(object).forEach((key) => {
        if (!properties[key]) {
            logger.throwArgumentError("invalid object key - " + key, "transaction:" + key, object);
        }
    });
}
function shallowCopy(object) {
    const result = {};
    for (const key in object) {
        result[key] = object[key];
    }
    return result;
}
const opaque = { bigint: true, boolean: true, "function": true, number: true, string: true };
function _isFrozen(object) {
    // Opaque objects are not mutable, so safe to copy by assignment
    if (object === undefined || object === null || opaque[typeof (object)]) {
        return true;
    }
    if (Array.isArray(object) || typeof (object) === "object") {
        if (!Object.isFrozen(object)) {
            return false;
        }
        const keys = Object.keys(object);
        for (let i = 0; i < keys.length; i++) {
            let value = null;
            try {
                value = object[keys[i]];
            }
            catch (error) {
                // If accessing a value triggers an error, it is a getter
                // designed to do so (e.g. Result) and is therefore "frozen"
                continue;
            }
            if (!_isFrozen(value)) {
                return false;
            }
        }
        return true;
    }
    return logger.throwArgumentError(`Cannot deepCopy ${typeof (object)}`, "object", object);
}
// Returns a new copy of object, such that no properties may be replaced.
// New properties may be added only to objects.
function _deepCopy(object) {
    if (_isFrozen(object)) {
        return object;
    }
    // Arrays are mutable, so we need to create a copy
    if (Array.isArray(object)) {
        return Object.freeze(object.map((item) => deepCopy(item)));
    }
    if (typeof (object) === "object") {
        const result = {};
        for (const key in object) {
            const value = object[key];
            if (value === undefined) {
                continue;
            }
            defineReadOnly(result, key, deepCopy(value));
        }
        return result;
    }
    return logger.throwArgumentError(`Cannot deepCopy ${typeof (object)}`, "object", object);
}
function deepCopy(object) {
    return _deepCopy(object);
}
class Description {
    constructor(info) {
        for (const key in info) {
            this[key] = deepCopy(info[key]);
        }
    }
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/@ethersproject/rlp/lib.esm/_version.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/@ethersproject/rlp/lib.esm/_version.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "version": () => (/* binding */ version)
/* harmony export */ });
const version = "rlp/5.7.0";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ "../../node_modules/@ethersproject/rlp/lib.esm/index.js":
/*!**************************************************************!*\
  !*** ../../node_modules/@ethersproject/rlp/lib.esm/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "decode": () => (/* binding */ decode),
/* harmony export */   "encode": () => (/* binding */ encode)
/* harmony export */ });
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bytes */ "../../node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "../../node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "../../node_modules/@ethersproject/rlp/lib.esm/_version.js");

//See: https://github.com/ethereum/wiki/wiki/RLP



const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);
function arrayifyInteger(value) {
    const result = [];
    while (value) {
        result.unshift(value & 0xff);
        value >>= 8;
    }
    return result;
}
function unarrayifyInteger(data, offset, length) {
    let result = 0;
    for (let i = 0; i < length; i++) {
        result = (result * 256) + data[offset + i];
    }
    return result;
}
function _encode(object) {
    if (Array.isArray(object)) {
        let payload = [];
        object.forEach(function (child) {
            payload = payload.concat(_encode(child));
        });
        if (payload.length <= 55) {
            payload.unshift(0xc0 + payload.length);
            return payload;
        }
        const length = arrayifyInteger(payload.length);
        length.unshift(0xf7 + length.length);
        return length.concat(payload);
    }
    if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.isBytesLike)(object)) {
        logger.throwArgumentError("RLP object must be BytesLike", "object", object);
    }
    const data = Array.prototype.slice.call((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.arrayify)(object));
    if (data.length === 1 && data[0] <= 0x7f) {
        return data;
    }
    else if (data.length <= 55) {
        data.unshift(0x80 + data.length);
        return data;
    }
    const length = arrayifyInteger(data.length);
    length.unshift(0xb7 + length.length);
    return length.concat(data);
}
function encode(object) {
    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)(_encode(object));
}
function _decodeChildren(data, offset, childOffset, length) {
    const result = [];
    while (childOffset < offset + 1 + length) {
        const decoded = _decode(data, childOffset);
        result.push(decoded.result);
        childOffset += decoded.consumed;
        if (childOffset > offset + 1 + length) {
            logger.throwError("child data too short", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {});
        }
    }
    return { consumed: (1 + length), result: result };
}
// returns { consumed: number, result: Object }
function _decode(data, offset) {
    if (data.length === 0) {
        logger.throwError("data too short", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {});
    }
    // Array with extra length prefix
    if (data[offset] >= 0xf8) {
        const lengthLength = data[offset] - 0xf7;
        if (offset + 1 + lengthLength > data.length) {
            logger.throwError("data short segment too short", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {});
        }
        const length = unarrayifyInteger(data, offset + 1, lengthLength);
        if (offset + 1 + lengthLength + length > data.length) {
            logger.throwError("data long segment too short", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {});
        }
        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);
    }
    else if (data[offset] >= 0xc0) {
        const length = data[offset] - 0xc0;
        if (offset + 1 + length > data.length) {
            logger.throwError("data array too short", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {});
        }
        return _decodeChildren(data, offset, offset + 1, length);
    }
    else if (data[offset] >= 0xb8) {
        const lengthLength = data[offset] - 0xb7;
        if (offset + 1 + lengthLength > data.length) {
            logger.throwError("data array too short", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {});
        }
        const length = unarrayifyInteger(data, offset + 1, lengthLength);
        if (offset + 1 + lengthLength + length > data.length) {
            logger.throwError("data array too short", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {});
        }
        const result = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));
        return { consumed: (1 + lengthLength + length), result: result };
    }
    else if (data[offset] >= 0x80) {
        const length = data[offset] - 0x80;
        if (offset + 1 + length > data.length) {
            logger.throwError("data too short", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {});
        }
        const result = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)(data.slice(offset + 1, offset + 1 + length));
        return { consumed: (1 + length), result: result };
    }
    return { consumed: 1, result: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)(data[offset]) };
}
function decode(data) {
    const bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.arrayify)(data);
    const decoded = _decode(bytes, 0);
    if (decoded.consumed !== bytes.length) {
        logger.throwArgumentError("invalid rlp data", "data", data);
    }
    return decoded.result;
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/@ethersproject/strings/lib.esm/_version.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/@ethersproject/strings/lib.esm/_version.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "version": () => (/* binding */ version)
/* harmony export */ });
const version = "strings/5.7.0";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ "../../node_modules/@ethersproject/strings/lib.esm/utf8.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/@ethersproject/strings/lib.esm/utf8.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UnicodeNormalizationForm": () => (/* binding */ UnicodeNormalizationForm),
/* harmony export */   "Utf8ErrorFuncs": () => (/* binding */ Utf8ErrorFuncs),
/* harmony export */   "Utf8ErrorReason": () => (/* binding */ Utf8ErrorReason),
/* harmony export */   "_toEscapedUtf8String": () => (/* binding */ _toEscapedUtf8String),
/* harmony export */   "_toUtf8String": () => (/* binding */ _toUtf8String),
/* harmony export */   "toUtf8Bytes": () => (/* binding */ toUtf8Bytes),
/* harmony export */   "toUtf8CodePoints": () => (/* binding */ toUtf8CodePoints),
/* harmony export */   "toUtf8String": () => (/* binding */ toUtf8String)
/* harmony export */ });
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bytes */ "../../node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "../../node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "../../node_modules/@ethersproject/strings/lib.esm/_version.js");




const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);
///////////////////////////////
var UnicodeNormalizationForm;
(function (UnicodeNormalizationForm) {
    UnicodeNormalizationForm["current"] = "";
    UnicodeNormalizationForm["NFC"] = "NFC";
    UnicodeNormalizationForm["NFD"] = "NFD";
    UnicodeNormalizationForm["NFKC"] = "NFKC";
    UnicodeNormalizationForm["NFKD"] = "NFKD";
})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));
;
var Utf8ErrorReason;
(function (Utf8ErrorReason) {
    // A continuation byte was present where there was nothing to continue
    // - offset = the index the codepoint began in
    Utf8ErrorReason["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found
    // - offset = the index the codepoint began in
    Utf8ErrorReason["BAD_PREFIX"] = "bad codepoint prefix";
    // The string is too short to process the expected codepoint
    // - offset = the index the codepoint began in
    Utf8ErrorReason["OVERRUN"] = "string overrun";
    // A missing continuation byte was expected but not found
    // - offset = the index the continuation byte was expected at
    Utf8ErrorReason["MISSING_CONTINUE"] = "missing continuation byte";
    // The computed code point is outside the range for UTF-8
    // - offset       = start of this codepoint
    // - badCodepoint = the computed codepoint; outside the UTF-8 range
    Utf8ErrorReason["OUT_OF_RANGE"] = "out of UTF-8 range";
    // UTF-8 strings may not contain UTF-16 surrogate pairs
    // - offset       = start of this codepoint
    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range
    Utf8ErrorReason["UTF16_SURROGATE"] = "UTF-16 surrogate";
    // The string is an overlong representation
    // - offset       = start of this codepoint
    // - badCodepoint = the computed codepoint; already bounds checked
    Utf8ErrorReason["OVERLONG"] = "overlong representation";
})(Utf8ErrorReason || (Utf8ErrorReason = {}));
;
function errorFunc(reason, offset, bytes, output, badCodepoint) {
    return logger.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes);
}
function ignoreFunc(reason, offset, bytes, output, badCodepoint) {
    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes
    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {
        let i = 0;
        for (let o = offset + 1; o < bytes.length; o++) {
            if (bytes[o] >> 6 !== 0x02) {
                break;
            }
            i++;
        }
        return i;
    }
    // This byte runs us past the end of the string, so just jump to the end
    // (but the first byte was read already read and therefore skipped)
    if (reason === Utf8ErrorReason.OVERRUN) {
        return bytes.length - offset - 1;
    }
    // Nothing to skip
    return 0;
}
function replaceFunc(reason, offset, bytes, output, badCodepoint) {
    // Overlong representations are otherwise "valid" code points; just non-deistingtished
    if (reason === Utf8ErrorReason.OVERLONG) {
        output.push(badCodepoint);
        return 0;
    }
    // Put the replacement character into the output
    output.push(0xfffd);
    // Otherwise, process as if ignoring errors
    return ignoreFunc(reason, offset, bytes, output, badCodepoint);
}
// Common error handing strategies
const Utf8ErrorFuncs = Object.freeze({
    error: errorFunc,
    ignore: ignoreFunc,
    replace: replaceFunc
});
// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499
function getUtf8CodePoints(bytes, onError) {
    if (onError == null) {
        onError = Utf8ErrorFuncs.error;
    }
    bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.arrayify)(bytes);
    const result = [];
    let i = 0;
    // Invalid bytes are ignored
    while (i < bytes.length) {
        const c = bytes[i++];
        // 0xxx xxxx
        if (c >> 7 === 0) {
            result.push(c);
            continue;
        }
        // Multibyte; how many bytes left for this character?
        let extraLength = null;
        let overlongMask = null;
        // 110x xxxx 10xx xxxx
        if ((c & 0xe0) === 0xc0) {
            extraLength = 1;
            overlongMask = 0x7f;
            // 1110 xxxx 10xx xxxx 10xx xxxx
        }
        else if ((c & 0xf0) === 0xe0) {
            extraLength = 2;
            overlongMask = 0x7ff;
            // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx
        }
        else if ((c & 0xf8) === 0xf0) {
            extraLength = 3;
            overlongMask = 0xffff;
        }
        else {
            if ((c & 0xc0) === 0x80) {
                i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);
            }
            else {
                i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);
            }
            continue;
        }
        // Do we have enough bytes in our data?
        if (i - 1 + extraLength >= bytes.length) {
            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);
            continue;
        }
        // Remove the length prefix from the char
        let res = c & ((1 << (8 - extraLength - 1)) - 1);
        for (let j = 0; j < extraLength; j++) {
            let nextChar = bytes[i];
            // Invalid continuation byte
            if ((nextChar & 0xc0) != 0x80) {
                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);
                res = null;
                break;
            }
            ;
            res = (res << 6) | (nextChar & 0x3f);
            i++;
        }
        // See above loop for invalid continuation byte
        if (res === null) {
            continue;
        }
        // Maximum code point
        if (res > 0x10ffff) {
            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);
            continue;
        }
        // Reserved for UTF-16 surrogate halves
        if (res >= 0xd800 && res <= 0xdfff) {
            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);
            continue;
        }
        // Check for overlong sequences (more bytes than needed)
        if (res <= overlongMask) {
            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);
            continue;
        }
        result.push(res);
    }
    return result;
}
// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array
function toUtf8Bytes(str, form = UnicodeNormalizationForm.current) {
    if (form != UnicodeNormalizationForm.current) {
        logger.checkNormalize();
        str = str.normalize(form);
    }
    let result = [];
    for (let i = 0; i < str.length; i++) {
        const c = str.charCodeAt(i);
        if (c < 0x80) {
            result.push(c);
        }
        else if (c < 0x800) {
            result.push((c >> 6) | 0xc0);
            result.push((c & 0x3f) | 0x80);
        }
        else if ((c & 0xfc00) == 0xd800) {
            i++;
            const c2 = str.charCodeAt(i);
            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {
                throw new Error("invalid utf-8 string");
            }
            // Surrogate Pair
            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);
            result.push((pair >> 18) | 0xf0);
            result.push(((pair >> 12) & 0x3f) | 0x80);
            result.push(((pair >> 6) & 0x3f) | 0x80);
            result.push((pair & 0x3f) | 0x80);
        }
        else {
            result.push((c >> 12) | 0xe0);
            result.push(((c >> 6) & 0x3f) | 0x80);
            result.push((c & 0x3f) | 0x80);
        }
    }
    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.arrayify)(result);
}
;
function escapeChar(value) {
    const hex = ("0000" + value.toString(16));
    return "\\u" + hex.substring(hex.length - 4);
}
function _toEscapedUtf8String(bytes, onError) {
    return '"' + getUtf8CodePoints(bytes, onError).map((codePoint) => {
        if (codePoint < 256) {
            switch (codePoint) {
                case 8: return "\\b";
                case 9: return "\\t";
                case 10: return "\\n";
                case 13: return "\\r";
                case 34: return "\\\"";
                case 92: return "\\\\";
            }
            if (codePoint >= 32 && codePoint < 127) {
                return String.fromCharCode(codePoint);
            }
        }
        if (codePoint <= 0xffff) {
            return escapeChar(codePoint);
        }
        codePoint -= 0x10000;
        return escapeChar(((codePoint >> 10) & 0x3ff) + 0xd800) + escapeChar((codePoint & 0x3ff) + 0xdc00);
    }).join("") + '"';
}
function _toUtf8String(codePoints) {
    return codePoints.map((codePoint) => {
        if (codePoint <= 0xffff) {
            return String.fromCharCode(codePoint);
        }
        codePoint -= 0x10000;
        return String.fromCharCode((((codePoint >> 10) & 0x3ff) + 0xd800), ((codePoint & 0x3ff) + 0xdc00));
    }).join("");
}
function toUtf8String(bytes, onError) {
    return _toUtf8String(getUtf8CodePoints(bytes, onError));
}
function toUtf8CodePoints(str, form = UnicodeNormalizationForm.current) {
    return getUtf8CodePoints(toUtf8Bytes(str, form));
}
//# sourceMappingURL=utf8.js.map

/***/ }),

/***/ "../../node_modules/@fortawesome/react-fontawesome/index.es.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/@fortawesome/react-fontawesome/index.es.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FontAwesomeIcon": () => (/* binding */ FontAwesomeIcon)
/* harmony export */ });
/* harmony import */ var _fortawesome_fontawesome_svg_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fortawesome/fontawesome-svg-core */ "../../node_modules/@fortawesome/fontawesome-svg-core/index.mjs");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prop-types */ "../../node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);




function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

// Get CSS class list from a props object
function classList(props) {
  var _classes;

  var beat = props.beat,
      fade = props.fade,
      beatFade = props.beatFade,
      bounce = props.bounce,
      shake = props.shake,
      flash = props.flash,
      spin = props.spin,
      spinPulse = props.spinPulse,
      spinReverse = props.spinReverse,
      pulse = props.pulse,
      fixedWidth = props.fixedWidth,
      inverse = props.inverse,
      border = props.border,
      listItem = props.listItem,
      flip = props.flip,
      size = props.size,
      rotation = props.rotation,
      pull = props.pull; // map of CSS class names to properties

  var classes = (_classes = {
    'fa-beat': beat,
    'fa-fade': fade,
    'fa-beat-fade': beatFade,
    'fa-bounce': bounce,
    'fa-shake': shake,
    'fa-flash': flash,
    'fa-spin': spin,
    'fa-spin-reverse': spinReverse,
    'fa-spin-pulse': spinPulse,
    'fa-pulse': pulse,
    'fa-fw': fixedWidth,
    'fa-inverse': inverse,
    'fa-border': border,
    'fa-li': listItem,
    'fa-flip': flip === true,
    'fa-flip-horizontal': flip === 'horizontal' || flip === 'both',
    'fa-flip-vertical': flip === 'vertical' || flip === 'both'
  }, _defineProperty(_classes, "fa-".concat(size), typeof size !== 'undefined' && size !== null), _defineProperty(_classes, "fa-rotate-".concat(rotation), typeof rotation !== 'undefined' && rotation !== null && rotation !== 0), _defineProperty(_classes, "fa-pull-".concat(pull), typeof pull !== 'undefined' && pull !== null), _defineProperty(_classes, 'fa-swap-opacity', props.swapOpacity), _classes); // map over all the keys in the classes object
  // return an array of the keys where the value for the key is not null

  return Object.keys(classes).map(function (key) {
    return classes[key] ? key : null;
  }).filter(function (key) {
    return key;
  });
}

// Camelize taken from humps
// humps is copyright  2012+ Dom Christie
// Released under the MIT license.
// Performant way to determine if object coerces to a number
function _isNumerical(obj) {
  obj = obj - 0; // eslint-disable-next-line no-self-compare

  return obj === obj;
}

function camelize(string) {
  if (_isNumerical(string)) {
    return string;
  } // eslint-disable-next-line no-useless-escape


  string = string.replace(/[\-_\s]+(.)?/g, function (match, chr) {
    return chr ? chr.toUpperCase() : '';
  }); // Ensure 1st char is always lowercase

  return string.substr(0, 1).toLowerCase() + string.substr(1);
}

var _excluded = ["style"];

function capitalize(val) {
  return val.charAt(0).toUpperCase() + val.slice(1);
}

function styleToObject(style) {
  return style.split(';').map(function (s) {
    return s.trim();
  }).filter(function (s) {
    return s;
  }).reduce(function (acc, pair) {
    var i = pair.indexOf(':');
    var prop = camelize(pair.slice(0, i));
    var value = pair.slice(i + 1).trim();
    prop.startsWith('webkit') ? acc[capitalize(prop)] = value : acc[prop] = value;
    return acc;
  }, {});
}

function convert(createElement, element) {
  var extraProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (typeof element === 'string') {
    return element;
  }

  var children = (element.children || []).map(function (child) {
    return convert(createElement, child);
  });
  /* eslint-disable dot-notation */

  var mixins = Object.keys(element.attributes || {}).reduce(function (acc, key) {
    var val = element.attributes[key];

    switch (key) {
      case 'class':
        acc.attrs['className'] = val;
        delete element.attributes['class'];
        break;

      case 'style':
        acc.attrs['style'] = styleToObject(val);
        break;

      default:
        if (key.indexOf('aria-') === 0 || key.indexOf('data-') === 0) {
          acc.attrs[key.toLowerCase()] = val;
        } else {
          acc.attrs[camelize(key)] = val;
        }

    }

    return acc;
  }, {
    attrs: {}
  });

  var _extraProps$style = extraProps.style,
      existingStyle = _extraProps$style === void 0 ? {} : _extraProps$style,
      remaining = _objectWithoutProperties(extraProps, _excluded);

  mixins.attrs['style'] = _objectSpread2(_objectSpread2({}, mixins.attrs['style']), existingStyle);
  /* eslint-enable */

  return createElement.apply(void 0, [element.tag, _objectSpread2(_objectSpread2({}, mixins.attrs), remaining)].concat(_toConsumableArray(children)));
}

var PRODUCTION = false;

try {
  PRODUCTION = "development" === 'production';
} catch (e) {}

function log () {
  if (!PRODUCTION && console && typeof console.error === 'function') {
    var _console;

    (_console = console).error.apply(_console, arguments);
  }
}

function normalizeIconArgs(icon) {
  // this has everything that it needs to be rendered which means it was probably imported
  // directly from an icon svg package
  if (icon && _typeof(icon) === 'object' && icon.prefix && icon.iconName && icon.icon) {
    return icon;
  }

  if (_fortawesome_fontawesome_svg_core__WEBPACK_IMPORTED_MODULE_0__.parse.icon) {
    return _fortawesome_fontawesome_svg_core__WEBPACK_IMPORTED_MODULE_0__.parse.icon(icon);
  } // if the icon is null, there's nothing to do


  if (icon === null) {
    return null;
  } // if the icon is an object and has a prefix and an icon name, return it


  if (icon && _typeof(icon) === 'object' && icon.prefix && icon.iconName) {
    return icon;
  } // if it's an array with length of two


  if (Array.isArray(icon) && icon.length === 2) {
    // use the first item as prefix, second as icon name
    return {
      prefix: icon[0],
      iconName: icon[1]
    };
  } // if it's a string, use it as the icon name


  if (typeof icon === 'string') {
    return {
      prefix: 'fas',
      iconName: icon
    };
  }
}

// creates an object with a key of key
// and a value of value
// if certain conditions are met
function objectWithKey(key, value) {
  // if the value is a non-empty array
  // or it's not an array but it is truthy
  // then create the object with the key and the value
  // if not, return an empty array
  return Array.isArray(value) && value.length > 0 || !Array.isArray(value) && value ? _defineProperty({}, key, value) : {};
}

var FontAwesomeIcon = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef(function (props, ref) {
  var iconArgs = props.icon,
      maskArgs = props.mask,
      symbol = props.symbol,
      className = props.className,
      title = props.title,
      titleId = props.titleId,
      maskId = props.maskId;
  var iconLookup = normalizeIconArgs(iconArgs);
  var classes = objectWithKey('classes', [].concat(_toConsumableArray(classList(props)), _toConsumableArray(className.split(' '))));
  var transform = objectWithKey('transform', typeof props.transform === 'string' ? _fortawesome_fontawesome_svg_core__WEBPACK_IMPORTED_MODULE_0__.parse.transform(props.transform) : props.transform);
  var mask = objectWithKey('mask', normalizeIconArgs(maskArgs));
  var renderedIcon = (0,_fortawesome_fontawesome_svg_core__WEBPACK_IMPORTED_MODULE_0__.icon)(iconLookup, _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, classes), transform), mask), {}, {
    symbol: symbol,
    title: title,
    titleId: titleId,
    maskId: maskId
  }));

  if (!renderedIcon) {
    log('Could not find icon', iconLookup);
    return null;
  }

  var abstract = renderedIcon.abstract;
  var extraProps = {
    ref: ref
  };
  Object.keys(props).forEach(function (key) {
    // eslint-disable-next-line no-prototype-builtins
    if (!FontAwesomeIcon.defaultProps.hasOwnProperty(key)) {
      extraProps[key] = props[key];
    }
  });
  return convertCurry(abstract[0], extraProps);
});
FontAwesomeIcon.displayName = 'FontAwesomeIcon';
FontAwesomeIcon.propTypes = {
  beat: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool),
  border: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool),
  beatFade: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool),
  bounce: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool),
  className: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().string),
  fade: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool),
  flash: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool),
  mask: prop_types__WEBPACK_IMPORTED_MODULE_2___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_2___default().object), (prop_types__WEBPACK_IMPORTED_MODULE_2___default().array), (prop_types__WEBPACK_IMPORTED_MODULE_2___default().string)]),
  maskId: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().string),
  fixedWidth: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool),
  inverse: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool),
  flip: prop_types__WEBPACK_IMPORTED_MODULE_2___default().oneOf([true, false, 'horizontal', 'vertical', 'both']),
  icon: prop_types__WEBPACK_IMPORTED_MODULE_2___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_2___default().object), (prop_types__WEBPACK_IMPORTED_MODULE_2___default().array), (prop_types__WEBPACK_IMPORTED_MODULE_2___default().string)]),
  listItem: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool),
  pull: prop_types__WEBPACK_IMPORTED_MODULE_2___default().oneOf(['right', 'left']),
  pulse: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool),
  rotation: prop_types__WEBPACK_IMPORTED_MODULE_2___default().oneOf([0, 90, 180, 270]),
  shake: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool),
  size: prop_types__WEBPACK_IMPORTED_MODULE_2___default().oneOf(['2xs', 'xs', 'sm', 'lg', 'xl', '2xl', '1x', '2x', '3x', '4x', '5x', '6x', '7x', '8x', '9x', '10x']),
  spin: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool),
  spinPulse: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool),
  spinReverse: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool),
  symbol: prop_types__WEBPACK_IMPORTED_MODULE_2___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool), (prop_types__WEBPACK_IMPORTED_MODULE_2___default().string)]),
  title: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().string),
  titleId: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().string),
  transform: prop_types__WEBPACK_IMPORTED_MODULE_2___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_2___default().string), (prop_types__WEBPACK_IMPORTED_MODULE_2___default().object)]),
  swapOpacity: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool)
};
FontAwesomeIcon.defaultProps = {
  border: false,
  className: '',
  mask: null,
  maskId: null,
  fixedWidth: false,
  inverse: false,
  flip: false,
  icon: null,
  listItem: false,
  pull: null,
  pulse: false,
  rotation: null,
  size: null,
  spin: false,
  spinPulse: false,
  spinReverse: false,
  beat: false,
  fade: false,
  beatFade: false,
  bounce: false,
  shake: false,
  symbol: false,
  title: '',
  titleId: null,
  transform: null,
  swapOpacity: false
};
var convertCurry = convert.bind(null, (react__WEBPACK_IMPORTED_MODULE_1___default().createElement));




/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/assets/close-material-svg.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/assets/close-material-svg.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ "../../node_modules/lit/index.js");
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (lit__WEBPACK_IMPORTED_MODULE_0__.html `
<svg xmlns="http://www.w3.org/2000/svg" width="24px" height="24px" viewBox="0 0 24 24" fill="#000000">
    <!-- NOTE(cdata): This SVG filter is a stop-gap until we can implement
         support for dynamic re-coloring of UI components -->
    <defs>
      <filter id="drop-shadow" x="-100%" y="-100%" width="300%" height="300%">
        <feGaussianBlur in="SourceAlpha" stdDeviation="1"/>
        <feOffset dx="0" dy="0" result="offsetblur"/>
        <feFlood flood-color="#000000"/>
        <feComposite in2="offsetblur" operator="in"/>
        <feMerge>
          <feMergeNode/>
          <feMergeNode in="SourceGraphic"/>
        </feMerge>
      </filter>
    </defs>
    <path filter="url(#drop-shadow)" d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
    <path d="M0 0h24v24H0z" fill="none"/>
</svg>`);
//# sourceMappingURL=close-material-svg.js.map

/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/assets/controls-svg.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/assets/controls-svg.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ "../../node_modules/lit/index.js");
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (lit__WEBPACK_IMPORTED_MODULE_0__.html `
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="25" height="36">
    <defs>
        <path id="A" d="M.001.232h24.997V36H.001z" />
    </defs>
    <g transform="translate(-11 -4)" fill="none" fill-rule="evenodd">
        <path fill-opacity="0" fill="#fff" d="M0 0h44v44H0z" />
        <g transform="translate(11 3)">
            <path d="M8.733 11.165c.04-1.108.766-2.027 1.743-2.307a2.54 2.54 0 0 1 .628-.089c.16 0 .314.017.463.044 1.088.2 1.9 1.092 1.9 2.16v8.88h1.26c2.943-1.39 5-4.45 5-8.025a9.01 9.01 0 0 0-1.9-5.56l-.43-.5c-.765-.838-1.683-1.522-2.712-2-1.057-.49-2.226-.77-3.46-.77s-2.4.278-3.46.77c-1.03.478-1.947 1.162-2.71 2l-.43.5a9.01 9.01 0 0 0-1.9 5.56 9.04 9.04 0 0 0 .094 1.305c.03.21.088.41.13.617l.136.624c.083.286.196.56.305.832l.124.333a8.78 8.78 0 0 0 .509.953l.065.122a8.69 8.69 0 0 0 3.521 3.191l1.11.537v-9.178z" fill-opacity=".5" fill="#e4e4e4" />
            <path d="M22.94 26.218l-2.76 7.74c-.172.485-.676.8-1.253.8H12.24c-1.606 0-3.092-.68-3.98-1.82-1.592-2.048-3.647-3.822-6.11-5.27-.095-.055-.15-.137-.152-.23-.004-.1.046-.196.193-.297.56-.393 1.234-.6 1.926-.6a3.43 3.43 0 0 1 .691.069l4.922.994V10.972c0-.663.615-1.203 1.37-1.203s1.373.54 1.373 1.203v9.882h2.953c.273 0 .533.073.757.21l6.257 3.874c.027.017.045.042.07.06.41.296.586.77.426 1.22M4.1 16.614c-.024-.04-.042-.083-.065-.122a8.69 8.69 0 0 1-.509-.953c-.048-.107-.08-.223-.124-.333l-.305-.832c-.058-.202-.09-.416-.136-.624l-.13-.617a9.03 9.03 0 0 1-.094-1.305c0-2.107.714-4.04 1.9-5.56l.43-.5c.764-.84 1.682-1.523 2.71-2 1.058-.49 2.226-.77 3.46-.77s2.402.28 3.46.77c1.03.477 1.947 1.16 2.712 2l.428.5a9 9 0 0 1 1.901 5.559c0 3.577-2.056 6.636-5 8.026h-1.26v-8.882c0-1.067-.822-1.96-1.9-2.16-.15-.028-.304-.044-.463-.044-.22 0-.427.037-.628.09-.977.28-1.703 1.198-1.743 2.306v9.178l-1.11-.537C6.18 19.098 4.96 18 4.1 16.614M22.97 24.09l-6.256-3.874c-.102-.063-.218-.098-.33-.144 2.683-1.8 4.354-4.855 4.354-8.243 0-.486-.037-.964-.104-1.43a9.97 9.97 0 0 0-1.57-4.128l-.295-.408-.066-.092a10.05 10.05 0 0 0-.949-1.078c-.342-.334-.708-.643-1.094-.922-1.155-.834-2.492-1.412-3.94-1.65l-.732-.088-.748-.03a9.29 9.29 0 0 0-1.482.119c-1.447.238-2.786.816-3.94 1.65a9.33 9.33 0 0 0-.813.686 9.59 9.59 0 0 0-.845.877l-.385.437-.36.5-.288.468-.418.778-.04.09c-.593 1.28-.93 2.71-.93 4.222 0 3.832 2.182 7.342 5.56 8.938l1.437.68v4.946L5 25.64a4.44 4.44 0 0 0-.888-.086c-.017 0-.034.003-.05.003-.252.004-.503.033-.75.08a5.08 5.08 0 0 0-.237.056c-.193.046-.382.107-.568.18-.075.03-.15.057-.225.1-.25.114-.494.244-.723.405a1.31 1.31 0 0 0-.566 1.122 1.28 1.28 0 0 0 .645 1.051C4 29.925 5.96 31.614 7.473 33.563a5.06 5.06 0 0 0 .434.491c1.086 1.082 2.656 1.713 4.326 1.715h6.697c.748-.001 1.43-.333 1.858-.872.142-.18.256-.38.336-.602l2.757-7.74c.094-.26.13-.53.112-.794s-.088-.52-.203-.76a2.19 2.19 0 0 0-.821-.91" fill-opacity=".6" fill="#000" />
            <path d="M22.444 24.94l-6.257-3.874a1.45 1.45 0 0 0-.757-.211h-2.953v-9.88c0-.663-.616-1.203-1.373-1.203s-1.37.54-1.37 1.203v16.643l-4.922-.994a3.44 3.44 0 0 0-.692-.069 3.35 3.35 0 0 0-1.925.598c-.147.102-.198.198-.194.298.004.094.058.176.153.23 2.462 1.448 4.517 3.22 6.11 5.27.887 1.14 2.373 1.82 3.98 1.82h6.686c.577 0 1.08-.326 1.253-.8l2.76-7.74c.16-.448-.017-.923-.426-1.22-.025-.02-.043-.043-.07-.06z" fill="#fff" />
            <g transform="translate(0 .769)">
                <mask id="B" fill="#fff">
                    <use xlink:href="#A" />
                </mask>
                <path d="M23.993 24.992a1.96 1.96 0 0 1-.111.794l-2.758 7.74c-.08.22-.194.423-.336.602-.427.54-1.11.87-1.857.872h-6.698c-1.67-.002-3.24-.633-4.326-1.715-.154-.154-.3-.318-.434-.49C5.96 30.846 4 29.157 1.646 27.773c-.385-.225-.626-.618-.645-1.05a1.31 1.31 0 0 1 .566-1.122 4.56 4.56 0 0 1 .723-.405l.225-.1a4.3 4.3 0 0 1 .568-.18l.237-.056c.248-.046.5-.075.75-.08.018 0 .034-.003.05-.003.303-.001.597.027.89.086l3.722.752V20.68l-1.436-.68c-3.377-1.596-5.56-5.106-5.56-8.938 0-1.51.336-2.94.93-4.222.015-.03.025-.06.04-.09.127-.267.268-.525.418-.778.093-.16.186-.316.288-.468.063-.095.133-.186.2-.277L3.773 5c.118-.155.26-.29.385-.437.266-.3.544-.604.845-.877a9.33 9.33 0 0 1 .813-.686C6.97 2.167 8.31 1.59 9.757 1.35a9.27 9.27 0 0 1 1.481-.119 8.82 8.82 0 0 1 .748.031c.247.02.49.05.733.088 1.448.238 2.786.816 3.94 1.65.387.28.752.588 1.094.922a9.94 9.94 0 0 1 .949 1.078l.066.092c.102.133.203.268.295.408a9.97 9.97 0 0 1 1.571 4.128c.066.467.103.945.103 1.43 0 3.388-1.67 6.453-4.353 8.243.11.046.227.08.33.144l6.256 3.874c.37.23.645.55.82.9.115.24.185.498.203.76m.697-1.195c-.265-.55-.677-1.007-1.194-1.326l-5.323-3.297c2.255-2.037 3.564-4.97 3.564-8.114 0-2.19-.637-4.304-1.84-6.114-.126-.188-.26-.37-.4-.552-.645-.848-1.402-1.6-2.252-2.204C15.472.91 13.393.232 11.238.232A10.21 10.21 0 0 0 5.23 2.19c-.848.614-1.606 1.356-2.253 2.205-.136.18-.272.363-.398.55C1.374 6.756.737 8.87.737 11.06c0 4.218 2.407 8.08 6.133 9.842l.863.41v3.092l-2.525-.51c-.356-.07-.717-.106-1.076-.106a5.45 5.45 0 0 0-3.14.996c-.653.46-1.022 1.202-.99 1.983a2.28 2.28 0 0 0 1.138 1.872c2.24 1.318 4.106 2.923 5.543 4.772 1.26 1.62 3.333 2.59 5.55 2.592h6.698c1.42-.001 2.68-.86 3.134-2.138l2.76-7.74c.272-.757.224-1.584-.134-2.325" fill-opacity=".05" fill="#000" mask="url(#B)" />
            </g>
        </g>
    </g>
</svg>`);
//# sourceMappingURL=controls-svg.js.map

/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/assets/view-in-ar-material-svg.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/assets/view-in-ar-material-svg.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ "../../node_modules/lit/index.js");
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (lit__WEBPACK_IMPORTED_MODULE_0__.html `
<svg version="1.1" id="view_x5F_in_x5F_AR_x5F_icon"
	 xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="24px" height="24px"
	 viewBox="0 0 24 24" enable-background="new 0 0 24 24" xml:space="preserve">
<rect id="Bounding_Box" x="0" y="0" fill="none" width="24" height="24"/>
<g id="Art_layer">
	<path d="M3,4c0-0.55,0.45-1,1-1h2V1H4C2.35,1,1,2.35,1,4v2h2V4z"/>
	<path d="M20,3c0.55,0,1,0.45,1,1v2h2V4c0-1.65-1.35-3-3-3h-2v2H20z"/>
	<path d="M4,21c-0.55,0-1-0.45-1-1v-2H1v2c0,1.65,1.35,3,3,3h2v-2H4z"/>
	<path d="M20,21c0.55,0,1-0.45,1-1v-2h2v2c0,1.65-1.35,3-3,3h-2v-2H20z"/>
	<g>
		<path d="M18.25,7.6l-5.5-3.18c-0.46-0.27-1.04-0.27-1.5,0L5.75,7.6C5.29,7.87,5,8.36,5,8.9v6.35c0,0.54,0.29,1.03,0.75,1.3
			l5.5,3.18c0.46,0.27,1.04,0.27,1.5,0l5.5-3.18c0.46-0.27,0.75-0.76,0.75-1.3V8.9C19,8.36,18.71,7.87,18.25,7.6z M7,14.96v-4.62
			l4,2.32v4.61L7,14.96z M12,10.93L8,8.61l4-2.31l4,2.31L12,10.93z M13,17.27v-4.61l4-2.32v4.62L13,17.27z"/>
	</g>
</g>
</svg>`);
//# sourceMappingURL=view-in-ar-material-svg.js.map

/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/constants.js":
/*!****************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/constants.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HAS_INTERSECTION_OBSERVER": () => (/* binding */ HAS_INTERSECTION_OBSERVER),
/* harmony export */   "HAS_RESIZE_OBSERVER": () => (/* binding */ HAS_RESIZE_OBSERVER),
/* harmony export */   "HAS_WEBXR_DEVICE_API": () => (/* binding */ HAS_WEBXR_DEVICE_API),
/* harmony export */   "HAS_WEBXR_HIT_TEST_API": () => (/* binding */ HAS_WEBXR_HIT_TEST_API),
/* harmony export */   "IS_ANDROID": () => (/* binding */ IS_ANDROID),
/* harmony export */   "IS_AR_QUICKLOOK_CANDIDATE": () => (/* binding */ IS_AR_QUICKLOOK_CANDIDATE),
/* harmony export */   "IS_CHROMEOS": () => (/* binding */ IS_CHROMEOS),
/* harmony export */   "IS_FIREFOX": () => (/* binding */ IS_FIREFOX),
/* harmony export */   "IS_IOS": () => (/* binding */ IS_IOS),
/* harmony export */   "IS_IOS_CHROME": () => (/* binding */ IS_IOS_CHROME),
/* harmony export */   "IS_IOS_SAFARI": () => (/* binding */ IS_IOS_SAFARI),
/* harmony export */   "IS_MOBILE": () => (/* binding */ IS_MOBILE),
/* harmony export */   "IS_OCULUS": () => (/* binding */ IS_OCULUS),
/* harmony export */   "IS_SAFARI": () => (/* binding */ IS_SAFARI),
/* harmony export */   "IS_SCENEVIEWER_CANDIDATE": () => (/* binding */ IS_SCENEVIEWER_CANDIDATE),
/* harmony export */   "IS_WEBXR_AR_CANDIDATE": () => (/* binding */ IS_WEBXR_AR_CANDIDATE),
/* harmony export */   "IS_WKWEBVIEW": () => (/* binding */ IS_WKWEBVIEW)
/* harmony export */ });
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// NOTE(cdata): The HAS_WEBXR_* constants can be enabled in Chrome by turning on
// the appropriate flags. However, just because we have the API does not
// guarantee that AR will work.
const HAS_WEBXR_DEVICE_API = navigator.xr != null &&
    self.XRSession != null && navigator.xr.isSessionSupported != null;
const HAS_WEBXR_HIT_TEST_API = HAS_WEBXR_DEVICE_API &&
    self.XRSession.prototype.requestHitTestSource != null;
const HAS_RESIZE_OBSERVER = self.ResizeObserver != null;
const HAS_INTERSECTION_OBSERVER = self.IntersectionObserver != null;
const IS_WEBXR_AR_CANDIDATE = HAS_WEBXR_HIT_TEST_API;
const IS_MOBILE = (() => {
    const userAgent = navigator.userAgent || navigator.vendor || self.opera;
    let check = false;
    // eslint-disable-next-line
    if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i
        .test(userAgent) ||
        /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i
            .test(userAgent.substr(0, 4))) {
        check = true;
    }
    return check;
})();
const IS_CHROMEOS = /\bCrOS\b/.test(navigator.userAgent);
const IS_ANDROID = /android/i.test(navigator.userAgent);
// Prior to iOS 13, detecting iOS Safari was relatively straight-forward.
// As of iOS 13, Safari on iPad (in its default configuration) reports the same
// user-agent string as Safari on desktop MacOS. Strictly speaking, we only care
// about iOS for the purposes if selecting for cases where Quick Look is known
// to be supported. However, for API correctness purposes, we must rely on
// known, detectable signals to distinguish iOS Safari from MacOS Safari. At the
// time of this writing, there are no non-iOS/iPadOS Apple devices with
// multi-touch displays.
// @see https://stackoverflow.com/questions/57765958/how-to-detect-ipad-and-ipad-os-version-in-ios-13-and-up
// @see https://forums.developer.apple.com/thread/119186
// @see https://github.com/google/model-viewer/issues/758
const IS_IOS = (/iPad|iPhone|iPod/.test(navigator.userAgent) && !self.MSStream) ||
    (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
// @see https://developer.chrome.com/multidevice/user-agent
const IS_SAFARI = /Safari\//.test(navigator.userAgent);
const IS_FIREFOX = /firefox/i.test(navigator.userAgent);
const IS_OCULUS = /OculusBrowser/.test(navigator.userAgent);
const IS_IOS_CHROME = IS_IOS && /CriOS\//.test(navigator.userAgent);
const IS_IOS_SAFARI = IS_IOS && IS_SAFARI;
const IS_SCENEVIEWER_CANDIDATE = IS_ANDROID && !IS_FIREFOX && !IS_OCULUS;
const IS_WKWEBVIEW = Boolean(window.webkit && window.webkit.messageHandlers);
// If running in iOS Safari proper, and not within a WKWebView component instance, check for ARQL feature support.
// Otherwise, if running in a WKWebView instance, check for known ARQL compatible iOS browsers, including:
// Chrome (CriOS), Edge (EdgiOS), Firefox (FxiOS), Google App (GSA), DuckDuckGo (DuckDuckGo).
// All other iOS browsers / apps will fail by default.
const IS_AR_QUICKLOOK_CANDIDATE = (() => {
    if (IS_IOS) {
        if (!IS_WKWEBVIEW) {
            const tempAnchor = document.createElement('a');
            return Boolean(tempAnchor.relList && tempAnchor.relList.supports && tempAnchor.relList.supports('ar'));
        }
        else {
            return Boolean(/CriOS\/|EdgiOS\/|FxiOS\/|GSA\/|DuckDuckGo\//.test(navigator.userAgent));
        }
    }
    else {
        return false;
    }
})();
//# sourceMappingURL=constants.js.map

/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/decorators.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/decorators.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "style": () => (/* binding */ style)
/* harmony export */ });
/* harmony import */ var _styles_evaluators__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./styles/evaluators */ "../../node_modules/@google/model-viewer/lib/styles/evaluators.js");
/* harmony import */ var _styles_parsers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./styles/parsers */ "../../node_modules/@google/model-viewer/lib/styles/parsers.js");
/* harmony import */ var _styles_style_effector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./styles/style-effector */ "../../node_modules/@google/model-viewer/lib/styles/style-effector.js");
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * The @style decorator is responsible for coordinating the conversion of a
 * CSS-like string property value into numbers that can be applied to
 * lower-level constructs. It also can optionally manage the lifecycle of a
 * StyleEffector which allows automatic updates for styles that use env() or
 * var() functions.
 *
 * The decorator is configured with Intrinsics and the property key for a
 * method that handles updates. The named update handler is invoked with the
 * result of parsing and evaluating the raw property string value. The format of
 * the evaluated result is derived from the basis of the configured Intrinsics,
 * and is always an array of numbers of fixed length.
 *
 * NOTE: This decorator depends on the property updating mechanism defined by
 * UpdatingElement as exported by the lit-element module. That means it *must*
 * be used in conjunction with the @property decorator, or equivalent
 * JavaScript.
 *
 * Supported configurations are:
 *
 *  - `intrinsics`: An Intrinsics struct that describes how to interpret a
 * serialized style attribute. For more detail on intrinsics see
 * ./styles/evaluators.ts
 *  - `updateHandler`: A string or Symbol that is the key of a method to be
 * invoked with the result of parsing and evaluating a serialized style string.
 *  - `observeEffects`: Optional, if set to true then styles that use env() will
 * cause their update handlers to be invoked every time the corresponding
 * environment variable changes (even if the style attribute itself remains
 * static).
 */
const style = (config) => {
    const observeEffects = config.observeEffects || false;
    const getIntrinsics = config.intrinsics instanceof Function ?
        config.intrinsics :
        (() => config.intrinsics);
    return (proto, propertyName) => {
        const originalUpdated = proto.updated;
        const originalConnectedCallback = proto.connectedCallback;
        const originalDisconnectedCallback = proto.disconnectedCallback;
        const $styleEffector = Symbol(`${propertyName}StyleEffector`);
        const $styleEvaluator = Symbol(`${propertyName}StyleEvaluator`);
        const $updateEvaluator = Symbol(`${propertyName}UpdateEvaluator`);
        const $evaluateAndSync = Symbol(`${propertyName}EvaluateAndSync`);
        Object.defineProperties(proto, {
            [$styleEffector]: { value: null, writable: true },
            [$styleEvaluator]: { value: null, writable: true },
            [$updateEvaluator]: {
                value: function () {
                    const ast = (0,_styles_parsers__WEBPACK_IMPORTED_MODULE_1__.parseExpressions)(this[propertyName]);
                    this[$styleEvaluator] =
                        new _styles_evaluators__WEBPACK_IMPORTED_MODULE_0__.StyleEvaluator(ast, getIntrinsics(this));
                    if (this[$styleEffector] == null && observeEffects) {
                        this[$styleEffector] =
                            new _styles_style_effector__WEBPACK_IMPORTED_MODULE_2__.StyleEffector(() => this[$evaluateAndSync]());
                    }
                    if (this[$styleEffector] != null) {
                        this[$styleEffector].observeEffectsFor(ast);
                    }
                }
            },
            [$evaluateAndSync]: {
                value: function () {
                    if (this[$styleEvaluator] == null) {
                        return;
                    }
                    const result = this[$styleEvaluator].evaluate();
                    // @see https://github.com/microsoft/TypeScript/pull/30769
                    // @see https://github.com/Microsoft/TypeScript/issues/1863
                    this[config.updateHandler](result);
                }
            },
            updated: {
                value: function (changedProperties) {
                    // Always invoke updates to styles first. This gives a class that
                    // uses this decorator the opportunity to override the effect, or
                    // respond to it, in its own implementation of `updated`.
                    if (changedProperties.has(propertyName)) {
                        this[$updateEvaluator]();
                        this[$evaluateAndSync]();
                    }
                    originalUpdated.call(this, changedProperties);
                }
            },
            connectedCallback: {
                value: function () {
                    originalConnectedCallback.call(this);
                    this.requestUpdate(propertyName, this[propertyName]);
                }
            },
            disconnectedCallback: {
                value: function () {
                    originalDisconnectedCallback.call(this);
                    if (this[$styleEffector] != null) {
                        this[$styleEffector].dispose();
                        this[$styleEffector] = null;
                    }
                }
            }
        });
    };
};
//# sourceMappingURL=decorators.js.map

/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/features/animation.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/features/animation.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnimationMixin": () => (/* binding */ AnimationMixin)
/* harmony export */ });
/* harmony import */ var lit_decorators_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit/decorators.js */ "../../node_modules/lit/decorators.js");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ "../../node_modules/three/build/three.module.js");
/* harmony import */ var _model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../model-viewer-base.js */ "../../node_modules/@google/model-viewer/lib/model-viewer-base.js");
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};



const MILLISECONDS_PER_SECOND = 1000.0;
const $changeAnimation = Symbol('changeAnimation');
const $paused = Symbol('paused');
const DEFAULT_PLAY_OPTIONS = {
    repetitions: Infinity,
    pingpong: false
};
const AnimationMixin = (ModelViewerElement) => {
    var _a;
    class AnimationModelViewerElement extends ModelViewerElement {
        constructor(...args) {
            super(args);
            this.autoplay = false;
            this.animationName = undefined;
            this.animationCrossfadeDuration = 300;
            this[_a] = true;
            this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$scene].subscribeMixerEvent('loop', (e) => {
                const count = e.action._loopCount;
                this.dispatchEvent(new CustomEvent('loop', { detail: { count } }));
            });
            this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$scene].subscribeMixerEvent('finished', () => {
                this[$paused] = true;
                this.dispatchEvent(new CustomEvent('finished'));
            });
        }
        /**
         * Returns an array
         */
        get availableAnimations() {
            if (this.loaded) {
                return this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$scene].animationNames;
            }
            return [];
        }
        get duration() {
            return this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$scene].duration;
        }
        get paused() {
            return this[$paused];
        }
        get currentTime() {
            return this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$scene].animationTime;
        }
        set currentTime(value) {
            this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$scene].animationTime = value;
            this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$needsRender]();
        }
        get timeScale() {
            return this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$scene].animationTimeScale;
        }
        set timeScale(value) {
            this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$scene].animationTimeScale = value;
        }
        pause() {
            if (this[$paused]) {
                return;
            }
            this[$paused] = true;
            this.dispatchEvent(new CustomEvent('pause'));
        }
        play(options) {
            if (this.availableAnimations.length > 0) {
                this[$paused] = false;
                this[$changeAnimation](options);
                this.dispatchEvent(new CustomEvent('play'));
            }
        }
        [(_a = $paused, _model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$onModelLoad)]() {
            super[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$onModelLoad]();
            this[$paused] = true;
            if (this.animationName != null) {
                this[$changeAnimation]();
            }
            if (this.autoplay) {
                this.play();
            }
        }
        [_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$tick](_time, delta) {
            super[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$tick](_time, delta);
            if (this[$paused] ||
                (!this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$getModelIsVisible]() && !this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$renderer].isPresenting)) {
                return;
            }
            this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$scene].updateAnimation(delta / MILLISECONDS_PER_SECOND);
            this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$needsRender]();
        }
        updated(changedProperties) {
            super.updated(changedProperties);
            if (changedProperties.has('autoplay') && this.autoplay) {
                this.play();
            }
            if (changedProperties.has('animationName')) {
                this[$changeAnimation]();
            }
        }
        [$changeAnimation](options = DEFAULT_PLAY_OPTIONS) {
            var _b;
            const repetitions = (_b = options.repetitions) !== null && _b !== void 0 ? _b : Infinity;
            const mode = options.pingpong ?
                three__WEBPACK_IMPORTED_MODULE_2__.LoopPingPong :
                (repetitions === 1 ? three__WEBPACK_IMPORTED_MODULE_2__.LoopOnce : three__WEBPACK_IMPORTED_MODULE_2__.LoopRepeat);
            this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$scene].playAnimation(this.animationName, this.animationCrossfadeDuration / MILLISECONDS_PER_SECOND, mode, repetitions);
            // If we are currently paused, we need to force a render so that
            // the scene updates to the first frame of the new animation
            if (this[$paused]) {
                this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$scene].updateAnimation(0);
                this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$needsRender]();
            }
        }
    }
    __decorate([
        (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_0__.property)({ type: Boolean })
    ], AnimationModelViewerElement.prototype, "autoplay", void 0);
    __decorate([
        (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_0__.property)({ type: String, attribute: 'animation-name' })
    ], AnimationModelViewerElement.prototype, "animationName", void 0);
    __decorate([
        (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_0__.property)({ type: Number, attribute: 'animation-crossfade-duration' })
    ], AnimationModelViewerElement.prototype, "animationCrossfadeDuration", void 0);
    return AnimationModelViewerElement;
};
//# sourceMappingURL=animation.js.map

/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/features/annotation.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/features/annotation.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnnotationMixin": () => (/* binding */ AnnotationMixin)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ "../../node_modules/three/build/three.module.js");
/* harmony import */ var _model_viewer_base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../model-viewer-base.js */ "../../node_modules/@google/model-viewer/lib/model-viewer-base.js");
/* harmony import */ var _three_components_Hotspot_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../three-components/Hotspot.js */ "../../node_modules/@google/model-viewer/lib/three-components/Hotspot.js");
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



const $hotspotMap = Symbol('hotspotMap');
const $mutationCallback = Symbol('mutationCallback');
const $observer = Symbol('observer');
const $addHotspot = Symbol('addHotspot');
const $removeHotspot = Symbol('removeHotspot');
const worldToModel = new three__WEBPACK_IMPORTED_MODULE_2__.Matrix4();
/**
 * AnnotationMixin implements a declarative API to add hotspots and annotations.
 * Child elements of the <model-viewer> element that have a slot name that
 * begins with "hotspot" and data-position and data-normal attributes in
 * the format of the camera-target attribute will be added to the scene and
 * track the specified model coordinates.
 */
const AnnotationMixin = (ModelViewerElement) => {
    var _a, _b, _c;
    class AnnotationModelViewerElement extends ModelViewerElement {
        constructor() {
            super(...arguments);
            this[_a] = new Map();
            this[_b] = (mutations) => {
                mutations.forEach((mutation) => {
                    // NOTE: Be wary that in ShadyDOM cases, the MutationRecord
                    // only has addedNodes and removedNodes (and no other details).
                    if (!(mutation instanceof MutationRecord) ||
                        mutation.type === 'childList') {
                        mutation.addedNodes.forEach((node) => {
                            this[$addHotspot](node);
                        });
                        mutation.removedNodes.forEach((node) => {
                            this[$removeHotspot](node);
                        });
                        this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_0__.$needsRender]();
                    }
                });
            };
            this[_c] = new MutationObserver(this[$mutationCallback]);
        }
        connectedCallback() {
            super.connectedCallback();
            for (let i = 0; i < this.children.length; ++i) {
                this[$addHotspot](this.children[i]);
            }
            const { ShadyDOM } = self;
            if (ShadyDOM == null) {
                this[$observer].observe(this, { childList: true });
            }
            else {
                this[$observer] =
                    ShadyDOM.observeChildren(this, this[$mutationCallback]);
            }
        }
        disconnectedCallback() {
            super.disconnectedCallback();
            const { ShadyDOM } = self;
            if (ShadyDOM == null) {
                this[$observer].disconnect();
            }
            else {
                ShadyDOM.unobserveChildren(this[$observer]);
            }
        }
        [(_a = $hotspotMap, _b = $mutationCallback, _c = $observer, _model_viewer_base_js__WEBPACK_IMPORTED_MODULE_0__.$tick)](time, delta) {
            super[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_0__.$tick](time, delta);
            const scene = this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_0__.$scene];
            const { annotationRenderer } = scene;
            const camera = scene.getCamera();
            if (scene.shouldRender()) {
                scene.updateSurfaceHotspots();
                scene.updateHotspotsVisibility(camera.position);
                annotationRenderer.domElement.style.display = '';
                annotationRenderer.render(scene, camera);
            }
        }
        /**
         * Since the data-position and data-normal attributes are not observed, use
         * this method to move a hotspot. Keep in mind that all hotspots with the
         * same slot name use a single location and the first definition takes
         * precedence, until updated with this method.
         */
        updateHotspot(config) {
            const hotspot = this[$hotspotMap].get(config.name);
            if (hotspot == null) {
                return;
            }
            hotspot.updatePosition(config.position);
            hotspot.updateNormal(config.normal);
            hotspot.surface = config.surface;
            this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_0__.$needsRender]();
        }
        /**
         * This method returns in-scene data about a requested hotspot including
         * its position in screen (canvas) space and its current visibility.
         */
        queryHotspot(name) {
            const hotspot = this[$hotspotMap].get(name);
            if (hotspot == null) {
                return null;
            }
            const position = (0,_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_0__.toVector3D)(hotspot.position);
            const normal = (0,_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_0__.toVector3D)(hotspot.normal);
            const facingCamera = hotspot.facingCamera;
            const scene = this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_0__.$scene];
            const camera = scene.getCamera();
            const vector = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();
            vector.setFromMatrixPosition(hotspot.matrixWorld);
            vector.project(camera);
            const widthHalf = scene.width / 2;
            const heightHalf = scene.height / 2;
            vector.x = (vector.x * widthHalf) + widthHalf;
            vector.y = -(vector.y * heightHalf) + heightHalf;
            const canvasPosition = (0,_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_0__.toVector3D)(new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(vector.x, vector.y, vector.z));
            if (!Number.isFinite(canvasPosition.x) ||
                !Number.isFinite(canvasPosition.y)) {
                return null;
            }
            return { position, normal, canvasPosition, facingCamera };
        }
        /**
         * This method returns the model position, normal and texture coordinate
         * of the point on the mesh corresponding to the input pixel coordinates
         * given relative to the model-viewer element. The position and normal
         * are returned as strings in the format suitable for putting in a
         * hotspot's data-position and data-normal attributes. If the mesh is
         * not hit, the result is null.
         */
        positionAndNormalFromPoint(pixelX, pixelY) {
            const scene = this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_0__.$scene];
            const ndcPosition = scene.getNDC(pixelX, pixelY);
            const hit = scene.positionAndNormalFromPoint(ndcPosition);
            if (hit == null) {
                return null;
            }
            worldToModel.copy(scene.target.matrixWorld).invert();
            const position = (0,_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_0__.toVector3D)(hit.position.applyMatrix4(worldToModel));
            const normal = (0,_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_0__.toVector3D)(hit.normal.transformDirection(worldToModel));
            let uv = null;
            if (hit.uv != null) {
                uv = (0,_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_0__.toVector2D)(hit.uv);
            }
            return { position: position, normal: normal, uv: uv };
        }
        /**
         * This method returns a dynamic hotspot ID string of the point on the mesh
         * corresponding to the input pixel coordinates given relative to the
         * model-viewer element. The ID string can be used in the data-surface
         * attribute of the hotspot to make it follow this point on the surface even
         * as the model animates. If the mesh is not hit, the result is null.
         */
        surfaceFromPoint(pixelX, pixelY) {
            const scene = this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_0__.$scene];
            const ndcPosition = scene.getNDC(pixelX, pixelY);
            return scene.surfaceFromPoint(ndcPosition);
        }
        [$addHotspot](node) {
            if (!(node instanceof HTMLElement &&
                node.slot.indexOf('hotspot') === 0)) {
                return;
            }
            let hotspot = this[$hotspotMap].get(node.slot);
            if (hotspot != null) {
                hotspot.increment();
            }
            else {
                hotspot = new _three_components_Hotspot_js__WEBPACK_IMPORTED_MODULE_1__.Hotspot({
                    name: node.slot,
                    position: node.dataset.position,
                    normal: node.dataset.normal,
                    surface: node.dataset.surface,
                });
                this[$hotspotMap].set(node.slot, hotspot);
                this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_0__.$scene].addHotspot(hotspot);
            }
            this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_0__.$scene].queueRender();
        }
        [$removeHotspot](node) {
            if (!(node instanceof HTMLElement)) {
                return;
            }
            const hotspot = this[$hotspotMap].get(node.slot);
            if (!hotspot) {
                return;
            }
            if (hotspot.decrement()) {
                this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_0__.$scene].removeHotspot(hotspot);
                this[$hotspotMap].delete(node.slot);
            }
            this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_0__.$scene].queueRender();
        }
    }
    return AnnotationModelViewerElement;
};
//# sourceMappingURL=annotation.js.map

/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/features/ar.js":
/*!******************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/features/ar.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$openIOSARQuickLook": () => (/* binding */ $openIOSARQuickLook),
/* harmony export */   "$openSceneViewer": () => (/* binding */ $openSceneViewer),
/* harmony export */   "ARMixin": () => (/* binding */ ARMixin)
/* harmony export */ });
/* harmony import */ var lit_decorators_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit/decorators.js */ "../../node_modules/lit/decorators.js");
/* harmony import */ var three_examples_jsm_exporters_USDZExporter_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! three/examples/jsm/exporters/USDZExporter.js */ "../../node_modules/three/examples/jsm/exporters/USDZExporter.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants.js */ "../../node_modules/@google/model-viewer/lib/constants.js");
/* harmony import */ var _model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../model-viewer-base.js */ "../../node_modules/@google/model-viewer/lib/model-viewer-base.js");
/* harmony import */ var _styles_deserializers_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../styles/deserializers.js */ "../../node_modules/@google/model-viewer/lib/styles/deserializers.js");
/* harmony import */ var _three_components_ARRenderer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../three-components/ARRenderer.js */ "../../node_modules/@google/model-viewer/lib/three-components/ARRenderer.js");
/* harmony import */ var _utilities_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utilities.js */ "../../node_modules/@google/model-viewer/lib/utilities.js");
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};







let isWebXRBlocked = false;
let isSceneViewerBlocked = false;
const noArViewerSigil = '#model-viewer-no-ar-fallback';
const deserializeARModes = (0,_styles_deserializers_js__WEBPACK_IMPORTED_MODULE_3__.enumerationDeserializer)(['quick-look', 'scene-viewer', 'webxr', 'none']);
const DEFAULT_AR_MODES = 'webxr scene-viewer quick-look';
const ARMode = {
    QUICK_LOOK: 'quick-look',
    SCENE_VIEWER: 'scene-viewer',
    WEBXR: 'webxr',
    NONE: 'none'
};
const $arButtonContainer = Symbol('arButtonContainer');
const $enterARWithWebXR = Symbol('enterARWithWebXR');
const $openSceneViewer = Symbol('openSceneViewer');
const $openIOSARQuickLook = Symbol('openIOSARQuickLook');
const $canActivateAR = Symbol('canActivateAR');
const $arMode = Symbol('arMode');
const $arModes = Symbol('arModes');
const $arAnchor = Symbol('arAnchor');
const $preload = Symbol('preload');
const $onARButtonContainerClick = Symbol('onARButtonContainerClick');
const $onARStatus = Symbol('onARStatus');
const $onARTracking = Symbol('onARTracking');
const $onARTap = Symbol('onARTap');
const $selectARMode = Symbol('selectARMode');
const $triggerLoad = Symbol('triggerLoad');
const ARMixin = (ModelViewerElement) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    class ARModelViewerElement extends ModelViewerElement {
        constructor() {
            super(...arguments);
            this.ar = false;
            this.arScale = 'auto';
            this.arPlacement = 'floor';
            this.arModes = DEFAULT_AR_MODES;
            this.iosSrc = null;
            this.xrEnvironment = false;
            this[_a] = false;
            // TODO: Add this to the shadow root as part of this mixin's
            // implementation:
            this[_b] = this.shadowRoot.querySelector('.ar-button');
            this[_c] = document.createElement('a');
            this[_d] = new Set();
            this[_e] = ARMode.NONE;
            this[_f] = false;
            this[_g] = (event) => {
                event.preventDefault();
                this.activateAR();
            };
            this[_h] = ({ status }) => {
                if (status === _three_components_ARRenderer_js__WEBPACK_IMPORTED_MODULE_4__.ARStatus.NOT_PRESENTING ||
                    this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$renderer].arRenderer.presentedScene === this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$scene]) {
                    this.setAttribute('ar-status', status);
                    this.dispatchEvent(new CustomEvent('ar-status', { detail: { status } }));
                    if (status === _three_components_ARRenderer_js__WEBPACK_IMPORTED_MODULE_4__.ARStatus.NOT_PRESENTING) {
                        this.removeAttribute('ar-tracking');
                    }
                    else if (status === _three_components_ARRenderer_js__WEBPACK_IMPORTED_MODULE_4__.ARStatus.SESSION_STARTED) {
                        this.setAttribute('ar-tracking', _three_components_ARRenderer_js__WEBPACK_IMPORTED_MODULE_4__.ARTracking.TRACKING);
                    }
                }
            };
            this[_j] = ({ status }) => {
                this.setAttribute('ar-tracking', status);
                this.dispatchEvent(new CustomEvent('ar-tracking', { detail: { status } }));
            };
            this[_k] = (event) => {
                if (event.data == '_apple_ar_quicklook_button_tapped') {
                    this.dispatchEvent(new CustomEvent('quick-look-button-tapped'));
                }
            };
        }
        get canActivateAR() {
            return this[$arMode] !== ARMode.NONE;
        }
        connectedCallback() {
            super.connectedCallback();
            this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$renderer].arRenderer.addEventListener('status', this[$onARStatus]);
            this.setAttribute('ar-status', _three_components_ARRenderer_js__WEBPACK_IMPORTED_MODULE_4__.ARStatus.NOT_PRESENTING);
            this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$renderer].arRenderer.addEventListener('tracking', this[$onARTracking]);
            this[$arAnchor].addEventListener('message', this[$onARTap]);
        }
        disconnectedCallback() {
            super.disconnectedCallback();
            this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$renderer].arRenderer.removeEventListener('status', this[$onARStatus]);
            this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$renderer].arRenderer.removeEventListener('tracking', this[$onARTracking]);
            this[$arAnchor].removeEventListener('message', this[$onARTap]);
        }
        update(changedProperties) {
            super.update(changedProperties);
            if (changedProperties.has('arScale')) {
                this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$scene].canScale = this.arScale !== 'fixed';
            }
            if (changedProperties.has('arPlacement')) {
                this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$scene].updateShadow();
                this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$needsRender]();
            }
            if (changedProperties.has('arModes')) {
                this[$arModes] = deserializeARModes(this.arModes);
            }
            if (changedProperties.has('ar') || changedProperties.has('arModes') ||
                changedProperties.has('src') || changedProperties.has('iosSrc')) {
                this[$selectARMode]();
            }
        }
        /**
         * Activates AR. Note that for any mode that is not WebXR-based, this
         * method most likely has to be called synchronous from a user
         * interaction handler. Otherwise, attempts to activate modes that
         * require user interaction will most likely be ignored.
         */
        async activateAR() {
            switch (this[$arMode]) {
                case ARMode.QUICK_LOOK:
                    this[$openIOSARQuickLook]();
                    break;
                case ARMode.WEBXR:
                    await this[$enterARWithWebXR]();
                    break;
                case ARMode.SCENE_VIEWER:
                    this[$openSceneViewer]();
                    break;
                default:
                    console.warn('No AR Mode can be activated. This is probably due to missing \
configuration or device capabilities');
                    break;
            }
        }
        async [(_a = $canActivateAR, _b = $arButtonContainer, _c = $arAnchor, _d = $arModes, _e = $arMode, _f = $preload, _g = $onARButtonContainerClick, _h = $onARStatus, _j = $onARTracking, _k = $onARTap, $selectARMode)]() {
            let arMode = ARMode.NONE;
            if (this.ar) {
                if (this.src != null) {
                    for (const value of this[$arModes]) {
                        if (value === 'webxr' && _constants_js__WEBPACK_IMPORTED_MODULE_1__.IS_WEBXR_AR_CANDIDATE && !isWebXRBlocked &&
                            await this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$renderer].arRenderer.supportsPresentation()) {
                            arMode = ARMode.WEBXR;
                            break;
                        }
                        if (value === 'scene-viewer' && _constants_js__WEBPACK_IMPORTED_MODULE_1__.IS_SCENEVIEWER_CANDIDATE &&
                            !isSceneViewerBlocked) {
                            arMode = ARMode.SCENE_VIEWER;
                            break;
                        }
                        if (value === 'quick-look' && _constants_js__WEBPACK_IMPORTED_MODULE_1__.IS_AR_QUICKLOOK_CANDIDATE) {
                            arMode = ARMode.QUICK_LOOK;
                            break;
                        }
                    }
                }
                // The presence of ios-src overrides the absence of quick-look
                // ar-mode.
                if (arMode === ARMode.NONE && this.iosSrc != null &&
                    _constants_js__WEBPACK_IMPORTED_MODULE_1__.IS_AR_QUICKLOOK_CANDIDATE) {
                    arMode = ARMode.QUICK_LOOK;
                }
            }
            if (arMode !== ARMode.NONE) {
                this[$arButtonContainer].classList.add('enabled');
                this[$arButtonContainer].addEventListener('click', this[$onARButtonContainerClick]);
            }
            else if (this[$arButtonContainer].classList.contains('enabled')) {
                this[$arButtonContainer].removeEventListener('click', this[$onARButtonContainerClick]);
                this[$arButtonContainer].classList.remove('enabled');
                // If AR went from working to not, notify the element.
                const status = _three_components_ARRenderer_js__WEBPACK_IMPORTED_MODULE_4__.ARStatus.FAILED;
                this.setAttribute('ar-status', status);
                this.dispatchEvent(new CustomEvent('ar-status', { detail: { status } }));
            }
            this[$arMode] = arMode;
        }
        async [$enterARWithWebXR]() {
            console.log('Attempting to present in AR with WebXR...');
            await this[$triggerLoad]();
            try {
                this[$arButtonContainer].removeEventListener('click', this[$onARButtonContainerClick]);
                const { arRenderer } = this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$renderer];
                arRenderer.placeOnWall = this.arPlacement === 'wall';
                await arRenderer.present(this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$scene], this.xrEnvironment);
            }
            catch (error) {
                console.warn('Error while trying to present in AR with WebXR');
                console.error(error);
                await this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$renderer].arRenderer.stopPresenting();
                isWebXRBlocked = true;
                console.warn('Falling back to next ar-mode');
                await this[$selectARMode]();
                this.activateAR();
            }
            finally {
                this[$selectARMode]();
            }
        }
        async [$triggerLoad]() {
            if (!this.loaded) {
                this[$preload] = true;
                this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$updateSource]();
                await (0,_utilities_js__WEBPACK_IMPORTED_MODULE_5__.waitForEvent)(this, 'load');
                this[$preload] = false;
            }
        }
        [_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$shouldAttemptPreload]() {
            return super[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$shouldAttemptPreload]() || this[$preload];
        }
        /**
         * Takes a URL and a title string, and attempts to launch Scene Viewer on
         * the current device.
         */
        [$openSceneViewer]() {
            const location = self.location.toString();
            const locationUrl = new URL(location);
            const modelUrl = new URL(this.src, location);
            if (modelUrl.hash)
                modelUrl.hash = '';
            const params = new URLSearchParams(modelUrl.search);
            locationUrl.hash = noArViewerSigil;
            // modelUrl can contain title/link/sound etc.
            params.set('mode', 'ar_preferred');
            if (!params.has('disable_occlusion')) {
                params.set('disable_occlusion', 'true');
            }
            if (this.arScale === 'fixed') {
                params.set('resizable', 'false');
            }
            if (this.arPlacement === 'wall') {
                params.set('enable_vertical_placement', 'true');
            }
            if (params.has('sound')) {
                const soundUrl = new URL(params.get('sound'), location);
                params.set('sound', soundUrl.toString());
            }
            if (params.has('link')) {
                const linkUrl = new URL(params.get('link'), location);
                params.set('link', linkUrl.toString());
            }
            const intent = `intent://arvr.google.com/scene-viewer/1.0?${params.toString() + '&file=' +
                encodeURIComponent(modelUrl
                    .toString())}#Intent;scheme=https;package=com.google.ar.core;action=android.intent.action.VIEW;S.browser_fallback_url=${encodeURIComponent(locationUrl.toString())};end;`;
            const undoHashChange = () => {
                if (self.location.hash === noArViewerSigil) {
                    isSceneViewerBlocked = true;
                    // The new history will be the current URL with a new hash.
                    // Go back one step so that we reset to the expected URL.
                    // NOTE(cdata): this should not invoke any browser-level navigation
                    // because hash-only changes modify the URL in-place without
                    // navigating:
                    self.history.back();
                    console.warn('Error while trying to present in AR with Scene Viewer');
                    console.warn('Falling back to next ar-mode');
                    this[$selectARMode]();
                    // Would be nice to activateAR() here, but webXR fails due to not
                    // seeing a user activation.
                }
            };
            self.addEventListener('hashchange', undoHashChange, { once: true });
            this[$arAnchor].setAttribute('href', intent);
            console.log('Attempting to present in AR with Scene Viewer...');
            this[$arAnchor].click();
        }
        /**
         * Takes a URL to a USDZ file and sets the appropriate fields so that
         * Safari iOS can intent to their AR Quick Look.
         */
        async [$openIOSARQuickLook]() {
            const generateUsdz = !this.iosSrc;
            this[$arButtonContainer].classList.remove('enabled');
            const objectURL = generateUsdz ? await this.prepareUSDZ() : this.iosSrc;
            const modelUrl = new URL(objectURL, self.location.toString());
            if (generateUsdz) {
                const location = self.location.toString();
                const locationUrl = new URL(location);
                const srcUrl = new URL(this.src, locationUrl);
                if (srcUrl.hash) {
                    modelUrl.hash = srcUrl.hash;
                }
            }
            if (this.arScale === 'fixed') {
                if (modelUrl.hash) {
                    modelUrl.hash += '&';
                }
                modelUrl.hash += 'allowsContentScaling=0';
            }
            const anchor = this[$arAnchor];
            anchor.setAttribute('rel', 'ar');
            const img = document.createElement('img');
            anchor.appendChild(img);
            anchor.setAttribute('href', modelUrl.toString());
            if (generateUsdz) {
                anchor.setAttribute('download', 'model.usdz');
            }
            // attach anchor to shadow DOM to ensure iOS16 ARQL banner click message event propagation 
            anchor.style.display = 'none';
            if (!anchor.isConnected)
                this.shadowRoot.appendChild(anchor);
            console.log('Attempting to present in AR with Quick Look...');
            anchor.click();
            anchor.removeChild(img);
            if (generateUsdz) {
                URL.revokeObjectURL(objectURL);
            }
            this[$arButtonContainer].classList.add('enabled');
        }
        async prepareUSDZ() {
            const updateSourceProgress = this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$progressTracker].beginActivity();
            await this[$triggerLoad]();
            const { model, shadow } = this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$scene];
            if (model == null) {
                return '';
            }
            let visible = false;
            // Remove shadow from export
            if (shadow != null) {
                visible = shadow.visible;
                shadow.visible = false;
            }
            updateSourceProgress(0.2);
            const exporter = new three_examples_jsm_exporters_USDZExporter_js__WEBPACK_IMPORTED_MODULE_6__.USDZExporter();
            const arraybuffer = await exporter.parse(model);
            const blob = new Blob([arraybuffer], {
                type: 'model/vnd.usdz+zip',
            });
            const url = URL.createObjectURL(blob);
            updateSourceProgress(1);
            if (shadow != null) {
                shadow.visible = visible;
            }
            return url;
        }
    }
    __decorate([
        (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_0__.property)({ type: Boolean, attribute: 'ar' })
    ], ARModelViewerElement.prototype, "ar", void 0);
    __decorate([
        (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_0__.property)({ type: String, attribute: 'ar-scale' })
    ], ARModelViewerElement.prototype, "arScale", void 0);
    __decorate([
        (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_0__.property)({ type: String, attribute: 'ar-placement' })
    ], ARModelViewerElement.prototype, "arPlacement", void 0);
    __decorate([
        (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_0__.property)({ type: String, attribute: 'ar-modes' })
    ], ARModelViewerElement.prototype, "arModes", void 0);
    __decorate([
        (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_0__.property)({ type: String, attribute: 'ios-src' })
    ], ARModelViewerElement.prototype, "iosSrc", void 0);
    __decorate([
        (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_0__.property)({ type: Boolean, attribute: 'xr-environment' })
    ], ARModelViewerElement.prototype, "xrEnvironment", void 0);
    return ARModelViewerElement;
};
//# sourceMappingURL=ar.js.map

/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/features/controls.js":
/*!************************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/features/controls.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$controls": () => (/* binding */ $controls),
/* harmony export */   "$fingerAnimatedContainers": () => (/* binding */ $fingerAnimatedContainers),
/* harmony export */   "$panElement": () => (/* binding */ $panElement),
/* harmony export */   "$promptAnimatedContainer": () => (/* binding */ $promptAnimatedContainer),
/* harmony export */   "$promptElement": () => (/* binding */ $promptElement),
/* harmony export */   "ControlsMixin": () => (/* binding */ ControlsMixin),
/* harmony export */   "DEFAULT_CAMERA_ORBIT": () => (/* binding */ DEFAULT_CAMERA_ORBIT),
/* harmony export */   "DEFAULT_FOV_DEG": () => (/* binding */ DEFAULT_FOV_DEG),
/* harmony export */   "DEFAULT_INTERACTION_PROMPT_THRESHOLD": () => (/* binding */ DEFAULT_INTERACTION_PROMPT_THRESHOLD),
/* harmony export */   "DEFAULT_MIN_FOV_DEG": () => (/* binding */ DEFAULT_MIN_FOV_DEG),
/* harmony export */   "INTERACTION_PROMPT": () => (/* binding */ INTERACTION_PROMPT),
/* harmony export */   "InteractionPromptStrategy": () => (/* binding */ InteractionPromptStrategy),
/* harmony export */   "InteractionPromptStyle": () => (/* binding */ InteractionPromptStyle),
/* harmony export */   "TouchAction": () => (/* binding */ TouchAction),
/* harmony export */   "cameraOrbitIntrinsics": () => (/* binding */ cameraOrbitIntrinsics),
/* harmony export */   "cameraTargetIntrinsics": () => (/* binding */ cameraTargetIntrinsics),
/* harmony export */   "fieldOfViewIntrinsics": () => (/* binding */ fieldOfViewIntrinsics)
/* harmony export */ });
/* harmony import */ var lit_decorators_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit/decorators.js */ "../../node_modules/lit/decorators.js");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! three */ "../../node_modules/three/build/three.module.js");
/* harmony import */ var _decorators_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../decorators.js */ "../../node_modules/@google/model-viewer/lib/decorators.js");
/* harmony import */ var _model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../model-viewer-base.js */ "../../node_modules/@google/model-viewer/lib/model-viewer-base.js");
/* harmony import */ var _styles_conversions_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../styles/conversions.js */ "../../node_modules/@google/model-viewer/lib/styles/conversions.js");
/* harmony import */ var _styles_evaluators_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../styles/evaluators.js */ "../../node_modules/@google/model-viewer/lib/styles/evaluators.js");
/* harmony import */ var _styles_parsers_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../styles/parsers.js */ "../../node_modules/@google/model-viewer/lib/styles/parsers.js");
/* harmony import */ var _three_components_Damper_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../three-components/Damper.js */ "../../node_modules/@google/model-viewer/lib/three-components/Damper.js");
/* harmony import */ var _three_components_SmoothControls_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../three-components/SmoothControls.js */ "../../node_modules/@google/model-viewer/lib/three-components/SmoothControls.js");
/* harmony import */ var _utilities_animation_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utilities/animation.js */ "../../node_modules/@google/model-viewer/lib/utilities/animation.js");
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};










// NOTE(cdata): The following "animation" timing functions are deliberately
// being used in favor of CSS animations. In Safari 12.1 and 13, CSS animations
// would cause the interaction prompt to glitch unexpectedly
// @see https://github.com/google/model-viewer/issues/839
const PROMPT_ANIMATION_TIME = 5000;
// For timing purposes, a "frame" is a timing agnostic relative unit of time
// and a "value" is a target value for the Frame.
const wiggle = (0,_utilities_animation_js__WEBPACK_IMPORTED_MODULE_8__.timeline)({
    initialValue: 0,
    keyframes: [
        { frames: 5, value: -1 },
        { frames: 1, value: -1 },
        { frames: 8, value: 1 },
        { frames: 1, value: 1 },
        { frames: 5, value: 0 },
        { frames: 18, value: 0 }
    ]
});
const fade = (0,_utilities_animation_js__WEBPACK_IMPORTED_MODULE_8__.timeline)({
    initialValue: 0,
    keyframes: [
        { frames: 1, value: 1 },
        { frames: 5, value: 1 },
        { frames: 1, value: 0 },
        { frames: 6, value: 0 }
    ]
});
const DEFAULT_FOV_DEG = 30;
const DEFAULT_MIN_FOV_DEG = 12;
const DEFAULT_CAMERA_ORBIT = '0deg 75deg 105%';
const DEFAULT_CAMERA_TARGET = 'auto auto auto';
const DEFAULT_FIELD_OF_VIEW = 'auto';
const MINIMUM_RADIUS_RATIO = 2.2;
const AZIMUTHAL_QUADRANT_LABELS = ['front', 'right', 'back', 'left'];
const POLAR_TRIENT_LABELS = ['upper-', '', 'lower-'];
const DEFAULT_INTERACTION_PROMPT_THRESHOLD = 3000;
const INTERACTION_PROMPT = '. Use mouse, touch or arrow keys to move.';
const InteractionPromptStrategy = {
    AUTO: 'auto',
    NONE: 'none'
};
const InteractionPromptStyle = {
    BASIC: 'basic',
    WIGGLE: 'wiggle'
};
const TouchAction = {
    PAN_Y: 'pan-y',
    PAN_X: 'pan-x',
    NONE: 'none'
};
const fieldOfViewIntrinsics = () => {
    return {
        basis: [(0,_styles_conversions_js__WEBPACK_IMPORTED_MODULE_3__.degreesToRadians)((0,_styles_parsers_js__WEBPACK_IMPORTED_MODULE_5__.numberNode)(DEFAULT_FOV_DEG, 'deg'))],
        keywords: { auto: [null] }
    };
};
const minFieldOfViewIntrinsics = () => {
    return {
        basis: [(0,_styles_conversions_js__WEBPACK_IMPORTED_MODULE_3__.degreesToRadians)((0,_styles_parsers_js__WEBPACK_IMPORTED_MODULE_5__.numberNode)(DEFAULT_MIN_FOV_DEG, 'deg'))],
        keywords: { auto: [null] }
    };
};
const cameraOrbitIntrinsics = (() => {
    const defaultTerms = (0,_styles_parsers_js__WEBPACK_IMPORTED_MODULE_5__.parseExpressions)(DEFAULT_CAMERA_ORBIT)[0]
        .terms;
    const theta = (0,_styles_conversions_js__WEBPACK_IMPORTED_MODULE_3__.normalizeUnit)(defaultTerms[0]);
    const phi = (0,_styles_conversions_js__WEBPACK_IMPORTED_MODULE_3__.normalizeUnit)(defaultTerms[1]);
    return (element) => {
        const radius = element[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$scene].idealCameraDistance();
        return {
            basis: [theta, phi, (0,_styles_parsers_js__WEBPACK_IMPORTED_MODULE_5__.numberNode)(radius, 'm')],
            keywords: { auto: [null, null, (0,_styles_parsers_js__WEBPACK_IMPORTED_MODULE_5__.numberNode)(105, '%')] }
        };
    };
})();
const minCameraOrbitIntrinsics = (element) => {
    const radius = MINIMUM_RADIUS_RATIO * element[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$scene].boundingSphere.radius;
    return {
        basis: [
            (0,_styles_parsers_js__WEBPACK_IMPORTED_MODULE_5__.numberNode)(-Infinity, 'rad'),
            (0,_styles_parsers_js__WEBPACK_IMPORTED_MODULE_5__.numberNode)(Math.PI / 8, 'rad'),
            (0,_styles_parsers_js__WEBPACK_IMPORTED_MODULE_5__.numberNode)(radius, 'm')
        ],
        keywords: { auto: [null, null, null] }
    };
};
const maxCameraOrbitIntrinsics = (element) => {
    const orbitIntrinsics = cameraOrbitIntrinsics(element);
    const evaluator = new _styles_evaluators_js__WEBPACK_IMPORTED_MODULE_4__.StyleEvaluator([], orbitIntrinsics);
    const defaultRadius = evaluator.evaluate()[2];
    return {
        basis: [
            (0,_styles_parsers_js__WEBPACK_IMPORTED_MODULE_5__.numberNode)(Infinity, 'rad'),
            (0,_styles_parsers_js__WEBPACK_IMPORTED_MODULE_5__.numberNode)(Math.PI - Math.PI / 8, 'rad'),
            (0,_styles_parsers_js__WEBPACK_IMPORTED_MODULE_5__.numberNode)(defaultRadius, 'm')
        ],
        keywords: { auto: [null, null, null] }
    };
};
const cameraTargetIntrinsics = (element) => {
    const center = element[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$scene].boundingBox.getCenter(new three__WEBPACK_IMPORTED_MODULE_9__.Vector3());
    return {
        basis: [
            (0,_styles_parsers_js__WEBPACK_IMPORTED_MODULE_5__.numberNode)(center.x, 'm'),
            (0,_styles_parsers_js__WEBPACK_IMPORTED_MODULE_5__.numberNode)(center.y, 'm'),
            (0,_styles_parsers_js__WEBPACK_IMPORTED_MODULE_5__.numberNode)(center.z, 'm')
        ],
        keywords: { auto: [null, null, null] }
    };
};
const HALF_PI = Math.PI / 2.0;
const THIRD_PI = Math.PI / 3.0;
const QUARTER_PI = HALF_PI / 2.0;
const TAU = 2.0 * Math.PI;
const $controls = Symbol('controls');
const $panElement = Symbol('panElement');
const $promptElement = Symbol('promptElement');
const $promptAnimatedContainer = Symbol('promptAnimatedContainer');
const $fingerAnimatedContainers = Symbol('fingerAnimatedContainers');
const $deferInteractionPrompt = Symbol('deferInteractionPrompt');
const $updateAria = Symbol('updateAria');
const $updateCameraForRadius = Symbol('updateCameraForRadius');
const $cancelPrompts = Symbol('cancelPrompts');
const $onChange = Symbol('onChange');
const $onPointerChange = Symbol('onPointerChange');
const $waitingToPromptUser = Symbol('waitingToPromptUser');
const $userHasInteracted = Symbol('userHasInteracted');
const $promptElementVisibleTime = Symbol('promptElementVisibleTime');
const $lastPromptOffset = Symbol('lastPromptOffset');
const $cancellationSource = Symbol('cancellationSource');
const $lastSpherical = Symbol('lastSpherical');
const $jumpCamera = Symbol('jumpCamera');
const $initialized = Symbol('initialized');
const $maintainThetaPhi = Symbol('maintainThetaPhi');
const $syncCameraOrbit = Symbol('syncCameraOrbit');
const $syncFieldOfView = Symbol('syncFieldOfView');
const $syncCameraTarget = Symbol('syncCameraTarget');
const $syncMinCameraOrbit = Symbol('syncMinCameraOrbit');
const $syncMaxCameraOrbit = Symbol('syncMaxCameraOrbit');
const $syncMinFieldOfView = Symbol('syncMinFieldOfView');
const $syncMaxFieldOfView = Symbol('syncMaxFieldOfView');
const ControlsMixin = (ModelViewerElement) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
    class ControlsModelViewerElement extends ModelViewerElement {
        constructor() {
            super(...arguments);
            this.cameraControls = false;
            this.cameraOrbit = DEFAULT_CAMERA_ORBIT;
            this.cameraTarget = DEFAULT_CAMERA_TARGET;
            this.fieldOfView = DEFAULT_FIELD_OF_VIEW;
            this.minCameraOrbit = 'auto';
            this.maxCameraOrbit = 'auto';
            this.minFieldOfView = 'auto';
            this.maxFieldOfView = 'auto';
            this.interactionPromptThreshold = DEFAULT_INTERACTION_PROMPT_THRESHOLD;
            this.interactionPrompt = InteractionPromptStrategy.AUTO;
            this.interactionPromptStyle = InteractionPromptStyle.WIGGLE;
            this.orbitSensitivity = 1;
            this.touchAction = TouchAction.NONE;
            this.disableZoom = false;
            this.disablePan = false;
            this.disableTap = false;
            this.interpolationDecay = _three_components_Damper_js__WEBPACK_IMPORTED_MODULE_6__.DECAY_MILLISECONDS;
            this[_a] = this.shadowRoot.querySelector('.interaction-prompt');
            this[_b] = this.shadowRoot.querySelector('#prompt');
            this[_c] = [
                this.shadowRoot.querySelector('#finger0'),
                this.shadowRoot.querySelector('#finger1')
            ];
            this[_d] = this.shadowRoot.querySelector('.pan-target');
            this[_e] = 0;
            this[_f] = Infinity;
            this[_g] = false;
            this[_h] = false;
            this[_j] = _three_components_SmoothControls_js__WEBPACK_IMPORTED_MODULE_7__.ChangeSource.AUTOMATIC;
            this[_k] = new _three_components_SmoothControls_js__WEBPACK_IMPORTED_MODULE_7__.SmoothControls(this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$scene].camera, this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$userInputElement], this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$scene]);
            this[_l] = new three__WEBPACK_IMPORTED_MODULE_9__.Spherical();
            this[_m] = false;
            this[_o] = false;
            this[_p] = false;
            this[_q] = () => {
                const source = this[$controls].changeSource;
                this[$cancellationSource] = source;
                if (source === _three_components_SmoothControls_js__WEBPACK_IMPORTED_MODULE_7__.ChangeSource.USER_INTERACTION) {
                    this[$userHasInteracted] = true;
                    this[$deferInteractionPrompt]();
                }
            };
            this[_r] = () => {
                this[$updateAria]();
                this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$needsRender]();
                const source = this[$controls].changeSource;
                this.dispatchEvent(new CustomEvent('camera-change', { detail: { source } }));
            };
            this[_s] = (event) => {
                if (event.type === 'pointer-change-start') {
                    this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$container].classList.add('pointer-tumbling');
                }
                else {
                    this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$container].classList.remove('pointer-tumbling');
                }
            };
        }
        get inputSensitivity() {
            return this[$controls].inputSensitivity;
        }
        set inputSensitivity(value) {
            this[$controls].inputSensitivity = value;
        }
        getCameraOrbit() {
            const { theta, phi, radius } = this[$lastSpherical];
            return {
                theta,
                phi,
                radius,
                toString() {
                    return `${this.theta}rad ${this.phi}rad ${this.radius}m`;
                }
            };
        }
        getCameraTarget() {
            return (0,_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.toVector3D)(this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$renderer].isPresenting ? this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$renderer].arRenderer.target :
                this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$scene].getTarget());
        }
        getFieldOfView() {
            return this[$controls].getFieldOfView();
        }
        // Provided so user code does not have to parse these from attributes.
        getMinimumFieldOfView() {
            return this[$controls].options.minimumFieldOfView;
        }
        getMaximumFieldOfView() {
            return this[$controls].options.maximumFieldOfView;
        }
        getIdealAspect() {
            return this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$scene].idealAspect;
        }
        jumpCameraToGoal() {
            this[$jumpCamera] = true;
            this.requestUpdate($jumpCamera, false);
        }
        resetInteractionPrompt() {
            this[$lastPromptOffset] = 0;
            this[$promptElementVisibleTime] = Infinity;
            this[$userHasInteracted] = false;
            this[$waitingToPromptUser] =
                this.interactionPrompt === InteractionPromptStrategy.AUTO &&
                    this.cameraControls;
        }
        zoom(keyPresses) {
            const event = new WheelEvent('wheel', { deltaY: -30 * keyPresses });
            this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$userInputElement].dispatchEvent(event);
        }
        connectedCallback() {
            super.connectedCallback();
            this[$controls].addEventListener('user-interaction', this[$cancelPrompts]);
            this[$controls].addEventListener('pointer-change-start', this[$onPointerChange]);
            this[$controls].addEventListener('pointer-change-end', this[$onPointerChange]);
        }
        disconnectedCallback() {
            super.disconnectedCallback();
            this[$controls].removeEventListener('user-interaction', this[$cancelPrompts]);
            this[$controls].removeEventListener('pointer-change-start', this[$onPointerChange]);
            this[$controls].removeEventListener('pointer-change-end', this[$onPointerChange]);
        }
        updated(changedProperties) {
            super.updated(changedProperties);
            const controls = this[$controls];
            const scene = this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$scene];
            if (changedProperties.has('cameraControls')) {
                if (this.cameraControls) {
                    controls.enableInteraction();
                    if (this.interactionPrompt === InteractionPromptStrategy.AUTO) {
                        this[$waitingToPromptUser] = true;
                    }
                }
                else {
                    controls.disableInteraction();
                    this[$deferInteractionPrompt]();
                }
                this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$userInputElement].setAttribute('aria-label', this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$ariaLabel]);
            }
            if (changedProperties.has('disableZoom')) {
                controls.disableZoom = this.disableZoom;
            }
            if (changedProperties.has('disablePan')) {
                controls.enablePan = !this.disablePan;
            }
            if (changedProperties.has('disableTap')) {
                controls.enableTap = !this.disableTap;
            }
            if (changedProperties.has('interactionPrompt') ||
                changedProperties.has('cameraControls') ||
                changedProperties.has('src')) {
                if (this.interactionPrompt === InteractionPromptStrategy.AUTO &&
                    this.cameraControls && !this[$userHasInteracted]) {
                    this[$waitingToPromptUser] = true;
                }
                else {
                    this[$deferInteractionPrompt]();
                }
            }
            if (changedProperties.has('interactionPromptStyle')) {
                this[$promptAnimatedContainer].style.opacity =
                    this.interactionPromptStyle == InteractionPromptStyle.BASIC ? '1' :
                        '0';
            }
            if (changedProperties.has('touchAction')) {
                const touchAction = this.touchAction;
                controls.applyOptions({ touchAction });
                controls.updateTouchActionStyle();
            }
            if (changedProperties.has('orbitSensitivity')) {
                controls.orbitSensitivity = this.orbitSensitivity;
            }
            if (changedProperties.has('interpolationDecay')) {
                controls.setDamperDecayTime(this.interpolationDecay);
                scene.setTargetDamperDecayTime(this.interpolationDecay);
            }
            if (this[$jumpCamera] === true) {
                Promise.resolve().then(() => {
                    controls.jumpToGoal();
                    scene.jumpToGoal();
                    this[$onChange]();
                    this[$jumpCamera] = false;
                });
            }
        }
        async updateFraming() {
            const scene = this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$scene];
            const oldFramedFoV = scene.adjustedFoV(scene.framedFoVDeg);
            await scene.updateFraming();
            const newFramedFoV = scene.adjustedFoV(scene.framedFoVDeg);
            const zoom = this[$controls].getFieldOfView() / oldFramedFoV;
            this[$controls].setFieldOfView(newFramedFoV * zoom);
            this[$maintainThetaPhi] = true;
            this.requestUpdate('maxFieldOfView');
            this.requestUpdate('fieldOfView');
            this.requestUpdate('minCameraOrbit');
            this.requestUpdate('maxCameraOrbit');
            this.requestUpdate('cameraOrbit');
            await this.updateComplete;
        }
        interact(duration, finger0, finger1) {
            const inputElement = this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$userInputElement];
            const fingerElements = this[$fingerAnimatedContainers];
            if (fingerElements[0].style.opacity === '1') {
                console.warn('interact() failed because an existing interaction is running.');
                return;
            }
            const xy = new Array();
            xy.push({ x: (0,_utilities_animation_js__WEBPACK_IMPORTED_MODULE_8__.timeline)(finger0.x), y: (0,_utilities_animation_js__WEBPACK_IMPORTED_MODULE_8__.timeline)(finger0.y) });
            const positions = [{ x: xy[0].x(0), y: xy[0].y(0) }];
            if (finger1 != null) {
                xy.push({ x: (0,_utilities_animation_js__WEBPACK_IMPORTED_MODULE_8__.timeline)(finger1.x), y: (0,_utilities_animation_js__WEBPACK_IMPORTED_MODULE_8__.timeline)(finger1.y) });
                positions.push({ x: xy[1].x(0), y: xy[1].y(0) });
            }
            let startTime = performance.now();
            const { width, height } = this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$scene];
            const dispatchTouches = (type) => {
                for (const [i, position] of positions.entries()) {
                    const { style } = fingerElements[i];
                    style.transform = `translateX(${width * position.x}px) translateY(${height * position.y}px)`;
                    if (type === 'pointerdown') {
                        style.opacity = '1';
                    }
                    else if (type === 'pointerup') {
                        style.opacity = '0';
                    }
                    const init = {
                        pointerId: i - 5678,
                        pointerType: 'touch',
                        target: inputElement,
                        clientX: width * position.x,
                        clientY: height * position.y,
                        altKey: true // flag that this is not a user interaction
                    };
                    inputElement.dispatchEvent(new PointerEvent(type, init));
                }
            };
            const moveTouches = () => {
                // Cancel interaction if something else moves the camera or input is
                // removed from the DOM.
                const changeSource = this[$cancellationSource];
                if (changeSource !== _three_components_SmoothControls_js__WEBPACK_IMPORTED_MODULE_7__.ChangeSource.AUTOMATIC ||
                    !inputElement.isConnected) {
                    for (const fingerElement of this[$fingerAnimatedContainers]) {
                        fingerElement.style.opacity = '0';
                    }
                    dispatchTouches('pointercancel');
                    this.dispatchEvent(new CustomEvent('interact-stopped', { detail: { source: changeSource } }));
                    document.removeEventListener('visibilitychange', onVisibilityChange);
                    return;
                }
                const time = Math.min(1, (performance.now() - startTime) / duration);
                for (const [i, position] of positions.entries()) {
                    position.x = xy[i].x(time);
                    position.y = xy[i].y(time);
                }
                dispatchTouches('pointermove');
                if (time < 1) {
                    requestAnimationFrame(moveTouches);
                }
                else {
                    dispatchTouches('pointerup');
                    this.dispatchEvent(new CustomEvent('interact-stopped', { detail: { source: _three_components_SmoothControls_js__WEBPACK_IMPORTED_MODULE_7__.ChangeSource.AUTOMATIC } }));
                    document.removeEventListener('visibilitychange', onVisibilityChange);
                }
            };
            const onVisibilityChange = () => {
                let elapsed = 0;
                if (document.visibilityState === 'hidden') {
                    elapsed = performance.now() - startTime;
                }
                else {
                    startTime = performance.now() - elapsed;
                }
            };
            document.addEventListener('visibilitychange', onVisibilityChange);
            dispatchTouches('pointerdown');
            this[$cancellationSource] = _three_components_SmoothControls_js__WEBPACK_IMPORTED_MODULE_7__.ChangeSource.AUTOMATIC;
            requestAnimationFrame(moveTouches);
        }
        [(_a = $promptElement, _b = $promptAnimatedContainer, _c = $fingerAnimatedContainers, _d = $panElement, _e = $lastPromptOffset, _f = $promptElementVisibleTime, _g = $userHasInteracted, _h = $waitingToPromptUser, _j = $cancellationSource, _k = $controls, _l = $lastSpherical, _m = $jumpCamera, _o = $initialized, _p = $maintainThetaPhi, $syncFieldOfView)](style) {
            const controls = this[$controls];
            const scene = this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$scene];
            scene.framedFoVDeg = style[0] * 180 / Math.PI;
            controls.changeSource = _three_components_SmoothControls_js__WEBPACK_IMPORTED_MODULE_7__.ChangeSource.NONE;
            controls.setFieldOfView(scene.adjustedFoV(scene.framedFoVDeg));
            this[$cancelPrompts]();
        }
        [$syncCameraOrbit](style) {
            const controls = this[$controls];
            if (this[$maintainThetaPhi]) {
                const { theta, phi } = this.getCameraOrbit();
                style[0] = theta;
                style[1] = phi;
                this[$maintainThetaPhi] = false;
            }
            controls.changeSource = _three_components_SmoothControls_js__WEBPACK_IMPORTED_MODULE_7__.ChangeSource.NONE;
            controls.setOrbit(style[0], style[1], style[2]);
            this[$cancelPrompts]();
        }
        [$syncMinCameraOrbit](style) {
            this[$controls].applyOptions({
                minimumAzimuthalAngle: style[0],
                minimumPolarAngle: style[1],
                minimumRadius: style[2]
            });
            this.jumpCameraToGoal();
        }
        [$syncMaxCameraOrbit](style) {
            this[$controls].applyOptions({
                maximumAzimuthalAngle: style[0],
                maximumPolarAngle: style[1],
                maximumRadius: style[2]
            });
            this[$updateCameraForRadius](style[2]);
            this.jumpCameraToGoal();
        }
        [$syncMinFieldOfView](style) {
            this[$controls].applyOptions({ minimumFieldOfView: style[0] * 180 / Math.PI });
            this.jumpCameraToGoal();
        }
        [$syncMaxFieldOfView](style) {
            const fov = this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$scene].adjustedFoV(style[0] * 180 / Math.PI);
            this[$controls].applyOptions({ maximumFieldOfView: fov });
            this.jumpCameraToGoal();
        }
        [$syncCameraTarget](style) {
            const [x, y, z] = style;
            if (!this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$renderer].arRenderer.isPresenting) {
                this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$scene].setTarget(x, y, z);
            }
            this[$controls].changeSource = _three_components_SmoothControls_js__WEBPACK_IMPORTED_MODULE_7__.ChangeSource.NONE;
            this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$renderer].arRenderer.updateTarget();
            this[$cancelPrompts]();
        }
        [_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$tick](time, delta) {
            super[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$tick](time, delta);
            if (this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$renderer].isPresenting || !this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$getModelIsVisible]()) {
                return;
            }
            const controls = this[$controls];
            const scene = this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$scene];
            const now = performance.now();
            if (this[$waitingToPromptUser]) {
                if (this.loaded &&
                    now > this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$loadedTime] + this.interactionPromptThreshold) {
                    this[$waitingToPromptUser] = false;
                    this[$promptElementVisibleTime] = now;
                    this[$promptElement].classList.add('visible');
                }
            }
            if (isFinite(this[$promptElementVisibleTime]) &&
                this.interactionPromptStyle === InteractionPromptStyle.WIGGLE) {
                const animationTime = ((now - this[$promptElementVisibleTime]) / PROMPT_ANIMATION_TIME) %
                    1;
                const offset = wiggle(animationTime);
                const opacity = fade(animationTime);
                this[$promptAnimatedContainer].style.opacity = `${opacity}`;
                if (offset !== this[$lastPromptOffset]) {
                    const xOffset = offset * scene.width * 0.05;
                    const deltaTheta = (offset - this[$lastPromptOffset]) * Math.PI / 16;
                    this[$promptAnimatedContainer].style.transform =
                        `translateX(${xOffset}px)`;
                    controls.changeSource = _three_components_SmoothControls_js__WEBPACK_IMPORTED_MODULE_7__.ChangeSource.AUTOMATIC;
                    controls.adjustOrbit(deltaTheta, 0, 0);
                    this[$lastPromptOffset] = offset;
                }
            }
            const cameraMoved = controls.update(time, delta);
            const targetMoved = scene.updateTarget(delta);
            if (cameraMoved || targetMoved) {
                this[$onChange]();
            }
        }
        [$deferInteractionPrompt]() {
            // Effectively cancel the timer waiting for user interaction:
            this[$waitingToPromptUser] = false;
            this[$promptElement].classList.remove('visible');
            this[$promptElementVisibleTime] = Infinity;
        }
        /**
         * Updates the camera's near and far planes to enclose the scene when
         * orbiting at the supplied radius.
         */
        [$updateCameraForRadius](radius) {
            const maximumRadius = Math.max(this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$scene].boundingSphere.radius, radius);
            const near = 0;
            const far = 2 * maximumRadius;
            this[$controls].updateNearFar(near, far);
        }
        [$updateAria]() {
            const { theta, phi } = this[$controls].getCameraSpherical(this[$lastSpherical]);
            const azimuthalQuadrant = (4 + Math.floor(((theta % TAU) + QUARTER_PI) / HALF_PI)) % 4;
            const polarTrient = Math.floor(phi / THIRD_PI);
            const azimuthalQuadrantLabel = AZIMUTHAL_QUADRANT_LABELS[azimuthalQuadrant];
            const polarTrientLabel = POLAR_TRIENT_LABELS[polarTrient];
            this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$updateStatus](`View from stage ${polarTrientLabel}${azimuthalQuadrantLabel}`);
        }
        get [_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$ariaLabel]() {
            return super[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$ariaLabel].replace(/\.$/, '') +
                (this.cameraControls ? INTERACTION_PROMPT : '');
        }
        async [_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$onResize](event) {
            const controls = this[$controls];
            const scene = this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$scene];
            const oldFramedFoV = scene.adjustedFoV(scene.framedFoVDeg);
            // The super of $onResize may update the scene's adjustedFoV, so we
            // compare the before and after to calculate the proper zoom.
            super[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$onResize](event);
            const fovRatio = scene.adjustedFoV(scene.framedFoVDeg) / oldFramedFoV;
            const fov = controls.getFieldOfView() * (isFinite(fovRatio) ? fovRatio : 1);
            controls.updateAspect(this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$scene].aspect);
            this.requestUpdate('maxFieldOfView', this.maxFieldOfView);
            await this.updateComplete;
            this[$controls].setFieldOfView(fov);
            this.jumpCameraToGoal();
        }
        [_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$onModelLoad]() {
            super[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$onModelLoad]();
            if (this[$initialized]) {
                this[$maintainThetaPhi] = true;
            }
            else {
                this[$initialized] = true;
            }
            this.requestUpdate('maxFieldOfView', this.maxFieldOfView);
            this.requestUpdate('fieldOfView', this.fieldOfView);
            this.requestUpdate('minCameraOrbit', this.minCameraOrbit);
            this.requestUpdate('maxCameraOrbit', this.maxCameraOrbit);
            this.requestUpdate('cameraOrbit', this.cameraOrbit);
            this.requestUpdate('cameraTarget', this.cameraTarget);
            this.jumpCameraToGoal();
        }
    }
    _q = $cancelPrompts, _r = $onChange, _s = $onPointerChange;
    __decorate([
        (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_0__.property)({ type: Boolean, attribute: 'camera-controls' })
    ], ControlsModelViewerElement.prototype, "cameraControls", void 0);
    __decorate([
        (0,_decorators_js__WEBPACK_IMPORTED_MODULE_1__.style)({
            intrinsics: cameraOrbitIntrinsics,
            observeEffects: true,
            updateHandler: $syncCameraOrbit
        }),
        (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_0__.property)({ type: String, attribute: 'camera-orbit', hasChanged: () => true })
    ], ControlsModelViewerElement.prototype, "cameraOrbit", void 0);
    __decorate([
        (0,_decorators_js__WEBPACK_IMPORTED_MODULE_1__.style)({
            intrinsics: cameraTargetIntrinsics,
            observeEffects: true,
            updateHandler: $syncCameraTarget
        }),
        (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_0__.property)({ type: String, attribute: 'camera-target', hasChanged: () => true })
    ], ControlsModelViewerElement.prototype, "cameraTarget", void 0);
    __decorate([
        (0,_decorators_js__WEBPACK_IMPORTED_MODULE_1__.style)({
            intrinsics: fieldOfViewIntrinsics,
            observeEffects: true,
            updateHandler: $syncFieldOfView
        }),
        (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_0__.property)({ type: String, attribute: 'field-of-view', hasChanged: () => true })
    ], ControlsModelViewerElement.prototype, "fieldOfView", void 0);
    __decorate([
        (0,_decorators_js__WEBPACK_IMPORTED_MODULE_1__.style)({
            intrinsics: minCameraOrbitIntrinsics,
            updateHandler: $syncMinCameraOrbit
        }),
        (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_0__.property)({ type: String, attribute: 'min-camera-orbit', hasChanged: () => true })
    ], ControlsModelViewerElement.prototype, "minCameraOrbit", void 0);
    __decorate([
        (0,_decorators_js__WEBPACK_IMPORTED_MODULE_1__.style)({
            intrinsics: maxCameraOrbitIntrinsics,
            updateHandler: $syncMaxCameraOrbit
        }),
        (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_0__.property)({ type: String, attribute: 'max-camera-orbit', hasChanged: () => true })
    ], ControlsModelViewerElement.prototype, "maxCameraOrbit", void 0);
    __decorate([
        (0,_decorators_js__WEBPACK_IMPORTED_MODULE_1__.style)({
            intrinsics: minFieldOfViewIntrinsics,
            updateHandler: $syncMinFieldOfView
        }),
        (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_0__.property)({ type: String, attribute: 'min-field-of-view', hasChanged: () => true })
    ], ControlsModelViewerElement.prototype, "minFieldOfView", void 0);
    __decorate([
        (0,_decorators_js__WEBPACK_IMPORTED_MODULE_1__.style)({ intrinsics: fieldOfViewIntrinsics, updateHandler: $syncMaxFieldOfView }),
        (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_0__.property)({ type: String, attribute: 'max-field-of-view', hasChanged: () => true })
    ], ControlsModelViewerElement.prototype, "maxFieldOfView", void 0);
    __decorate([
        (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_0__.property)({ type: Number, attribute: 'interaction-prompt-threshold' })
    ], ControlsModelViewerElement.prototype, "interactionPromptThreshold", void 0);
    __decorate([
        (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_0__.property)({ type: String, attribute: 'interaction-prompt' })
    ], ControlsModelViewerElement.prototype, "interactionPrompt", void 0);
    __decorate([
        (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_0__.property)({ type: String, attribute: 'interaction-prompt-style' })
    ], ControlsModelViewerElement.prototype, "interactionPromptStyle", void 0);
    __decorate([
        (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_0__.property)({ type: Number, attribute: 'orbit-sensitivity' })
    ], ControlsModelViewerElement.prototype, "orbitSensitivity", void 0);
    __decorate([
        (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_0__.property)({ type: String, attribute: 'touch-action' })
    ], ControlsModelViewerElement.prototype, "touchAction", void 0);
    __decorate([
        (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_0__.property)({ type: Boolean, attribute: 'disable-zoom' })
    ], ControlsModelViewerElement.prototype, "disableZoom", void 0);
    __decorate([
        (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_0__.property)({ type: Boolean, attribute: 'disable-pan' })
    ], ControlsModelViewerElement.prototype, "disablePan", void 0);
    __decorate([
        (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_0__.property)({ type: Boolean, attribute: 'disable-tap' })
    ], ControlsModelViewerElement.prototype, "disableTap", void 0);
    __decorate([
        (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_0__.property)({ type: Number, attribute: 'interpolation-decay' })
    ], ControlsModelViewerElement.prototype, "interpolationDecay", void 0);
    return ControlsModelViewerElement;
};
//# sourceMappingURL=controls.js.map

/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/features/environment.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/features/environment.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$currentBackground": () => (/* binding */ $currentBackground),
/* harmony export */   "$currentEnvironmentMap": () => (/* binding */ $currentEnvironmentMap),
/* harmony export */   "$updateEnvironment": () => (/* binding */ $updateEnvironment),
/* harmony export */   "BASE_OPACITY": () => (/* binding */ BASE_OPACITY),
/* harmony export */   "EnvironmentMixin": () => (/* binding */ EnvironmentMixin)
/* harmony export */ });
/* harmony import */ var lit_decorators_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit/decorators.js */ "../../node_modules/lit/decorators.js");
/* harmony import */ var _model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../model-viewer-base.js */ "../../node_modules/@google/model-viewer/lib/model-viewer-base.js");
/* harmony import */ var _utilities_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utilities.js */ "../../node_modules/@google/model-viewer/lib/utilities.js");
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};



const BASE_OPACITY = 0.5;
const DEFAULT_SHADOW_INTENSITY = 0.0;
const DEFAULT_SHADOW_SOFTNESS = 1.0;
const DEFAULT_EXPOSURE = 1.0;
const $currentEnvironmentMap = Symbol('currentEnvironmentMap');
const $currentBackground = Symbol('currentBackground');
const $updateEnvironment = Symbol('updateEnvironment');
const $cancelEnvironmentUpdate = Symbol('cancelEnvironmentUpdate');
const EnvironmentMixin = (ModelViewerElement) => {
    var _a, _b, _c;
    class EnvironmentModelViewerElement extends ModelViewerElement {
        constructor() {
            super(...arguments);
            this.environmentImage = null;
            this.skyboxImage = null;
            this.shadowIntensity = DEFAULT_SHADOW_INTENSITY;
            this.shadowSoftness = DEFAULT_SHADOW_SOFTNESS;
            this.exposure = DEFAULT_EXPOSURE;
            this[_a] = null;
            this[_b] = null;
            this[_c] = null;
        }
        updated(changedProperties) {
            super.updated(changedProperties);
            if (changedProperties.has('shadowIntensity')) {
                this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$scene].setShadowIntensity(this.shadowIntensity * BASE_OPACITY);
                this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$needsRender]();
            }
            if (changedProperties.has('shadowSoftness')) {
                this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$scene].setShadowSoftness(this.shadowSoftness);
                this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$needsRender]();
            }
            if (changedProperties.has('exposure')) {
                this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$scene].exposure = this.exposure;
                this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$needsRender]();
            }
            if ((changedProperties.has('environmentImage') ||
                changedProperties.has('skyboxImage')) &&
                this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$shouldAttemptPreload]()) {
                this[$updateEnvironment]();
            }
        }
        hasBakedShadow() {
            return this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$scene].bakedShadows.size > 0;
        }
        async [(_a = $currentEnvironmentMap, _b = $currentBackground, _c = $cancelEnvironmentUpdate, $updateEnvironment)]() {
            const { skyboxImage, environmentImage } = this;
            if (this[$cancelEnvironmentUpdate] != null) {
                this[$cancelEnvironmentUpdate]();
                this[$cancelEnvironmentUpdate] = null;
            }
            const { textureUtils } = this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$renderer];
            if (textureUtils == null) {
                return;
            }
            const updateEnvProgress = this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$progressTracker].beginActivity();
            try {
                const { environmentMap, skybox } = await textureUtils.generateEnvironmentMapAndSkybox((0,_utilities_js__WEBPACK_IMPORTED_MODULE_2__.deserializeUrl)(skyboxImage), environmentImage, (progress) => updateEnvProgress((0,_utilities_js__WEBPACK_IMPORTED_MODULE_2__.clamp)(progress, 0, 1)));
                if (this[$currentEnvironmentMap] !== environmentMap) {
                    this[$currentEnvironmentMap] = environmentMap;
                    this.dispatchEvent(new CustomEvent('environment-change'));
                }
                if (skybox != null) {
                    // When using the same environment and skybox, use the environment as
                    // it gives HDR filtering.
                    this[$currentBackground] =
                        skybox.name === environmentMap.name ? environmentMap : skybox;
                }
                else {
                    this[$currentBackground] = null;
                }
                this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$scene].setEnvironmentAndSkybox(this[$currentEnvironmentMap], this[$currentBackground]);
                this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$scene].dispatchEvent({ type: 'envmap-update' });
            }
            catch (errorOrPromise) {
                if (errorOrPromise instanceof Error) {
                    this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$scene].setEnvironmentAndSkybox(null, null);
                    throw errorOrPromise;
                }
            }
            finally {
                updateEnvProgress(1.0);
            }
        }
    }
    __decorate([
        (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_0__.property)({ type: String, attribute: 'environment-image' })
    ], EnvironmentModelViewerElement.prototype, "environmentImage", void 0);
    __decorate([
        (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_0__.property)({ type: String, attribute: 'skybox-image' })
    ], EnvironmentModelViewerElement.prototype, "skyboxImage", void 0);
    __decorate([
        (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_0__.property)({ type: Number, attribute: 'shadow-intensity' })
    ], EnvironmentModelViewerElement.prototype, "shadowIntensity", void 0);
    __decorate([
        (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_0__.property)({ type: Number, attribute: 'shadow-softness' })
    ], EnvironmentModelViewerElement.prototype, "shadowSoftness", void 0);
    __decorate([
        (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_0__.property)({
            type: Number,
        })
    ], EnvironmentModelViewerElement.prototype, "exposure", void 0);
    return EnvironmentModelViewerElement;
};
//# sourceMappingURL=environment.js.map

/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/features/loading.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/features/loading.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$defaultPosterElement": () => (/* binding */ $defaultPosterElement),
/* harmony export */   "$defaultProgressBarElement": () => (/* binding */ $defaultProgressBarElement),
/* harmony export */   "$posterContainerElement": () => (/* binding */ $posterContainerElement),
/* harmony export */   "LoadingMixin": () => (/* binding */ LoadingMixin),
/* harmony export */   "PROGRESS_BAR_UPDATE_THRESHOLD": () => (/* binding */ PROGRESS_BAR_UPDATE_THRESHOLD)
/* harmony export */ });
/* harmony import */ var lit_decorators_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit/decorators.js */ "../../node_modules/lit/decorators.js");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three */ "../../node_modules/three/build/three.module.js");
/* harmony import */ var _model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../model-viewer-base.js */ "../../node_modules/@google/model-viewer/lib/model-viewer-base.js");
/* harmony import */ var _three_components_CachingGLTFLoader_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../three-components/CachingGLTFLoader.js */ "../../node_modules/@google/model-viewer/lib/three-components/CachingGLTFLoader.js");
/* harmony import */ var _three_components_Renderer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../three-components/Renderer.js */ "../../node_modules/@google/model-viewer/lib/three-components/Renderer.js");
/* harmony import */ var _utilities_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utilities.js */ "../../node_modules/@google/model-viewer/lib/utilities.js");
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};






const PROGRESS_BAR_UPDATE_THRESHOLD = 100;
const DEFAULT_DRACO_DECODER_LOCATION = 'https://www.gstatic.com/draco/versioned/decoders/1.5.6/';
const DEFAULT_KTX2_TRANSCODER_LOCATION = 'https://www.gstatic.com/basis-universal/versioned/2021-04-15-ba1c3e4/';
const DEFAULT_LOTTIE_LOADER_LOCATION = 'https://cdn.jsdelivr.net/npm/three@0.149.0/examples/jsm/loaders/LottieLoader.js';
const RevealStrategy = {
    AUTO: 'auto',
    MANUAL: 'manual'
};
const LoadingStrategy = {
    AUTO: 'auto',
    LAZY: 'lazy',
    EAGER: 'eager'
};
const $defaultProgressBarElement = Symbol('defaultProgressBarElement');
const $posterContainerElement = Symbol('posterContainerElement');
const $defaultPosterElement = Symbol('defaultPosterElement');
const $shouldDismissPoster = Symbol('shouldDismissPoster');
const $hidePoster = Symbol('hidePoster');
const $modelIsRevealed = Symbol('modelIsRevealed');
const $updateProgressBar = Symbol('updateProgressBar');
const $ariaLabelCallToAction = Symbol('ariaLabelCallToAction');
const $onProgress = Symbol('onProgress');
/**
 * LoadingMixin implements features related to lazy loading, as well as
 * presentation details related to the pre-load / pre-render presentation of a
 * <model-viewer>
 *
 * This mixin implements support for models with DRACO-compressed meshes.
 * The DRACO decoder will be loaded on-demand if a glTF that uses the DRACO mesh
 * compression extension is encountered.
 *
 * By default, the DRACO decoder will be loaded from a Google CDN. It is
 * possible to customize where the decoder is loaded from by defining a global
 * configuration option for `<model-viewer>` like so:
 *
 * ```html
 * <script>
 * self.ModelViewerElement = self.ModelViewerElement || {};
 * self.ModelViewerElement.dracoDecoderLocation =
 *     'http://example.com/location/of/draco/decoder/files/';
 * </script>
 * ```
 *
 * Note that the above configuration strategy must be performed *before* the
 * first `<model-viewer>` element is created in the browser. The configuration
 * can be done anywhere, but the easiest way to ensure it is done at the right
 * time is to do it in the `<head>` of the HTML document. This is the
 * recommended way to set the location because it is most compatible with
 * scenarios where the `<model-viewer>` library is lazily loaded.
 *
 * If you absolutely have to set the DRACO decoder location *after* the first
 * `<model-viewer>` element is created, you can do it this way:
 *
 * ```html
 * <script>
 * const ModelViewerElement = customElements.get('model-viewer');
 * ModelViewerElement.dracoDecoderLocation =
 *     'http://example.com/location/of/draco/decoder/files/';
 * </script>
 * ```
 *
 * Note that the above configuration approach will not work until *after*
 * `<model-viewer>` is defined in the browser. Also note that this configuration
 * *must* be set *before* the first DRACO model is fully loaded.
 *
 * It is recommended that users who intend to take advantage of DRACO mesh
 * compression consider whether or not it is acceptable for their use case to
 * have code side-loaded from a Google CDN. If it is not acceptable, then the
 * location must be customized before loading any DRACO models in order to cause
 * the decoder to be loaded from an alternative, acceptable location.
 */
const LoadingMixin = (ModelViewerElement) => {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    class LoadingModelViewerElement extends ModelViewerElement {
        constructor(...args) {
            super(...args);
            /**
             * A URL pointing to the image to use as a poster in scenarios where the
             * <model-viewer> is not ready to reveal a rendered model to the viewer.
             */
            this.poster = null;
            /**
             * An enumerable attribute describing under what conditions the
             * <model-viewer> should reveal a model to the viewer.
             *
             * The default value is "auto". The only supported alternative values is
             * "manual".
             */
            this.reveal = RevealStrategy.AUTO;
            /**
             * An enumerable attribute describing under what conditions the
             * <model-viewer> should preload a model.
             *
             * The default value is "auto". The only supported alternative values are
             * "lazy" and "eager". Auto is equivalent to lazy, which loads the model
             * when it is near the viewport for reveal = "auto", and when interacted
             * with for reveal = "interaction". Eager loads the model immediately.
             */
            this.loading = LoadingStrategy.AUTO;
            this[_a] = false;
            this[_b] = false;
            // TODO: Add this to the shadow root as part of this mixin's
            // implementation:
            this[_c] = this.shadowRoot.querySelector('.slot.poster');
            this[_d] = this.shadowRoot.querySelector('#default-poster');
            this[_e] = this.shadowRoot.querySelector('#default-progress-bar > .bar');
            this[_f] = this[$defaultPosterElement].getAttribute('aria-label');
            this[_g] = (0,_utilities_js__WEBPACK_IMPORTED_MODULE_4__.throttle)((progress) => {
                const parentNode = this[$defaultProgressBarElement].parentNode;
                requestAnimationFrame(() => {
                    this[$defaultProgressBarElement].style.transform =
                        `scaleX(${progress})`;
                    if (progress === 0) {
                        // NOTE(cdata): We remove and re-append the progress bar in this
                        // condition so that the progress bar does not appear to
                        // transition backwards from the right when we reset to 0 (or
                        // otherwise <1) progress after having already reached 1 progress
                        // previously.
                        parentNode.removeChild(this[$defaultProgressBarElement]);
                        parentNode.appendChild(this[$defaultProgressBarElement]);
                    }
                    // NOTE(cdata): IE11 does not properly respect the second parameter
                    // of classList.toggle, which this implementation originally used.
                    // @see https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11865865/
                    if (progress === 1.0) {
                        this[$defaultProgressBarElement].classList.add('hide');
                    }
                    else {
                        this[$defaultProgressBarElement].classList.remove('hide');
                    }
                });
            }, PROGRESS_BAR_UPDATE_THRESHOLD);
            this[_h] = (event) => {
                const progress = event.detail.totalProgress;
                if (progress === 1.0) {
                    this[$updateProgressBar].flush();
                    if (this.loaded &&
                        (this[$shouldDismissPoster] ||
                            this.reveal === RevealStrategy.AUTO)) {
                        this[$hidePoster]();
                    }
                }
                this[$updateProgressBar](progress);
                this.dispatchEvent(new CustomEvent('progress', { detail: { totalProgress: progress } }));
            };
            const ModelViewerElement = self.ModelViewerElement || {};
            const dracoDecoderLocation = ModelViewerElement.dracoDecoderLocation ||
                DEFAULT_DRACO_DECODER_LOCATION;
            _three_components_CachingGLTFLoader_js__WEBPACK_IMPORTED_MODULE_2__.CachingGLTFLoader.setDRACODecoderLocation(dracoDecoderLocation);
            const ktx2TranscoderLocation = ModelViewerElement.ktx2TranscoderLocation ||
                DEFAULT_KTX2_TRANSCODER_LOCATION;
            _three_components_CachingGLTFLoader_js__WEBPACK_IMPORTED_MODULE_2__.CachingGLTFLoader.setKTX2TranscoderLocation(ktx2TranscoderLocation);
            if (ModelViewerElement.meshoptDecoderLocation) {
                _three_components_CachingGLTFLoader_js__WEBPACK_IMPORTED_MODULE_2__.CachingGLTFLoader.setMeshoptDecoderLocation(ModelViewerElement.meshoptDecoderLocation);
            }
            const lottieLoaderLocation = ModelViewerElement.lottieLoaderLocation ||
                DEFAULT_LOTTIE_LOADER_LOCATION;
            _three_components_Renderer_js__WEBPACK_IMPORTED_MODULE_3__.Renderer.singleton.textureUtils.lottieLoaderUrl = lottieLoaderLocation;
        }
        static set dracoDecoderLocation(value) {
            _three_components_CachingGLTFLoader_js__WEBPACK_IMPORTED_MODULE_2__.CachingGLTFLoader.setDRACODecoderLocation(value);
        }
        static get dracoDecoderLocation() {
            return _three_components_CachingGLTFLoader_js__WEBPACK_IMPORTED_MODULE_2__.CachingGLTFLoader.getDRACODecoderLocation();
        }
        static set ktx2TranscoderLocation(value) {
            _three_components_CachingGLTFLoader_js__WEBPACK_IMPORTED_MODULE_2__.CachingGLTFLoader.setKTX2TranscoderLocation(value);
        }
        static get ktx2TranscoderLocation() {
            return _three_components_CachingGLTFLoader_js__WEBPACK_IMPORTED_MODULE_2__.CachingGLTFLoader.getKTX2TranscoderLocation();
        }
        static set meshoptDecoderLocation(value) {
            _three_components_CachingGLTFLoader_js__WEBPACK_IMPORTED_MODULE_2__.CachingGLTFLoader.setMeshoptDecoderLocation(value);
        }
        static get meshoptDecoderLocation() {
            return _three_components_CachingGLTFLoader_js__WEBPACK_IMPORTED_MODULE_2__.CachingGLTFLoader.getMeshoptDecoderLocation();
        }
        static set lottieLoaderLocation(value) {
            _three_components_Renderer_js__WEBPACK_IMPORTED_MODULE_3__.Renderer.singleton.textureUtils.lottieLoaderUrl = value;
        }
        static get lottieLoaderLocation() {
            return _three_components_Renderer_js__WEBPACK_IMPORTED_MODULE_3__.Renderer.singleton.textureUtils.lottieLoaderUrl;
        }
        /**
         * If provided, the callback will be passed each resource URL before a
         * request is sent. The callback may return the original URL, or a new URL
         * to override loading behavior. This behavior can be used to load assets
         * from .ZIP files, drag-and-drop APIs, and Data URIs.
         */
        static mapURLs(callback) {
            _three_components_Renderer_js__WEBPACK_IMPORTED_MODULE_3__.Renderer.singleton.loader[_three_components_CachingGLTFLoader_js__WEBPACK_IMPORTED_MODULE_2__.$loader].manager.setURLModifier(callback);
        }
        /**
         * Dismisses the poster, causing the model to load and render if
         * necessary. This is currently effectively the same as interacting with
         * the poster via user input.
         */
        dismissPoster() {
            if (this.loaded) {
                this[$hidePoster]();
            }
            else {
                this[$shouldDismissPoster] = true;
                this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$updateSource]();
            }
        }
        /**
         * Displays the poster, hiding the 3D model. If this is called after the 3D
         * model has been revealed, then it must be dismissed by a call to
         * dismissPoster().
         */
        showPoster() {
            const posterContainerElement = this[$posterContainerElement];
            if (posterContainerElement.classList.contains('show')) {
                return;
            }
            posterContainerElement.classList.add('show');
            this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$userInputElement].classList.remove('show');
            const defaultPosterElement = this[$defaultPosterElement];
            defaultPosterElement.removeAttribute('tabindex');
            defaultPosterElement.removeAttribute('aria-hidden');
            const oldVisibility = this.modelIsVisible;
            this[$modelIsRevealed] = false;
            this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$announceModelVisibility](oldVisibility);
        }
        /**
         * Returns the model's bounding box dimensions in meters, independent of
         * turntable rotation.
         */
        getDimensions() {
            return (0,_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.toVector3D)(this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$scene].size);
        }
        getBoundingBoxCenter() {
            return (0,_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.toVector3D)(this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$scene].boundingBox.getCenter(new three__WEBPACK_IMPORTED_MODULE_5__.Vector3()));
        }
        connectedCallback() {
            super.connectedCallback();
            if (!this.loaded) {
                this.showPoster();
            }
            this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$progressTracker].addEventListener('progress', this[$onProgress]);
        }
        disconnectedCallback() {
            super.disconnectedCallback();
            this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$progressTracker].removeEventListener('progress', this[$onProgress]);
        }
        async updated(changedProperties) {
            super.updated(changedProperties);
            if (changedProperties.has('poster') && this.poster != null) {
                this[$defaultPosterElement].style.backgroundImage =
                    `url(${this.poster})`;
            }
            if (changedProperties.has('alt')) {
                this[$defaultPosterElement].setAttribute('aria-label', this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$altDefaulted]);
            }
            if (changedProperties.has('reveal') || changedProperties.has('loading')) {
                this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$updateSource]();
            }
        }
        [(_a = $modelIsRevealed, _b = $shouldDismissPoster, _c = $posterContainerElement, _d = $defaultPosterElement, _e = $defaultProgressBarElement, _f = $ariaLabelCallToAction, _g = $updateProgressBar, _h = $onProgress, _model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$shouldAttemptPreload)]() {
            return !!this.src &&
                (this[$shouldDismissPoster] ||
                    this.loading === LoadingStrategy.EAGER ||
                    (this.reveal === RevealStrategy.AUTO && this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$isElementInViewport]));
        }
        [$hidePoster]() {
            this[$shouldDismissPoster] = false;
            const posterContainerElement = this[$posterContainerElement];
            if (!posterContainerElement.classList.contains('show')) {
                return;
            }
            posterContainerElement.classList.remove('show');
            this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$userInputElement].classList.add('show');
            const oldVisibility = this.modelIsVisible;
            this[$modelIsRevealed] = true;
            this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$announceModelVisibility](oldVisibility);
            const root = this.getRootNode();
            // If the <model-viewer> is still focused, forward the focus to
            // the canvas that has just been revealed
            if (root && root.activeElement === this) {
                this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$userInputElement].focus();
            }
            // Ensure that the poster is no longer focusable or visible to
            // screen readers
            const defaultPosterElement = this[$defaultPosterElement];
            defaultPosterElement.setAttribute('aria-hidden', 'true');
            defaultPosterElement.tabIndex = -1;
            this.dispatchEvent(new CustomEvent('poster-dismissed'));
        }
        [_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$getModelIsVisible]() {
            return super[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$getModelIsVisible]() && this[$modelIsRevealed];
        }
    }
    __decorate([
        (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_0__.property)({ type: String })
    ], LoadingModelViewerElement.prototype, "poster", void 0);
    __decorate([
        (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_0__.property)({ type: String })
    ], LoadingModelViewerElement.prototype, "reveal", void 0);
    __decorate([
        (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_0__.property)({ type: String })
    ], LoadingModelViewerElement.prototype, "loading", void 0);
    return LoadingModelViewerElement;
};
//# sourceMappingURL=loading.js.map

/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/features/scene-graph.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/features/scene-graph.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$currentGLTF": () => (/* binding */ $currentGLTF),
/* harmony export */   "$model": () => (/* binding */ $model),
/* harmony export */   "$originalGltfJson": () => (/* binding */ $originalGltfJson),
/* harmony export */   "SceneGraphMixin": () => (/* binding */ SceneGraphMixin)
/* harmony export */ });
/* harmony import */ var lit_decorators_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit/decorators.js */ "../../node_modules/lit/decorators.js");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three */ "../../node_modules/three/build/three.module.js");
/* harmony import */ var three_examples_jsm_exporters_GLTFExporter_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! three/examples/jsm/exporters/GLTFExporter.js */ "../../node_modules/three/examples/jsm/exporters/GLTFExporter.js");
/* harmony import */ var _model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../model-viewer-base.js */ "../../node_modules/@google/model-viewer/lib/model-viewer-base.js");
/* harmony import */ var _three_components_gltf_instance_VariantMaterialExporterPlugin__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../three-components/gltf-instance/VariantMaterialExporterPlugin */ "../../node_modules/@google/model-viewer/lib/three-components/gltf-instance/VariantMaterialExporterPlugin.js");
/* harmony import */ var _scene_graph_model_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./scene-graph/model.js */ "../../node_modules/@google/model-viewer/lib/features/scene-graph/model.js");
/* harmony import */ var _scene_graph_texture__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./scene-graph/texture */ "../../node_modules/@google/model-viewer/lib/features/scene-graph/texture.js");
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};







const $currentGLTF = Symbol('currentGLTF');
const $originalGltfJson = Symbol('originalGltfJson');
const $model = Symbol('model');
const $getOnUpdateMethod = Symbol('getOnUpdateMethod');
const $buildTexture = Symbol('buildTexture');
/**
 * SceneGraphMixin manages exposes a model API in order to support operations on
 * the <model-viewer> scene graph.
 */
const SceneGraphMixin = (ModelViewerElement) => {
    var _a, _b, _c;
    class SceneGraphModelViewerElement extends ModelViewerElement {
        constructor() {
            super(...arguments);
            this[_a] = undefined;
            this[_b] = null;
            this[_c] = null;
            this.variantName = null;
            this.orientation = '0 0 0';
            this.scale = '1 1 1';
        }
        // Scene-graph API:
        /** @export */
        get model() {
            return this[$model];
        }
        get availableVariants() {
            return this.model ? this.model[_scene_graph_model_js__WEBPACK_IMPORTED_MODULE_3__.$availableVariants]() : [];
        }
        /**
         * Returns a deep copy of the gltf JSON as loaded. It will not reflect
         * changes to the scene-graph, nor will editing it have any effect.
         */
        get originalGltfJson() {
            return this[$originalGltfJson];
        }
        [(_a = $model, _b = $currentGLTF, _c = $originalGltfJson, $getOnUpdateMethod)]() {
            return () => {
                this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$needsRender]();
            };
        }
        [$buildTexture](texture) {
            // Applies glTF default settings.
            texture.encoding = three__WEBPACK_IMPORTED_MODULE_5__.sRGBEncoding;
            texture.wrapS = three__WEBPACK_IMPORTED_MODULE_5__.RepeatWrapping;
            texture.wrapT = three__WEBPACK_IMPORTED_MODULE_5__.RepeatWrapping;
            return new _scene_graph_texture__WEBPACK_IMPORTED_MODULE_4__.Texture(this[$getOnUpdateMethod](), texture);
        }
        async createTexture(uri, type = 'image/png') {
            const { textureUtils } = this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$renderer];
            const texture = await textureUtils.loadImage(uri);
            texture.userData.mimeType = type;
            return this[$buildTexture](texture);
        }
        async createLottieTexture(uri, quality = 1) {
            const { textureUtils } = this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$renderer];
            const texture = await textureUtils.loadLottie(uri, quality);
            return this[$buildTexture](texture);
        }
        createVideoTexture(uri) {
            const video = document.createElement('video');
            video.src = uri;
            video.muted = true;
            video.playsInline = true;
            video.loop = true;
            video.play();
            const texture = new three__WEBPACK_IMPORTED_MODULE_5__.VideoTexture(video);
            return this[$buildTexture](texture);
        }
        createCanvasTexture() {
            const canvas = document.createElement('canvas');
            const texture = new three__WEBPACK_IMPORTED_MODULE_5__.CanvasTexture(canvas);
            return this[$buildTexture](texture);
        }
        async updated(changedProperties) {
            super.updated(changedProperties);
            if (changedProperties.has('variantName')) {
                const updateVariantProgress = this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$progressTracker].beginActivity();
                updateVariantProgress(0.1);
                const model = this[$model];
                const { variantName } = this;
                if (model != null) {
                    await model[_scene_graph_model_js__WEBPACK_IMPORTED_MODULE_3__.$switchVariant](variantName);
                    this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$needsRender]();
                    this.dispatchEvent(new CustomEvent('variant-applied'));
                }
                updateVariantProgress(1.0);
            }
            if (changedProperties.has('orientation') ||
                changedProperties.has('scale')) {
                if (!this.loaded) {
                    return;
                }
                const scene = this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$scene];
                scene.applyTransform();
                scene.updateBoundingBox();
                scene.updateShadow();
                this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$renderer].arRenderer.onUpdateScene();
                this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$needsRender]();
            }
        }
        [_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$onModelLoad]() {
            super[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$onModelLoad]();
            const { currentGLTF } = this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$scene];
            if (currentGLTF != null) {
                const { correlatedSceneGraph } = currentGLTF;
                if (correlatedSceneGraph != null &&
                    currentGLTF !== this[$currentGLTF]) {
                    this[$model] =
                        new _scene_graph_model_js__WEBPACK_IMPORTED_MODULE_3__.Model(correlatedSceneGraph, this[$getOnUpdateMethod]());
                    this[$originalGltfJson] =
                        JSON.parse(JSON.stringify(correlatedSceneGraph.gltf));
                }
                // KHR_materials_variants extension spec:
                // https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_variants
                if ('variants' in currentGLTF.userData) {
                    this.requestUpdate('variantName');
                }
            }
            this[$currentGLTF] = currentGLTF;
        }
        /** @export */
        async exportScene(options) {
            const scene = this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$scene];
            return new Promise(async (resolve, reject) => {
                // Defaults
                const opts = {
                    binary: true,
                    onlyVisible: true,
                    maxTextureSize: Infinity,
                    includeCustomExtensions: false,
                    forceIndices: false
                };
                Object.assign(opts, options);
                // Not configurable
                opts.animations = scene.animations;
                opts.truncateDrawRange = true;
                const shadow = scene.shadow;
                let visible = false;
                // Remove shadow from export
                if (shadow != null) {
                    visible = shadow.visible;
                    shadow.visible = false;
                }
                await this[$model][_scene_graph_model_js__WEBPACK_IMPORTED_MODULE_3__.$prepareVariantsForExport]();
                const exporter = new three_examples_jsm_exporters_GLTFExporter_js__WEBPACK_IMPORTED_MODULE_6__.GLTFExporter()
                    .register((writer) => new _three_components_gltf_instance_VariantMaterialExporterPlugin__WEBPACK_IMPORTED_MODULE_2__["default"](writer));
                exporter.parse(scene.model, (gltf) => {
                    return resolve(new Blob([opts.binary ? gltf : JSON.stringify(gltf)], {
                        type: opts.binary ? 'application/octet-stream' :
                            'application/json'
                    }));
                }, () => {
                    return reject('glTF export failed');
                }, opts);
                if (shadow != null) {
                    shadow.visible = visible;
                }
            });
        }
        materialFromPoint(pixelX, pixelY) {
            const model = this[$model];
            if (model == null) {
                return null;
            }
            const scene = this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$scene];
            const ndcCoords = scene.getNDC(pixelX, pixelY);
            const hit = scene.hitFromPoint(ndcCoords);
            if (hit == null || hit.face == null) {
                return null;
            }
            return model[_scene_graph_model_js__WEBPACK_IMPORTED_MODULE_3__.$materialFromPoint](hit);
        }
    }
    __decorate([
        (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_0__.property)({ type: String, attribute: 'variant-name' })
    ], SceneGraphModelViewerElement.prototype, "variantName", void 0);
    __decorate([
        (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_0__.property)({ type: String, attribute: 'orientation' })
    ], SceneGraphModelViewerElement.prototype, "orientation", void 0);
    __decorate([
        (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_0__.property)({ type: String, attribute: 'scale' })
    ], SceneGraphModelViewerElement.prototype, "scale", void 0);
    return SceneGraphModelViewerElement;
};
//# sourceMappingURL=scene-graph.js.map

/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/features/scene-graph/image.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/features/scene-graph/image.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$applyTexture": () => (/* binding */ $applyTexture),
/* harmony export */   "$threeTexture": () => (/* binding */ $threeTexture),
/* harmony export */   "Image": () => (/* binding */ Image)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ "../../node_modules/three/build/three.module.js");
/* harmony import */ var _model_viewer_base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../model-viewer-base.js */ "../../node_modules/@google/model-viewer/lib/model-viewer-base.js");
/* harmony import */ var _three_components_Renderer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../three-components/Renderer.js */ "../../node_modules/@google/model-viewer/lib/three-components/Renderer.js");
/* harmony import */ var _three_dom_element_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./three-dom-element.js */ "../../node_modules/@google/model-viewer/lib/features/scene-graph/three-dom-element.js");
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




const quadMaterial = new three__WEBPACK_IMPORTED_MODULE_3__.MeshBasicMaterial();
const quad = new three__WEBPACK_IMPORTED_MODULE_3__.PlaneGeometry(2, 2);
let adhocNum = 0;
const $threeTexture = Symbol('threeTexture');
const $applyTexture = Symbol('applyTexture');
/**
 * Image facade implementation for Three.js textures
 */
class Image extends _three_dom_element_js__WEBPACK_IMPORTED_MODULE_2__.ThreeDOMElement {
    get [$threeTexture]() {
        var _a;
        console.assert(this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_2__.$correlatedObjects] != null && this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_2__.$correlatedObjects].size > 0, 'Image correlated object is undefined');
        return (_a = this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_2__.$correlatedObjects]) === null || _a === void 0 ? void 0 : _a.values().next().value;
    }
    constructor(onUpdate, texture, gltfImage) {
        gltfImage = gltfImage !== null && gltfImage !== void 0 ? gltfImage : {
            name: (texture && texture.image && texture.image.src) ?
                texture.image.src.split('/').pop() :
                'adhoc_image',
            uri: (texture && texture.image && texture.image.src) ?
                texture.image.src :
                'adhoc_image' + adhocNum++
        };
        super(onUpdate, gltfImage, new Set(texture ? [texture] : []));
    }
    get name() {
        return this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_2__.$sourceObject].name || '';
    }
    get uri() {
        return this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_2__.$sourceObject].uri;
    }
    get bufferView() {
        return this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_2__.$sourceObject].bufferView;
    }
    get element() {
        const texture = this[$threeTexture];
        if (texture && (texture.isCanvasTexture || texture.isVideoTexture)) {
            return texture.image;
        }
        return;
    }
    get animation() {
        const texture = this[$threeTexture];
        if (texture && texture.isCanvasTexture && texture.animation) {
            return texture.animation;
        }
        return;
    }
    get type() {
        return this.uri != null ? 'external' : 'embedded';
    }
    set name(name) {
        this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_2__.$sourceObject].name = name;
    }
    update() {
        const texture = this[$threeTexture];
        // Applies to non-Lottie canvas textures only
        if (texture && texture.isCanvasTexture && !texture.animation) {
            this[$threeTexture].needsUpdate = true;
            this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_2__.$onUpdate]();
        }
    }
    async createThumbnail(width, height) {
        const scene = new three__WEBPACK_IMPORTED_MODULE_3__.Scene();
        quadMaterial.map = this[$threeTexture];
        const mesh = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(quad, quadMaterial);
        scene.add(mesh);
        const camera = new three__WEBPACK_IMPORTED_MODULE_3__.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        const { threeRenderer } = _three_components_Renderer_js__WEBPACK_IMPORTED_MODULE_1__.Renderer.singleton;
        const renderTarget = new three__WEBPACK_IMPORTED_MODULE_3__.WebGLRenderTarget(width, height);
        threeRenderer.setRenderTarget(renderTarget);
        threeRenderer.render(scene, camera);
        threeRenderer.setRenderTarget(null);
        const buffer = new Uint8Array(width * height * 4);
        threeRenderer.readRenderTargetPixels(renderTarget, 0, 0, width, height, buffer);
        _model_viewer_base_js__WEBPACK_IMPORTED_MODULE_0__.blobCanvas.width = width;
        _model_viewer_base_js__WEBPACK_IMPORTED_MODULE_0__.blobCanvas.height = height;
        const blobContext = _model_viewer_base_js__WEBPACK_IMPORTED_MODULE_0__.blobCanvas.getContext('2d');
        const imageData = blobContext.createImageData(width, height);
        imageData.data.set(buffer);
        blobContext.putImageData(imageData, 0, 0);
        return new Promise(async (resolve, reject) => {
            _model_viewer_base_js__WEBPACK_IMPORTED_MODULE_0__.blobCanvas.toBlob(blob => {
                if (!blob) {
                    return reject('Failed to capture thumbnail.');
                }
                resolve(URL.createObjectURL(blob));
            }, 'image/png');
        });
    }
}
//# sourceMappingURL=image.js.map

/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/features/scene-graph/material.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/features/scene-graph/material.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$ensureMaterialIsLoaded": () => (/* binding */ $ensureMaterialIsLoaded),
/* harmony export */   "$getLoadedMaterial": () => (/* binding */ $getLoadedMaterial),
/* harmony export */   "$gltfIndex": () => (/* binding */ $gltfIndex),
/* harmony export */   "$lazyLoadGLTFInfo": () => (/* binding */ $lazyLoadGLTFInfo),
/* harmony export */   "$setActive": () => (/* binding */ $setActive),
/* harmony export */   "$variantIndices": () => (/* binding */ $variantIndices),
/* harmony export */   "$variantSet": () => (/* binding */ $variantSet),
/* harmony export */   "Material": () => (/* binding */ Material)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ "../../node_modules/three/build/three.module.js");
/* harmony import */ var _pbr_metallic_roughness_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pbr-metallic-roughness.js */ "../../node_modules/@google/model-viewer/lib/features/scene-graph/pbr-metallic-roughness.js");
/* harmony import */ var _texture_info_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./texture-info.js */ "../../node_modules/@google/model-viewer/lib/features/scene-graph/texture-info.js");
/* harmony import */ var _three_dom_element_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./three-dom-element.js */ "../../node_modules/@google/model-viewer/lib/features/scene-graph/three-dom-element.js");
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var _a;




const $pbrMetallicRoughness = Symbol('pbrMetallicRoughness');
const $normalTexture = Symbol('normalTexture');
const $occlusionTexture = Symbol('occlusionTexture');
const $emissiveTexture = Symbol('emissiveTexture');
const $backingThreeMaterial = Symbol('backingThreeMaterial');
const $applyAlphaCutoff = Symbol('applyAlphaCutoff');
const $lazyLoadGLTFInfo = Symbol('lazyLoadGLTFInfo');
const $initialize = Symbol('initialize');
const $getLoadedMaterial = Symbol('getLoadedMaterial');
const $ensureMaterialIsLoaded = Symbol('ensureMaterialIsLoaded');
const $gltfIndex = Symbol('gltfIndex');
const $setActive = Symbol('setActive');
const $variantIndices = Symbol('variantIndices');
const $isActive = Symbol('isActive');
const $variantSet = Symbol('variantSet');
const $modelVariants = Symbol('modelVariants');
/**
 * Material facade implementation for Three.js materials
 */
class Material extends _three_dom_element_js__WEBPACK_IMPORTED_MODULE_2__.ThreeDOMElement {
    constructor(onUpdate, gltf, gltfMaterial, gltfIndex, isActive, modelVariants, correlatedMaterials, lazyLoadInfo = undefined) {
        super(onUpdate, gltfMaterial, correlatedMaterials);
        this[_a] = new Set();
        this[$gltfIndex] = gltfIndex;
        this[$isActive] = isActive;
        this[$modelVariants] = modelVariants;
        if (lazyLoadInfo == null) {
            this[$initialize](gltf);
        }
        else {
            this[$lazyLoadGLTFInfo] = lazyLoadInfo;
        }
    }
    get [(_a = $variantSet, $backingThreeMaterial)]() {
        return this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_2__.$correlatedObjects]
            .values()
            .next()
            .value;
    }
    [$initialize](gltf) {
        const onUpdate = this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_2__.$onUpdate];
        const gltfMaterial = this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_2__.$sourceObject];
        const correlatedMaterials = this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_2__.$correlatedObjects];
        if (gltfMaterial.extensions &&
            gltfMaterial.extensions['KHR_materials_pbrSpecularGlossiness']) {
            console.warn(`Material ${gltfMaterial.name} uses a deprecated extension
          "KHR_materials_pbrSpecularGlossiness", please use
          "pbrMetallicRoughness" instead. Specular Glossiness materials are
          no longer supported; to convert to metal-rough, see 
          https://www.donmccurdy.com/2022/11/28/converting-gltf-pbr-materials-from-specgloss-to-metalrough/.`);
        }
        if (gltfMaterial.pbrMetallicRoughness == null) {
            gltfMaterial.pbrMetallicRoughness = {};
        }
        this[$pbrMetallicRoughness] = new _pbr_metallic_roughness_js__WEBPACK_IMPORTED_MODULE_0__.PBRMetallicRoughness(onUpdate, gltf, gltfMaterial.pbrMetallicRoughness, correlatedMaterials);
        if (gltfMaterial.emissiveFactor == null) {
            gltfMaterial.emissiveFactor = [0, 0, 0];
        }
        if (gltfMaterial.doubleSided == null) {
            gltfMaterial.doubleSided = false;
        }
        if (gltfMaterial.alphaMode == null) {
            gltfMaterial.alphaMode = 'OPAQUE';
        }
        if (gltfMaterial.alphaCutoff == null) {
            gltfMaterial.alphaCutoff = 0.5;
        }
        const { normalTexture: gltfNormalTexture, occlusionTexture: gltfOcclusionTexture, emissiveTexture: gltfEmissiveTexture } = gltfMaterial;
        const { normalMap, aoMap, emissiveMap } = correlatedMaterials.values().next().value;
        this[$normalTexture] = new _texture_info_js__WEBPACK_IMPORTED_MODULE_1__.TextureInfo(onUpdate, _texture_info_js__WEBPACK_IMPORTED_MODULE_1__.TextureUsage.Normal, normalMap, correlatedMaterials, gltf, gltfNormalTexture ? gltfNormalTexture : null);
        this[$occlusionTexture] = new _texture_info_js__WEBPACK_IMPORTED_MODULE_1__.TextureInfo(onUpdate, _texture_info_js__WEBPACK_IMPORTED_MODULE_1__.TextureUsage.Occlusion, aoMap, correlatedMaterials, gltf, gltfOcclusionTexture ? gltfOcclusionTexture : null);
        this[$emissiveTexture] = new _texture_info_js__WEBPACK_IMPORTED_MODULE_1__.TextureInfo(onUpdate, _texture_info_js__WEBPACK_IMPORTED_MODULE_1__.TextureUsage.Emissive, emissiveMap, correlatedMaterials, gltf, gltfEmissiveTexture ? gltfEmissiveTexture : null);
    }
    async [$getLoadedMaterial]() {
        if (this[$lazyLoadGLTFInfo] != null) {
            const { set, material } = await this[$lazyLoadGLTFInfo].doLazyLoad();
            // Fills in the missing data.
            this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_2__.$correlatedObjects] = set;
            this[$initialize](this[$lazyLoadGLTFInfo].gltf);
            // Releases lazy load info.
            this[$lazyLoadGLTFInfo] = undefined;
            // Redefines the method as a noop method.
            this.ensureLoaded = async () => { };
            return material;
        }
        return this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_2__.$correlatedObjects].values().next().value;
    }
    [$ensureMaterialIsLoaded]() {
        if (this[$lazyLoadGLTFInfo] == null) {
            return;
        }
        throw new Error(`Material "${this.name}" has not been loaded, call 'await
    myMaterial.ensureLoaded()' before using an unloaded material.`);
    }
    async ensureLoaded() {
        await this[$getLoadedMaterial]();
    }
    get isLoaded() {
        return this[$lazyLoadGLTFInfo] == null;
    }
    get isActive() {
        return this[$isActive];
    }
    [$setActive](isActive) {
        this[$isActive] = isActive;
    }
    get name() {
        return this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_2__.$sourceObject].name;
    }
    set name(name) {
        const sourceMaterial = this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_2__.$sourceObject];
        if (sourceMaterial != null) {
            sourceMaterial.name = name;
        }
        if (this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_2__.$correlatedObjects] != null) {
            for (const threeMaterial of this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_2__.$correlatedObjects]) {
                threeMaterial.name = name;
            }
        }
    }
    get pbrMetallicRoughness() {
        this[$ensureMaterialIsLoaded]();
        return this[$pbrMetallicRoughness];
    }
    get normalTexture() {
        this[$ensureMaterialIsLoaded]();
        return this[$normalTexture];
    }
    get occlusionTexture() {
        this[$ensureMaterialIsLoaded]();
        return this[$occlusionTexture];
    }
    get emissiveTexture() {
        this[$ensureMaterialIsLoaded]();
        return this[$emissiveTexture];
    }
    get emissiveFactor() {
        this[$ensureMaterialIsLoaded]();
        return this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_2__.$sourceObject].emissiveFactor;
    }
    get index() {
        return this[$gltfIndex];
    }
    [$variantIndices]() {
        return this[$variantSet];
    }
    hasVariant(name) {
        const variantData = this[$modelVariants].get(name);
        return variantData != null && this[$variantSet].has(variantData.index);
    }
    setEmissiveFactor(rgb) {
        this[$ensureMaterialIsLoaded]();
        const color = new three__WEBPACK_IMPORTED_MODULE_3__.Color();
        if (rgb instanceof Array) {
            color.fromArray(rgb);
        }
        else {
            color.set(rgb).convertSRGBToLinear();
        }
        for (const material of this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_2__.$correlatedObjects]) {
            material.emissive.set(color);
        }
        this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_2__.$sourceObject].emissiveFactor =
            color.toArray();
        this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_2__.$onUpdate]();
    }
    [$applyAlphaCutoff]() {
        this[$ensureMaterialIsLoaded]();
        const gltfMaterial = this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_2__.$sourceObject];
        for (const material of this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_2__.$correlatedObjects]) {
            if (this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_2__.$sourceObject].alphaMode === 'MASK') {
                material.alphaTest = gltfMaterial.alphaCutoff;
            }
            else {
                material.alphaTest = undefined;
            }
            material.needsUpdate = true;
        }
    }
    setAlphaCutoff(cutoff) {
        this[$ensureMaterialIsLoaded]();
        this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_2__.$sourceObject].alphaCutoff = cutoff;
        this[$applyAlphaCutoff]();
        this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_2__.$onUpdate]();
    }
    getAlphaCutoff() {
        this[$ensureMaterialIsLoaded]();
        return this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_2__.$sourceObject].alphaCutoff;
    }
    setDoubleSided(doubleSided) {
        this[$ensureMaterialIsLoaded]();
        for (const material of this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_2__.$correlatedObjects]) {
            // When double-sided is disabled gltf spec dictates that Back-Face culling
            // must be disabled, in three.js parlance that would mean FrontSide
            // rendering only.
            // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#double-sided
            material.side = doubleSided ? three__WEBPACK_IMPORTED_MODULE_3__.DoubleSide : three__WEBPACK_IMPORTED_MODULE_3__.FrontSide;
            material.needsUpdate = true;
        }
        this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_2__.$sourceObject].doubleSided = doubleSided;
        this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_2__.$onUpdate]();
    }
    getDoubleSided() {
        this[$ensureMaterialIsLoaded]();
        return this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_2__.$sourceObject].doubleSided;
    }
    setAlphaMode(alphaMode) {
        this[$ensureMaterialIsLoaded]();
        const enableTransparency = (material, enabled) => {
            material.transparent = enabled;
            material.depthWrite = !enabled;
        };
        this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_2__.$sourceObject].alphaMode = alphaMode;
        for (const material of this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_2__.$correlatedObjects]) {
            enableTransparency(material, alphaMode === 'BLEND');
            this[$applyAlphaCutoff]();
            material.needsUpdate = true;
        }
        this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_2__.$onUpdate]();
    }
    getAlphaMode() {
        this[$ensureMaterialIsLoaded]();
        return this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_2__.$sourceObject].alphaMode;
    }
}
//# sourceMappingURL=material.js.map

/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/features/scene-graph/model.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/features/scene-graph/model.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$availableVariants": () => (/* binding */ $availableVariants),
/* harmony export */   "$correlatedSceneGraph": () => (/* binding */ $correlatedSceneGraph),
/* harmony export */   "$loadVariant": () => (/* binding */ $loadVariant),
/* harmony export */   "$materialFromPoint": () => (/* binding */ $materialFromPoint),
/* harmony export */   "$materials": () => (/* binding */ $materials),
/* harmony export */   "$nodeFromIndex": () => (/* binding */ $nodeFromIndex),
/* harmony export */   "$nodeFromPoint": () => (/* binding */ $nodeFromPoint),
/* harmony export */   "$prepareVariantsForExport": () => (/* binding */ $prepareVariantsForExport),
/* harmony export */   "$primitivesList": () => (/* binding */ $primitivesList),
/* harmony export */   "$switchVariant": () => (/* binding */ $switchVariant),
/* harmony export */   "$variantData": () => (/* binding */ $variantData),
/* harmony export */   "LazyLoader": () => (/* binding */ LazyLoader),
/* harmony export */   "Model": () => (/* binding */ Model)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ "../../node_modules/three/build/three.module.js");
/* harmony import */ var _material_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./material.js */ "../../node_modules/@google/model-viewer/lib/features/scene-graph/material.js");
/* harmony import */ var _nodes_primitive_node_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nodes/primitive-node.js */ "../../node_modules/@google/model-viewer/lib/features/scene-graph/nodes/primitive-node.js");
/* harmony import */ var _three_dom_element_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./three-dom-element.js */ "../../node_modules/@google/model-viewer/lib/features/scene-graph/three-dom-element.js");
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var _a, _b, _c, _d, _e, _f;




const $materials = Symbol('materials');
const $hierarchy = Symbol('hierarchy');
const $roots = Symbol('roots');
const $primitivesList = Symbol('primitives');
const $loadVariant = Symbol('loadVariant');
const $correlatedSceneGraph = Symbol('correlatedSceneGraph');
const $prepareVariantsForExport = Symbol('prepareVariantsForExport');
const $switchVariant = Symbol('switchVariant');
const $materialFromPoint = Symbol('materialFromPoint');
const $nodeFromPoint = Symbol('nodeFromPoint');
const $nodeFromIndex = Symbol('nodeFromIndex');
const $variantData = Symbol('variantData');
const $availableVariants = Symbol('availableVariants');
const $modelOnUpdate = Symbol('modelOnUpdate');
const $cloneMaterial = Symbol('cloneMaterial');
// Holds onto temporary scene context information needed to perform lazy loading
// of a resource.
class LazyLoader {
    constructor(gltf, gltfElementMap, mapKey, doLazyLoad) {
        this.gltf = gltf;
        this.gltfElementMap = gltfElementMap;
        this.mapKey = mapKey;
        this.doLazyLoad = doLazyLoad;
    }
}
/**
 * A Model facades the top-level GLTF object returned by Three.js' GLTFLoader.
 * Currently, the model only bothers itself with the materials in the Three.js
 * scene graph.
 */
class Model {
    constructor(correlatedSceneGraph, onUpdate = () => { }) {
        this[_a] = new Array();
        this[_b] = new Array();
        this[_c] = new Array();
        this[_d] = new Array();
        this[_e] = () => { };
        this[_f] = new Map();
        this[$modelOnUpdate] = onUpdate;
        this[$correlatedSceneGraph] = correlatedSceneGraph;
        const { gltf, threeGLTF, gltfElementMap } = correlatedSceneGraph;
        for (const [i, material] of gltf.materials.entries()) {
            const correlatedMaterial = gltfElementMap.get(material);
            if (correlatedMaterial != null) {
                this[$materials].push(new _material_js__WEBPACK_IMPORTED_MODULE_0__.Material(onUpdate, gltf, material, i, true, this[$variantData], correlatedMaterial));
            }
            else {
                const elementArray = gltf['materials'] || [];
                const gltfMaterialDef = elementArray[i];
                // Loads the three.js material.
                const capturedMatIndex = i;
                const materialLoadCallback = async () => {
                    const threeMaterial = await threeGLTF.parser.getDependency('material', capturedMatIndex);
                    // Adds correlation, maps the variant gltf-def to the
                    // three material set containing the variant material.
                    const threeMaterialSet = new Set();
                    gltfElementMap.set(gltfMaterialDef, threeMaterialSet);
                    threeMaterialSet.add(threeMaterial);
                    return { set: threeMaterialSet, material: threeMaterial };
                };
                // Configures the material for lazy loading.
                this[$materials].push(new _material_js__WEBPACK_IMPORTED_MODULE_0__.Material(onUpdate, gltf, gltfMaterialDef, i, false, this[$variantData], correlatedMaterial, new LazyLoader(gltf, gltfElementMap, gltfMaterialDef, materialLoadCallback)));
            }
        }
        // Creates a hierarchy of Nodes. Allows not just for switching which
        // material is applied to a mesh but also exposes a way to provide API
        // for switching materials and general assignment/modification.
        // Prepares for scene iteration.
        const parentMap = new Map();
        const nodeStack = new Array();
        for (const object of threeGLTF.scene.children) {
            nodeStack.push(object);
        }
        // Walks the hierarchy and creates a node tree.
        while (nodeStack.length > 0) {
            const object = nodeStack.pop();
            let node = null;
            if (object instanceof three__WEBPACK_IMPORTED_MODULE_3__.Mesh) {
                node = new _nodes_primitive_node_js__WEBPACK_IMPORTED_MODULE_1__.PrimitiveNode(object, this.materials, this[$variantData], correlatedSceneGraph);
                this[$primitivesList].push(node);
            }
            else {
                node = new _nodes_primitive_node_js__WEBPACK_IMPORTED_MODULE_1__.Node(object.name);
            }
            const parent = parentMap.get(object);
            if (parent != null) {
                parent.children.push(node);
            }
            else {
                this[$roots].push(node);
            }
            this[$hierarchy].push(node);
            for (const child of object.children) {
                nodeStack.push(child);
                parentMap.set(object, node);
            }
        }
    }
    /**
     * Materials are listed in the order of the GLTF materials array, plus a
     * default material at the end if one is used.
     *
     * TODO(#1003): How do we handle non-active scenes?
     */
    get materials() {
        return this[$materials];
    }
    [(_a = $materials, _b = $hierarchy, _c = $roots, _d = $primitivesList, _e = $modelOnUpdate, _f = $variantData, $availableVariants)]() {
        const variants = Array.from(this[$variantData].values());
        variants.sort((a, b) => {
            return a.index - b.index;
        });
        return variants.map((data) => {
            return data.name;
        });
    }
    getMaterialByName(name) {
        const matches = this[$materials].filter(material => {
            return material.name === name;
        });
        if (matches.length > 0) {
            return matches[0];
        }
        return null;
    }
    [$nodeFromIndex](mesh, primitive) {
        const found = this[$hierarchy].find((node) => {
            if (node instanceof _nodes_primitive_node_js__WEBPACK_IMPORTED_MODULE_1__.PrimitiveNode) {
                const { meshes, primitives } = node.mesh.userData.associations;
                if (meshes == mesh && primitives == primitive) {
                    return true;
                }
            }
            return false;
        });
        return found == null ? null : found;
    }
    [$nodeFromPoint](hit) {
        return this[$hierarchy].find((node) => {
            if (node instanceof _nodes_primitive_node_js__WEBPACK_IMPORTED_MODULE_1__.PrimitiveNode) {
                const primitive = node;
                if (primitive.mesh === hit.object) {
                    return true;
                }
            }
            return false;
        });
    }
    /**
     * Intersects a ray with the Model and returns the first material whose
     * object was intersected.
     */
    [$materialFromPoint](hit) {
        return this[$nodeFromPoint](hit).getActiveMaterial();
    }
    /**
     * Switches model variant to the variant name provided, or switches to
     * default/initial materials if 'null' is provided.
     */
    async [$switchVariant](variantName) {
        for (const primitive of this[$primitivesList]) {
            await primitive.enableVariant(variantName);
        }
        for (const material of this.materials) {
            material[_material_js__WEBPACK_IMPORTED_MODULE_0__.$setActive](false);
        }
        // Marks the materials that are now in use after the variant switch.
        for (const primitive of this[$primitivesList]) {
            this.materials[primitive.getActiveMaterial().index][_material_js__WEBPACK_IMPORTED_MODULE_0__.$setActive](true);
        }
    }
    async [$prepareVariantsForExport]() {
        const promises = new Array();
        for (const primitive of this[$primitivesList]) {
            promises.push(primitive.instantiateVariants());
        }
        await Promise.all(promises);
    }
    [$cloneMaterial](index, newMaterialName) {
        const material = this.materials[index];
        if (!material.isLoaded) {
            console.error(`Cloning an unloaded material,
           call 'material.ensureLoaded() before cloning the material.`);
        }
        const threeMaterialSet = material[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_2__.$correlatedObjects];
        // clones the gltf material data and updates the material name.
        const gltfSourceMaterial = JSON.parse(JSON.stringify(material[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_2__.$sourceObject]));
        gltfSourceMaterial.name = newMaterialName;
        // Adds the source material clone to the gltf def.
        const gltf = this[$correlatedSceneGraph].gltf;
        gltf.materials.push(gltfSourceMaterial);
        const clonedSet = new Set();
        for (const [i, threeMaterial] of threeMaterialSet.entries()) {
            const clone = threeMaterial.clone();
            clone.name =
                newMaterialName + (threeMaterialSet.size > 1 ? '_inst' + i : '');
            clonedSet.add(clone);
        }
        const clonedMaterial = new _material_js__WEBPACK_IMPORTED_MODULE_0__.Material(this[$modelOnUpdate], this[$correlatedSceneGraph].gltf, gltfSourceMaterial, this[$materials].length, false, // Cloned as inactive.
        this[$variantData], clonedSet);
        this[$materials].push(clonedMaterial);
        return clonedMaterial;
    }
    createMaterialInstanceForVariant(originalMaterialIndex, newMaterialName, variantName, activateVariant = true) {
        let variantMaterialInstance = null;
        for (const primitive of this[$primitivesList]) {
            const variantData = this[$variantData].get(variantName);
            // Skips the primitive if the variant already exists.
            if (variantData != null && primitive.variantInfo.has(variantData.index)) {
                continue;
            }
            // Skips the primitive if the source/original material does not exist.
            if (primitive.getMaterial(originalMaterialIndex) == null) {
                continue;
            }
            if (!this.hasVariant(variantName)) {
                this.createVariant(variantName);
            }
            if (variantMaterialInstance == null) {
                variantMaterialInstance =
                    this[$cloneMaterial](originalMaterialIndex, newMaterialName);
            }
            primitive.addVariant(variantMaterialInstance, variantName);
        }
        if (activateVariant && variantMaterialInstance != null) {
            variantMaterialInstance[_material_js__WEBPACK_IMPORTED_MODULE_0__.$setActive](true);
            this.materials[originalMaterialIndex][_material_js__WEBPACK_IMPORTED_MODULE_0__.$setActive](false);
            for (const primitive of this[$primitivesList]) {
                primitive.enableVariant(variantName);
            }
        }
        return variantMaterialInstance;
    }
    createVariant(variantName) {
        if (!this[$variantData].has(variantName)) {
            // Adds the name if it's not already in the list.
            this[$variantData].set(variantName, { name: variantName, index: this[$variantData].size });
        }
        else {
            console.warn(`Variant '${variantName}'' already exists`);
        }
    }
    hasVariant(variantName) {
        return this[$variantData].has(variantName);
    }
    setMaterialToVariant(materialIndex, targetVariantName) {
        if (this[$availableVariants]().find(name => name === targetVariantName) ==
            null) {
            console.warn(`Can't add material to '${targetVariantName}', the variant does not exist.'`);
            return;
        }
        if (materialIndex < 0 || materialIndex >= this.materials.length) {
            console.error(`setMaterialToVariant(): materialIndex is out of bounds.`);
            return;
        }
        for (const primitive of this[$primitivesList]) {
            const material = primitive.getMaterial(materialIndex);
            // Ensures the material exists on the primitive before setting it to a
            // variant.
            if (material != null) {
                primitive.addVariant(material, targetVariantName);
            }
        }
    }
    updateVariantName(currentName, newName) {
        const variantData = this[$variantData].get(currentName);
        if (variantData == null) {
            return;
        }
        variantData.name = newName;
        this[$variantData].set(newName, variantData);
        this[$variantData].delete(currentName);
    }
    deleteVariant(variantName) {
        const variant = this[$variantData].get(variantName);
        if (variant == null) {
            return;
        }
        for (const material of this.materials) {
            if (material.hasVariant(variantName)) {
                material[_material_js__WEBPACK_IMPORTED_MODULE_0__.$variantSet].delete(variant.index);
            }
        }
        for (const primitive of this[$primitivesList]) {
            primitive.deleteVariant(variant.index);
        }
        this[$variantData].delete(variantName);
    }
}
//# sourceMappingURL=model.js.map

/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/features/scene-graph/nodes/primitive-node.js":
/*!************************************************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/features/scene-graph/nodes/primitive-node.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Node": () => (/* binding */ Node),
/* harmony export */   "PrimitiveNode": () => (/* binding */ PrimitiveNode)
/* harmony export */ });
/* harmony import */ var _material_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../material.js */ "../../node_modules/@google/model-viewer/lib/features/scene-graph/material.js");
/* harmony import */ var _three_dom_element_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../three-dom-element.js */ "../../node_modules/@google/model-viewer/lib/features/scene-graph/three-dom-element.js");


// Defines the base level node methods and data.
class Node {
    constructor(name) {
        this.name = '';
        this.children = new Array();
        this.name = name;
    }
}
// Represents a primitive in a glTF mesh.
class PrimitiveNode extends Node {
    constructor(mesh, mvMaterials, modelVariants, correlatedSceneGraph) {
        super(mesh.name);
        // Maps glTF material index number to a material that this primitive supports.
        this.materials = new Map();
        // Maps variant index to material.
        this.variantToMaterialMap = new Map();
        this.initialMaterialIdx = 0;
        this.activeMaterialIdx = 0;
        this.mesh = mesh;
        const { gltf, threeGLTF, threeObjectMap } = correlatedSceneGraph;
        this.modelVariants = modelVariants;
        this.mesh.userData.variantData = modelVariants;
        // Captures the primitive's initial material.
        const materialMappings = threeObjectMap.get(mesh.material);
        if (materialMappings.materials != null) {
            this.initialMaterialIdx = this.activeMaterialIdx =
                materialMappings.materials;
        }
        else {
            console.error(`Primitive (${mesh.name}) missing initial material reference.`);
        }
        // Gets the mesh index from the node.
        const associations = mesh.userData.associations ||
            {};
        if (associations.meshes == null) {
            console.error('Mesh is missing primitive index association');
            return;
        }
        // The gltf mesh array to sample from.
        const meshElementArray = gltf['meshes'] || [];
        // List of primitives under the mesh.
        const gltfPrimitives = (meshElementArray[associations.meshes].primitives || []);
        const gltfPrimitive = gltfPrimitives[associations.primitives];
        if (gltfPrimitive == null) {
            console.error('Mesh primitive definition is missing.');
            return;
        }
        // Maps the gltfPrimitive default to a material.
        if (gltfPrimitive.material != null) {
            this.materials.set(gltfPrimitive.material, mvMaterials[gltfPrimitive.material]);
        }
        else {
            const defaultIdx = mvMaterials.findIndex((mat) => {
                return mat.name === 'Default';
            });
            if (defaultIdx >= 0) {
                this.materials.set(defaultIdx, mvMaterials[defaultIdx]);
            }
            else {
                console.warn('gltfPrimitive has no material!');
            }
        }
        if (gltfPrimitive.extensions &&
            gltfPrimitive.extensions['KHR_materials_variants']) {
            const variantsExtension = gltfPrimitive.extensions['KHR_materials_variants'];
            const extensions = threeGLTF.parser.json.extensions;
            const variantNames = extensions['KHR_materials_variants'].variants;
            // Provides definition now that we know there are variants to
            // support.
            for (const mapping of variantsExtension.mappings) {
                const mvMaterial = mvMaterials[mapping.material];
                // Maps variant indices to Materials.
                this.materials.set(mapping.material, mvMaterial);
                for (const variant of mapping.variants) {
                    const { name } = variantNames[variant];
                    this.variantToMaterialMap.set(variant, mvMaterial);
                    // Provides variant info for material self lookup.
                    mvMaterial[_material_js__WEBPACK_IMPORTED_MODULE_0__.$variantIndices]().add(variant);
                    // Updates the models variant data.
                    if (!modelVariants.has(name)) {
                        modelVariants.set(name, { name, index: variant });
                    }
                }
            }
        }
    }
    async setActiveMaterial(material) {
        const mvMaterial = this.materials.get(material);
        if (mvMaterial != null) {
            this.mesh.material = await mvMaterial[_material_js__WEBPACK_IMPORTED_MODULE_0__.$getLoadedMaterial]();
            this.activeMaterialIdx = material;
        }
        return this.mesh.material;
    }
    getActiveMaterial() {
        return this.materials.get(this.activeMaterialIdx);
    }
    getMaterial(index) {
        return this.materials.get(index);
    }
    async enableVariant(name) {
        if (name == null) {
            return this.setActiveMaterial(this.initialMaterialIdx);
        }
        if (this.variantToMaterialMap != null && this.modelVariants.has(name)) {
            const modelVariants = this.modelVariants.get(name);
            return this.enableVariantHelper(modelVariants.index);
        }
        return null;
    }
    async enableVariantHelper(index) {
        if (this.variantToMaterialMap != null && index != null) {
            const material = this.variantToMaterialMap.get(index);
            if (material != null) {
                return this.setActiveMaterial(material.index);
            }
        }
        return null;
    }
    async instantiateVariants() {
        if (this.variantToMaterialMap == null) {
            return;
        }
        for (const index of this.variantToMaterialMap.keys()) {
            const variantMaterial = this.mesh.userData.variantMaterials.get(index);
            if (variantMaterial.material != null) {
                continue;
            }
            const threeMaterial = await this.enableVariantHelper(index);
            if (threeMaterial != null) {
                variantMaterial.material = threeMaterial;
            }
        }
    }
    get variantInfo() {
        return this.variantToMaterialMap;
    }
    addVariant(materialVariant, variantName) {
        if (!this.ensureVariantIsUnused(variantName)) {
            return false;
        }
        // Adds the variant to the model variants if needed.
        if (!this.modelVariants.has(variantName)) {
            this.modelVariants.set(variantName, { name: variantName, index: this.modelVariants.size });
        }
        const modelVariantData = this.modelVariants.get(variantName);
        const variantIndex = modelVariantData.index;
        // Updates materials mapped to the variant.
        materialVariant[_material_js__WEBPACK_IMPORTED_MODULE_0__.$variantIndices]().add(variantIndex);
        // Updates internal mappings.
        this.variantToMaterialMap.set(variantIndex, materialVariant);
        this.materials.set(materialVariant.index, materialVariant);
        this.updateVariantUserData(variantIndex, materialVariant);
        return true;
    }
    deleteVariant(variantIndex) {
        if (this.variantInfo.has(variantIndex)) {
            this.variantInfo.delete(variantIndex);
            const userDataMap = this.mesh.userData.variantMaterials;
            if (userDataMap != null) {
                userDataMap.delete(variantIndex);
            }
        }
    }
    updateVariantUserData(variantIndex, materialVariant) {
        // Adds variants name to material variants set.
        materialVariant[_material_js__WEBPACK_IMPORTED_MODULE_0__.$variantIndices]().add(variantIndex);
        this.mesh.userData.variantData = this.modelVariants;
        // Updates import data (see VariantMaterialLoaderPlugin.ts).
        this.mesh.userData.variantMaterials = this.mesh.userData.variantMaterials ||
            new Map();
        const map = this.mesh.userData.variantMaterials;
        map.set(variantIndex, {
            material: materialVariant[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_1__.$correlatedObjects].values().next().value,
            gltfMaterialIndex: materialVariant.index,
        });
    }
    ensureVariantIsUnused(variantName) {
        const modelVariants = this.modelVariants.get(variantName);
        if (modelVariants != null && this.variantInfo.has(modelVariants.index)) {
            console.warn(`Primitive cannot add variant '${variantName}' for this material, it already exists.`);
            return false;
        }
        return true;
    }
}
//# sourceMappingURL=primitive-node.js.map

/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/features/scene-graph/pbr-metallic-roughness.js":
/*!**************************************************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/features/scene-graph/pbr-metallic-roughness.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PBRMetallicRoughness": () => (/* binding */ PBRMetallicRoughness)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ "../../node_modules/three/build/three.module.js");
/* harmony import */ var _texture_info_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./texture-info.js */ "../../node_modules/@google/model-viewer/lib/features/scene-graph/texture-info.js");
/* harmony import */ var _three_dom_element_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./three-dom-element.js */ "../../node_modules/@google/model-viewer/lib/features/scene-graph/three-dom-element.js");
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



const $threeMaterials = Symbol('threeMaterials');
const $baseColorTexture = Symbol('baseColorTexture');
const $metallicRoughnessTexture = Symbol('metallicRoughnessTexture');
/**
 * PBR material properties facade implementation for Three.js materials
 */
class PBRMetallicRoughness extends _three_dom_element_js__WEBPACK_IMPORTED_MODULE_1__.ThreeDOMElement {
    constructor(onUpdate, gltf, pbrMetallicRoughness, correlatedMaterials) {
        super(onUpdate, pbrMetallicRoughness, correlatedMaterials);
        // Assign glTF default values
        if (pbrMetallicRoughness.baseColorFactor == null) {
            pbrMetallicRoughness.baseColorFactor = [1, 1, 1, 1];
        }
        if (pbrMetallicRoughness.roughnessFactor == null) {
            pbrMetallicRoughness.roughnessFactor = 1;
        }
        if (pbrMetallicRoughness.metallicFactor == null) {
            pbrMetallicRoughness.metallicFactor = 1;
        }
        const { baseColorTexture: gltfBaseColorTexture, metallicRoughnessTexture: gltfMetallicRoughnessTexture } = pbrMetallicRoughness;
        const { map, metalnessMap } = correlatedMaterials.values().next().value;
        this[$baseColorTexture] = new _texture_info_js__WEBPACK_IMPORTED_MODULE_0__.TextureInfo(onUpdate, _texture_info_js__WEBPACK_IMPORTED_MODULE_0__.TextureUsage.Base, map, correlatedMaterials, gltf, gltfBaseColorTexture ? gltfBaseColorTexture : null);
        this[$metallicRoughnessTexture] = new _texture_info_js__WEBPACK_IMPORTED_MODULE_0__.TextureInfo(onUpdate, _texture_info_js__WEBPACK_IMPORTED_MODULE_0__.TextureUsage.MetallicRoughness, metalnessMap, correlatedMaterials, gltf, gltfMetallicRoughnessTexture ? gltfMetallicRoughnessTexture : null);
    }
    get [$threeMaterials]() {
        return this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_1__.$correlatedObjects];
    }
    get baseColorFactor() {
        return this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_1__.$sourceObject]
            .baseColorFactor;
    }
    get metallicFactor() {
        return this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_1__.$sourceObject]
            .metallicFactor;
    }
    get roughnessFactor() {
        return this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_1__.$sourceObject]
            .roughnessFactor;
    }
    get baseColorTexture() {
        return this[$baseColorTexture];
    }
    get metallicRoughnessTexture() {
        return this[$metallicRoughnessTexture];
    }
    setBaseColorFactor(rgba) {
        const color = new three__WEBPACK_IMPORTED_MODULE_2__.Color();
        if (rgba instanceof Array) {
            color.fromArray(rgba);
        }
        else {
            color.set(rgba).convertSRGBToLinear();
        }
        for (const material of this[$threeMaterials]) {
            material.color.set(color);
            if (rgba instanceof Array) {
                material.opacity = (rgba)[3];
            }
            else {
                rgba = [0, 0, 0, material.opacity];
                color.toArray(rgba);
            }
        }
        const pbrMetallicRoughness = this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_1__.$sourceObject];
        pbrMetallicRoughness.baseColorFactor = rgba;
        this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_1__.$onUpdate]();
    }
    setMetallicFactor(value) {
        for (const material of this[$threeMaterials]) {
            material.metalness = value;
        }
        const pbrMetallicRoughness = this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_1__.$sourceObject];
        pbrMetallicRoughness.metallicFactor = value;
        this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_1__.$onUpdate]();
    }
    setRoughnessFactor(value) {
        for (const material of this[$threeMaterials]) {
            material.roughness = value;
        }
        const pbrMetallicRoughness = this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_1__.$sourceObject];
        pbrMetallicRoughness.roughnessFactor = value;
        this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_1__.$onUpdate]();
    }
}
//# sourceMappingURL=pbr-metallic-roughness.js.map

/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/features/scene-graph/sampler.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/features/scene-graph/sampler.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Sampler": () => (/* binding */ Sampler)
/* harmony export */ });
/* harmony import */ var _three_components_gltf_instance_gltf_2_0_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../three-components/gltf-instance/gltf-2.0.js */ "../../node_modules/@google/model-viewer/lib/three-components/gltf-instance/gltf-2.0.js");
/* harmony import */ var _three_dom_element_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./three-dom-element.js */ "../../node_modules/@google/model-viewer/lib/features/scene-graph/three-dom-element.js");
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


const isMinFilter = (() => {
    const minFilterValues = [
        _three_components_gltf_instance_gltf_2_0_js__WEBPACK_IMPORTED_MODULE_0__.Filter.Nearest,
        _three_components_gltf_instance_gltf_2_0_js__WEBPACK_IMPORTED_MODULE_0__.Filter.Linear,
        _three_components_gltf_instance_gltf_2_0_js__WEBPACK_IMPORTED_MODULE_0__.Filter.NearestMipmapNearest,
        _three_components_gltf_instance_gltf_2_0_js__WEBPACK_IMPORTED_MODULE_0__.Filter.LinearMipmapLinear,
        _three_components_gltf_instance_gltf_2_0_js__WEBPACK_IMPORTED_MODULE_0__.Filter.NearestMipmapLinear,
        _three_components_gltf_instance_gltf_2_0_js__WEBPACK_IMPORTED_MODULE_0__.Filter.LinearMipmapLinear
    ];
    return (value) => minFilterValues.indexOf(value) > -1;
})();
const isMagFilter = (() => {
    const magFilterValues = [_three_components_gltf_instance_gltf_2_0_js__WEBPACK_IMPORTED_MODULE_0__.Filter.Nearest, _three_components_gltf_instance_gltf_2_0_js__WEBPACK_IMPORTED_MODULE_0__.Filter.Linear];
    return (value) => magFilterValues.indexOf(value) > -1;
})();
const isWrapMode = (() => {
    const wrapModes = [_three_components_gltf_instance_gltf_2_0_js__WEBPACK_IMPORTED_MODULE_0__.Wrap.ClampToEdge, _three_components_gltf_instance_gltf_2_0_js__WEBPACK_IMPORTED_MODULE_0__.Wrap.MirroredRepeat, _three_components_gltf_instance_gltf_2_0_js__WEBPACK_IMPORTED_MODULE_0__.Wrap.Repeat];
    return (value) => wrapModes.indexOf(value) > -1;
})();
const isValidSamplerValue = (property, value) => {
    switch (property) {
        case 'minFilter':
            return isMinFilter(value);
        case 'magFilter':
            return isMagFilter(value);
        case 'wrapS':
        case 'wrapT':
            return isWrapMode(value);
        default:
            throw new Error(`Cannot configure property "${property}" on Sampler`);
    }
};
const $threeTextures = Symbol('threeTextures');
const $setProperty = Symbol('setProperty');
const $sourceSampler = Symbol('sourceSampler');
/**
 * Sampler facade implementation for Three.js textures
 */
class Sampler extends _three_dom_element_js__WEBPACK_IMPORTED_MODULE_1__.ThreeDOMElement {
    get [$threeTextures]() {
        console.assert(this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_1__.$correlatedObjects] != null && this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_1__.$correlatedObjects].size > 0, 'Sampler correlated object is undefined');
        return this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_1__.$correlatedObjects];
    }
    get [$sourceSampler]() {
        console.assert(this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_1__.$sourceObject] != null, 'Sampler source is undefined');
        return this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_1__.$sourceObject];
    }
    constructor(onUpdate, texture, gltfSampler) {
        gltfSampler = gltfSampler !== null && gltfSampler !== void 0 ? gltfSampler : {};
        // These defaults represent a convergence of glTF defaults for wrap mode and
        // Three.js defaults for filters. Per glTF 2.0 spec, a renderer may choose
        // its own defaults for filters.
        // @see https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-sampler
        // @see https://threejs.org/docs/#api/en/textures/Texture
        if (gltfSampler.minFilter == null) {
            gltfSampler.minFilter =
                texture ? texture.minFilter : _three_components_gltf_instance_gltf_2_0_js__WEBPACK_IMPORTED_MODULE_0__.Filter.LinearMipmapLinear;
        }
        if (gltfSampler.magFilter == null) {
            gltfSampler.magFilter =
                texture ? texture.magFilter : _three_components_gltf_instance_gltf_2_0_js__WEBPACK_IMPORTED_MODULE_0__.Filter.Linear;
        }
        if (gltfSampler.wrapS == null) {
            gltfSampler.wrapS = texture ? texture.wrapS : _three_components_gltf_instance_gltf_2_0_js__WEBPACK_IMPORTED_MODULE_0__.Wrap.Repeat;
        }
        if (gltfSampler.wrapT == null) {
            gltfSampler.wrapT = texture ? texture.wrapT : _three_components_gltf_instance_gltf_2_0_js__WEBPACK_IMPORTED_MODULE_0__.Wrap.Repeat;
        }
        super(onUpdate, gltfSampler, new Set(texture ? [texture] : []));
    }
    get name() {
        return this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_1__.$sourceObject].name || '';
    }
    get minFilter() {
        return this[$sourceSampler].minFilter;
    }
    get magFilter() {
        return this[$sourceSampler].magFilter;
    }
    get wrapS() {
        return this[$sourceSampler].wrapS;
    }
    get wrapT() {
        return this[$sourceSampler].wrapT;
    }
    setMinFilter(filter) {
        this[$setProperty]('minFilter', filter);
    }
    setMagFilter(filter) {
        this[$setProperty]('magFilter', filter);
    }
    setWrapS(mode) {
        this[$setProperty]('wrapS', mode);
    }
    setWrapT(mode) {
        this[$setProperty]('wrapT', mode);
    }
    [$setProperty](property, value) {
        const sampler = this[$sourceSampler];
        if (sampler != null) {
            if (isValidSamplerValue(property, value)) {
                sampler[property] = value;
                for (const texture of this[$threeTextures]) {
                    texture[property] = value;
                    texture.needsUpdate = true;
                }
            }
            this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_1__.$onUpdate]();
        }
    }
}
//# sourceMappingURL=sampler.js.map

/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/features/scene-graph/texture-info.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/features/scene-graph/texture-info.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$materials": () => (/* binding */ $materials),
/* harmony export */   "$usage": () => (/* binding */ $usage),
/* harmony export */   "TextureInfo": () => (/* binding */ TextureInfo),
/* harmony export */   "TextureUsage": () => (/* binding */ TextureUsage)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ "../../node_modules/three/build/three.module.js");
/* harmony import */ var _image_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./image.js */ "../../node_modules/@google/model-viewer/lib/features/scene-graph/image.js");
/* harmony import */ var _texture_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./texture.js */ "../../node_modules/@google/model-viewer/lib/features/scene-graph/texture.js");
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var _a, _b, _c;



const $texture = Symbol('texture');
const $transform = Symbol('transform');
const $materials = Symbol('materials');
const $usage = Symbol('usage');
const $onUpdate = Symbol('onUpdate');
const $activeVideo = Symbol('activeVideo');
// Defines what a texture will be used for.
var TextureUsage;
(function (TextureUsage) {
    TextureUsage[TextureUsage["Base"] = 0] = "Base";
    TextureUsage[TextureUsage["MetallicRoughness"] = 1] = "MetallicRoughness";
    TextureUsage[TextureUsage["Normal"] = 2] = "Normal";
    TextureUsage[TextureUsage["Occlusion"] = 3] = "Occlusion";
    TextureUsage[TextureUsage["Emissive"] = 4] = "Emissive";
})(TextureUsage || (TextureUsage = {}));
/**
 * TextureInfo facade implementation for Three.js materials
 */
class TextureInfo {
    constructor(onUpdate, usage, threeTexture, material, gltf, gltfTextureInfo) {
        this[_a] = null;
        this[_b] = {
            rotation: 0,
            scale: new three__WEBPACK_IMPORTED_MODULE_2__.Vector2(1, 1),
            offset: new three__WEBPACK_IMPORTED_MODULE_2__.Vector2(0, 0)
        };
        this[_c] = false;
        // Creates image, sampler, and texture if valid texture info is provided.
        if (gltfTextureInfo && threeTexture) {
            const gltfTexture = gltf.textures ? gltf.textures[gltfTextureInfo.index] : null;
            const sampler = gltfTexture ?
                (gltf.samplers ? gltf.samplers[gltfTexture.sampler] : null) :
                null;
            const image = gltfTexture ?
                (gltf.images ? gltf.images[gltfTexture.source] : null) :
                null;
            this[$transform].rotation = threeTexture.rotation;
            this[$transform].scale.copy(threeTexture.repeat);
            this[$transform].offset.copy(threeTexture.offset);
            this[$texture] =
                new _texture_js__WEBPACK_IMPORTED_MODULE_1__.Texture(onUpdate, threeTexture, gltfTexture, sampler, image);
        }
        this[$onUpdate] = onUpdate;
        this[$materials] = material;
        this[$usage] = usage;
    }
    get texture() {
        return this[$texture];
    }
    setTexture(texture) {
        var _d, _e;
        const threeTexture = texture != null ? texture.source[_image_js__WEBPACK_IMPORTED_MODULE_0__.$threeTexture] : null;
        const oldTexture = (_d = this[$texture]) === null || _d === void 0 ? void 0 : _d.source[_image_js__WEBPACK_IMPORTED_MODULE_0__.$threeTexture];
        if (oldTexture != null && oldTexture.isVideoTexture) {
            this[$activeVideo] = false;
        }
        else if ((_e = this[$texture]) === null || _e === void 0 ? void 0 : _e.source.animation) {
            this[$texture].source.animation.removeEventListener('enterFrame', this[$onUpdate]);
        }
        this[$texture] = texture;
        if (threeTexture != null && threeTexture.isVideoTexture) {
            const element = threeTexture.image;
            this[$activeVideo] = true;
            if (element.requestVideoFrameCallback != null) {
                const update = () => {
                    if (!this[$activeVideo]) {
                        return;
                    }
                    this[$onUpdate]();
                    element.requestVideoFrameCallback(update);
                };
                element.requestVideoFrameCallback(update);
            }
            else {
                const update = () => {
                    if (!this[$activeVideo]) {
                        return;
                    }
                    this[$onUpdate]();
                    requestAnimationFrame(update);
                };
                requestAnimationFrame(update);
            }
        }
        else if ((texture === null || texture === void 0 ? void 0 : texture.source.animation) != null) {
            texture.source.animation.addEventListener('enterFrame', this[$onUpdate]);
        }
        let encoding = three__WEBPACK_IMPORTED_MODULE_2__.sRGBEncoding;
        if (this[$materials]) {
            for (const material of this[$materials]) {
                switch (this[$usage]) {
                    case TextureUsage.Base:
                        material.map = threeTexture;
                        break;
                    case TextureUsage.MetallicRoughness:
                        encoding = three__WEBPACK_IMPORTED_MODULE_2__.LinearEncoding;
                        material.metalnessMap = threeTexture;
                        material.roughnessMap = threeTexture;
                        break;
                    case TextureUsage.Normal:
                        encoding = three__WEBPACK_IMPORTED_MODULE_2__.LinearEncoding;
                        material.normalMap = threeTexture;
                        break;
                    case TextureUsage.Occlusion:
                        encoding = three__WEBPACK_IMPORTED_MODULE_2__.LinearEncoding;
                        material.aoMap = threeTexture;
                        break;
                    case TextureUsage.Emissive:
                        material.emissiveMap = threeTexture;
                        break;
                    default:
                }
                material.needsUpdate = true;
            }
        }
        if (threeTexture) {
            // Updates the encoding for the texture, affects all references.
            threeTexture.encoding = encoding;
            threeTexture.rotation = this[$transform].rotation;
            threeTexture.repeat = this[$transform].scale;
            threeTexture.offset = this[$transform].offset;
        }
        this[$onUpdate]();
    }
}
_a = $texture, _b = $transform, _c = $activeVideo;
//# sourceMappingURL=texture-info.js.map

/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/features/scene-graph/texture.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/features/scene-graph/texture.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Texture": () => (/* binding */ Texture)
/* harmony export */ });
/* harmony import */ var _image_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./image.js */ "../../node_modules/@google/model-viewer/lib/features/scene-graph/image.js");
/* harmony import */ var _sampler_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sampler.js */ "../../node_modules/@google/model-viewer/lib/features/scene-graph/sampler.js");
/* harmony import */ var _three_dom_element_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./three-dom-element.js */ "../../node_modules/@google/model-viewer/lib/features/scene-graph/three-dom-element.js");
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



const $image = Symbol('image');
const $sampler = Symbol('sampler');
/**
 * Material facade implementation for Three.js materials
 */
class Texture extends _three_dom_element_js__WEBPACK_IMPORTED_MODULE_2__.ThreeDOMElement {
    constructor(onUpdate, threeTexture, gltfTexture = null, gltfSampler = null, gltfImage = null) {
        super(onUpdate, gltfTexture ? gltfTexture : {}, new Set(threeTexture ? [threeTexture] : []));
        this[$sampler] = new _sampler_js__WEBPACK_IMPORTED_MODULE_1__.Sampler(onUpdate, threeTexture, gltfSampler);
        this[$image] = new _image_js__WEBPACK_IMPORTED_MODULE_0__.Image(onUpdate, threeTexture, gltfImage);
    }
    get name() {
        return this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_2__.$sourceObject].name || '';
    }
    set name(name) {
        this[_three_dom_element_js__WEBPACK_IMPORTED_MODULE_2__.$sourceObject].name = name;
    }
    get sampler() {
        return this[$sampler];
    }
    get source() {
        return this[$image];
    }
}
//# sourceMappingURL=texture.js.map

/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/features/scene-graph/three-dom-element.js":
/*!*********************************************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/features/scene-graph/three-dom-element.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$correlatedObjects": () => (/* binding */ $correlatedObjects),
/* harmony export */   "$onUpdate": () => (/* binding */ $onUpdate),
/* harmony export */   "$sourceObject": () => (/* binding */ $sourceObject),
/* harmony export */   "ThreeDOMElement": () => (/* binding */ ThreeDOMElement)
/* harmony export */ });
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const $correlatedObjects = Symbol('correlatedObjects');
const $sourceObject = Symbol('sourceObject');
const $onUpdate = Symbol('onUpdate');
/**
 * A SerializableThreeDOMElement is the common primitive of all scene graph
 * elements that have been facaded in the host execution context. It adds
 * a common interface to these elements in support of convenient
 * serializability.
 */
class ThreeDOMElement {
    constructor(onUpdate, element, correlatedObjects = null) {
        this[$onUpdate] = onUpdate;
        this[$sourceObject] = element;
        this[$correlatedObjects] = correlatedObjects;
    }
}
//# sourceMappingURL=three-dom-element.js.map

/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/features/staging.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/features/staging.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AUTO_ROTATE_DELAY_DEFAULT": () => (/* binding */ AUTO_ROTATE_DELAY_DEFAULT),
/* harmony export */   "StagingMixin": () => (/* binding */ StagingMixin)
/* harmony export */ });
/* harmony import */ var lit_decorators_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit/decorators.js */ "../../node_modules/lit/decorators.js");
/* harmony import */ var _decorators_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../decorators.js */ "../../node_modules/@google/model-viewer/lib/decorators.js");
/* harmony import */ var _model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../model-viewer-base.js */ "../../node_modules/@google/model-viewer/lib/model-viewer-base.js");
/* harmony import */ var _styles_conversions_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../styles/conversions.js */ "../../node_modules/@google/model-viewer/lib/styles/conversions.js");
/* harmony import */ var _styles_parsers_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../styles/parsers.js */ "../../node_modules/@google/model-viewer/lib/styles/parsers.js");
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};





// How much the model will rotate per
// second in radians:
const DEFAULT_ROTATION_SPEED = Math.PI / 32;
const AUTO_ROTATE_DELAY_DEFAULT = 3000;
const rotationRateIntrinsics = {
    basis: [(0,_styles_conversions_js__WEBPACK_IMPORTED_MODULE_3__.degreesToRadians)((0,_styles_parsers_js__WEBPACK_IMPORTED_MODULE_4__.numberNode)(DEFAULT_ROTATION_SPEED, 'rad'))],
    keywords: { auto: [null] }
};
const $autoRotateStartTime = Symbol('autoRotateStartTime');
const $radiansPerSecond = Symbol('radiansPerSecond');
const $syncRotationRate = Symbol('syncRotationRate');
const $onCameraChange = Symbol('onCameraChange');
const StagingMixin = (ModelViewerElement) => {
    var _a, _b, _c;
    class StagingModelViewerElement extends ModelViewerElement {
        constructor() {
            super(...arguments);
            this.autoRotate = false;
            this.autoRotateDelay = AUTO_ROTATE_DELAY_DEFAULT;
            this.rotationPerSecond = 'auto';
            this[_a] = performance.now();
            this[_b] = 0;
            this[_c] = (event) => {
                if (!this.autoRotate) {
                    return;
                }
                if (event.detail.source === 'user-interaction') {
                    this[$autoRotateStartTime] = performance.now();
                }
            };
        }
        connectedCallback() {
            super.connectedCallback();
            this.addEventListener('camera-change', this[$onCameraChange]);
            this[$autoRotateStartTime] = performance.now();
        }
        disconnectedCallback() {
            super.disconnectedCallback();
            this.removeEventListener('camera-change', this[$onCameraChange]);
            this[$autoRotateStartTime] = performance.now();
        }
        updated(changedProperties) {
            super.updated(changedProperties);
            if (changedProperties.has('autoRotate')) {
                this[$autoRotateStartTime] = performance.now();
            }
        }
        [(_a = $autoRotateStartTime, _b = $radiansPerSecond, $syncRotationRate)](style) {
            this[$radiansPerSecond] = style[0];
        }
        [_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$tick](time, delta) {
            super[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$tick](time, delta);
            if (!this.autoRotate || !this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$getModelIsVisible]() ||
                this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$renderer].isPresenting) {
                return;
            }
            const rotationDelta = Math.min(delta, time - this[$autoRotateStartTime] - this.autoRotateDelay);
            if (rotationDelta > 0) {
                this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$scene].yaw = this.turntableRotation +
                    this[$radiansPerSecond] * rotationDelta * 0.001;
            }
        }
        get turntableRotation() {
            return this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$scene].yaw;
        }
        resetTurntableRotation(theta = 0) {
            this[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$scene].yaw = theta;
        }
    }
    _c = $onCameraChange;
    __decorate([
        (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_0__.property)({ type: Boolean, attribute: 'auto-rotate' })
    ], StagingModelViewerElement.prototype, "autoRotate", void 0);
    __decorate([
        (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_0__.property)({ type: Number, attribute: 'auto-rotate-delay' })
    ], StagingModelViewerElement.prototype, "autoRotateDelay", void 0);
    __decorate([
        (0,_decorators_js__WEBPACK_IMPORTED_MODULE_1__.style)({ intrinsics: rotationRateIntrinsics, updateHandler: $syncRotationRate }),
        (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_0__.property)({ type: String, attribute: 'rotation-per-second' })
    ], StagingModelViewerElement.prototype, "rotationPerSecond", void 0);
    return StagingModelViewerElement;
};
//# sourceMappingURL=staging.js.map

/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/model-viewer-base.js":
/*!************************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/model-viewer-base.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$altDefaulted": () => (/* binding */ $altDefaulted),
/* harmony export */   "$announceModelVisibility": () => (/* binding */ $announceModelVisibility),
/* harmony export */   "$ariaLabel": () => (/* binding */ $ariaLabel),
/* harmony export */   "$canvas": () => (/* binding */ $canvas),
/* harmony export */   "$container": () => (/* binding */ $container),
/* harmony export */   "$getLoaded": () => (/* binding */ $getLoaded),
/* harmony export */   "$getModelIsVisible": () => (/* binding */ $getModelIsVisible),
/* harmony export */   "$intersectionObserver": () => (/* binding */ $intersectionObserver),
/* harmony export */   "$isElementInViewport": () => (/* binding */ $isElementInViewport),
/* harmony export */   "$loadedTime": () => (/* binding */ $loadedTime),
/* harmony export */   "$markLoaded": () => (/* binding */ $markLoaded),
/* harmony export */   "$needsRender": () => (/* binding */ $needsRender),
/* harmony export */   "$onModelLoad": () => (/* binding */ $onModelLoad),
/* harmony export */   "$onResize": () => (/* binding */ $onResize),
/* harmony export */   "$progressTracker": () => (/* binding */ $progressTracker),
/* harmony export */   "$renderer": () => (/* binding */ $renderer),
/* harmony export */   "$scene": () => (/* binding */ $scene),
/* harmony export */   "$shouldAttemptPreload": () => (/* binding */ $shouldAttemptPreload),
/* harmony export */   "$statusElement": () => (/* binding */ $statusElement),
/* harmony export */   "$tick": () => (/* binding */ $tick),
/* harmony export */   "$updateSize": () => (/* binding */ $updateSize),
/* harmony export */   "$updateSource": () => (/* binding */ $updateSource),
/* harmony export */   "$updateStatus": () => (/* binding */ $updateStatus),
/* harmony export */   "$userInputElement": () => (/* binding */ $userInputElement),
/* harmony export */   "blobCanvas": () => (/* binding */ blobCanvas),
/* harmony export */   "default": () => (/* binding */ ModelViewerElementBase),
/* harmony export */   "toVector2D": () => (/* binding */ toVector2D),
/* harmony export */   "toVector3D": () => (/* binding */ toVector3D)
/* harmony export */ });
/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ "../../node_modules/lit/index.js");
/* harmony import */ var lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit/decorators.js */ "../../node_modules/lit/decorators.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants.js */ "../../node_modules/@google/model-viewer/lib/constants.js");
/* harmony import */ var _features_environment_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./features/environment.js */ "../../node_modules/@google/model-viewer/lib/features/environment.js");
/* harmony import */ var _template_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./template.js */ "../../node_modules/@google/model-viewer/lib/template.js");
/* harmony import */ var _three_components_CachingGLTFLoader_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./three-components/CachingGLTFLoader.js */ "../../node_modules/@google/model-viewer/lib/three-components/CachingGLTFLoader.js");
/* harmony import */ var _three_components_ModelScene_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./three-components/ModelScene.js */ "../../node_modules/@google/model-viewer/lib/three-components/ModelScene.js");
/* harmony import */ var _three_components_Renderer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./three-components/Renderer.js */ "../../node_modules/@google/model-viewer/lib/three-components/Renderer.js");
/* harmony import */ var _utilities_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utilities.js */ "../../node_modules/@google/model-viewer/lib/utilities.js");
/* harmony import */ var _utilities_data_conversion_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utilities/data-conversion.js */ "../../node_modules/@google/model-viewer/lib/utilities/data-conversion.js");
/* harmony import */ var _utilities_progress_tracker_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./utilities/progress-tracker.js */ "../../node_modules/@google/model-viewer/lib/utilities/progress-tracker.js");
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;











const CLEAR_MODEL_TIMEOUT_MS = 10;
const FALLBACK_SIZE_UPDATE_THRESHOLD_MS = 50;
const ANNOUNCE_MODEL_VISIBILITY_DEBOUNCE_THRESHOLD = 0;
const UNSIZED_MEDIA_WIDTH = 300;
const UNSIZED_MEDIA_HEIGHT = 150;
const blobCanvas = document.createElement('canvas');
const $fallbackResizeHandler = Symbol('fallbackResizeHandler');
const $defaultAriaLabel = Symbol('defaultAriaLabel');
const $resizeObserver = Symbol('resizeObserver');
const $clearModelTimeout = Symbol('clearModelTimeout');
const $onContextLost = Symbol('onContextLost');
const $loaded = Symbol('loaded');
const $status = Symbol('status');
const $onFocus = Symbol('onFocus');
const $onBlur = Symbol('onBlur');
const $updateSize = Symbol('updateSize');
const $intersectionObserver = Symbol('intersectionObserver');
const $isElementInViewport = Symbol('isElementInViewport');
const $announceModelVisibility = Symbol('announceModelVisibility');
const $ariaLabel = Symbol('ariaLabel');
const $altDefaulted = Symbol('altDefaulted');
const $statusElement = Symbol('statusElement');
const $updateStatus = Symbol('updateStatus');
const $loadedTime = Symbol('loadedTime');
const $updateSource = Symbol('updateSource');
const $markLoaded = Symbol('markLoaded');
const $container = Symbol('container');
const $userInputElement = Symbol('input');
const $canvas = Symbol('canvas');
const $scene = Symbol('scene');
const $needsRender = Symbol('needsRender');
const $tick = Symbol('tick');
const $onModelLoad = Symbol('onModelLoad');
const $onResize = Symbol('onResize');
const $renderer = Symbol('renderer');
const $progressTracker = Symbol('progressTracker');
const $getLoaded = Symbol('getLoaded');
const $getModelIsVisible = Symbol('getModelIsVisible');
const $shouldAttemptPreload = Symbol('shouldAttemptPreload');
const toVector3D = (v) => {
    return {
        x: v.x,
        y: v.y,
        z: v.z,
        toString() {
            return `${this.x}m ${this.y}m ${this.z}m`;
        }
    };
};
const toVector2D = (v) => {
    return {
        u: v.x,
        v: v.y,
        toString() {
            return `${this.u} ${this.v}`;
        }
    };
};
/**
 * Definition for a basic <model-viewer> element.
 */
class ModelViewerElementBase extends lit__WEBPACK_IMPORTED_MODULE_0__.ReactiveElement {
    /**
     * Creates a new ModelViewerElement.
     */
    constructor() {
        super();
        this.alt = null;
        this.src = null;
        this.withCredentials = false;
        /**
         * Generates a 3D model schema https://schema.org/3DModel associated with
         * the loaded src and inserts it into the header of the page for search
         * engines to crawl.
         */
        this.generateSchema = false;
        this[_a] = false;
        this[_b] = false;
        this[_c] = 0;
        this[_d] = '';
        this[_e] = null;
        this[_f] = (0,_utilities_js__WEBPACK_IMPORTED_MODULE_8__.debounce)(() => {
            const boundingRect = this.getBoundingClientRect();
            this[$updateSize](boundingRect);
        }, FALLBACK_SIZE_UPDATE_THRESHOLD_MS);
        this[_g] = (0,_utilities_js__WEBPACK_IMPORTED_MODULE_8__.debounce)((oldVisibility) => {
            const newVisibility = this.modelIsVisible;
            if (newVisibility !== oldVisibility) {
                this.dispatchEvent(new CustomEvent('model-visibility', { detail: { visible: newVisibility } }));
            }
        }, ANNOUNCE_MODEL_VISIBILITY_DEBOUNCE_THRESHOLD);
        this[_h] = null;
        this[_j] = null;
        this[_k] = new _utilities_progress_tracker_js__WEBPACK_IMPORTED_MODULE_10__.ProgressTracker();
        this[_l] = () => {
            this[$statusElement].textContent = this[$status];
        };
        this[_m] = () => {
            this[$statusElement].textContent = '';
        };
        this[_o] = (event) => {
            this.dispatchEvent(new CustomEvent('error', { detail: { type: 'webglcontextlost', sourceError: event.sourceEvent } }));
        };
        this.attachShadow({ mode: 'open' });
        const shadowRoot = this.shadowRoot;
        (0,_template_js__WEBPACK_IMPORTED_MODULE_4__.makeTemplate)(shadowRoot);
        this[$container] = shadowRoot.querySelector('.container');
        this[$userInputElement] =
            shadowRoot.querySelector('.userInput');
        this[$canvas] = shadowRoot.querySelector('canvas');
        this[$statusElement] =
            shadowRoot.querySelector('#status');
        this[$defaultAriaLabel] =
            this[$userInputElement].getAttribute('aria-label');
        // Because of potential race conditions related to invoking the constructor
        // we only use the bounding rect to set the initial size if the element is
        // already connected to the document:
        let width, height;
        if (this.isConnected) {
            const rect = this.getBoundingClientRect();
            width = rect.width;
            height = rect.height;
        }
        else {
            width = UNSIZED_MEDIA_WIDTH;
            height = UNSIZED_MEDIA_HEIGHT;
        }
        // Create the underlying ModelScene.
        this[$scene] =
            new _three_components_ModelScene_js__WEBPACK_IMPORTED_MODULE_6__.ModelScene({ canvas: this[$canvas], element: this, width, height });
        // Update initial size on microtask timing so that subclasses have a
        // chance to initialize
        Promise.resolve().then(() => {
            this[$updateSize](this.getBoundingClientRect());
        });
        if (_constants_js__WEBPACK_IMPORTED_MODULE_2__.HAS_RESIZE_OBSERVER) {
            // Set up a resize observer so we can scale our canvas
            // if our <model-viewer> changes
            this[$resizeObserver] =
                new ResizeObserver((entries) => {
                    // Don't resize anything if in AR mode; otherwise the canvas
                    // scaling to fullscreen on entering AR will clobber the flat/2d
                    // dimensions of the element.
                    if (this[$renderer].isPresenting) {
                        return;
                    }
                    for (let entry of entries) {
                        if (entry.target === this) {
                            this[$updateSize](entry.contentRect);
                        }
                    }
                });
        }
        if (_constants_js__WEBPACK_IMPORTED_MODULE_2__.HAS_INTERSECTION_OBSERVER) {
            this[$intersectionObserver] = new IntersectionObserver(entries => {
                for (let entry of entries) {
                    if (entry.target === this) {
                        const oldVisibility = this.modelIsVisible;
                        this[$isElementInViewport] = entry.isIntersecting;
                        this[$announceModelVisibility](oldVisibility);
                        if (this[$isElementInViewport] && !this.loaded) {
                            this[$updateSource]();
                        }
                    }
                }
            }, {
                root: null,
                // We used to have margin here, but it was causing animated models below
                // the fold to steal the frame budget. Weirder still, it would also
                // cause input events to be swallowed, sometimes for seconds on the
                // model above the fold, but only when the animated model was completely
                // below. Setting this margin to zero fixed it.
                rootMargin: '0px',
                // With zero threshold, an element adjacent to but not intersecting the
                // viewport will be reported as intersecting, which will cause
                // unnecessary rendering. Any slight positive threshold alleviates this.
                threshold: 0.00001,
            });
        }
        else {
            // If there is no intersection observer, then all models should be visible
            // at all times:
            this[$isElementInViewport] = true;
        }
    }
    static get is() {
        return 'model-viewer';
    }
    /** @export */
    static set modelCacheSize(value) {
        _three_components_CachingGLTFLoader_js__WEBPACK_IMPORTED_MODULE_5__.CachingGLTFLoader[_three_components_CachingGLTFLoader_js__WEBPACK_IMPORTED_MODULE_5__.$evictionPolicy].evictionThreshold = value;
    }
    /** @export */
    static get modelCacheSize() {
        return _three_components_CachingGLTFLoader_js__WEBPACK_IMPORTED_MODULE_5__.CachingGLTFLoader[_three_components_CachingGLTFLoader_js__WEBPACK_IMPORTED_MODULE_5__.$evictionPolicy].evictionThreshold;
    }
    /** @export */
    static set minimumRenderScale(value) {
        if (value > 1) {
            console.warn('<model-viewer> minimumRenderScale has been clamped to a maximum value of 1.');
        }
        if (value <= 0) {
            console.warn('<model-viewer> minimumRenderScale has been clamped to a minimum value of 0.25.');
        }
        _three_components_Renderer_js__WEBPACK_IMPORTED_MODULE_7__.Renderer.singleton.minScale = value;
    }
    /** @export */
    static get minimumRenderScale() {
        return _three_components_Renderer_js__WEBPACK_IMPORTED_MODULE_7__.Renderer.singleton.minScale;
    }
    /** @export */
    get loaded() {
        return this[$getLoaded]();
    }
    get [(_a = $isElementInViewport, _b = $loaded, _c = $loadedTime, _d = $status, _e = $clearModelTimeout, _f = $fallbackResizeHandler, _g = $announceModelVisibility, _h = $resizeObserver, _j = $intersectionObserver, _k = $progressTracker, $renderer)]() {
        return _three_components_Renderer_js__WEBPACK_IMPORTED_MODULE_7__.Renderer.singleton;
    }
    /** @export */
    get modelIsVisible() {
        return this[$getModelIsVisible]();
    }
    connectedCallback() {
        super.connectedCallback && super.connectedCallback();
        if (_constants_js__WEBPACK_IMPORTED_MODULE_2__.HAS_RESIZE_OBSERVER) {
            this[$resizeObserver].observe(this);
        }
        else {
            self.addEventListener('resize', this[$fallbackResizeHandler]);
        }
        if (_constants_js__WEBPACK_IMPORTED_MODULE_2__.HAS_INTERSECTION_OBSERVER) {
            this[$intersectionObserver].observe(this);
        }
        this.addEventListener('focus', this[$onFocus]);
        this.addEventListener('blur', this[$onBlur]);
        const renderer = this[$renderer];
        renderer.addEventListener('contextlost', this[$onContextLost]);
        renderer.registerScene(this[$scene]);
        if (this[$clearModelTimeout] != null) {
            self.clearTimeout(this[$clearModelTimeout]);
            this[$clearModelTimeout] = null;
            // Force an update in case the model has been evicted from our GLTF cache
            // @see https://lit-element.polymer-project.org/guide/lifecycle#requestupdate
            this.requestUpdate('src', null);
        }
    }
    disconnectedCallback() {
        super.disconnectedCallback && super.disconnectedCallback();
        if (_constants_js__WEBPACK_IMPORTED_MODULE_2__.HAS_RESIZE_OBSERVER) {
            this[$resizeObserver].unobserve(this);
        }
        else {
            self.removeEventListener('resize', this[$fallbackResizeHandler]);
        }
        if (_constants_js__WEBPACK_IMPORTED_MODULE_2__.HAS_INTERSECTION_OBSERVER) {
            this[$intersectionObserver].unobserve(this);
        }
        this.removeEventListener('focus', this[$onFocus]);
        this.removeEventListener('blur', this[$onBlur]);
        const renderer = this[$renderer];
        renderer.removeEventListener('contextlost', this[$onContextLost]);
        renderer.unregisterScene(this[$scene]);
        this[$clearModelTimeout] = self.setTimeout(() => {
            this[$scene].dispose();
            this[$clearModelTimeout] = null;
        }, CLEAR_MODEL_TIMEOUT_MS);
    }
    updated(changedProperties) {
        super.updated(changedProperties);
        // NOTE(cdata): If a property changes from values A -> B -> A in the space
        // of a microtask, LitElement/UpdatingElement will notify of a change even
        // though the value has effectively not changed, so we need to check to make
        // sure that the value has actually changed before changing the loaded flag.
        if (changedProperties.has('src')) {
            if (this.src == null) {
                this[$loaded] = false;
                this[$loadedTime] = 0;
                this[$scene].reset();
            }
            else if (this.src !== this[$scene].url) {
                this[$loaded] = false;
                this[$loadedTime] = 0;
                this[$updateSource]();
            }
        }
        if (changedProperties.has('alt')) {
            this[$userInputElement].setAttribute('aria-label', this[$ariaLabel]);
        }
        if (changedProperties.has('withCredentials')) {
            _three_components_CachingGLTFLoader_js__WEBPACK_IMPORTED_MODULE_5__.CachingGLTFLoader.withCredentials = this.withCredentials;
            this[$renderer].textureUtils.withCredentials = this.withCredentials;
        }
        if (changedProperties.has('generateSchema')) {
            if (this.generateSchema) {
                this[$scene].updateSchema(this.src);
            }
            else {
                this[$scene].updateSchema(null);
            }
        }
    }
    /** @export */
    toDataURL(type, encoderOptions) {
        return this[$renderer]
            .displayCanvas(this[$scene])
            .toDataURL(type, encoderOptions);
    }
    /** @export */
    async toBlob(options) {
        const mimeType = options ? options.mimeType : undefined;
        const qualityArgument = options ? options.qualityArgument : undefined;
        const useIdealAspect = options ? options.idealAspect : undefined;
        const { width, height, idealAspect, aspect } = this[$scene];
        const { dpr, scaleFactor } = this[$renderer];
        let outputWidth = width * scaleFactor * dpr;
        let outputHeight = height * scaleFactor * dpr;
        let offsetX = 0;
        let offsetY = 0;
        if (useIdealAspect === true) {
            if (idealAspect > aspect) {
                const oldHeight = outputHeight;
                outputHeight = Math.round(outputWidth / idealAspect);
                offsetY = (oldHeight - outputHeight) / 2;
            }
            else {
                const oldWidth = outputWidth;
                outputWidth = Math.round(outputHeight * idealAspect);
                offsetX = (oldWidth - outputWidth) / 2;
            }
        }
        blobCanvas.width = outputWidth;
        blobCanvas.height = outputHeight;
        try {
            return new Promise(async (resolve, reject) => {
                blobCanvas.getContext('2d').drawImage(this[$renderer].displayCanvas(this[$scene]), offsetX, offsetY, outputWidth, outputHeight, 0, 0, outputWidth, outputHeight);
                if (blobCanvas.msToBlob) {
                    // NOTE: msToBlob only returns image/png
                    // so ensure mimeType is not specified (defaults to image/png)
                    // or is image/png, otherwise fallback to using toDataURL on IE.
                    if (!mimeType || mimeType === 'image/png') {
                        return resolve(blobCanvas.msToBlob());
                    }
                }
                if (!blobCanvas.toBlob) {
                    return resolve(await (0,_utilities_data_conversion_js__WEBPACK_IMPORTED_MODULE_9__.dataUrlToBlob)(blobCanvas.toDataURL(mimeType, qualityArgument)));
                }
                blobCanvas.toBlob((blob) => {
                    if (!blob) {
                        return reject(new Error('Unable to retrieve canvas blob'));
                    }
                    resolve(blob);
                }, mimeType, qualityArgument);
            });
        }
        finally {
            this[$updateSize]({ width, height });
        }
        ;
    }
    registerRenderer(renderer) {
        this[$scene].externalRenderer = renderer;
    }
    unregisterRenderer() {
        this[$scene].externalRenderer = null;
    }
    get [$ariaLabel]() {
        return this[$altDefaulted];
    }
    get [$altDefaulted]() {
        return (this.alt == null || this.alt === 'null') ? this[$defaultAriaLabel] :
            this.alt;
    }
    // NOTE(cdata): Although this may seem extremely redundant, it is required in
    // order to support overloading when TypeScript is compiled to ES5
    // @see https://github.com/Polymer/lit-element/pull/745
    // @see https://github.com/microsoft/TypeScript/issues/338
    [$getLoaded]() {
        return this[$loaded];
    }
    // @see [$getLoaded]
    [$getModelIsVisible]() {
        return this.loaded && this[$isElementInViewport];
    }
    [$shouldAttemptPreload]() {
        return !!this.src && this[$isElementInViewport];
    }
    /**
     * Called on initialization and when the resize observer fires.
     */
    [$updateSize]({ width, height }) {
        if (width === 0 || height === 0) {
            return;
        }
        this[$container].style.width = `${width}px`;
        this[$container].style.height = `${height}px`;
        this[$onResize]({ width, height });
    }
    [$tick](_time, _delta) {
    }
    [$markLoaded]() {
        if (this[$loaded]) {
            return;
        }
        this[$loaded] = true;
        this[$loadedTime] = performance.now();
    }
    [$needsRender]() {
        this[$scene].queueRender();
    }
    [$onModelLoad]() {
    }
    [$updateStatus](status) {
        this[$status] = status;
        const rootNode = this.getRootNode();
        // Only change the aria-label if <model-viewer> is currently focused:
        if (rootNode != null && rootNode.activeElement === this &&
            this[$statusElement].textContent != status) {
            this[$statusElement].textContent = status;
        }
    }
    [(_l = $onFocus, _m = $onBlur, $onResize)](e) {
        this[$scene].setSize(e.width, e.height);
    }
    /**
     * Parses the element for an appropriate source URL and
     * sets the views to use the new model based.
     */
    async [(_o = $onContextLost, $updateSource)]() {
        const scene = this[$scene];
        if (this.loaded || !this[$shouldAttemptPreload]() ||
            this.src === scene.url) {
            return;
        }
        if (this.generateSchema) {
            scene.updateSchema(this.src);
        }
        this[$updateStatus]('Loading');
        // If we are loading a new model, we need to stop the animation of
        // the current one (if any is playing). Otherwise, we might lose
        // the reference to the scene root and running actions start to
        // throw exceptions and/or behave in unexpected ways:
        scene.stopAnimation();
        const updateSourceProgress = this[$progressTracker].beginActivity();
        const source = this.src;
        try {
            const srcUpdated = scene.setSource(source, (progress) => updateSourceProgress((0,_utilities_js__WEBPACK_IMPORTED_MODULE_8__.clamp)(progress, 0, 1) * 0.95));
            const envUpdated = this[_features_environment_js__WEBPACK_IMPORTED_MODULE_3__.$updateEnvironment]();
            await Promise.all([srcUpdated, envUpdated]);
            this[$markLoaded]();
            this[$onModelLoad]();
            // Wait for shaders to compile and pixels to be drawn.
            await new Promise(resolve => {
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        this.dispatchEvent(new CustomEvent('load', { detail: { url: source } }));
                        resolve();
                    });
                });
            });
        }
        catch (error) {
            this.dispatchEvent(new CustomEvent('error', { detail: { type: 'loadfailure', sourceError: error } }));
        }
        finally {
            updateSourceProgress(1.0);
        }
    }
}
__decorate([
    (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ type: String })
], ModelViewerElementBase.prototype, "alt", void 0);
__decorate([
    (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ type: String })
], ModelViewerElementBase.prototype, "src", void 0);
__decorate([
    (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ type: Boolean, attribute: 'with-credentials' })
], ModelViewerElementBase.prototype, "withCredentials", void 0);
__decorate([
    (0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({ type: Boolean, attribute: 'generate-schema' })
], ModelViewerElementBase.prototype, "generateSchema", void 0);
//# sourceMappingURL=model-viewer-base.js.map

/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/model-viewer.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/model-viewer.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CanvasTexture": () => (/* reexport safe */ three__WEBPACK_IMPORTED_MODULE_9__.CanvasTexture),
/* harmony export */   "FileLoader": () => (/* reexport safe */ three__WEBPACK_IMPORTED_MODULE_9__.FileLoader),
/* harmony export */   "Loader": () => (/* reexport safe */ three__WEBPACK_IMPORTED_MODULE_9__.Loader),
/* harmony export */   "ModelViewerElement": () => (/* binding */ ModelViewerElement),
/* harmony export */   "NearestFilter": () => (/* reexport safe */ three__WEBPACK_IMPORTED_MODULE_9__.NearestFilter)
/* harmony export */ });
/* harmony import */ var _features_animation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./features/animation.js */ "../../node_modules/@google/model-viewer/lib/features/animation.js");
/* harmony import */ var _features_annotation_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./features/annotation.js */ "../../node_modules/@google/model-viewer/lib/features/annotation.js");
/* harmony import */ var _features_ar_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./features/ar.js */ "../../node_modules/@google/model-viewer/lib/features/ar.js");
/* harmony import */ var _features_controls_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./features/controls.js */ "../../node_modules/@google/model-viewer/lib/features/controls.js");
/* harmony import */ var _features_environment_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./features/environment.js */ "../../node_modules/@google/model-viewer/lib/features/environment.js");
/* harmony import */ var _features_loading_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./features/loading.js */ "../../node_modules/@google/model-viewer/lib/features/loading.js");
/* harmony import */ var _features_scene_graph_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./features/scene-graph.js */ "../../node_modules/@google/model-viewer/lib/features/scene-graph.js");
/* harmony import */ var _features_staging_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./features/staging.js */ "../../node_modules/@google/model-viewer/lib/features/staging.js");
/* harmony import */ var _model_viewer_base_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./model-viewer-base.js */ "../../node_modules/@google/model-viewer/lib/model-viewer-base.js");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! three */ "../../node_modules/three/build/three.module.js");
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */









// Export these to allow lazy-loaded LottieLoader.js to find what it needs.
// Requires an import map - "three": "path/to/model-viewer.min.js".

const ModelViewerElement = (0,_features_annotation_js__WEBPACK_IMPORTED_MODULE_1__.AnnotationMixin)((0,_features_scene_graph_js__WEBPACK_IMPORTED_MODULE_6__.SceneGraphMixin)((0,_features_staging_js__WEBPACK_IMPORTED_MODULE_7__.StagingMixin)((0,_features_environment_js__WEBPACK_IMPORTED_MODULE_4__.EnvironmentMixin)((0,_features_controls_js__WEBPACK_IMPORTED_MODULE_3__.ControlsMixin)((0,_features_ar_js__WEBPACK_IMPORTED_MODULE_2__.ARMixin)((0,_features_loading_js__WEBPACK_IMPORTED_MODULE_5__.LoadingMixin)((0,_features_animation_js__WEBPACK_IMPORTED_MODULE_0__.AnimationMixin)(_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_8__["default"]))))))));
customElements.define('model-viewer', ModelViewerElement);
//# sourceMappingURL=model-viewer.js.map

/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/styles/conversions.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/styles/conversions.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "degreesToRadians": () => (/* binding */ degreesToRadians),
/* harmony export */   "lengthToBaseMeters": () => (/* binding */ lengthToBaseMeters),
/* harmony export */   "normalizeUnit": () => (/* binding */ normalizeUnit),
/* harmony export */   "radiansToDegrees": () => (/* binding */ radiansToDegrees)
/* harmony export */ });
/* harmony import */ var _parsers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parsers */ "../../node_modules/@google/model-viewer/lib/styles/parsers.js");
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Ensures that a given number is expressed in radians. If the number is already
 * in radians, does nothing. If the value is in degrees, converts it to radians.
 * If the value has no specified unit, the unit is assumed to be radians. If the
 * value is not in radians or degrees, the value is resolved as 0 radians.
 *
 * Also accepts a second argument that is a default value to use if the input
 * numberNode number is NaN or Infinity.
 */
const degreesToRadians = (numberNode, fallbackRadianValue = 0) => {
    let { number, unit } = numberNode;
    if (!isFinite(number)) {
        number = fallbackRadianValue;
        unit = 'rad';
    }
    else if (numberNode.unit === 'rad' || numberNode.unit == null) {
        return numberNode;
    }
    const valueIsDegrees = unit === 'deg' && number != null;
    const value = valueIsDegrees ? number : 0;
    const radians = value * Math.PI / 180;
    return { type: 'number', number: radians, unit: 'rad' };
};
/**
 * Ensures that a given number is expressed in degrees. If the number is already
 * in degrees, does nothing. If the value is in radians or has no specified
 * unit, converts it to degrees. If the value is not in radians or degrees, the
 * value is resolved as 0 degrees.
 *
 * Also accepts a second argument that is a default value to use if the input
 * numberNode number is NaN or Infinity.
 */
const radiansToDegrees = (numberNode, fallbackDegreeValue = 0) => {
    let { number, unit } = numberNode;
    if (!isFinite(number)) {
        number = fallbackDegreeValue;
        unit = 'deg';
    }
    else if (numberNode.unit === 'deg') {
        return numberNode;
    }
    const valueIsRadians = (unit === null || unit === 'rad') && number != null;
    const value = valueIsRadians ? number : 0;
    const degrees = value * 180 / Math.PI;
    return { type: 'number', number: degrees, unit: 'deg' };
};
/**
 * Converts a given length to meters. Currently supported input units are
 * meters, centimeters and millimeters.
 *
 * Also accepts a second argument that is a default value to use if the input
 * numberNode number is NaN or Infinity.
 */
const lengthToBaseMeters = (numberNode, fallbackMeterValue = 0) => {
    let { number, unit } = numberNode;
    if (!isFinite(number)) {
        number = fallbackMeterValue;
        unit = 'm';
    }
    else if (numberNode.unit === 'm') {
        return numberNode;
    }
    let scale;
    switch (unit) {
        default:
            scale = 1;
            break;
        case 'cm':
            scale = 1 / 100;
            break;
        case 'mm':
            scale = 1 / 1000;
            break;
    }
    const value = scale * number;
    return { type: 'number', number: value, unit: 'm' };
};
/**
 * Normalizes the unit of a given input number so that it is expressed in a
 * preferred unit. For length nodes, the return value will be expressed in
 * meters. For angle nodes, the return value will be expressed in radians.
 *
 * Also takes a fallback number that is used when the number value is not a
 * valid number or when the unit of the given number cannot be normalized.
 */
const normalizeUnit = (() => {
    const identity = (node) => node;
    const unitNormalizers = {
        'rad': identity,
        'deg': degreesToRadians,
        'm': identity,
        'mm': lengthToBaseMeters,
        'cm': lengthToBaseMeters
    };
    return (node, fallback = _parsers__WEBPACK_IMPORTED_MODULE_0__.ZERO) => {
        if (!isFinite(node.number)) {
            node.number = fallback.number;
            node.unit = fallback.unit;
        }
        const { unit } = node;
        if (unit == null) {
            return node;
        }
        const normalize = unitNormalizers[unit];
        if (normalize == null) {
            return fallback;
        }
        return normalize(node);
    };
})();
//# sourceMappingURL=conversions.js.map

/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/styles/deserializers.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/styles/deserializers.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "enumerationDeserializer": () => (/* binding */ enumerationDeserializer)
/* harmony export */ });
/* harmony import */ var _parsers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parsers.js */ "../../node_modules/@google/model-viewer/lib/styles/parsers.js");
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * For our purposes, an enumeration is a fixed set of CSS-expression-compatible
 * names. When serialized, a selected subset of the members may be specified as
 * whitespace-separated strings. An enumeration deserializer is a function that
 * parses a serialized subset of an enumeration and returns any members that are
 * found as a Set.
 *
 * The following example will produce a deserializer for the days of the
 * week:
 *
 * const deserializeDaysOfTheWeek = enumerationDeserializer([
 *   'Monday',
 *   'Tuesday',
 *   'Wednesday',
 *   'Thursday',
 *   'Friday',
 *   'Saturday',
 *   'Sunday'
 * ]);
 */
const enumerationDeserializer = (allowedNames) => (valueString) => {
    try {
        const expressions = (0,_parsers_js__WEBPACK_IMPORTED_MODULE_0__.parseExpressions)(valueString);
        const names = (expressions.length ? expressions[0].terms : [])
            .filter((valueNode) => valueNode && valueNode.type === 'ident')
            .map(valueNode => valueNode.value)
            .filter(name => allowedNames.indexOf(name) > -1);
        // NOTE(cdata): IE11 does not support constructing a Set directly from
        // an iterable, so we need to manually add all the items:
        const result = new Set();
        for (const name of names) {
            result.add(name);
        }
        return result;
    }
    catch (_error) {
    }
    return new Set();
};
//# sourceMappingURL=deserializers.js.map

/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/styles/evaluators.js":
/*!************************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/styles/evaluators.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CalcEvaluator": () => (/* binding */ CalcEvaluator),
/* harmony export */   "EnvEvaluator": () => (/* binding */ EnvEvaluator),
/* harmony export */   "Evaluator": () => (/* binding */ Evaluator),
/* harmony export */   "OperatorEvaluator": () => (/* binding */ OperatorEvaluator),
/* harmony export */   "PercentageEvaluator": () => (/* binding */ PercentageEvaluator),
/* harmony export */   "StyleEvaluator": () => (/* binding */ StyleEvaluator)
/* harmony export */ });
/* harmony import */ var _conversions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./conversions */ "../../node_modules/@google/model-viewer/lib/styles/conversions.js");
/* harmony import */ var _parsers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parsers */ "../../node_modules/@google/model-viewer/lib/styles/parsers.js");
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var _a, _b, _c;


const $evaluate = Symbol('evaluate');
const $lastValue = Symbol('lastValue');
/**
 * An Evaluator is used to derive a computed style from part (or all) of a CSS
 * expression AST. This construct is particularly useful for complex ASTs
 * containing function calls such as calc, var and env. Such styles could be
 * costly to re-evaluate on every frame (and in some cases we may try to do
 * that). The Evaluator construct allows us to mark sub-trees of the AST as
 * constant, so that only the dynamic parts are re-evaluated. It also separates
 * one-time AST preparation work from work that necessarily has to happen upon
 * each evaluation.
 */
class Evaluator {
    constructor() {
        this[_a] = null;
    }
    /**
     * An Evaluatable is a NumberNode or an Evaluator that evaluates a NumberNode
     * as the result of invoking its evaluate method. This is mainly used to
     * ensure that CSS function nodes are cast to the corresponding Evaluators
     * that will resolve the result of the function, but is also used to ensure
     * that a percentage nested at arbitrary depth in the expression will always
     * be evaluated against the correct basis.
     */
    static evaluatableFor(node, basis = _parsers__WEBPACK_IMPORTED_MODULE_1__.ZERO) {
        if (node instanceof Evaluator) {
            return node;
        }
        if (node.type === 'number') {
            if (node.unit === '%') {
                return new PercentageEvaluator(node, basis);
            }
            return node;
        }
        switch (node.name.value) {
            case 'calc':
                return new CalcEvaluator(node, basis);
            case 'env':
                return new EnvEvaluator(node);
        }
        return _parsers__WEBPACK_IMPORTED_MODULE_1__.ZERO;
    }
    /**
     * If the input is an Evaluator, returns the result of evaluating it.
     * Otherwise, returns the input.
     *
     * This is a helper to aide in resolving a NumberNode without conditionally
     * checking if the Evaluatable is an Evaluator everywhere.
     */
    static evaluate(evaluatable) {
        if (evaluatable instanceof Evaluator) {
            return evaluatable.evaluate();
        }
        return evaluatable;
    }
    /**
     * If the input is an Evaluator, returns the value of its isConstant property.
     * Returns true for all other input values.
     */
    static isConstant(evaluatable) {
        if (evaluatable instanceof Evaluator) {
            return evaluatable.isConstant;
        }
        return true;
    }
    /**
     * This method applies a set of structured intrinsic metadata to an evaluated
     * result from a parsed CSS-like string of expressions. Intrinsics provide
     * sufficient metadata (e.g., basis values, analogs for keywords) such that
     * omitted values in the input string can be backfilled, and keywords can be
     * converted to concrete numbers.
     *
     * The result of applying intrinsics is a tuple of NumberNode values whose
     * units match the units used by the basis of the intrinsics.
     *
     * The following is a high-level description of how intrinsics are applied:
     *
     *  1. Determine the value of 'auto' for the current term
     *  2. If there is no corresponding input value for this term, substitute the
     *     'auto' value.
     *  3. If the term is an IdentNode, treat it as a keyword and perform the
     *     appropriate substitution.
     *  4. If the term is still null, fallback to the 'auto' value
     *  5. If the term is a percentage, apply it to the basis and return that
     *     value
     *  6. Normalize the unit of the term
     *  7. If the term's unit does not match the basis unit, return the basis
     *     value
     *  8. Return the term as is
     */
    static applyIntrinsics(evaluated, intrinsics) {
        const { basis, keywords } = intrinsics;
        const { auto } = keywords;
        return basis.map((basisNode, index) => {
            // Use an auto value if we have it, otherwise the auto value is the basis:
            const autoSubstituteNode = auto[index] == null ? basisNode : auto[index];
            // If the evaluated nodes do not have a node at the current
            // index, fallback to the "auto" substitute right away:
            let evaluatedNode = evaluated[index] ? evaluated[index] : autoSubstituteNode;
            // Any ident node is considered a keyword:
            if (evaluatedNode.type === 'ident') {
                const keyword = evaluatedNode.value;
                // Substitute any keywords for concrete values first:
                if (keyword in keywords) {
                    evaluatedNode = keywords[keyword][index];
                }
            }
            // If we don't have a NumberNode at this point, fall back to whatever
            // is specified for auto:
            if (evaluatedNode == null || evaluatedNode.type === 'ident') {
                evaluatedNode = autoSubstituteNode;
            }
            // For percentages, we always apply the percentage to the basis value:
            if (evaluatedNode.unit === '%') {
                return (0,_parsers__WEBPACK_IMPORTED_MODULE_1__.numberNode)(evaluatedNode.number / 100 * basisNode.number, basisNode.unit);
            }
            // Otherwise, normalize whatever we have:
            evaluatedNode = (0,_conversions__WEBPACK_IMPORTED_MODULE_0__.normalizeUnit)(evaluatedNode, basisNode);
            // If the normalized units do not match, return the basis as a fallback:
            if (evaluatedNode.unit !== basisNode.unit) {
                return basisNode;
            }
            // Finally, return the evaluated node with intrinsics applied:
            return evaluatedNode;
        });
    }
    /**
     * If true, the Evaluator will only evaluate its AST one time. If false, the
     * Evaluator will re-evaluate the AST each time that the public evaluate
     * method is invoked.
     */
    get isConstant() {
        return false;
    }
    /**
     * Evaluate the Evaluator and return the result. If the Evaluator is constant,
     * the corresponding AST will only be evaluated once, and the result of
     * evaluating it the first time will be returned on all subsequent
     * evaluations.
     */
    evaluate() {
        if (!this.isConstant || this[$lastValue] == null) {
            this[$lastValue] = this[$evaluate]();
        }
        return this[$lastValue];
    }
}
_a = $lastValue;
const $percentage = Symbol('percentage');
const $basis = Symbol('basis');
/**
 * A PercentageEvaluator scales a given basis value by a given percentage value.
 * The evaluated result is always considered to be constant.
 */
class PercentageEvaluator extends Evaluator {
    constructor(percentage, basis) {
        super();
        this[$percentage] = percentage;
        this[$basis] = basis;
    }
    get isConstant() {
        return true;
    }
    [$evaluate]() {
        return (0,_parsers__WEBPACK_IMPORTED_MODULE_1__.numberNode)(this[$percentage].number / 100 * this[$basis].number, this[$basis].unit);
    }
}
const $identNode = Symbol('identNode');
/**
 * Evaluator for CSS-like env() functions. Currently, only one environment
 * variable is accepted as an argument for such functions: window-scroll-y.
 *
 * The env() Evaluator is explicitly dynamic because it always refers to
 * external state that changes as the user scrolls, so it should always be
 * re-evaluated to ensure we get the most recent value.
 *
 * Some important notes about this feature include:
 *
 *  - There is no such thing as a "window-scroll-y" CSS environment variable in
 *    any stable browser at the time that this comment is being written.
 *  - The actual CSS env() function accepts a second argument as a fallback for
 *    the case that the specified first argument isn't set; our syntax does not
 *    support this second argument.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/env
 */
class EnvEvaluator extends Evaluator {
    constructor(envFunction) {
        super();
        this[_b] = null;
        const identNode = envFunction.arguments.length ? envFunction.arguments[0].terms[0] : null;
        if (identNode != null && identNode.type === 'ident') {
            this[$identNode] = identNode;
        }
    }
    get isConstant() {
        return false;
    }
    ;
    [(_b = $identNode, $evaluate)]() {
        if (this[$identNode] != null) {
            switch (this[$identNode].value) {
                case 'window-scroll-y':
                    const verticalScrollPosition = window.pageYOffset;
                    const verticalScrollMax = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight);
                    const scrollY = verticalScrollPosition /
                        (verticalScrollMax - window.innerHeight) ||
                        0;
                    return { type: 'number', number: scrollY, unit: null };
            }
        }
        return _parsers__WEBPACK_IMPORTED_MODULE_1__.ZERO;
    }
}
const IS_MULTIPLICATION_RE = /[\*\/]/;
const $evaluator = Symbol('evaluator');
/**
 * Evaluator for CSS-like calc() functions. Our implementation of calc()
 * evaluation currently support nested function calls, an unlimited number of
 * terms, and all four algebraic operators (+, -, * and /).
 *
 * The Evaluator is marked as constant unless the calc expression contains an
 * internal env expression at any depth, in which case it will be marked as
 * dynamic.
 *
 * @see https://www.w3.org/TR/css-values-3/#calc-syntax
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/calc
 */
class CalcEvaluator extends Evaluator {
    constructor(calcFunction, basis = _parsers__WEBPACK_IMPORTED_MODULE_1__.ZERO) {
        super();
        this[_c] = null;
        if (calcFunction.arguments.length !== 1) {
            return;
        }
        const terms = calcFunction.arguments[0].terms.slice();
        const secondOrderTerms = [];
        while (terms.length) {
            const term = terms.shift();
            if (secondOrderTerms.length > 0) {
                const previousTerm = secondOrderTerms[secondOrderTerms.length - 1];
                if (previousTerm.type === 'operator' &&
                    IS_MULTIPLICATION_RE.test(previousTerm.value)) {
                    const operator = secondOrderTerms.pop();
                    const leftValue = secondOrderTerms.pop();
                    if (leftValue == null) {
                        return;
                    }
                    secondOrderTerms.push(new OperatorEvaluator(operator, Evaluator.evaluatableFor(leftValue, basis), Evaluator.evaluatableFor(term, basis)));
                    continue;
                }
            }
            secondOrderTerms.push(term.type === 'operator' ? term :
                Evaluator.evaluatableFor(term, basis));
        }
        while (secondOrderTerms.length > 2) {
            const [left, operator, right] = secondOrderTerms.splice(0, 3);
            if (operator.type !== 'operator') {
                return;
            }
            secondOrderTerms.unshift(new OperatorEvaluator(operator, Evaluator.evaluatableFor(left, basis), Evaluator.evaluatableFor(right, basis)));
        }
        // There should only be one combined evaluator at this point:
        if (secondOrderTerms.length === 1) {
            this[$evaluator] = secondOrderTerms[0];
        }
    }
    get isConstant() {
        return this[$evaluator] == null || Evaluator.isConstant(this[$evaluator]);
    }
    [(_c = $evaluator, $evaluate)]() {
        return this[$evaluator] != null ? Evaluator.evaluate(this[$evaluator]) :
            _parsers__WEBPACK_IMPORTED_MODULE_1__.ZERO;
    }
}
const $operator = Symbol('operator');
const $left = Symbol('left');
const $right = Symbol('right');
/**
 * An Evaluator for the operators found inside CSS calc() functions.
 * The evaluator accepts an operator and left/right operands. The operands can
 * be any valid expression term typically allowed inside a CSS calc function.
 *
 * As detail of this implementation, the only supported unit types are angles
 * expressed as radians or degrees, and lengths expressed as meters, centimeters
 * or millimeters.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/calc
 */
class OperatorEvaluator extends Evaluator {
    constructor(operator, left, right) {
        super();
        this[$operator] = operator;
        this[$left] = left;
        this[$right] = right;
    }
    get isConstant() {
        return Evaluator.isConstant(this[$left]) &&
            Evaluator.isConstant(this[$right]);
    }
    [$evaluate]() {
        const leftNode = (0,_conversions__WEBPACK_IMPORTED_MODULE_0__.normalizeUnit)(Evaluator.evaluate(this[$left]));
        const rightNode = (0,_conversions__WEBPACK_IMPORTED_MODULE_0__.normalizeUnit)(Evaluator.evaluate(this[$right]));
        const { number: leftValue, unit: leftUnit } = leftNode;
        const { number: rightValue, unit: rightUnit } = rightNode;
        // Disallow operations for mismatched normalized units e.g., m and rad:
        if (rightUnit != null && leftUnit != null && rightUnit != leftUnit) {
            return _parsers__WEBPACK_IMPORTED_MODULE_1__.ZERO;
        }
        // NOTE(cdata): rules for calc type checking are defined here
        // https://drafts.csswg.org/css-values-3/#calc-type-checking
        // This is a simplification and may not hold up once we begin to support
        // additional unit types:
        const unit = leftUnit || rightUnit;
        let value;
        switch (this[$operator].value) {
            case '+':
                value = leftValue + rightValue;
                break;
            case '-':
                value = leftValue - rightValue;
                break;
            case '/':
                value = leftValue / rightValue;
                break;
            case '*':
                value = leftValue * rightValue;
                break;
            default:
                return _parsers__WEBPACK_IMPORTED_MODULE_1__.ZERO;
        }
        return { type: 'number', number: value, unit };
    }
}
const $evaluatables = Symbol('evaluatables');
const $intrinsics = Symbol('intrinsics');
/**
 * A VectorEvaluator evaluates a series of numeric terms that usually represent
 * a data structure such as a multi-dimensional vector or a spherical
 *
 * The form of the evaluator's result is determined by the Intrinsics that are
 * given to it when it is constructed. For example, spherical intrinsics would
 * establish two angle terms and a length term, so the result of evaluating the
 * evaluator that is configured with spherical intrinsics is a three element
 * array where the first two elements represent angles in radians and the third
 * element representing a length in meters.
 */
class StyleEvaluator extends Evaluator {
    constructor(expressions, intrinsics) {
        super();
        this[$intrinsics] = intrinsics;
        const firstExpression = expressions[0];
        const terms = firstExpression != null ? firstExpression.terms : [];
        this[$evaluatables] =
            intrinsics.basis.map((basisNode, index) => {
                const term = terms[index];
                if (term == null) {
                    return { type: 'ident', value: 'auto' };
                }
                if (term.type === 'ident') {
                    return term;
                }
                return Evaluator.evaluatableFor(term, basisNode);
            });
    }
    get isConstant() {
        for (const evaluatable of this[$evaluatables]) {
            if (!Evaluator.isConstant(evaluatable)) {
                return false;
            }
        }
        return true;
    }
    [$evaluate]() {
        const evaluated = this[$evaluatables].map(evaluatable => Evaluator.evaluate(evaluatable));
        return Evaluator.applyIntrinsics(evaluated, this[$intrinsics])
            .map(numberNode => numberNode.number);
    }
}
//# sourceMappingURL=evaluators.js.map

/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/styles/parsers.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/styles/parsers.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ASTWalker": () => (/* binding */ ASTWalker),
/* harmony export */   "ZERO": () => (/* binding */ ZERO),
/* harmony export */   "numberNode": () => (/* binding */ numberNode),
/* harmony export */   "parseExpressions": () => (/* binding */ parseExpressions)
/* harmony export */ });
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const numberNode = (value, unit) => ({ type: 'number', number: value, unit });
/**
 * Given a string representing a comma-separated set of CSS-like expressions,
 * parses and returns an array of ASTs that correspond to those expressions.
 *
 * Currently supported syntax includes:
 *
 *  - functions (top-level and nested)
 *  - calc() arithmetic operators
 *  - numbers with units
 *  - hexadecimal-encoded colors in 3, 6 or 8 digit form
 *  - idents
 *
 * All syntax is intended to match the parsing rules and semantics of the actual
 * CSS spec as closely as possible.
 *
 * @see https://www.w3.org/TR/CSS2/
 * @see https://www.w3.org/TR/css-values-3/
 */
const parseExpressions = (() => {
    const cache = {};
    const MAX_PARSE_ITERATIONS = 1000; // Arbitrarily large
    return (inputString) => {
        const cacheKey = inputString;
        if (cacheKey in cache) {
            return cache[cacheKey];
        }
        const expressions = [];
        let parseIterations = 0;
        while (inputString) {
            if (++parseIterations > MAX_PARSE_ITERATIONS) {
                // Avoid a potentially infinite loop due to typos:
                inputString = '';
                break;
            }
            const expressionParseResult = parseExpression(inputString);
            const expression = expressionParseResult.nodes[0];
            if (expression == null || expression.terms.length === 0) {
                break;
            }
            expressions.push(expression);
            inputString = expressionParseResult.remainingInput;
        }
        return cache[cacheKey] = expressions;
    };
})();
/**
 * Parse a single expression. For the purposes of our supported syntax, an
 * expression is the set of semantically meaningful terms that appear before the
 * next comma, or between the parens of a function invocation.
 */
const parseExpression = (() => {
    const IS_IDENT_RE = /^(\-\-|[a-z\u0240-\uffff])/i;
    const IS_OPERATOR_RE = /^([\*\+\/]|[\-]\s)/i;
    const IS_EXPRESSION_END_RE = /^[\),]/;
    const FUNCTION_ARGUMENTS_FIRST_TOKEN = '(';
    const HEX_FIRST_TOKEN = '#';
    return (inputString) => {
        const terms = [];
        while (inputString.length) {
            inputString = inputString.trim();
            if (IS_EXPRESSION_END_RE.test(inputString)) {
                break;
            }
            else if (inputString[0] === FUNCTION_ARGUMENTS_FIRST_TOKEN) {
                const { nodes, remainingInput } = parseFunctionArguments(inputString);
                inputString = remainingInput;
                terms.push({
                    type: 'function',
                    name: { type: 'ident', value: 'calc' },
                    arguments: nodes
                });
            }
            else if (IS_IDENT_RE.test(inputString)) {
                const identParseResult = parseIdent(inputString);
                const identNode = identParseResult.nodes[0];
                inputString = identParseResult.remainingInput;
                if (inputString[0] === FUNCTION_ARGUMENTS_FIRST_TOKEN) {
                    const { nodes, remainingInput } = parseFunctionArguments(inputString);
                    terms.push({ type: 'function', name: identNode, arguments: nodes });
                    inputString = remainingInput;
                }
                else {
                    terms.push(identNode);
                }
            }
            else if (IS_OPERATOR_RE.test(inputString)) {
                // Operators are always a single character, so just pluck them out:
                terms.push({ type: 'operator', value: inputString[0] });
                inputString = inputString.slice(1);
            }
            else {
                const { nodes, remainingInput } = inputString[0] === HEX_FIRST_TOKEN ?
                    parseHex(inputString) :
                    parseNumber(inputString);
                // The remaining string may not have had any meaningful content. Exit
                // early if this is the case:
                if (nodes.length === 0) {
                    break;
                }
                terms.push(nodes[0]);
                inputString = remainingInput;
            }
        }
        return { nodes: [{ type: 'expression', terms }], remainingInput: inputString };
    };
})();
/**
 * An ident is something like a function name or the keyword "auto".
 */
const parseIdent = (() => {
    const NOT_IDENT_RE = /[^a-z0-9_\-\u0240-\uffff]/i;
    return (inputString) => {
        const match = inputString.match(NOT_IDENT_RE);
        const ident = match == null ? inputString : inputString.substr(0, match.index);
        const remainingInput = match == null ? '' : inputString.substr(match.index);
        return { nodes: [{ type: 'ident', value: ident }], remainingInput };
    };
})();
/**
 * Parses a number. A number value can be expressed with an integer or
 * non-integer syntax, and usually includes a unit (but does not strictly
 * require one for our purposes).
 */
const parseNumber = (() => {
    // @see https://www.w3.org/TR/css-syntax/#number-token-diagram
    const VALUE_RE = /[\+\-]?(\d+[\.]\d+|\d+|[\.]\d+)([eE][\+\-]?\d+)?/;
    const UNIT_RE = /^[a-z%]+/i;
    const ALLOWED_UNITS = /^(m|mm|cm|rad|deg|[%])$/;
    return (inputString) => {
        const valueMatch = inputString.match(VALUE_RE);
        const value = valueMatch == null ? '0' : valueMatch[0];
        inputString = value == null ? inputString : inputString.slice(value.length);
        const unitMatch = inputString.match(UNIT_RE);
        let unit = unitMatch != null && unitMatch[0] !== '' ? unitMatch[0] : null;
        const remainingInput = unitMatch == null ? inputString : inputString.slice(unit.length);
        if (unit != null && !ALLOWED_UNITS.test(unit)) {
            unit = null;
        }
        return {
            nodes: [{
                    type: 'number',
                    number: parseFloat(value) || 0,
                    unit: unit
                }],
            remainingInput
        };
    };
})();
/**
 * Parses a hexadecimal-encoded color in 3, 6 or 8 digit form.
 */
const parseHex = (() => {
    // TODO(cdata): right now we don't actually enforce the number of digits
    const HEX_RE = /^[a-f0-9]*/i;
    return (inputString) => {
        inputString = inputString.slice(1).trim();
        const hexMatch = inputString.match(HEX_RE);
        const nodes = hexMatch == null ? [] : [{ type: 'hex', value: hexMatch[0] }];
        return {
            nodes,
            remainingInput: hexMatch == null ? inputString :
                inputString.slice(hexMatch[0].length)
        };
    };
})();
/**
 * Parses arguments passed to a function invocation (e.g., the expressions
 * within a matched set of parens).
 */
const parseFunctionArguments = (inputString) => {
    const expressionNodes = [];
    // Consume the opening paren
    inputString = inputString.slice(1).trim();
    while (inputString.length) {
        const expressionParseResult = parseExpression(inputString);
        expressionNodes.push(expressionParseResult.nodes[0]);
        inputString = expressionParseResult.remainingInput.trim();
        if (inputString[0] === ',') {
            inputString = inputString.slice(1).trim();
        }
        else if (inputString[0] === ')') {
            // Consume the closing paren and stop parsing
            inputString = inputString.slice(1);
            break;
        }
    }
    return { nodes: expressionNodes, remainingInput: inputString };
};
const $visitedTypes = Symbol('visitedTypes');
/**
 * An ASTWalker walks an array of ASTs such as the type produced by
 * parseExpressions and invokes a callback for a configured set of nodes that
 * the user wishes to "visit" during the walk.
 */
class ASTWalker {
    constructor(visitedTypes) {
        this[$visitedTypes] = visitedTypes;
    }
    /**
     * Walk the given set of ASTs, and invoke the provided callback for nodes that
     * match the filtered set that the ASTWalker was constructed with.
     */
    walk(ast, callback) {
        const remaining = ast.slice();
        while (remaining.length) {
            const next = remaining.shift();
            if (this[$visitedTypes].indexOf(next.type) > -1) {
                callback(next);
            }
            switch (next.type) {
                case 'expression':
                    remaining.unshift(...next.terms);
                    break;
                case 'function':
                    remaining.unshift(next.name, ...next.arguments);
                    break;
            }
        }
    }
}
const ZERO = Object.freeze({ type: 'number', number: 0, unit: null });
//# sourceMappingURL=parsers.js.map

/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/styles/style-effector.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/styles/style-effector.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StyleEffector": () => (/* binding */ StyleEffector)
/* harmony export */ });
/* harmony import */ var _parsers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parsers */ "../../node_modules/@google/model-viewer/lib/styles/parsers.js");
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var _a, _b, _c, _d;

const $instances = Symbol('instances');
const $activateListener = Symbol('activateListener');
const $deactivateListener = Symbol('deactivateListener');
const $notifyInstances = Symbol('notifyInstances');
const $notify = Symbol('notify');
const $scrollCallback = Symbol('callback');
/**
 * This internal helper is intended to work as a reference-counting manager of
 * scroll event listeners. Only one scroll listener is ever registered for all
 * instances of the class, and when the last ScrollObserver "disconnects", that
 * event listener is removed. This spares us from thrashing
 * the {add,remove}EventListener API (the binding cost of these methods has been
 * known to show up in performance analyses) as well as potential memory leaks.
 */
class ScrollObserver {
    constructor(callback) {
        this[$scrollCallback] = callback;
    }
    static [$notifyInstances]() {
        for (const instance of ScrollObserver[$instances]) {
            instance[$notify]();
        }
    }
    static [(_a = $instances, $activateListener)]() {
        window.addEventListener('scroll', this[$notifyInstances], { passive: true });
    }
    static [$deactivateListener]() {
        window.removeEventListener('scroll', this[$notifyInstances]);
    }
    /**
     * Listen for scroll events. The configured callback (passed to the
     * constructor) will be invoked for subsequent global scroll events.
     */
    observe() {
        if (ScrollObserver[$instances].size === 0) {
            ScrollObserver[$activateListener]();
        }
        ScrollObserver[$instances].add(this);
    }
    /**
     * Stop listening for scroll events.
     */
    disconnect() {
        ScrollObserver[$instances].delete(this);
        if (ScrollObserver[$instances].size === 0) {
            ScrollObserver[$deactivateListener]();
        }
    }
    [$notify]() {
        this[$scrollCallback]();
    }
    ;
}
ScrollObserver[_a] = new Set();
const $computeStyleCallback = Symbol('computeStyleCallback');
const $astWalker = Symbol('astWalker');
const $dependencies = Symbol('dependencies');
const $onScroll = Symbol('onScroll');
/**
 * The StyleEffector is configured with a callback that will be invoked at the
 * optimal time that some array of CSS expression ASTs ought to be evaluated.
 *
 * For example, our CSS-like expression syntax supports usage of the env()
 * function to incorporate the current top-level scroll position into a CSS
 * expression: env(window-scroll-y).
 *
 * This "environment variable" will change dynamically as the user scrolls the
 * page. If an AST contains such a usage of env(), we would have to evaluate the
 * AST on every frame in order to be sure that the computed style stays up to
 * date.
 *
 * The StyleEffector spares us from evaluating the expressions on every frame by
 * correlating specific parts of an AST with observers of the external effects
 * that they refer to (if any). So, if the AST contains env(window-scroll-y),
 * the StyleEffector manages the lifetime of a global scroll event listener and
 * notifies the user at the optimal time to evaluate the computed style.
 */
class StyleEffector {
    constructor(callback) {
        this[_b] = {};
        this[_c] = new _parsers__WEBPACK_IMPORTED_MODULE_0__.ASTWalker(['function']);
        this[_d] = () => {
            this[$computeStyleCallback]({ relatedState: 'window-scroll' });
        };
        this[$computeStyleCallback] = callback;
    }
    /**
     * Sets the expressions that govern when the StyleEffector callback will be
     * invoked.
     */
    observeEffectsFor(ast) {
        const newDependencies = {};
        const oldDependencies = this[$dependencies];
        this[$astWalker].walk(ast, functionNode => {
            const { name } = functionNode;
            const firstArgument = functionNode.arguments[0];
            const firstTerm = firstArgument.terms[0];
            if (name.value !== 'env' || firstTerm == null ||
                firstTerm.type !== 'ident') {
                return;
            }
            switch (firstTerm.value) {
                case 'window-scroll-y':
                    if (newDependencies['window-scroll'] == null) {
                        const observer = 'window-scroll' in oldDependencies ?
                            oldDependencies['window-scroll'] :
                            new ScrollObserver(this[$onScroll]);
                        observer.observe();
                        delete oldDependencies['window-scroll'];
                        newDependencies['window-scroll'] = observer;
                    }
                    break;
            }
        });
        for (const environmentState in oldDependencies) {
            const observer = oldDependencies[environmentState];
            observer.disconnect();
        }
        this[$dependencies] = newDependencies;
    }
    /**
     * Disposes of the StyleEffector by disconnecting all observers of external
     * effects.
     */
    dispose() {
        for (const environmentState in this[$dependencies]) {
            const observer = this[$dependencies][environmentState];
            observer.disconnect();
        }
    }
}
_b = $dependencies, _c = $astWalker, _d = $onScroll;
//# sourceMappingURL=style-effector.js.map

/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/template.js":
/*!***************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/template.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "makeTemplate": () => (/* binding */ makeTemplate)
/* harmony export */ });
/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ "../../node_modules/lit/index.js");
/* harmony import */ var _assets_close_material_svg_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assets/close-material-svg.js */ "../../node_modules/@google/model-viewer/lib/assets/close-material-svg.js");
/* harmony import */ var _assets_controls_svg_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./assets/controls-svg.js */ "../../node_modules/@google/model-viewer/lib/assets/controls-svg.js");
/* harmony import */ var _assets_view_in_ar_material_svg_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./assets/view-in-ar-material-svg.js */ "../../node_modules/@google/model-viewer/lib/assets/view-in-ar-material-svg.js");
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




const templateResult = lit__WEBPACK_IMPORTED_MODULE_0__.html `
<style>
:host {
  display: block;
  position: relative;
  contain: strict;
  width: 300px;
  height: 150px;
}

.container {
  position: relative;
  overflow: hidden;
}

.userInput {
  width: 100%;
  height: 100%;
  display: none;
  position: relative;
  outline-offset: -1px;
  outline-width: 1px;
}

canvas {
  position: absolute;
  display: none;
  pointer-events: none;
  /* NOTE(cdata): Chrome 76 and below apparently have a bug
   * that causes our canvas not to display pixels unless it is
   * on its own render layer
   * @see https://github.com/google/model-viewer/pull/755#issuecomment-536597893
   */
  transform: translateZ(0);
}

.show {
  display: block;
}

/* Adapted from HTML5 Boilerplate
 *
 * @see https://github.com/h5bp/html5-boilerplate/blob/ceb4620c78fc82e13534fc44202a3f168754873f/dist/css/main.css#L122-L133 */
.screen-reader-only {
  border: 0;
  left: 0;
  top: 0;
  clip: rect(0, 0, 0, 0);
  height: 1px;
  margin: -1px;
  overflow: hidden;
  padding: 0;
  position: absolute;
  white-space: nowrap;
  width: 1px;
  pointer-events: none;
}

.slot {
  position: absolute;
  pointer-events: none;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}

.slot > * {
  pointer-events: initial;
}

.annotation-wrapper ::slotted(*) {
  opacity: var(--max-hotspot-opacity, 1);
  transition: opacity 0.3s;
}

.pointer-tumbling .annotation-wrapper ::slotted(*) {
  pointer-events: none;
}

.annotation-wrapper ::slotted(*) {
  pointer-events: initial;
}

.annotation-wrapper.hide ::slotted(*) {
  opacity: var(--min-hotspot-opacity, 0.25);
}

.slot.poster {
  display: none;
  background-color: inherit;
}

.slot.poster.show {
  display: inherit;
}

.slot.poster > * {
  pointer-events: initial;
}

.slot.poster:not(.show) > * {
  pointer-events: none;
}

#default-poster {
  width: 100%;
  height: 100%;
  /* The default poster is a <button> so we need to set display
   * to prevent it from being affected by text-align: */
  display: block;
  position: absolute;
  border: none;
  padding: 0;
  background-size: contain;
  background-repeat: no-repeat;
  background-position: center;
  background-color: #fff0;
}

#default-progress-bar {
  display: block;
  position: relative;
  width: 100%;
  height: 100%;
  pointer-events: none;
  overflow: hidden;
}

#default-progress-bar > .bar {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: var(--progress-bar-height, 5px);
  background-color: var(--progress-bar-color, rgba(0, 0, 0, 0.4));
  transition: transform 0.09s;
  transform-origin: top left;
  transform: scaleX(0);
  overflow: hidden;
}

#default-progress-bar > .bar.hide {
  transition: opacity 0.3s 1s;
  opacity: 0;
}

.centered {
  align-items: center;
  justify-content: center;
}

.cover {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
}

.slot.interaction-prompt {
  display: var(--interaction-prompt-display, flex);
  overflow: hidden;
  opacity: 0;
  will-change: opacity;
  transition: opacity 0.3s;
}

.slot.interaction-prompt.visible {
  opacity: 1;
}

.animated-container {
  will-change: transform, opacity;
  opacity: 0;
  transition: opacity 0.3s;
}

.slot.interaction-prompt > * {
  pointer-events: none;
}

.slot.ar-button {
  -moz-user-select: none;
  -webkit-tap-highlight-color: transparent;
  user-select: none;

  display: var(--ar-button-display, block);
}

.slot.ar-button:not(.enabled) {
  display: none;
}

.fab {
  display: flex;
  align-items: center;
  justify-content: center;
  box-sizing: border-box;
  width: 40px;
  height: 40px;
  cursor: pointer;
  background-color: #fff;
  box-shadow: 0px 0px 4px rgba(0, 0, 0, 0.15);
  border-radius: 100px;
}

.fab > * {
  opacity: 0.87;
}

#default-ar-button {
  position: absolute;
  bottom: 16px;
  right: 16px;
  transform: scale(var(--ar-button-scale, 1));
  transform-origin: bottom right;
}

.slot.pan-target {
  display: block;
  position: absolute;
  width: 0;
  height: 0;
  left: 50%;
  top: 50%;
  transform: translate3d(-50%, -50%, 0);
  background-color: transparent;
  opacity: 0;
  transition: opacity 0.3s;
}

#default-pan-target {
  width: 6px;
  height: 6px;
  border-radius: 6px;
  border: 1px solid white;
  box-shadow: 0px 0px 2px 1px rgba(0, 0, 0, 0.8);
}

.slot.default {
  pointer-events: none;
}

.slot.progress-bar {
  pointer-events: none;
}

.slot.exit-webxr-ar-button {
  pointer-events: none;
}

.slot.exit-webxr-ar-button:not(.enabled) {
  display: none;
}

#default-exit-webxr-ar-button {
  display: flex;
  align-items: center;
  justify-content: center;
  position: absolute;
  top: env(safe-area-inset-top, 16px);
  right: 16px;
  width: 40px;
  height: 40px;
  box-sizing: border-box;
}

#default-exit-webxr-ar-button > svg {
  fill: #fff;
}
</style>
<div class="container">
  <div class="userInput" tabindex="0" role="img"
      aria-label="3D model">
      <div class="slot canvas">
        <slot name="canvas">
          <canvas></canvas>
        </slot>
      </div>

  </div>

  <!-- NOTE(cdata): We need to wrap slots because browsers without ShadowDOM
        will have their <slot> elements removed by ShadyCSS -->
  <div class="slot poster">
    <slot name="poster">
      <button type="button" id="default-poster" aria-hidden="true" aria-label="Loading 3D model"></button>
    </slot>
  </div>

  <div class="slot ar-button">
    <slot name="ar-button">
      <a id="default-ar-button" part="default-ar-button" class="fab"
          tabindex="2"
          aria-label="View in your space">
        ${_assets_view_in_ar_material_svg_js__WEBPACK_IMPORTED_MODULE_3__["default"]}
      </a>
    </slot>
  </div>

  <div class="slot pan-target">
    <slot name="pan-target">
      <div id="default-pan-target">
      </div>
    </slot>
  </div>

  <div class="slot interaction-prompt cover centered">
    <div id="prompt" class="animated-container">
      <slot name="interaction-prompt" aria-hidden="true">
        ${_assets_controls_svg_js__WEBPACK_IMPORTED_MODULE_2__["default"]}
      </slot>
    </div>
  </div>

  <div id="finger0" class="animated-container cover">
    <slot name="finger0" aria-hidden="true">
    </slot>
  </div>
  <div id="finger1" class="animated-container cover">
    <slot name="finger1" aria-hidden="true">
    </slot>
  </div>

  <div class="slot default">
    <slot></slot>

    <div class="slot progress-bar">
      <slot name="progress-bar">
        <div id="default-progress-bar" aria-hidden="true">
          <div class="bar" part="default-progress-bar"></div>
        </div>
      </slot>
    </div>

    <div class="slot exit-webxr-ar-button">
      <slot name="exit-webxr-ar-button">
        <a id="default-exit-webxr-ar-button" part="default-exit-webxr-ar-button"
            tabindex="3"
            aria-label="Exit AR"
            aria-hidden="true">
          ${_assets_close_material_svg_js__WEBPACK_IMPORTED_MODULE_1__["default"]}
        </a>
      </slot>
    </div>
  </div>
</div>
<div class="screen-reader-only" role="region" aria-label="Live announcements">
  <span id="status" role="status"></span>
</div>`;
const makeTemplate = (shadowRoot) => {
    (0,lit__WEBPACK_IMPORTED_MODULE_0__.render)(templateResult, shadowRoot);
};
//# sourceMappingURL=template.js.map

/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/three-components/ARRenderer.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/three-components/ARRenderer.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ARRenderer": () => (/* binding */ ARRenderer),
/* harmony export */   "ARStatus": () => (/* binding */ ARStatus),
/* harmony export */   "ARTracking": () => (/* binding */ ARTracking)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! three */ "../../node_modules/three/build/three.module.js");
/* harmony import */ var three_examples_jsm_webxr_XREstimatedLight_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! three/examples/jsm/webxr/XREstimatedLight.js */ "../../node_modules/three/examples/jsm/webxr/XREstimatedLight.js");
/* harmony import */ var _features_environment_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../features/environment.js */ "../../node_modules/@google/model-viewer/lib/features/environment.js");
/* harmony import */ var _model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../model-viewer-base.js */ "../../node_modules/@google/model-viewer/lib/model-viewer-base.js");
/* harmony import */ var _utilities_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utilities.js */ "../../node_modules/@google/model-viewer/lib/utilities.js");
/* harmony import */ var _Damper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Damper.js */ "../../node_modules/@google/model-viewer/lib/three-components/Damper.js");
/* harmony import */ var _PlacementBox_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./PlacementBox.js */ "../../node_modules/@google/model-viewer/lib/three-components/PlacementBox.js");
/* harmony import */ var _SmoothControls_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./SmoothControls.js */ "../../node_modules/@google/model-viewer/lib/three-components/SmoothControls.js");
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








// number of initial null pose XRFrames allowed before we post not-tracking
const INIT_FRAMES = 30;
// AR shadow is not user-configurable. This is to pave the way for AR lighting
// estimation, which will be used once available in WebXR.
const AR_SHADOW_INTENSITY = 0.8;
const ROTATION_RATE = 1.5;
// Angle down (towards bottom of screen) from camera center ray to use for hit
// testing against the floor. This makes placement faster and more intuitive
// assuming the phone is in portrait mode. This seems to be a reasonable
// assumption for the start of the session and UI will lack landscape mode to
// encourage upright use.
const HIT_ANGLE_DEG = 20;
const SCALE_SNAP_HIGH = 1.3;
const SCALE_SNAP_LOW = 1 / SCALE_SNAP_HIGH;
// For automatic dynamic viewport scaling, don't let the scale drop below this
// limit.
const MIN_VIEWPORT_SCALE = 0.25;
// Furthest away you can move an object (meters).
const MAX_DISTANCE = 10;
const ARStatus = {
    NOT_PRESENTING: 'not-presenting',
    SESSION_STARTED: 'session-started',
    OBJECT_PLACED: 'object-placed',
    FAILED: 'failed'
};
const ARTracking = {
    TRACKING: 'tracking',
    NOT_TRACKING: 'not-tracking'
};
const vector3 = new three__WEBPACK_IMPORTED_MODULE_6__.Vector3();
const matrix4 = new three__WEBPACK_IMPORTED_MODULE_6__.Matrix4();
const hitPosition = new three__WEBPACK_IMPORTED_MODULE_6__.Vector3();
const camera = new three__WEBPACK_IMPORTED_MODULE_6__.PerspectiveCamera(45, 1, 0.1, 100);
class ARRenderer extends three__WEBPACK_IMPORTED_MODULE_6__.EventDispatcher {
    constructor(renderer) {
        super();
        this.renderer = renderer;
        this.currentSession = null;
        this.placeOnWall = false;
        this.placementBox = null;
        this.lastTick = null;
        this.turntableRotation = null;
        this.oldShadowIntensity = null;
        this.frame = null;
        this.initialHitSource = null;
        this.transientHitTestSource = null;
        this.inputSource = null;
        this._presentedScene = null;
        this.resolveCleanup = null;
        this.exitWebXRButtonContainer = null;
        this.overlay = null;
        this.xrLight = null;
        this.tracking = true;
        this.frames = 0;
        this.initialized = false;
        this.oldTarget = new three__WEBPACK_IMPORTED_MODULE_6__.Vector3();
        this.placementComplete = false;
        this.isTranslating = false;
        this.isRotating = false;
        this.isTwoFingering = false;
        this.lastDragPosition = new three__WEBPACK_IMPORTED_MODULE_6__.Vector3();
        this.firstRatio = 0;
        this.lastAngle = 0;
        this.goalPosition = new three__WEBPACK_IMPORTED_MODULE_6__.Vector3();
        this.goalYaw = 0;
        this.goalScale = 1;
        this.xDamper = new _Damper_js__WEBPACK_IMPORTED_MODULE_3__.Damper();
        this.yDamper = new _Damper_js__WEBPACK_IMPORTED_MODULE_3__.Damper();
        this.zDamper = new _Damper_js__WEBPACK_IMPORTED_MODULE_3__.Damper();
        this.yawDamper = new _Damper_js__WEBPACK_IMPORTED_MODULE_3__.Damper();
        this.scaleDamper = new _Damper_js__WEBPACK_IMPORTED_MODULE_3__.Damper();
        this.onExitWebXRButtonContainerClick = () => this.stopPresenting();
        this.onUpdateScene = () => {
            if (this.placementBox != null && this.isPresenting) {
                this.placementBox.dispose();
                this.placementBox = new _PlacementBox_js__WEBPACK_IMPORTED_MODULE_4__.PlacementBox(this.presentedScene, this.placeOnWall ? 'back' : 'bottom');
            }
        };
        this.onSelectStart = (event) => {
            const hitSource = this.transientHitTestSource;
            if (hitSource == null) {
                return;
            }
            const fingers = this.frame.getHitTestResultsForTransientInput(hitSource);
            const scene = this.presentedScene;
            const box = this.placementBox;
            if (fingers.length === 1) {
                this.inputSource = event.inputSource;
                const { axes } = this.inputSource.gamepad;
                const hitPosition = box.getHit(this.presentedScene, axes[0], axes[1]);
                box.show = true;
                if (hitPosition != null) {
                    this.isTranslating = true;
                    this.lastDragPosition.copy(hitPosition);
                }
                else if (this.placeOnWall === false) {
                    this.isRotating = true;
                    this.lastAngle = axes[0] * ROTATION_RATE;
                }
            }
            else if (fingers.length === 2) {
                box.show = true;
                this.isTwoFingering = true;
                const { separation } = this.fingerPolar(fingers);
                this.firstRatio = separation / scene.scale.x;
            }
        };
        this.onSelectEnd = () => {
            this.isTranslating = false;
            this.isRotating = false;
            this.isTwoFingering = false;
            this.inputSource = null;
            this.goalPosition.y +=
                this.placementBox.offsetHeight * this.presentedScene.scale.x;
            this.placementBox.show = false;
        };
        this.threeRenderer = renderer.threeRenderer;
        this.threeRenderer.xr.enabled = true;
    }
    async resolveARSession() {
        (0,_utilities_js__WEBPACK_IMPORTED_MODULE_2__.assertIsArCandidate)();
        const session = await navigator.xr.requestSession('immersive-ar', {
            requiredFeatures: ['hit-test'],
            optionalFeatures: ['dom-overlay', 'light-estimation'],
            domOverlay: this.overlay ? { root: this.overlay } : undefined
        });
        this.threeRenderer.xr.setReferenceSpaceType('local');
        await this.threeRenderer.xr.setSession(session);
        this.threeRenderer.xr.cameraAutoUpdate = false;
        return session;
    }
    /**
     * The currently presented scene, if any
     */
    get presentedScene() {
        return this._presentedScene;
    }
    /**
     * Resolves to true if the renderer has detected all the necessary qualities
     * to support presentation in AR.
     */
    async supportsPresentation() {
        try {
            (0,_utilities_js__WEBPACK_IMPORTED_MODULE_2__.assertIsArCandidate)();
            return await navigator.xr.isSessionSupported('immersive-ar');
        }
        catch (error) {
            console.warn('Request to present in WebXR denied:');
            console.warn(error);
            console.warn('Falling back to next ar-mode');
            return false;
        }
    }
    /**
     * Present a scene in AR
     */
    async present(scene, environmentEstimation = false) {
        if (this.isPresenting) {
            console.warn('Cannot present while a model is already presenting');
        }
        let waitForAnimationFrame = new Promise((resolve, _reject) => {
            requestAnimationFrame(() => resolve());
        });
        scene.setHotspotsVisibility(false);
        scene.queueRender();
        // Render a frame to turn off the hotspots
        await waitForAnimationFrame;
        // This sets isPresenting to true
        this._presentedScene = scene;
        this.overlay = scene.element.shadowRoot.querySelector('div.default');
        if (environmentEstimation === true) {
            this.xrLight = new three_examples_jsm_webxr_XREstimatedLight_js__WEBPACK_IMPORTED_MODULE_7__.XREstimatedLight(this.threeRenderer);
            this.xrLight.addEventListener('estimationstart', () => {
                if (!this.isPresenting || this.xrLight == null) {
                    return;
                }
                const scene = this.presentedScene;
                scene.add(this.xrLight);
                scene.environment = this.xrLight.environment;
            });
        }
        const currentSession = await this.resolveARSession();
        currentSession.addEventListener('end', () => {
            this.postSessionCleanup();
        }, { once: true });
        const exitButton = scene.element.shadowRoot.querySelector('.slot.exit-webxr-ar-button');
        exitButton.classList.add('enabled');
        exitButton.addEventListener('click', this.onExitWebXRButtonContainerClick);
        this.exitWebXRButtonContainer = exitButton;
        const viewerRefSpace = await currentSession.requestReferenceSpace('viewer');
        this.tracking = true;
        this.frames = 0;
        this.initialized = false;
        this.turntableRotation = scene.yaw;
        this.goalYaw = scene.yaw;
        this.goalScale = 1;
        scene.background = null;
        this.oldShadowIntensity = scene.shadowIntensity;
        scene.setShadowIntensity(0.01); // invisible, but not changing the shader
        this.oldTarget.copy(scene.getTarget());
        scene.element.addEventListener('load', this.onUpdateScene);
        const radians = HIT_ANGLE_DEG * Math.PI / 180;
        const ray = this.placeOnWall === true ?
            undefined :
            new XRRay(new DOMPoint(0, 0, 0), { x: 0, y: -Math.sin(radians), z: -Math.cos(radians) });
        currentSession
            .requestHitTestSource({ space: viewerRefSpace, offsetRay: ray }).then(hitTestSource => {
            this.initialHitSource = hitTestSource;
        });
        this.currentSession = currentSession;
        this.placementBox =
            new _PlacementBox_js__WEBPACK_IMPORTED_MODULE_4__.PlacementBox(scene, this.placeOnWall ? 'back' : 'bottom');
        this.placementComplete = false;
        this.lastTick = performance.now();
        this.dispatchEvent({ type: 'status', status: ARStatus.SESSION_STARTED });
    }
    /**
     * If currently presenting a scene in AR, stops presentation and exits AR.
     */
    async stopPresenting() {
        if (!this.isPresenting) {
            return;
        }
        const cleanupPromise = new Promise((resolve) => {
            this.resolveCleanup = resolve;
        });
        try {
            await this.currentSession.end();
            await cleanupPromise;
        }
        catch (error) {
            console.warn('Error while trying to end WebXR AR session');
            console.warn(error);
            this.postSessionCleanup();
        }
    }
    /**
     * True if a scene is currently in the process of being presented in AR
     */
    get isPresenting() {
        return this.presentedScene != null;
    }
    get target() {
        return this.oldTarget;
    }
    updateTarget() {
        const scene = this.presentedScene;
        if (scene != null) {
            const target = scene.getTarget();
            this.oldTarget.copy(target);
            if (this.placeOnWall) {
                // Move the scene's target to the center of the back of the model's
                // bounding box.
                target.z = scene.boundingBox.min.z;
            }
            else {
                // Move the scene's target to the model's floor height.
                target.y = scene.boundingBox.min.y;
            }
            scene.setTarget(target.x, target.y, target.z);
        }
    }
    postSessionCleanup() {
        const session = this.currentSession;
        if (session != null) {
            session.removeEventListener('selectstart', this.onSelectStart);
            session.removeEventListener('selectend', this.onSelectEnd);
            this.currentSession = null;
        }
        const scene = this.presentedScene;
        this._presentedScene = null;
        if (scene != null) {
            const { element } = scene;
            if (this.xrLight != null) {
                scene.remove(this.xrLight);
                this.xrLight.dispose();
                this.xrLight = null;
            }
            scene.position.set(0, 0, 0);
            scene.scale.set(1, 1, 1);
            scene.setShadowOffset(0);
            const yaw = this.turntableRotation;
            if (yaw != null) {
                scene.yaw = yaw;
            }
            const intensity = this.oldShadowIntensity;
            if (intensity != null) {
                scene.setShadowIntensity(intensity);
            }
            scene.setEnvironmentAndSkybox(element[_features_environment_js__WEBPACK_IMPORTED_MODULE_0__.$currentEnvironmentMap], element[_features_environment_js__WEBPACK_IMPORTED_MODULE_0__.$currentBackground]);
            const point = this.oldTarget;
            scene.setTarget(point.x, point.y, point.z);
            scene.xrCamera = null;
            scene.element.removeEventListener('load', this.onUpdateScene);
            scene.orientHotspots(0);
            element.requestUpdate('cameraTarget');
            element.requestUpdate('maxCameraOrbit');
            element[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$onResize](element.getBoundingClientRect());
            requestAnimationFrame(() => {
                scene.element.dispatchEvent(new CustomEvent('camera-change', { detail: { source: _SmoothControls_js__WEBPACK_IMPORTED_MODULE_5__.ChangeSource.NONE } }));
            });
        }
        // Force the Renderer to update its size
        this.renderer.height = 0;
        const exitButton = this.exitWebXRButtonContainer;
        if (exitButton != null) {
            exitButton.classList.remove('enabled');
            exitButton.removeEventListener('click', this.onExitWebXRButtonContainerClick);
            this.exitWebXRButtonContainer = null;
        }
        const hitSource = this.transientHitTestSource;
        if (hitSource != null) {
            hitSource.cancel();
            this.transientHitTestSource = null;
        }
        const hitSourceInitial = this.initialHitSource;
        if (hitSourceInitial != null) {
            hitSourceInitial.cancel();
            this.initialHitSource = null;
        }
        if (this.placementBox != null) {
            this.placementBox.dispose();
            this.placementBox = null;
        }
        this.lastTick = null;
        this.turntableRotation = null;
        this.oldShadowIntensity = null;
        this.frame = null;
        this.inputSource = null;
        this.overlay = null;
        if (this.resolveCleanup != null) {
            this.resolveCleanup();
        }
        this.dispatchEvent({ type: 'status', status: ARStatus.NOT_PRESENTING });
    }
    updateView(view) {
        const scene = this.presentedScene;
        const xr = this.threeRenderer.xr;
        xr.updateCamera(camera);
        scene.xrCamera = xr.getCamera();
        const { elements } = scene.getCamera().matrixWorld;
        scene.orientHotspots(Math.atan2(elements[1], elements[5]));
        if (!this.initialized) {
            this.placeInitially();
            this.initialized = true;
        }
        // Use automatic dynamic viewport scaling if supported.
        if (view.requestViewportScale && view.recommendedViewportScale) {
            const scale = view.recommendedViewportScale;
            view.requestViewportScale(Math.max(scale, MIN_VIEWPORT_SCALE));
        }
        const layer = xr.getBaseLayer();
        if (layer != null) {
            const viewport = layer instanceof XRWebGLLayer ?
                layer.getViewport(view) :
                xr.getBinding().getViewSubImage(layer, view).viewport;
            this.threeRenderer.setViewport(viewport.x, viewport.y, viewport.width, viewport.height);
        }
    }
    placeInitially() {
        const scene = this.presentedScene;
        const { position, element } = scene;
        const xrCamera = scene.getCamera();
        const { width, height } = this.overlay.getBoundingClientRect();
        scene.setSize(width, height);
        xrCamera.projectionMatrixInverse.copy(xrCamera.projectionMatrix).invert();
        const { theta, radius } = element
            .getCameraOrbit();
        // Orient model to match the 3D camera view
        const cameraDirection = xrCamera.getWorldDirection(vector3);
        scene.yaw = Math.atan2(-cameraDirection.x, -cameraDirection.z) - theta;
        this.goalYaw = scene.yaw;
        position.copy(xrCamera.position)
            .add(cameraDirection.multiplyScalar(radius));
        this.updateTarget();
        const target = scene.getTarget();
        position.add(target).sub(this.oldTarget);
        this.goalPosition.copy(position);
        scene.setHotspotsVisibility(true);
        const { session } = this.frame;
        session.addEventListener('selectstart', this.onSelectStart);
        session.addEventListener('selectend', this.onSelectEnd);
        session
            .requestHitTestSourceForTransientInput({ profile: 'generic-touchscreen' }).then(hitTestSource => {
            this.transientHitTestSource = hitTestSource;
        });
    }
    getTouchLocation() {
        const { axes } = this.inputSource.gamepad;
        let location = this.placementBox.getExpandedHit(this.presentedScene, axes[0], axes[1]);
        if (location != null) {
            vector3.copy(location).sub(this.presentedScene.getCamera().position);
            if (vector3.length() > MAX_DISTANCE)
                return null;
        }
        return location;
    }
    getHitPoint(hitResult) {
        const refSpace = this.threeRenderer.xr.getReferenceSpace();
        const pose = hitResult.getPose(refSpace);
        if (pose == null) {
            return null;
        }
        const hitMatrix = matrix4.fromArray(pose.transform.matrix);
        if (this.placeOnWall === true) {
            // Orient the model to the wall's normal vector.
            this.goalYaw = Math.atan2(hitMatrix.elements[4], hitMatrix.elements[6]);
        }
        // Check that the y-coordinate of the normal is large enough that the normal
        // is pointing up for floor placement; opposite for wall placement.
        return hitMatrix.elements[5] > 0.75 !== this.placeOnWall ?
            hitPosition.setFromMatrixPosition(hitMatrix) :
            null;
    }
    moveToFloor(frame) {
        const hitSource = this.initialHitSource;
        if (hitSource == null) {
            return;
        }
        const hitTestResults = frame.getHitTestResults(hitSource);
        if (hitTestResults.length == 0) {
            return;
        }
        const hit = hitTestResults[0];
        const hitPoint = this.getHitPoint(hit);
        if (hitPoint == null) {
            return;
        }
        this.placementBox.show = true;
        // If the user is translating, let the finger hit-ray take precedence and
        // ignore this hit result.
        if (!this.isTranslating) {
            if (this.placeOnWall) {
                this.goalPosition.copy(hitPoint);
            }
            else {
                this.goalPosition.y = hitPoint.y;
            }
        }
        hitSource.cancel();
        this.initialHitSource = null;
        this.dispatchEvent({ type: 'status', status: ARStatus.OBJECT_PLACED });
    }
    fingerPolar(fingers) {
        const fingerOne = fingers[0].inputSource.gamepad.axes;
        const fingerTwo = fingers[1].inputSource.gamepad.axes;
        const deltaX = fingerTwo[0] - fingerOne[0];
        const deltaY = fingerTwo[1] - fingerOne[1];
        const angle = Math.atan2(deltaY, deltaX);
        let deltaYaw = this.lastAngle - angle;
        if (deltaYaw > Math.PI) {
            deltaYaw -= 2 * Math.PI;
        }
        else if (deltaYaw < -Math.PI) {
            deltaYaw += 2 * Math.PI;
        }
        this.lastAngle = angle;
        return {
            separation: Math.sqrt(deltaX * deltaX + deltaY * deltaY),
            deltaYaw: deltaYaw
        };
    }
    processInput(frame) {
        const hitSource = this.transientHitTestSource;
        if (hitSource == null) {
            return;
        }
        if (!this.isTranslating && !this.isTwoFingering && !this.isRotating) {
            return;
        }
        const fingers = frame.getHitTestResultsForTransientInput(hitSource);
        const scene = this.presentedScene;
        const scale = scene.scale.x;
        // Rotating, translating and scaling are mutually exclusive operations; only
        // one can happen at a time, but we can switch during a gesture.
        if (this.isTwoFingering) {
            if (fingers.length < 2) {
                // If we lose the second finger, stop scaling (in fact, stop processing
                // input altogether until a new gesture starts).
                this.isTwoFingering = false;
            }
            else {
                const { separation, deltaYaw } = this.fingerPolar(fingers);
                if (this.placeOnWall === false) {
                    this.goalYaw += deltaYaw;
                }
                if (scene.canScale) {
                    const scale = separation / this.firstRatio;
                    this.goalScale =
                        (scale < SCALE_SNAP_HIGH && scale > SCALE_SNAP_LOW) ? 1 : scale;
                }
            }
            return;
        }
        else if (fingers.length === 2) {
            // If we were rotating or translating and we get a second finger, switch
            // to scaling instead.
            this.isTranslating = false;
            this.isRotating = false;
            this.isTwoFingering = true;
            const { separation } = this.fingerPolar(fingers);
            this.firstRatio = separation / scale;
            return;
        }
        if (this.isRotating) {
            const angle = this.inputSource.gamepad.axes[0] * ROTATION_RATE;
            this.goalYaw += angle - this.lastAngle;
            this.lastAngle = angle;
        }
        else if (this.isTranslating) {
            fingers.forEach(finger => {
                if (finger.inputSource !== this.inputSource) {
                    return;
                }
                let hit = null;
                if (finger.results.length > 0) {
                    hit = this.getHitPoint(finger.results[0]);
                }
                if (hit == null) {
                    hit = this.getTouchLocation();
                }
                if (hit == null) {
                    return;
                }
                this.goalPosition.sub(this.lastDragPosition);
                if (this.placeOnWall === false) {
                    const offset = hit.y - this.lastDragPosition.y;
                    // When a lower floor is found, keep the model at the same height, but
                    // drop the placement box to the floor. The model falls on select end.
                    if (offset < 0) {
                        this.placementBox.offsetHeight = offset / scale;
                        this.presentedScene.setShadowOffset(offset);
                        // Interpolate hit ray up to drag plane
                        const cameraPosition = vector3.copy(scene.getCamera().position);
                        const alpha = -offset / (cameraPosition.y - hit.y);
                        cameraPosition.multiplyScalar(alpha);
                        hit.multiplyScalar(1 - alpha).add(cameraPosition);
                    }
                }
                this.goalPosition.add(hit);
                this.lastDragPosition.copy(hit);
            });
        }
    }
    moveScene(delta) {
        const scene = this.presentedScene;
        const { position, yaw } = scene;
        const boundingRadius = scene.boundingSphere.radius;
        const goal = this.goalPosition;
        const oldScale = scene.scale.x;
        const box = this.placementBox;
        let source = _SmoothControls_js__WEBPACK_IMPORTED_MODULE_5__.ChangeSource.NONE;
        if (!goal.equals(position) || this.goalScale !== oldScale) {
            source = _SmoothControls_js__WEBPACK_IMPORTED_MODULE_5__.ChangeSource.USER_INTERACTION;
            let { x, y, z } = position;
            x = this.xDamper.update(x, goal.x, delta, boundingRadius);
            y = this.yDamper.update(y, goal.y, delta, boundingRadius);
            z = this.zDamper.update(z, goal.z, delta, boundingRadius);
            position.set(x, y, z);
            const newScale = this.scaleDamper.update(oldScale, this.goalScale, delta, 1);
            scene.scale.set(newScale, newScale, newScale);
            if (!this.isTranslating) {
                const offset = goal.y - y;
                if (this.placementComplete && this.placeOnWall === false) {
                    box.offsetHeight = offset / newScale;
                    scene.setShadowOffset(offset);
                }
                else if (offset === 0) {
                    this.placementComplete = true;
                    box.show = false;
                    scene.setShadowIntensity(AR_SHADOW_INTENSITY);
                }
            }
        }
        box.updateOpacity(delta);
        scene.updateTarget(delta);
        // yaw must be updated last, since this also updates the shadow position.
        scene.yaw = this.yawDamper.update(yaw, this.goalYaw, delta, Math.PI);
        // camera changes on every frame - user-interaction only if touching the
        // screen, plus damping time.
        scene.element.dispatchEvent(new CustomEvent('camera-change', { detail: { source } }));
    }
    /**
     * Only public to make it testable.
     */
    onWebXRFrame(time, frame) {
        this.frame = frame;
        ++this.frames;
        const refSpace = this.threeRenderer.xr.getReferenceSpace();
        const pose = frame.getViewerPose(refSpace);
        if (pose == null && this.tracking === true && this.frames > INIT_FRAMES) {
            this.tracking = false;
            this.dispatchEvent({ type: 'tracking', status: ARTracking.NOT_TRACKING });
        }
        const scene = this.presentedScene;
        if (pose == null || scene == null || !scene.element.loaded) {
            this.threeRenderer.clear();
            return;
        }
        if (this.tracking === false) {
            this.tracking = true;
            this.dispatchEvent({ type: 'tracking', status: ARTracking.TRACKING });
        }
        // WebXR may return multiple views, i.e. for headset AR. This
        // isn't really supported at this point, but make a best-effort
        // attempt to render other views also, using the first view
        // as the main viewpoint.
        let isFirstView = true;
        for (const view of pose.views) {
            this.updateView(view);
            if (isFirstView) {
                this.moveToFloor(frame);
                this.processInput(frame);
                const delta = time - this.lastTick;
                this.moveScene(delta);
                this.renderer.preRender(scene, time, delta);
                this.lastTick = time;
                scene.renderShadow(this.threeRenderer);
            }
            this.threeRenderer.render(scene, scene.getCamera());
            isFirstView = false;
        }
    }
}
//# sourceMappingURL=ARRenderer.js.map

/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/three-components/CachingGLTFLoader.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/three-components/CachingGLTFLoader.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$evictionPolicy": () => (/* binding */ $evictionPolicy),
/* harmony export */   "$loader": () => (/* binding */ $loader),
/* harmony export */   "CachingGLTFLoader": () => (/* binding */ CachingGLTFLoader),
/* harmony export */   "loadWithLoader": () => (/* binding */ loadWithLoader)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ "../../node_modules/three/build/three.module.js");
/* harmony import */ var three_examples_jsm_loaders_DRACOLoader_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three/examples/jsm/loaders/DRACOLoader.js */ "../../node_modules/three/examples/jsm/loaders/DRACOLoader.js");
/* harmony import */ var three_examples_jsm_loaders_GLTFLoader_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three/examples/jsm/loaders/GLTFLoader.js */ "../../node_modules/three/examples/jsm/loaders/GLTFLoader.js");
/* harmony import */ var three_examples_jsm_loaders_KTX2Loader_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three/examples/jsm/loaders/KTX2Loader.js */ "../../node_modules/three/examples/jsm/loaders/KTX2Loader.js");
/* harmony import */ var _utilities_cache_eviction_policy_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utilities/cache-eviction-policy.js */ "../../node_modules/@google/model-viewer/lib/utilities/cache-eviction-policy.js");
/* harmony import */ var _gltf_instance_VariantMaterialLoaderPlugin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./gltf-instance/VariantMaterialLoaderPlugin */ "../../node_modules/@google/model-viewer/lib/three-components/gltf-instance/VariantMaterialLoaderPlugin.js");
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var _a, _b;






three__WEBPACK_IMPORTED_MODULE_2__.Texture.DEFAULT_ANISOTROPY = 4;
/**
 * A helper to Promise-ify a Three.js GLTFLoader
 */
const loadWithLoader = (url, loader, progressCallback = () => { }) => {
    const onProgress = (event) => {
        const fraction = event.loaded / event.total;
        progressCallback(Math.max(0, Math.min(1, isFinite(fraction) ? fraction : 1)));
    };
    return new Promise((resolve, reject) => {
        loader.load(url, resolve, onProgress, reject);
    });
};
/** Helper to load a script tag. */
const fetchScript = (src) => {
    return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        document.body.appendChild(script);
        script.onload = resolve;
        script.onerror = reject;
        script.async = true;
        script.src = src;
    });
};
const cache = new Map();
const preloaded = new Map();
let dracoDecoderLocation;
const dracoLoader = new three_examples_jsm_loaders_DRACOLoader_js__WEBPACK_IMPORTED_MODULE_3__.DRACOLoader();
let ktx2TranscoderLocation;
const ktx2Loader = new three_examples_jsm_loaders_KTX2Loader_js__WEBPACK_IMPORTED_MODULE_4__.KTX2Loader();
let meshoptDecoderLocation;
let meshoptDecoder;
const $loader = Symbol('loader');
const $evictionPolicy = Symbol('evictionPolicy');
const $GLTFInstance = Symbol('GLTFInstance');
class CachingGLTFLoader extends three__WEBPACK_IMPORTED_MODULE_2__.EventDispatcher {
    constructor(GLTFInstance) {
        super();
        this[_b] = new three_examples_jsm_loaders_GLTFLoader_js__WEBPACK_IMPORTED_MODULE_5__.GLTFLoader().register(parser => new _gltf_instance_VariantMaterialLoaderPlugin__WEBPACK_IMPORTED_MODULE_1__["default"](parser));
        this[$GLTFInstance] = GLTFInstance;
        this[$loader].setDRACOLoader(dracoLoader);
        this[$loader].setKTX2Loader(ktx2Loader);
    }
    static setDRACODecoderLocation(url) {
        dracoDecoderLocation = url;
        dracoLoader.setDecoderPath(url);
    }
    static getDRACODecoderLocation() {
        return dracoDecoderLocation;
    }
    static setKTX2TranscoderLocation(url) {
        ktx2TranscoderLocation = url;
        ktx2Loader.setTranscoderPath(url);
    }
    static getKTX2TranscoderLocation() {
        return ktx2TranscoderLocation;
    }
    static setMeshoptDecoderLocation(url) {
        if (meshoptDecoderLocation !== url) {
            meshoptDecoderLocation = url;
            meshoptDecoder = fetchScript(url)
                .then(() => MeshoptDecoder.ready)
                .then(() => MeshoptDecoder);
        }
    }
    static getMeshoptDecoderLocation() {
        return meshoptDecoderLocation;
    }
    static initializeKTX2Loader(renderer) {
        ktx2Loader.detectSupport(renderer);
    }
    static get cache() {
        return cache;
    }
    /** @nocollapse */
    static clearCache() {
        cache.forEach((_value, url) => {
            this.delete(url);
        });
        this[$evictionPolicy].reset();
    }
    static has(url) {
        return cache.has(url);
    }
    /** @nocollapse */
    static async delete(url) {
        if (!this.has(url)) {
            return;
        }
        const gltfLoads = cache.get(url);
        preloaded.delete(url);
        cache.delete(url);
        const gltf = await gltfLoads;
        // Dispose of the cached glTF's materials and geometries:
        gltf.dispose();
    }
    /**
     * Returns true if the model that corresponds to the specified url is
     * available in our local cache.
     */
    static hasFinishedLoading(url) {
        return !!preloaded.get(url);
    }
    get [(_a = $evictionPolicy, _b = $loader, $evictionPolicy)]() {
        return this.constructor[$evictionPolicy];
    }
    /**
     * Preloads a glTF, populating the cache. Returns a promise that resolves
     * when the cache is populated.
     */
    async preload(url, element, progressCallback = () => { }) {
        this[$loader].setWithCredentials(CachingGLTFLoader.withCredentials);
        this.dispatchEvent({ type: 'preload', element: element, src: url });
        if (!cache.has(url)) {
            if (meshoptDecoder != null) {
                this[$loader].setMeshoptDecoder(await meshoptDecoder);
            }
            const rawGLTFLoads = loadWithLoader(url, this[$loader], (progress) => {
                progressCallback(progress * 0.8);
            });
            const GLTFInstance = this[$GLTFInstance];
            const gltfInstanceLoads = rawGLTFLoads
                .then((rawGLTF) => {
                return GLTFInstance.prepare(rawGLTF);
            })
                .then((preparedGLTF) => {
                progressCallback(0.9);
                return new GLTFInstance(preparedGLTF);
            })
                .catch((reason => {
                console.error(reason);
                return new GLTFInstance();
            }));
            cache.set(url, gltfInstanceLoads);
        }
        await cache.get(url);
        preloaded.set(url, true);
        if (progressCallback) {
            progressCallback(1.0);
        }
    }
    /**
     * Loads a glTF from the specified url and resolves a unique clone of the
     * glTF. If the glTF has already been loaded, makes a clone of the cached
     * copy.
     */
    async load(url, element, progressCallback = () => { }) {
        await this.preload(url, element, progressCallback);
        const gltf = await cache.get(url);
        const clone = await gltf.clone();
        this[$evictionPolicy].retain(url);
        // Patch dispose so that we can properly account for instance use
        // in the caching layer:
        clone.dispose = () => {
            this[$evictionPolicy].release(url);
        };
        return clone;
    }
}
CachingGLTFLoader[_a] = new _utilities_cache_eviction_policy_js__WEBPACK_IMPORTED_MODULE_0__.CacheEvictionPolicy(CachingGLTFLoader);
//# sourceMappingURL=CachingGLTFLoader.js.map

/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/three-components/Damper.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/three-components/Damper.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DECAY_MILLISECONDS": () => (/* binding */ DECAY_MILLISECONDS),
/* harmony export */   "Damper": () => (/* binding */ Damper),
/* harmony export */   "SETTLING_TIME": () => (/* binding */ SETTLING_TIME)
/* harmony export */ });
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const SETTLING_TIME = 10000; // plenty long enough
const MIN_DECAY_MILLISECONDS = 0.001;
const DECAY_MILLISECONDS = 50;
/**
 * The Damper class is a generic second-order critically damped system that does
 * one linear step of the desired length of time. The only parameter is
 * DECAY_MILLISECONDS. This common parameter makes all states converge at the
 * same rate regardless of scale. xNormalization is a number to provide the
 * rough scale of x, such that NIL_SPEED clamping also happens at roughly the
 * same convergence for all states.
 */
class Damper {
    constructor(decayMilliseconds = DECAY_MILLISECONDS) {
        this.velocity = 0;
        this.naturalFrequency = 0;
        this.setDecayTime(decayMilliseconds);
    }
    setDecayTime(decayMilliseconds) {
        this.naturalFrequency =
            1 / Math.max(MIN_DECAY_MILLISECONDS, decayMilliseconds);
    }
    update(x, xGoal, timeStepMilliseconds, xNormalization) {
        const nilSpeed = 0.0002 * this.naturalFrequency;
        if (x == null || xNormalization === 0) {
            return xGoal;
        }
        if (x === xGoal && this.velocity === 0) {
            return xGoal;
        }
        if (timeStepMilliseconds < 0) {
            return x;
        }
        // Exact solution to a critically damped second-order system, where:
        // acceleration = this.naturalFrequency * this.naturalFrequency * (xGoal
        // - x) - 2 * this.naturalFrequency * this.velocity;
        const deltaX = (x - xGoal);
        const intermediateVelocity = this.velocity + this.naturalFrequency * deltaX;
        const intermediateX = deltaX + timeStepMilliseconds * intermediateVelocity;
        const decay = Math.exp(-this.naturalFrequency * timeStepMilliseconds);
        const newVelocity = (intermediateVelocity - this.naturalFrequency * intermediateX) * decay;
        const acceleration = -this.naturalFrequency * (newVelocity + intermediateVelocity * decay);
        if (Math.abs(newVelocity) < nilSpeed * Math.abs(xNormalization) &&
            acceleration * deltaX >= 0) {
            // This ensures the controls settle and stop calling this function instead
            // of asymptotically approaching their goal.
            this.velocity = 0;
            return xGoal;
        }
        else {
            this.velocity = newVelocity;
            return xGoal + intermediateX * decay;
        }
    }
}
//# sourceMappingURL=Damper.js.map

/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/three-components/Debugger.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/three-components/Debugger.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Debugger": () => (/* binding */ Debugger)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../../node_modules/three/build/three.module.js");
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * This Debugger exposes internal details of the <model-viewer> rendering
 * substructure so that external tools can more easily inspect and operate on
 * them.
 *
 * It also activates shader debugging on the associated GL context. Shader
 * debugging trades performance for useful error information, so it is not
 * recommended to activate this unless needed.
 */
class Debugger {
    constructor(renderer) {
        // Force WebGL shader debugging on:
        renderer.threeRenderer.debug = { checkShaderErrors: true };
        // Announce debug details at microtask timing to give the `Renderer`
        // constructor time to complete its initialization, just to be on the safe
        // side:
        Promise.resolve().then(() => {
            self.dispatchEvent(new CustomEvent('model-viewer-renderer-debug', {
                detail: {
                    renderer,
                    THREE: {
                        ShaderMaterial: three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial,
                        Texture: three__WEBPACK_IMPORTED_MODULE_0__.Texture,
                        Mesh: three__WEBPACK_IMPORTED_MODULE_0__.Mesh,
                        Scene: three__WEBPACK_IMPORTED_MODULE_0__.Scene,
                        PlaneGeometry: three__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry,
                        OrthographicCamera: three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera,
                        WebGLRenderTarget: three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget
                    }
                }
            }));
        });
    }
    addScene(scene) {
        self.dispatchEvent(new CustomEvent('model-viewer-scene-added-debug', { detail: { scene } }));
    }
    removeScene(scene) {
        self.dispatchEvent(new CustomEvent('model-viewer-scene-removed-debug', { detail: { scene } }));
    }
}
//# sourceMappingURL=Debugger.js.map

/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/three-components/EnvironmentScene.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/three-components/EnvironmentScene.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ EnvironmentScene)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../../node_modules/three/build/three.module.js");
/* @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class EnvironmentScene extends three__WEBPACK_IMPORTED_MODULE_0__.Scene {
    constructor() {
        super();
        this.position.y = -3.5;
        const geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BoxGeometry();
        geometry.deleteAttribute('uv');
        const roomMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({ metalness: 0, side: three__WEBPACK_IMPORTED_MODULE_0__.BackSide });
        const boxMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({ metalness: 0 });
        const mainLight = new three__WEBPACK_IMPORTED_MODULE_0__.PointLight(0xffffff, 500.0, 28, 2);
        mainLight.position.set(0.418, 16.199, 0.300);
        this.add(mainLight);
        const room = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, roomMaterial);
        room.position.set(-0.757, 13.219, 0.717);
        room.scale.set(31.713, 28.305, 28.591);
        this.add(room);
        const box1 = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, boxMaterial);
        box1.position.set(-10.906, 2.009, 1.846);
        box1.rotation.set(0, -0.195, 0);
        box1.scale.set(2.328, 7.905, 4.651);
        this.add(box1);
        const box2 = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, boxMaterial);
        box2.position.set(-5.607, -0.754, -0.758);
        box2.rotation.set(0, 0.994, 0);
        box2.scale.set(1.970, 1.534, 3.955);
        this.add(box2);
        const box3 = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, boxMaterial);
        box3.position.set(6.167, 0.857, 7.803);
        box3.rotation.set(0, 0.561, 0);
        box3.scale.set(3.927, 6.285, 3.687);
        this.add(box3);
        const box4 = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, boxMaterial);
        box4.position.set(-2.017, 0.018, 6.124);
        box4.rotation.set(0, 0.333, 0);
        box4.scale.set(2.002, 4.566, 2.064);
        this.add(box4);
        const box5 = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, boxMaterial);
        box5.position.set(2.291, -0.756, -2.621);
        box5.rotation.set(0, -0.286, 0);
        box5.scale.set(1.546, 1.552, 1.496);
        this.add(box5);
        const box6 = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, boxMaterial);
        box6.position.set(-2.193, -0.369, -5.547);
        box6.rotation.set(0, 0.516, 0);
        box6.scale.set(3.875, 3.487, 2.986);
        this.add(box6);
        // -x right
        const light1 = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, this.createAreaLightMaterial(50));
        light1.position.set(-16.116, 14.37, 8.208);
        light1.scale.set(0.1, 2.428, 2.739);
        this.add(light1);
        // -x left
        const light2 = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, this.createAreaLightMaterial(50));
        light2.position.set(-16.109, 18.021, -8.207);
        light2.scale.set(0.1, 2.425, 2.751);
        this.add(light2);
        // +x
        const light3 = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, this.createAreaLightMaterial(17));
        light3.position.set(14.904, 12.198, -1.832);
        light3.scale.set(0.15, 4.265, 6.331);
        this.add(light3);
        // +z
        const light4 = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, this.createAreaLightMaterial(43));
        light4.position.set(-0.462, 8.89, 14.520);
        light4.scale.set(4.38, 5.441, 0.088);
        this.add(light4);
        // -z
        const light5 = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, this.createAreaLightMaterial(20));
        light5.position.set(3.235, 11.486, -12.541);
        light5.scale.set(2.5, 2.0, 0.1);
        this.add(light5);
        // +y
        const light6 = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, this.createAreaLightMaterial(100));
        light6.position.set(0.0, 20.0, 0.0);
        light6.scale.set(1.0, 0.1, 1.0);
        this.add(light6);
    }
    createAreaLightMaterial(intensity) {
        const material = new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial();
        material.color.setScalar(intensity);
        return material;
    }
}
//# sourceMappingURL=EnvironmentScene.js.map

/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/three-components/EnvironmentSceneAlt.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/three-components/EnvironmentSceneAlt.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ EnvironmentSceneAlt)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../../node_modules/three/build/three.module.js");
/* @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class EnvironmentSceneAlt extends three__WEBPACK_IMPORTED_MODULE_0__.Scene {
    constructor() {
        super();
        this.position.y = -3.5;
        const geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BoxGeometry();
        geometry.deleteAttribute('uv');
        const roomMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({ metalness: 0, side: three__WEBPACK_IMPORTED_MODULE_0__.BackSide });
        const boxMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({ metalness: 0 });
        const mainLight = new three__WEBPACK_IMPORTED_MODULE_0__.PointLight(0xffffff, 400.0, 28, 2);
        mainLight.position.set(0.5, 14.0, 0.5);
        this.add(mainLight);
        const room = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, roomMaterial);
        room.position.set(0.0, 13.2, 0.0);
        room.scale.set(31.5, 28.5, 31.5);
        this.add(room);
        const box1 = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, boxMaterial);
        box1.position.set(-10.906, -1.0, 1.846);
        box1.rotation.set(0, -0.195, 0);
        box1.scale.set(2.328, 7.905, 4.651);
        this.add(box1);
        const box2 = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, boxMaterial);
        box2.position.set(-5.607, -0.754, -0.758);
        box2.rotation.set(0, 0.994, 0);
        box2.scale.set(1.970, 1.534, 3.955);
        this.add(box2);
        const box3 = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, boxMaterial);
        box3.position.set(6.167, -0.16, 7.803);
        box3.rotation.set(0, 0.561, 0);
        box3.scale.set(3.927, 6.285, 3.687);
        this.add(box3);
        const box4 = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, boxMaterial);
        box4.position.set(-2.017, 0.018, 6.124);
        box4.rotation.set(0, 0.333, 0);
        box4.scale.set(2.002, 4.566, 2.064);
        this.add(box4);
        const box5 = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, boxMaterial);
        box5.position.set(2.291, -0.756, -2.621);
        box5.rotation.set(0, -0.286, 0);
        box5.scale.set(1.546, 1.552, 1.496);
        this.add(box5);
        const box6 = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, boxMaterial);
        box6.position.set(-2.193, -0.369, -5.547);
        box6.rotation.set(0, 0.516, 0);
        box6.scale.set(3.875, 3.487, 2.986);
        this.add(box6);
        // -x_left
        const light1 = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, this.createAreaLightMaterial(80));
        light1.position.set(-14.0, 10.0, 8.0);
        light1.scale.set(0.1, 2.5, 2.5);
        this.add(light1);
        // -x_right
        const light2 = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, this.createAreaLightMaterial(80));
        light2.position.set(-14.0, 14.0, -4.0);
        light2.scale.set(0.1, 2.5, 2.5);
        this.add(light2);
        // +x only on light
        const light3 = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, this.createAreaLightMaterial(23));
        light3.position.set(14.0, 12.0, 0.0);
        light3.scale.set(0.1, 5.0, 5.0);
        this.add(light3);
        // +z
        const light4 = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, this.createAreaLightMaterial(16));
        light4.position.set(0.0, 9.0, 14.0);
        light4.scale.set(5.0, 5.0, 0.1);
        this.add(light4);
        // -z right
        const light5 = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, this.createAreaLightMaterial(80));
        light5.position.set(7.0, 8.0, -14.0);
        light5.scale.set(2.5, 2.5, 0.1);
        this.add(light5);
        // -z left
        const light6 = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, this.createAreaLightMaterial(80));
        light6.position.set(-7.0, 16.0, -14.0);
        light6.scale.set(2.5, 2.5, 0.1);
        this.add(light6);
        // +y
        const light7 = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, this.createAreaLightMaterial(1));
        light7.position.set(0.0, 20.0, 0.0);
        light7.scale.set(0.1, 0.1, 0.1);
        this.add(light7);
    }
    createAreaLightMaterial(intensity) {
        const material = new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial();
        material.color.setScalar(intensity);
        return material;
    }
}
//# sourceMappingURL=EnvironmentSceneAlt.js.map

/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/three-components/GLTFInstance.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/three-components/GLTFInstance.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$clone": () => (/* binding */ $clone),
/* harmony export */   "$prepare": () => (/* binding */ $prepare),
/* harmony export */   "$prepared": () => (/* binding */ $prepared),
/* harmony export */   "$preparedGLTF": () => (/* binding */ $preparedGLTF),
/* harmony export */   "GLTFInstance": () => (/* binding */ GLTFInstance)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../../node_modules/three/build/three.module.js");
/* harmony import */ var three_examples_jsm_utils_SkeletonUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three/examples/jsm/utils/SkeletonUtils.js */ "../../node_modules/three/examples/jsm/utils/SkeletonUtils.js");
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


const $prepared = Symbol('prepared');
const $prepare = Symbol('prepare');
const $preparedGLTF = Symbol('preparedGLTF');
const $clone = Symbol('clone');
/**
 * Represents the preparation and enhancement of the output of a Three.js
 * GLTFLoader (a Three.js-flavor "GLTF"), to make it suitable for optimal,
 * correct viewing in a given presentation context and also make the cloning
 * process more explicit and legible.
 *
 * A GLTFInstance is API-compatible with a Three.js-flavor "GLTF", so it should
 * be considered to be interchangeable with the loaded result of a GLTFLoader.
 *
 * This basic implementation only implements trivial preparation and enhancement
 * of a GLTF. These operations are intended to be enhanced by inheriting
 * classes.
 */
class GLTFInstance {
    constructor(preparedGLTF) {
        this[$preparedGLTF] = preparedGLTF;
    }
    /**
     * Prepares a given GLTF for presentation and future cloning. A GLTF that is
     * prepared can safely have this method invoked on it multiple times; it will
     * only be prepared once, including after being cloned.
     */
    static prepare(source) {
        if (source.scene == null) {
            throw new Error('Model does not have a scene');
        }
        if (source[$prepared]) {
            return source;
        }
        const prepared = this[$prepare](source);
        // NOTE: ES5 Symbol polyfill is not compatible with spread operator
        // so {...prepared, [$prepared]: true} does not work
        prepared[$prepared] = true;
        return prepared;
    }
    /**
     * Override in an inheriting class to apply specialty one-time preparations
     * for a given input GLTF.
     */
    static [$prepare](source) {
        // TODO(#195,#1003): We don't currently support multiple scenes, so we don't
        // bother preparing extra scenes for now:
        const { scene } = source;
        const scenes = [scene];
        return Object.assign(Object.assign({}, source), { scene, scenes });
    }
    get parser() {
        return this[$preparedGLTF].parser;
    }
    get animations() {
        return this[$preparedGLTF].animations;
    }
    get scene() {
        return this[$preparedGLTF].scene;
    }
    get scenes() {
        return this[$preparedGLTF].scenes;
    }
    get cameras() {
        return this[$preparedGLTF].cameras;
    }
    get asset() {
        return this[$preparedGLTF].asset;
    }
    get userData() {
        return this[$preparedGLTF].userData;
    }
    /**
     * Creates and returns a copy of this instance.
     */
    clone() {
        const GLTFInstanceConstructor = this.constructor;
        const clonedGLTF = this[$clone]();
        return new GLTFInstanceConstructor(clonedGLTF);
    }
    /**
     * Cleans up any retained memory that might not otherwise be released when
     * this instance is done being used.
     */
    dispose() {
        this.scenes.forEach((scene) => {
            scene.traverse((object) => {
                const mesh = object;
                if (!mesh.material) {
                    return;
                }
                const materials = Array.isArray(mesh.material) ? mesh.material : [mesh.material];
                materials.forEach(material => {
                    // Explicitly dispose any textures assigned to this material
                    for (const propertyName in material) {
                        const texture = material[propertyName];
                        if (texture instanceof three__WEBPACK_IMPORTED_MODULE_0__.Texture) {
                            const image = texture.source.data;
                            if (image.close != null) {
                                image.close();
                            }
                            texture.dispose();
                        }
                    }
                    material.dispose();
                });
                mesh.geometry.dispose();
            });
        });
    }
    /**
     * Override in an inheriting class to implement specialized cloning strategies
     */
    [$clone]() {
        const source = this[$preparedGLTF];
        // TODO(#195,#1003): We don't currently support multiple scenes, so we don't
        // bother cloning extra scenes for now:
        const scene = three_examples_jsm_utils_SkeletonUtils_js__WEBPACK_IMPORTED_MODULE_1__.clone(this.scene);
        cloneVariantMaterials(scene, this.scene);
        const scenes = [scene];
        const userData = source.userData ? Object.assign({}, source.userData) : {};
        return Object.assign(Object.assign({}, source), { scene, scenes, userData });
    }
}
// Variant materials and original material instances are stored under
// object.userData.variantMaterials/originalMaterial.
// Three.js Object3D.clone() doesn't clone Three.js objects under
// .userData so this function is a workaround.
const cloneVariantMaterials = (dst, src) => {
    traversePair(dst, src, (dst, src) => {
        if (src.userData.variantMaterials !== undefined) {
            dst.userData.variantMaterials = new Map(src.userData.variantMaterials);
        }
        if (src.userData.variantData !== undefined) {
            dst.userData.variantData = src.userData.variantData;
        }
        if (src.userData.originalMaterial !== undefined) {
            dst.userData.originalMaterial = src.userData.originalMaterial;
        }
    });
};
const traversePair = (obj1, obj2, callback) => {
    callback(obj1, obj2);
    // Assume obj1 and obj2 have the same tree structure
    for (let i = 0; i < obj1.children.length; i++) {
        traversePair(obj1.children[i], obj2.children[i], callback);
    }
};
//# sourceMappingURL=GLTFInstance.js.map

/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/three-components/Hotspot.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/three-components/Hotspot.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Hotspot": () => (/* binding */ Hotspot)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ "../../node_modules/three/build/three.module.js");
/* harmony import */ var three_examples_jsm_renderers_CSS2DRenderer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three/examples/jsm/renderers/CSS2DRenderer.js */ "../../node_modules/three/examples/jsm/renderers/CSS2DRenderer.js");
/* harmony import */ var _styles_conversions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../styles/conversions.js */ "../../node_modules/@google/model-viewer/lib/styles/conversions.js");
/* harmony import */ var _styles_parsers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../styles/parsers.js */ "../../node_modules/@google/model-viewer/lib/styles/parsers.js");
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




const a = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();
const b = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();
const c = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();
const mat = new three__WEBPACK_IMPORTED_MODULE_2__.Matrix3();
const triangle = new three__WEBPACK_IMPORTED_MODULE_2__.Triangle();
const quat = new three__WEBPACK_IMPORTED_MODULE_2__.Quaternion();
/**
 * The Hotspot object is a reference-counted slot. If decrement() returns true,
 * it should be removed from the tree so it can be garbage-collected.
 */
class Hotspot extends three_examples_jsm_renderers_CSS2DRenderer_js__WEBPACK_IMPORTED_MODULE_3__.CSS2DObject {
    constructor(config) {
        super(document.createElement('div'));
        this.normal = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 1, 0);
        this.initialized = false;
        this.referenceCount = 1;
        this.pivot = document.createElement('div');
        this.slot = document.createElement('slot');
        this.element.classList.add('annotation-wrapper');
        this.slot.name = config.name;
        this.element.appendChild(this.pivot);
        this.pivot.appendChild(this.slot);
        this.updatePosition(config.position);
        this.updateNormal(config.normal);
        this.surface = config.surface;
    }
    get facingCamera() {
        return !this.element.classList.contains('hide');
    }
    /**
     * Sets the hotspot to be in the highly visible foreground state.
     */
    show() {
        if (!this.facingCamera || !this.initialized) {
            this.updateVisibility(true);
        }
    }
    /**
     * Sets the hotspot to be in the diminished background state.
     */
    hide() {
        if (this.facingCamera || !this.initialized) {
            this.updateVisibility(false);
        }
    }
    /**
     * Call this when adding elements to the same slot to keep track.
     */
    increment() {
        this.referenceCount++;
    }
    /**
     * Call this when removing elements from the slot; returns true when the slot
     * is unused.
     */
    decrement() {
        if (this.referenceCount > 0) {
            --this.referenceCount;
        }
        return this.referenceCount === 0;
    }
    /**
     * Change the position of the hotspot to the input string, in the same format
     * as the data-position attribute.
     */
    updatePosition(position) {
        if (position == null)
            return;
        const positionNodes = (0,_styles_parsers_js__WEBPACK_IMPORTED_MODULE_1__.parseExpressions)(position)[0].terms;
        for (let i = 0; i < 3; ++i) {
            this.position.setComponent(i, (0,_styles_conversions_js__WEBPACK_IMPORTED_MODULE_0__.normalizeUnit)(positionNodes[i]).number);
        }
        this.updateMatrixWorld();
    }
    /**
     * Change the hotspot's normal to the input string, in the same format as the
     * data-normal attribute.
     */
    updateNormal(normal) {
        if (normal == null)
            return;
        const normalNodes = (0,_styles_parsers_js__WEBPACK_IMPORTED_MODULE_1__.parseExpressions)(normal)[0].terms;
        for (let i = 0; i < 3; ++i) {
            this.normal.setComponent(i, normalNodes[i].number);
        }
    }
    updateSurface(forceUpdate) {
        if (!forceUpdate && this.initialized) {
            return;
        }
        const { mesh, tri, bary } = this;
        if (mesh == null || tri == null || bary == null) {
            return;
        }
        mesh.getVertexPosition(tri.x, a);
        mesh.getVertexPosition(tri.y, b);
        mesh.getVertexPosition(tri.z, c);
        a.toArray(mat.elements, 0);
        b.toArray(mat.elements, 3);
        c.toArray(mat.elements, 6);
        this.position.copy(bary).applyMatrix3(mat);
        const target = this.parent;
        target.worldToLocal(mesh.localToWorld(this.position));
        triangle.set(a, b, c);
        triangle.getNormal(this.normal).transformDirection(mesh.matrixWorld);
        const scene = target.parent;
        quat.setFromAxisAngle(a.set(0, 1, 0), -scene.yaw);
        this.normal.applyQuaternion(quat);
    }
    orient(radians) {
        this.pivot.style.transform = `rotate(${radians}rad)`;
    }
    updateVisibility(show) {
        // NOTE: IE11 doesn't support a second arg for classList.toggle
        if (show) {
            this.element.classList.remove('hide');
        }
        else {
            this.element.classList.add('hide');
        }
        // NOTE: ShadyDOM doesn't support slot.assignedElements, otherwise we could
        // use that here.
        this.slot.assignedNodes().forEach((node) => {
            if (node.nodeType !== Node.ELEMENT_NODE) {
                return;
            }
            const element = node;
            // Visibility attribute can be configured per-node in the hotspot:
            const visibilityAttribute = element.dataset.visibilityAttribute;
            if (visibilityAttribute != null) {
                const attributeName = `data-${visibilityAttribute}`;
                // NOTE: IE11 doesn't support toggleAttribute
                if (show) {
                    element.setAttribute(attributeName, '');
                }
                else {
                    element.removeAttribute(attributeName);
                }
            }
            element.dispatchEvent(new CustomEvent('hotspot-visibility', {
                detail: {
                    visible: show,
                },
            }));
        });
        this.initialized = true;
    }
}
//# sourceMappingURL=Hotspot.js.map

/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/three-components/ModelScene.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/three-components/ModelScene.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IlluminationRole": () => (/* binding */ IlluminationRole),
/* harmony export */   "ModelScene": () => (/* binding */ ModelScene)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! three */ "../../node_modules/three/build/three.module.js");
/* harmony import */ var three_examples_jsm_renderers_CSS2DRenderer_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! three/examples/jsm/renderers/CSS2DRenderer.js */ "../../node_modules/three/examples/jsm/renderers/CSS2DRenderer.js");
/* harmony import */ var three_examples_jsm_utils_SceneUtils_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! three/examples/jsm/utils/SceneUtils.js */ "../../node_modules/three/examples/jsm/utils/SceneUtils.js");
/* harmony import */ var _features_scene_graph_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../features/scene-graph.js */ "../../node_modules/@google/model-viewer/lib/features/scene-graph.js");
/* harmony import */ var _features_scene_graph_model_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../features/scene-graph/model.js */ "../../node_modules/@google/model-viewer/lib/features/scene-graph/model.js");
/* harmony import */ var _model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../model-viewer-base.js */ "../../node_modules/@google/model-viewer/lib/model-viewer-base.js");
/* harmony import */ var _styles_conversions_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../styles/conversions.js */ "../../node_modules/@google/model-viewer/lib/styles/conversions.js");
/* harmony import */ var _styles_parsers_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../styles/parsers.js */ "../../node_modules/@google/model-viewer/lib/styles/parsers.js");
/* harmony import */ var _utilities_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utilities.js */ "../../node_modules/@google/model-viewer/lib/utilities.js");
/* harmony import */ var _Damper_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Damper.js */ "../../node_modules/@google/model-viewer/lib/three-components/Damper.js");
/* harmony import */ var _Hotspot_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Hotspot.js */ "../../node_modules/@google/model-viewer/lib/three-components/Hotspot.js");
/* harmony import */ var _Shadow_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Shadow.js */ "../../node_modules/@google/model-viewer/lib/three-components/Shadow.js");
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


// @ts-ignore










const MIN_SHADOW_RATIO = 100;
const IlluminationRole = {
    Primary: 'primary',
    Secondary: 'secondary'
};
const view = new three__WEBPACK_IMPORTED_MODULE_9__.Vector3();
const target = new three__WEBPACK_IMPORTED_MODULE_9__.Vector3();
const normalWorld = new three__WEBPACK_IMPORTED_MODULE_9__.Vector3();
const raycaster = new three__WEBPACK_IMPORTED_MODULE_9__.Raycaster();
const vector3 = new three__WEBPACK_IMPORTED_MODULE_9__.Vector3();
const ndc = new three__WEBPACK_IMPORTED_MODULE_9__.Vector2();
/**
 * A THREE.Scene object that takes a Model and CanvasHTMLElement and
 * constructs a framed scene based off of the canvas dimensions.
 * Provides lights and cameras to be used in a renderer.
 */
class ModelScene extends three__WEBPACK_IMPORTED_MODULE_9__.Scene {
    constructor({ canvas, element, width, height }) {
        super();
        this.annotationRenderer = new three_examples_jsm_renderers_CSS2DRenderer_js__WEBPACK_IMPORTED_MODULE_10__.CSS2DRenderer();
        this.schemaElement = document.createElement('script');
        this.width = 1;
        this.height = 1;
        this.aspect = 1;
        this.scaleStep = 0;
        this.renderCount = 0;
        this.externalRenderer = null;
        // These default camera values are never used, as they are reset once the
        // model is loaded and framing is computed.
        this.camera = new three__WEBPACK_IMPORTED_MODULE_9__.PerspectiveCamera(45, 1, 0.1, 100);
        this.xrCamera = null;
        this.url = null;
        this.target = new three__WEBPACK_IMPORTED_MODULE_9__.Object3D();
        this.animationNames = [];
        this.boundingBox = new three__WEBPACK_IMPORTED_MODULE_9__.Box3();
        this.boundingSphere = new three__WEBPACK_IMPORTED_MODULE_9__.Sphere();
        this.size = new three__WEBPACK_IMPORTED_MODULE_9__.Vector3();
        this.idealAspect = 0;
        this.framedFoVDeg = 0;
        this.shadow = null;
        this.shadowIntensity = 0;
        this.shadowSoftness = 1;
        this.bakedShadows = new Set();
        this.exposure = 1;
        this.canScale = true;
        this.isDirty = false;
        this.goalTarget = new three__WEBPACK_IMPORTED_MODULE_9__.Vector3();
        this.targetDamperX = new _Damper_js__WEBPACK_IMPORTED_MODULE_6__.Damper();
        this.targetDamperY = new _Damper_js__WEBPACK_IMPORTED_MODULE_6__.Damper();
        this.targetDamperZ = new _Damper_js__WEBPACK_IMPORTED_MODULE_6__.Damper();
        this._currentGLTF = null;
        this._model = null;
        this.cancelPendingSourceChange = null;
        this.animationsByName = new Map();
        this.currentAnimationAction = null;
        this.name = 'ModelScene';
        this.element = element;
        this.canvas = canvas;
        // These default camera values are never used, as they are reset once the
        // model is loaded and framing is computed.
        this.camera = new three__WEBPACK_IMPORTED_MODULE_9__.PerspectiveCamera(45, 1, 0.1, 100);
        this.camera.name = 'MainCamera';
        this.add(this.target);
        this.setSize(width, height);
        this.target.name = 'Target';
        this.mixer = new three__WEBPACK_IMPORTED_MODULE_9__.AnimationMixer(this.target);
        const { domElement } = this.annotationRenderer;
        const { style } = domElement;
        style.display = 'none';
        style.pointerEvents = 'none';
        style.position = 'absolute';
        style.top = '0';
        this.element.shadowRoot.querySelector('.default').appendChild(domElement);
        this.schemaElement.setAttribute('type', 'application/ld+json');
    }
    /**
     * Function to create the context lazily, as when there is only one
     * <model-viewer> element, the renderer's 3D context can be displayed
     * directly. This extra context is necessary to copy the renderings into when
     * there are more than one.
     */
    get context() {
        return this.canvas.getContext('2d');
    }
    getCamera() {
        return this.xrCamera != null ? this.xrCamera : this.camera;
    }
    queueRender() {
        this.isDirty = true;
    }
    shouldRender() {
        return this.isDirty;
    }
    hasRendered() {
        this.isDirty = false;
    }
    forceRescale() {
        this.scaleStep = -1;
        this.queueRender();
    }
    /**
     * Pass in a THREE.Object3D to be controlled
     * by this model.
     */
    async setObject(model) {
        this.reset();
        this._model = model;
        this.target.add(model);
        await this.setupScene();
    }
    /**
     * Sets the model via URL.
     */
    async setSource(url, progressCallback = () => { }) {
        if (!url || url === this.url) {
            progressCallback(1);
            return;
        }
        this.reset();
        this.url = url;
        if (this.externalRenderer != null) {
            const framingInfo = await this.externalRenderer.load(progressCallback);
            this.boundingSphere.radius = framingInfo.framedRadius;
            this.idealAspect = framingInfo.fieldOfViewAspect;
            return;
        }
        // If we have pending work due to a previous source change in progress,
        // cancel it so that we do not incur a race condition:
        if (this.cancelPendingSourceChange != null) {
            this.cancelPendingSourceChange();
            this.cancelPendingSourceChange = null;
        }
        let gltf;
        try {
            gltf = await new Promise(async (resolve, reject) => {
                this.cancelPendingSourceChange = () => reject();
                try {
                    const result = await this.element[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$renderer].loader.load(url, this.element, progressCallback);
                    resolve(result);
                }
                catch (error) {
                    reject(error);
                }
            });
        }
        catch (error) {
            if (error == null) {
                // Loading was cancelled, so silently return
                return;
            }
            throw error;
        }
        this.cancelPendingSourceChange = null;
        this.reset();
        this.url = url;
        this._currentGLTF = gltf;
        if (gltf != null) {
            this._model = gltf.scene;
            this.target.add(gltf.scene);
        }
        const { animations } = gltf;
        const animationsByName = new Map();
        const animationNames = [];
        for (const animation of animations) {
            animationsByName.set(animation.name, animation);
            animationNames.push(animation.name);
        }
        this.animations = animations;
        this.animationsByName = animationsByName;
        this.animationNames = animationNames;
        await this.setupScene();
    }
    async setupScene() {
        this.applyTransform();
        this.updateBoundingBox();
        await this.updateFraming();
        this.updateShadow();
        this.setShadowIntensity(this.shadowIntensity);
    }
    reset() {
        this.url = null;
        this.renderCount = 0;
        this.queueRender();
        if (this.shadow != null) {
            this.shadow.setIntensity(0);
        }
        this.bakedShadows.clear();
        const { _model } = this;
        if (_model != null) {
            _model.removeFromParent();
            this._model = null;
        }
        const gltf = this._currentGLTF;
        if (gltf != null) {
            gltf.dispose();
            this._currentGLTF = null;
        }
        if (this.currentAnimationAction != null) {
            this.currentAnimationAction.stop();
            this.currentAnimationAction = null;
        }
        this.mixer.stopAllAction();
        this.mixer.uncacheRoot(this);
    }
    dispose() {
        this.reset();
        if (this.shadow != null) {
            this.shadow.dispose();
            this.shadow = null;
        }
        this.element[_features_scene_graph_js__WEBPACK_IMPORTED_MODULE_0__.$currentGLTF] = null;
        this.element[_features_scene_graph_js__WEBPACK_IMPORTED_MODULE_0__.$originalGltfJson] = null;
        this.element[_features_scene_graph_js__WEBPACK_IMPORTED_MODULE_0__.$model] = null;
    }
    get currentGLTF() {
        return this._currentGLTF;
    }
    /**
     * Updates the ModelScene for a new container size in CSS pixels.
     */
    setSize(width, height) {
        if (this.width === width && this.height === height) {
            return;
        }
        this.width = Math.max(width, 1);
        this.height = Math.max(height, 1);
        this.annotationRenderer.setSize(width, height);
        this.aspect = this.width / this.height;
        if (this.externalRenderer != null) {
            const dpr = (0,_utilities_js__WEBPACK_IMPORTED_MODULE_5__.resolveDpr)();
            this.externalRenderer.resize(width * dpr, height * dpr);
        }
        this.queueRender();
    }
    markBakedShadow(mesh) {
        mesh.userData.shadow = true;
        this.bakedShadows.add(mesh);
    }
    unmarkBakedShadow(mesh) {
        mesh.userData.shadow = false;
        mesh.visible = true;
        this.bakedShadows.delete(mesh);
        this.boundingBox.expandByObject(mesh);
    }
    findBakedShadows(group) {
        const boundingBox = new three__WEBPACK_IMPORTED_MODULE_9__.Box3();
        group.traverse((object) => {
            const mesh = object;
            if (!mesh.material) {
                return;
            }
            const material = mesh.material;
            if (!material.transparent) {
                return;
            }
            boundingBox.setFromObject(mesh);
            const size = boundingBox.getSize(vector3);
            const minDim = Math.min(size.x, size.y, size.z);
            const maxDim = Math.max(size.x, size.y, size.z);
            if (maxDim < MIN_SHADOW_RATIO * minDim) {
                return;
            }
            this.markBakedShadow(mesh);
        });
    }
    checkBakedShadows() {
        const { min, max } = this.boundingBox;
        const shadowBox = new three__WEBPACK_IMPORTED_MODULE_9__.Box3();
        this.boundingBox.getSize(this.size);
        for (const mesh of this.bakedShadows) {
            shadowBox.setFromObject(mesh);
            if (shadowBox.min.y < min.y + this.size.y / MIN_SHADOW_RATIO &&
                shadowBox.min.x <= min.x && shadowBox.max.x >= max.x &&
                shadowBox.min.z <= min.z && shadowBox.max.z >= max.z) {
                // floor shadow
                continue;
            }
            if (shadowBox.min.z < min.z + this.size.z / MIN_SHADOW_RATIO &&
                shadowBox.min.x <= min.x && shadowBox.max.x >= max.x &&
                shadowBox.min.y <= min.y && shadowBox.max.y >= max.y) {
                // wall shadow
                continue;
            }
            this.unmarkBakedShadow(mesh);
        }
    }
    applyTransform() {
        const { model } = this;
        if (model == null) {
            return;
        }
        const orientation = (0,_styles_parsers_js__WEBPACK_IMPORTED_MODULE_4__.parseExpressions)(this.element.orientation)[0]
            .terms;
        const roll = (0,_styles_conversions_js__WEBPACK_IMPORTED_MODULE_3__.normalizeUnit)(orientation[0]).number;
        const pitch = (0,_styles_conversions_js__WEBPACK_IMPORTED_MODULE_3__.normalizeUnit)(orientation[1]).number;
        const yaw = (0,_styles_conversions_js__WEBPACK_IMPORTED_MODULE_3__.normalizeUnit)(orientation[2]).number;
        model.quaternion.setFromEuler(new three__WEBPACK_IMPORTED_MODULE_9__.Euler(pitch, yaw, roll, 'YXZ'));
        const scale = (0,_styles_parsers_js__WEBPACK_IMPORTED_MODULE_4__.parseExpressions)(this.element.scale)[0]
            .terms;
        model.scale.set(scale[0].number, scale[1].number, scale[2].number);
    }
    updateBoundingBox() {
        const { model } = this;
        if (model == null) {
            return;
        }
        this.target.remove(model);
        this.findBakedShadows(model);
        const bound = (box, vertex) => {
            return box.expandByPoint(vertex);
        };
        this.setBakedShadowVisibility(false);
        this.boundingBox = (0,three_examples_jsm_utils_SceneUtils_js__WEBPACK_IMPORTED_MODULE_11__.reduceVertices)(model, bound, new three__WEBPACK_IMPORTED_MODULE_9__.Box3());
        // If there's nothing but the baked shadow, then it's not a baked shadow.
        if (this.boundingBox.isEmpty()) {
            this.setBakedShadowVisibility(true);
            this.bakedShadows.forEach((mesh) => this.unmarkBakedShadow(mesh));
            this.boundingBox = (0,three_examples_jsm_utils_SceneUtils_js__WEBPACK_IMPORTED_MODULE_11__.reduceVertices)(model, bound, new three__WEBPACK_IMPORTED_MODULE_9__.Box3());
        }
        this.checkBakedShadows();
        this.setBakedShadowVisibility();
        this.boundingBox.getSize(this.size);
        this.target.add(model);
    }
    /**
     * Calculates the boundingSphere and idealAspect that allows the 3D
     * object to be framed tightly in a 2D window of any aspect ratio without
     * clipping at any camera orbit. The camera's center target point can be
     * optionally specified. If no center is specified, it defaults to the center
     * of the bounding box, which means asymmetric models will tend to be tight on
     * one side instead of both. Proper choice of center can correct this.
     */
    async updateFraming() {
        const { model } = this;
        if (model == null) {
            return;
        }
        this.target.remove(model);
        this.setBakedShadowVisibility(false);
        const { center } = this.boundingSphere;
        this.element.requestUpdate('cameraTarget');
        await this.element.updateComplete;
        center.copy(this.getTarget());
        const radiusSquared = (value, vertex) => {
            return Math.max(value, center.distanceToSquared(vertex));
        };
        this.boundingSphere.radius =
            Math.sqrt((0,three_examples_jsm_utils_SceneUtils_js__WEBPACK_IMPORTED_MODULE_11__.reduceVertices)(model, radiusSquared, 0));
        const horizontalTanFov = (value, vertex) => {
            vertex.sub(center);
            const radiusXZ = Math.sqrt(vertex.x * vertex.x + vertex.z * vertex.z);
            return Math.max(value, radiusXZ / (this.idealCameraDistance() - Math.abs(vertex.y)));
        };
        this.idealAspect = (0,three_examples_jsm_utils_SceneUtils_js__WEBPACK_IMPORTED_MODULE_11__.reduceVertices)(model, horizontalTanFov, 0) /
            Math.tan((this.framedFoVDeg / 2) * Math.PI / 180);
        this.setBakedShadowVisibility();
        this.target.add(model);
    }
    setBakedShadowVisibility(visible = this.shadowIntensity <= 0) {
        for (const shadow of this.bakedShadows) {
            shadow.visible = visible;
        }
    }
    idealCameraDistance() {
        const halfFovRad = (this.framedFoVDeg / 2) * Math.PI / 180;
        return this.boundingSphere.radius / Math.sin(halfFovRad);
    }
    /**
     * Set's the framedFieldOfView based on the aspect ratio of the window in
     * order to keep the model fully visible at any camera orientation.
     */
    adjustedFoV(fovDeg) {
        const vertical = Math.tan((fovDeg / 2) * Math.PI / 180) *
            Math.max(1, this.idealAspect / this.aspect);
        return 2 * Math.atan(vertical) * 180 / Math.PI;
    }
    getNDC(clientX, clientY) {
        if (this.xrCamera != null) {
            ndc.set(clientX / window.screen.width, clientY / window.screen.height);
        }
        else {
            const rect = this.element.getBoundingClientRect();
            ndc.set((clientX - rect.x) / this.width, (clientY - rect.y) / this.height);
        }
        ndc.multiplyScalar(2).subScalar(1);
        ndc.y *= -1;
        return ndc;
    }
    /**
     * Returns the size of the corresponding canvas element.
     */
    getSize() {
        return { width: this.width, height: this.height };
    }
    setEnvironmentAndSkybox(environment, skybox) {
        if (this.element[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_2__.$renderer].arRenderer.presentedScene === this) {
            return;
        }
        this.environment = environment;
        this.background = skybox;
        this.queueRender();
    }
    /**
     * Sets the point in model coordinates the model should orbit/pivot around.
     */
    setTarget(modelX, modelY, modelZ) {
        this.goalTarget.set(-modelX, -modelY, -modelZ);
    }
    /**
     * Set the decay time of, affects the speed of target transitions.
     */
    setTargetDamperDecayTime(decayMilliseconds) {
        this.targetDamperX.setDecayTime(decayMilliseconds);
        this.targetDamperY.setDecayTime(decayMilliseconds);
        this.targetDamperZ.setDecayTime(decayMilliseconds);
    }
    /**
     * Gets the point in model coordinates the model should orbit/pivot around.
     */
    getTarget() {
        return this.goalTarget.clone().multiplyScalar(-1);
    }
    /**
     * Shifts the model to the target point immediately instead of easing in.
     */
    jumpToGoal() {
        this.updateTarget(_Damper_js__WEBPACK_IMPORTED_MODULE_6__.SETTLING_TIME);
    }
    /**
     * This should be called every frame with the frame delta to cause the target
     * to transition to its set point.
     */
    updateTarget(delta) {
        const goal = this.goalTarget;
        const target = this.target.position;
        if (!goal.equals(target)) {
            const normalization = this.boundingSphere.radius / 10;
            let { x, y, z } = target;
            x = this.targetDamperX.update(x, goal.x, delta, normalization);
            y = this.targetDamperY.update(y, goal.y, delta, normalization);
            z = this.targetDamperZ.update(z, goal.z, delta, normalization);
            this.target.position.set(x, y, z);
            this.target.updateMatrixWorld();
            this.queueRender();
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Yaw the +z (front) of the model toward the indicated world coordinates.
     */
    pointTowards(worldX, worldZ) {
        const { x, z } = this.position;
        this.yaw = Math.atan2(worldX - x, worldZ - z);
    }
    get model() {
        return this._model;
    }
    /**
     * Yaw is the scene's orientation about the y-axis, around the rotation
     * center.
     */
    set yaw(radiansY) {
        this.rotation.y = radiansY;
        this.queueRender();
    }
    get yaw() {
        return this.rotation.y;
    }
    set animationTime(value) {
        this.mixer.setTime(value);
        this.queueShadowRender();
    }
    get animationTime() {
        if (this.currentAnimationAction != null) {
            const loopCount = Math.max(this.currentAnimationAction._loopCount, 0);
            if (this.currentAnimationAction.loop === three__WEBPACK_IMPORTED_MODULE_9__.LoopPingPong &&
                (loopCount & 1) === 1) {
                return this.duration - this.currentAnimationAction.time;
            }
            else {
                return this.currentAnimationAction.time;
            }
        }
        return 0;
    }
    set animationTimeScale(value) {
        this.mixer.timeScale = value;
    }
    get animationTimeScale() {
        return this.mixer.timeScale;
    }
    get duration() {
        if (this.currentAnimationAction != null &&
            this.currentAnimationAction.getClip()) {
            return this.currentAnimationAction.getClip().duration;
        }
        return 0;
    }
    get hasActiveAnimation() {
        return this.currentAnimationAction != null;
    }
    /**
     * Plays an animation if there are any associated with the current model.
     * Accepts an optional string name of an animation to play. If no name is
     * provided, or if no animation is found by the given name, always falls back
     * to playing the first animation.
     */
    playAnimation(name = null, crossfadeTime = 0, loopMode = three__WEBPACK_IMPORTED_MODULE_9__.LoopRepeat, repetitionCount = Infinity) {
        if (this._currentGLTF == null) {
            return;
        }
        const { animations } = this;
        if (animations == null || animations.length === 0) {
            return;
        }
        let animationClip = null;
        if (name != null) {
            animationClip = this.animationsByName.get(name);
            if (animationClip == null) {
                const parsedAnimationIndex = parseInt(name);
                if (!isNaN(parsedAnimationIndex) && parsedAnimationIndex >= 0 &&
                    parsedAnimationIndex < animations.length) {
                    animationClip = animations[parsedAnimationIndex];
                }
            }
        }
        if (animationClip == null) {
            animationClip = animations[0];
        }
        try {
            const { currentAnimationAction: lastAnimationAction } = this;
            const action = this.mixer.clipAction(animationClip, this);
            this.currentAnimationAction = action;
            if (this.element.paused) {
                this.mixer.stopAllAction();
            }
            else {
                action.paused = false;
                if (lastAnimationAction != null && action !== lastAnimationAction) {
                    action.crossFadeFrom(lastAnimationAction, crossfadeTime, false);
                }
                else if (this.animationTimeScale > 0 &&
                    this.animationTime == this.duration) {
                    // This is a workaround for what I believe is a three.js bug.
                    this.animationTime = 0;
                }
            }
            action.setLoop(loopMode, repetitionCount);
            action.enabled = true;
            action.clampWhenFinished = true;
            action.play();
        }
        catch (error) {
            console.error(error);
        }
    }
    stopAnimation() {
        this.currentAnimationAction = null;
        this.mixer.stopAllAction();
    }
    updateAnimation(step) {
        this.mixer.update(step);
        this.queueShadowRender();
    }
    subscribeMixerEvent(event, callback) {
        this.mixer.addEventListener(event, callback);
    }
    /**
     * Call if the object has been changed in such a way that the shadow's shape
     * has changed (not a rotation about the Y axis).
     */
    updateShadow() {
        const shadow = this.shadow;
        if (shadow != null) {
            const side = this.element.arPlacement === 'wall' ? 'back' : 'bottom';
            shadow.setScene(this, this.shadowSoftness, side);
            shadow.needsUpdate = true;
        }
    }
    renderShadow(renderer) {
        const shadow = this.shadow;
        if (shadow != null && shadow.needsUpdate == true) {
            shadow.render(renderer, this);
            shadow.needsUpdate = false;
        }
    }
    queueShadowRender() {
        if (this.shadow != null) {
            this.shadow.needsUpdate = true;
        }
    }
    /**
     * Sets the shadow's intensity, lazily creating the shadow as necessary.
     */
    setShadowIntensity(shadowIntensity) {
        this.shadowIntensity = shadowIntensity;
        if (this._currentGLTF == null) {
            return;
        }
        this.setBakedShadowVisibility();
        if (shadowIntensity <= 0 && this.shadow == null) {
            return;
        }
        if (this.shadow == null) {
            const side = this.element.arPlacement === 'wall' ? 'back' : 'bottom';
            this.shadow = new _Shadow_js__WEBPACK_IMPORTED_MODULE_8__.Shadow(this, this.shadowSoftness, side);
        }
        this.shadow.setIntensity(shadowIntensity);
    }
    /**
     * Sets the shadow's softness by mapping a [0, 1] softness parameter to the
     * shadow's resolution. This involves reallocation, so it should not be
     * changed frequently. Softer shadows are cheaper to render.
     */
    setShadowSoftness(softness) {
        this.shadowSoftness = softness;
        const shadow = this.shadow;
        if (shadow != null) {
            shadow.setSoftness(softness);
        }
    }
    /**
     * Shift the floor vertically from the bottom of the model's bounding box by
     * offset (should generally be negative).
     */
    setShadowOffset(offset) {
        const shadow = this.shadow;
        if (shadow != null) {
            shadow.setOffset(offset);
        }
    }
    hitFromPoint(ndcPosition, object = this) {
        raycaster.setFromCamera(ndcPosition, this.getCamera());
        const hits = raycaster.intersectObject(object, true);
        return hits.find((hit) => hit.object.visible && !hit.object.userData.shadow);
    }
    /**
     * This method returns the world position, model-space normal and texture
     * coordinate of the point on the mesh corresponding to the input pixel
     * coordinates given relative to the model-viewer element. If the mesh
     * is not hit, the result is null.
     */
    positionAndNormalFromPoint(ndcPosition, object = this) {
        var _a;
        const hit = this.hitFromPoint(ndcPosition, object);
        if (hit == null) {
            return null;
        }
        const position = hit.point;
        const normal = hit.face != null ?
            hit.face.normal.clone().applyNormalMatrix(new three__WEBPACK_IMPORTED_MODULE_9__.Matrix3().getNormalMatrix(hit.object.matrixWorld)) :
            raycaster.ray.direction.clone().multiplyScalar(-1);
        const uv = (_a = hit.uv) !== null && _a !== void 0 ? _a : null;
        return { position, normal, uv };
    }
    /**
     * This method returns a dynamic hotspot ID string of the point on the mesh
     * corresponding to the input pixel coordinates given relative to the
     * model-viewer element. The ID string can be used in the data-surface
     * attribute of the hotspot to make it follow this point on the surface even
     * as the model animates. If the mesh is not hit, the result is null.
     */
    surfaceFromPoint(ndcPosition, object = this) {
        const model = this.element.model;
        if (model == null) {
            return null;
        }
        const hit = this.hitFromPoint(ndcPosition, object);
        if (hit == null || hit.face == null) {
            return null;
        }
        const node = model[_features_scene_graph_model_js__WEBPACK_IMPORTED_MODULE_1__.$nodeFromPoint](hit);
        const { meshes, primitives } = node.mesh.userData.associations;
        const va = new three__WEBPACK_IMPORTED_MODULE_9__.Vector3();
        const vb = new three__WEBPACK_IMPORTED_MODULE_9__.Vector3();
        const vc = new three__WEBPACK_IMPORTED_MODULE_9__.Vector3();
        const { a, b, c } = hit.face;
        const mesh = hit.object;
        mesh.getVertexPosition(a, va);
        mesh.getVertexPosition(b, vb);
        mesh.getVertexPosition(c, vc);
        const tri = new three__WEBPACK_IMPORTED_MODULE_9__.Triangle(va, vb, vc);
        const uvw = new three__WEBPACK_IMPORTED_MODULE_9__.Vector3();
        tri.getBarycoord(mesh.worldToLocal(hit.point), uvw);
        return `${meshes} ${primitives} ${a} ${b} ${c} ${uvw.x.toFixed(3)} ${uvw.y.toFixed(3)} ${uvw.z.toFixed(3)}`;
    }
    /**
     * The following methods are for operating on the set of Hotspot objects
     * attached to the scene. These come from DOM elements, provided to slots by
     * the Annotation Mixin.
     */
    addHotspot(hotspot) {
        this.target.add(hotspot);
        // This happens automatically in render(), but we do it early so that
        // the slots appear in the shadow DOM and the elements get attached,
        // allowing us to dispatch events on them.
        this.annotationRenderer.domElement.appendChild(hotspot.element);
    }
    removeHotspot(hotspot) {
        this.target.remove(hotspot);
    }
    /**
     * Helper method to apply a function to all hotspots.
     */
    forHotspots(func) {
        const { children } = this.target;
        for (let i = 0, l = children.length; i < l; i++) {
            const hotspot = children[i];
            if (hotspot instanceof _Hotspot_js__WEBPACK_IMPORTED_MODULE_7__.Hotspot) {
                func(hotspot);
            }
        }
    }
    /**
     * Lazy initializer for surface hotspots - will only run once.
     */
    initializeSurface(hotspot) {
        if (hotspot.surface != null && hotspot.mesh == null) {
            const nodes = (0,_styles_parsers_js__WEBPACK_IMPORTED_MODULE_4__.parseExpressions)(hotspot.surface)[0].terms;
            if (nodes.length != 8) {
                console.warn(hotspot.surface + ' does not have exactly 8 numbers.');
                return;
            }
            const primitiveNode = this.element.model[_features_scene_graph_model_js__WEBPACK_IMPORTED_MODULE_1__.$nodeFromIndex](nodes[0].number, nodes[1].number);
            const tri = new three__WEBPACK_IMPORTED_MODULE_9__.Vector3(nodes[2].number, nodes[3].number, nodes[4].number);
            if (primitiveNode == null) {
                console.warn(hotspot.surface +
                    ' does not match a node/primitive in this glTF! Skipping this hotspot.');
                return;
            }
            const numVert = primitiveNode.mesh.geometry.attributes.position.count;
            if (tri.x >= numVert || tri.y >= numVert || tri.z >= numVert) {
                console.warn(hotspot.surface +
                    ' vertex indices out of range in this glTF! Skipping this hotspot.');
                return;
            }
            const bary = new three__WEBPACK_IMPORTED_MODULE_9__.Vector3(nodes[5].number, nodes[6].number, nodes[7].number);
            hotspot.mesh = primitiveNode.mesh;
            hotspot.tri = tri;
            hotspot.bary = bary;
        }
    }
    /**
     * Update positions of surface hotspots to follow model animation.
     */
    updateSurfaceHotspots() {
        const forceUpdate = !this.element.paused;
        this.forHotspots((hotspot) => {
            this.initializeSurface(hotspot);
            hotspot.updateSurface(forceUpdate);
        });
    }
    /**
     * Update the CSS visibility of the hotspots based on whether their normals
     * point toward the camera.
     */
    updateHotspotsVisibility(viewerPosition) {
        this.forHotspots((hotspot) => {
            view.copy(viewerPosition);
            target.setFromMatrixPosition(hotspot.matrixWorld);
            view.sub(target);
            normalWorld.copy(hotspot.normal)
                .transformDirection(this.target.matrixWorld);
            if (view.dot(normalWorld) < 0) {
                hotspot.hide();
            }
            else {
                hotspot.show();
            }
        });
    }
    /**
     * Rotate all hotspots to an absolute orientation given by the input number of
     * radians. Zero returns them to upright.
     */
    orientHotspots(radians) {
        this.forHotspots((hotspot) => {
            hotspot.orient(radians);
        });
    }
    /**
     * Set the rendering visibility of all hotspots. This is used to hide them
     * during transitions and such.
     */
    setHotspotsVisibility(visible) {
        this.forHotspots((hotspot) => {
            hotspot.visible = visible;
        });
    }
    updateSchema(src) {
        var _a;
        const { schemaElement, element } = this;
        const { alt, poster, iosSrc } = element;
        if (src != null) {
            const encoding = [{
                    '@type': 'MediaObject',
                    contentUrl: src,
                    encodingFormat: ((_a = src.split('.').pop()) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === 'gltf' ?
                        'model/gltf+json' :
                        'model/gltf-binary'
                }];
            if (iosSrc) {
                encoding.push({
                    '@type': 'MediaObject',
                    contentUrl: iosSrc,
                    encodingFormat: 'model/vnd.usdz+zip'
                });
            }
            const structuredData = {
                '@context': 'http://schema.org/',
                '@type': '3DModel',
                image: poster !== null && poster !== void 0 ? poster : undefined,
                name: alt !== null && alt !== void 0 ? alt : undefined,
                encoding
            };
            schemaElement.textContent = JSON.stringify(structuredData);
            document.head.appendChild(schemaElement);
        }
        else if (schemaElement.parentElement != null) {
            schemaElement.parentElement.removeChild(schemaElement);
        }
    }
}
//# sourceMappingURL=ModelScene.js.map

/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/three-components/PlacementBox.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/three-components/PlacementBox.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PlacementBox": () => (/* binding */ PlacementBox)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ "../../node_modules/three/build/three.module.js");
/* harmony import */ var _Damper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Damper.js */ "../../node_modules/@google/model-viewer/lib/three-components/Damper.js");
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


const RADIUS = 0.2;
const LINE_WIDTH = 0.03;
const MAX_OPACITY = 0.75;
const SEGMENTS = 12;
const DELTA_PHI = Math.PI / (2 * SEGMENTS);
const vector2 = new three__WEBPACK_IMPORTED_MODULE_1__.Vector2();
/**
 * Adds a quarter-annulus of vertices to the array, centered on cornerX,
 * cornerY.
 */
const addCorner = (vertices, cornerX, cornerY) => {
    let phi = cornerX > 0 ? (cornerY > 0 ? 0 : -Math.PI / 2) :
        (cornerY > 0 ? Math.PI / 2 : Math.PI);
    for (let i = 0; i <= SEGMENTS; ++i) {
        vertices.push(cornerX + (RADIUS - LINE_WIDTH) * Math.cos(phi), cornerY + (RADIUS - LINE_WIDTH) * Math.sin(phi), 0, cornerX + RADIUS * Math.cos(phi), cornerY + RADIUS * Math.sin(phi), 0);
        phi += DELTA_PHI;
    }
};
/**
 * This class is a set of two coincident planes. The first is just a cute box
 * outline with rounded corners and damped opacity to indicate the floor extents
 * of a scene. It is purposely larger than the scene's bounding box by RADIUS on
 * all sides so that small scenes are still visible / selectable. Its center is
 * actually carved out by vertices to ensure its fragment shader doesn't add
 * much time.
 *
 * The child plane is a simple plane with the same extents for use in hit
 * testing (translation is triggered when the touch hits the plane, rotation
 * otherwise).
 */
class PlacementBox extends three__WEBPACK_IMPORTED_MODULE_1__.Mesh {
    constructor(scene, side) {
        const geometry = new three__WEBPACK_IMPORTED_MODULE_1__.BufferGeometry();
        const triangles = [];
        const vertices = [];
        const { size, boundingBox } = scene;
        const x = size.x / 2;
        const y = (side === 'back' ? size.y : size.z) / 2;
        addCorner(vertices, x, y);
        addCorner(vertices, -x, y);
        addCorner(vertices, -x, -y);
        addCorner(vertices, x, -y);
        const numVertices = vertices.length / 3;
        for (let i = 0; i < numVertices - 2; i += 2) {
            triangles.push(i, i + 1, i + 3, i, i + 3, i + 2);
        }
        const i = numVertices - 2;
        triangles.push(i, i + 1, 1, i, 1, 0);
        geometry.setAttribute('position', new three__WEBPACK_IMPORTED_MODULE_1__.Float32BufferAttribute(vertices, 3));
        geometry.setIndex(triangles);
        super(geometry);
        this.side = side;
        const material = this.material;
        material.side = three__WEBPACK_IMPORTED_MODULE_1__.DoubleSide;
        material.transparent = true;
        material.opacity = 0;
        this.goalOpacity = 0;
        this.opacityDamper = new _Damper_js__WEBPACK_IMPORTED_MODULE_0__.Damper();
        this.hitPlane =
            new three__WEBPACK_IMPORTED_MODULE_1__.Mesh(new three__WEBPACK_IMPORTED_MODULE_1__.PlaneGeometry(2 * (x + RADIUS), 2 * (y + RADIUS)));
        this.hitPlane.visible = false;
        this.hitPlane.material.side = three__WEBPACK_IMPORTED_MODULE_1__.DoubleSide;
        this.add(this.hitPlane);
        boundingBox.getCenter(this.position);
        switch (side) {
            case 'bottom':
                this.rotateX(-Math.PI / 2);
                this.shadowHeight = boundingBox.min.y;
                this.position.y = this.shadowHeight;
                break;
            case 'back':
                this.shadowHeight = boundingBox.min.z;
                this.position.z = this.shadowHeight;
        }
        scene.target.add(this);
        this.offsetHeight = 0;
    }
    /**
     * Get the world hit position if the touch coordinates hit the box, and null
     * otherwise. Pass the scene in to get access to its raycaster.
     */
    getHit(scene, screenX, screenY) {
        vector2.set(screenX, -screenY);
        this.hitPlane.visible = true;
        const hitResult = scene.positionAndNormalFromPoint(vector2, this.hitPlane);
        this.hitPlane.visible = false;
        return hitResult == null ? null : hitResult.position;
    }
    getExpandedHit(scene, screenX, screenY) {
        this.hitPlane.scale.set(1000, 1000, 1000);
        this.hitPlane.updateMatrixWorld();
        const hitResult = this.getHit(scene, screenX, screenY);
        this.hitPlane.scale.set(1, 1, 1);
        return hitResult;
    }
    /**
     * Offset the height of the box relative to the bottom of the scene. Positive
     * is up, so generally only negative values are used.
     */
    set offsetHeight(offset) {
        offset -= 0.001; // push 1 mm below shadow to avoid z-fighting
        if (this.side === 'back') {
            this.position.z = this.shadowHeight + offset;
        }
        else {
            this.position.y = this.shadowHeight + offset;
        }
    }
    get offsetHeight() {
        if (this.side === 'back') {
            return this.position.z - this.shadowHeight;
        }
        else {
            return this.position.y - this.shadowHeight;
        }
    }
    /**
     * Set the box's visibility; it will fade in and out.
     */
    set show(visible) {
        this.goalOpacity = visible ? MAX_OPACITY : 0;
    }
    /**
     * Call on each frame with the frame delta to fade the box.
     */
    updateOpacity(delta) {
        const material = this.material;
        material.opacity =
            this.opacityDamper.update(material.opacity, this.goalOpacity, delta, 1);
        this.visible = material.opacity > 0;
    }
    /**
     * Call this to clean up Three's cache when you remove the box.
     */
    dispose() {
        var _a;
        const { geometry, material } = this.hitPlane;
        geometry.dispose();
        material.dispose();
        this.geometry.dispose();
        this.material.dispose();
        (_a = this.parent) === null || _a === void 0 ? void 0 : _a.remove(this);
    }
}
//# sourceMappingURL=PlacementBox.js.map

/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/three-components/Renderer.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/three-components/Renderer.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DEFAULT_POWER_PREFERENCE": () => (/* binding */ DEFAULT_POWER_PREFERENCE),
/* harmony export */   "Renderer": () => (/* binding */ Renderer)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! three */ "../../node_modules/three/build/three.module.js");
/* harmony import */ var _features_environment_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../features/environment.js */ "../../node_modules/@google/model-viewer/lib/features/environment.js");
/* harmony import */ var _model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../model-viewer-base.js */ "../../node_modules/@google/model-viewer/lib/model-viewer-base.js");
/* harmony import */ var _utilities_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utilities.js */ "../../node_modules/@google/model-viewer/lib/utilities.js");
/* harmony import */ var _ARRenderer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ARRenderer.js */ "../../node_modules/@google/model-viewer/lib/three-components/ARRenderer.js");
/* harmony import */ var _CachingGLTFLoader_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./CachingGLTFLoader.js */ "../../node_modules/@google/model-viewer/lib/three-components/CachingGLTFLoader.js");
/* harmony import */ var _Debugger_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Debugger.js */ "../../node_modules/@google/model-viewer/lib/three-components/Debugger.js");
/* harmony import */ var _gltf_instance_ModelViewerGLTFInstance_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./gltf-instance/ModelViewerGLTFInstance.js */ "../../node_modules/@google/model-viewer/lib/three-components/gltf-instance/ModelViewerGLTFInstance.js");
/* harmony import */ var _TextureUtils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./TextureUtils.js */ "../../node_modules/@google/model-viewer/lib/three-components/TextureUtils.js");
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */









// Between 0 and 1: larger means the average responds faster and is less smooth.
const DURATION_DECAY = 0.2;
const LOW_FRAME_DURATION_MS = 40;
const HIGH_FRAME_DURATION_MS = 60;
const MAX_AVG_CHANGE_MS = 5;
const SCALE_STEPS = [1, 0.79, 0.62, 0.5, 0.4, 0.31, 0.25];
const DEFAULT_LAST_STEP = 3;
const DEFAULT_POWER_PREFERENCE = 'high-performance';
/**
 * Registers canvases with Canvas2DRenderingContexts and renders them
 * all in the same WebGLRenderingContext, spitting out textures to apply
 * to the canvases. Creates a fullscreen WebGL canvas that is not added
 * to the DOM, and on each frame, renders each registered canvas on a portion
 * of the WebGL canvas, and applies the texture on the registered canvas.
 *
 * In the future, can use ImageBitmapRenderingContext instead of
 * Canvas2DRenderingContext if supported for cheaper transferring of
 * the texture.
 */
class Renderer extends three__WEBPACK_IMPORTED_MODULE_8__.EventDispatcher {
    constructor(options) {
        super();
        this.loader = new _CachingGLTFLoader_js__WEBPACK_IMPORTED_MODULE_4__.CachingGLTFLoader(_gltf_instance_ModelViewerGLTFInstance_js__WEBPACK_IMPORTED_MODULE_6__.ModelViewerGLTFInstance);
        this.width = 0;
        this.height = 0;
        this.dpr = 1;
        this.debugger = null;
        this.scenes = new Set();
        this.multipleScenesVisible = false;
        this.lastTick = performance.now();
        this.renderedLastFrame = false;
        this.scaleStep = 0;
        this.lastStep = DEFAULT_LAST_STEP;
        this.avgFrameDuration = (HIGH_FRAME_DURATION_MS + LOW_FRAME_DURATION_MS) / 2;
        this.onWebGLContextLost = (event) => {
            this.dispatchEvent({ type: 'contextlost', sourceEvent: event });
        };
        this.onWebGLContextRestored = () => {
            var _a;
            (_a = this.textureUtils) === null || _a === void 0 ? void 0 : _a.dispose();
            this.textureUtils = new _TextureUtils_js__WEBPACK_IMPORTED_MODULE_7__["default"](this.threeRenderer);
            for (const scene of this.scenes) {
                scene.element[_features_environment_js__WEBPACK_IMPORTED_MODULE_0__.$updateEnvironment]();
            }
        };
        this.dpr = (0,_utilities_js__WEBPACK_IMPORTED_MODULE_2__.resolveDpr)();
        this.canvas3D = document.createElement('canvas');
        this.canvas3D.id = 'webgl-canvas';
        this.canvas3D.classList.add('show');
        try {
            this.threeRenderer = new three__WEBPACK_IMPORTED_MODULE_8__.WebGLRenderer({
                canvas: this.canvas3D,
                alpha: true,
                antialias: true,
                powerPreference: options.powerPreference,
                preserveDrawingBuffer: true
            });
            this.threeRenderer.autoClear = true;
            this.threeRenderer.outputEncoding = three__WEBPACK_IMPORTED_MODULE_8__.sRGBEncoding;
            this.threeRenderer.useLegacyLights = false;
            this.threeRenderer.setPixelRatio(1); // handle pixel ratio externally
            this.debugger = !!options.debug ? new _Debugger_js__WEBPACK_IMPORTED_MODULE_5__.Debugger(this) : null;
            this.threeRenderer.debug = { checkShaderErrors: !!this.debugger };
            // ACESFilmicToneMapping appears to be the most "saturated",
            // and similar to Filament's gltf-viewer.
            this.threeRenderer.toneMapping = three__WEBPACK_IMPORTED_MODULE_8__.ACESFilmicToneMapping;
        }
        catch (error) {
            console.warn(error);
        }
        this.arRenderer = new _ARRenderer_js__WEBPACK_IMPORTED_MODULE_3__.ARRenderer(this);
        this.textureUtils =
            this.canRender ? new _TextureUtils_js__WEBPACK_IMPORTED_MODULE_7__["default"](this.threeRenderer) : null;
        _CachingGLTFLoader_js__WEBPACK_IMPORTED_MODULE_4__.CachingGLTFLoader.initializeKTX2Loader(this.threeRenderer);
        this.canvas3D.addEventListener('webglcontextlost', this.onWebGLContextLost);
        this.canvas3D.addEventListener('webglcontextrestored', this.onWebGLContextRestored);
        this.updateRendererSize();
    }
    static get singleton() {
        return this._singleton;
    }
    static resetSingleton() {
        const elements = this._singleton.dispose();
        for (const element of elements) {
            element.disconnectedCallback();
        }
        this._singleton = new Renderer({
            powerPreference: (self.ModelViewerElement || {})
                .powerPreference ||
                DEFAULT_POWER_PREFERENCE,
            debug: (0,_utilities_js__WEBPACK_IMPORTED_MODULE_2__.isDebugMode)()
        });
        for (const element of elements) {
            element.connectedCallback();
        }
    }
    get canRender() {
        return this.threeRenderer != null;
    }
    get scaleFactor() {
        return SCALE_STEPS[this.scaleStep];
    }
    set minScale(scale) {
        let i = 1;
        while (i < SCALE_STEPS.length) {
            if (SCALE_STEPS[i] < scale) {
                break;
            }
            ++i;
        }
        this.lastStep = i - 1;
    }
    registerScene(scene) {
        this.scenes.add(scene);
        scene.forceRescale();
        const size = new three__WEBPACK_IMPORTED_MODULE_8__.Vector2();
        this.threeRenderer.getSize(size);
        scene.canvas.width = size.x;
        scene.canvas.height = size.y;
        if (this.canRender && this.scenes.size > 0) {
            this.threeRenderer.setAnimationLoop((time, frame) => this.render(time, frame));
        }
        if (this.debugger != null) {
            this.debugger.addScene(scene);
        }
    }
    unregisterScene(scene) {
        this.scenes.delete(scene);
        if (this.canvas3D.parentElement === scene.canvas.parentElement) {
            scene.canvas.parentElement.removeChild(this.canvas3D);
        }
        if (this.canRender && this.scenes.size === 0) {
            this.threeRenderer.setAnimationLoop(null);
        }
        if (this.debugger != null) {
            this.debugger.removeScene(scene);
        }
    }
    displayCanvas(scene) {
        return this.multipleScenesVisible ? scene.element[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$canvas] : this.canvas3D;
    }
    /**
     * The function enables an optimization, where when there is only a single
     * <model-viewer> element, we can use the renderer's 3D canvas directly for
     * display. Otherwise we need to use the element's 2D canvas and copy the
     * renderer's result into it.
     */
    countVisibleScenes() {
        const { canvas3D } = this;
        let visibleScenes = 0;
        let canvas3DScene = null;
        for (const scene of this.scenes) {
            const { element } = scene;
            if (element.modelIsVisible && scene.externalRenderer == null) {
                ++visibleScenes;
            }
            if (canvas3D.parentElement === scene.canvas.parentElement) {
                canvas3DScene = scene;
            }
        }
        const multipleScenesVisible = visibleScenes > 1;
        if (canvas3DScene != null) {
            const newlyMultiple = multipleScenesVisible && !this.multipleScenesVisible;
            const disappearing = !canvas3DScene.element.modelIsVisible;
            if (newlyMultiple || disappearing) {
                const { width, height } = this.sceneSize(canvas3DScene);
                this.copyPixels(canvas3DScene, width, height);
                canvas3D.parentElement.removeChild(canvas3D);
            }
        }
        this.multipleScenesVisible = multipleScenesVisible;
    }
    /**
     * Updates the renderer's size based on the largest scene and any changes to
     * device pixel ratio.
     */
    updateRendererSize() {
        const dpr = (0,_utilities_js__WEBPACK_IMPORTED_MODULE_2__.resolveDpr)();
        if (dpr !== this.dpr) {
            // If the device pixel ratio has changed due to page zoom, elements
            // specified by % width do not fire a resize event even though their CSS
            // pixel dimensions change, so we force them to update their size here.
            for (const scene of this.scenes) {
                const { element } = scene;
                element[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$updateSize](element.getBoundingClientRect());
            }
        }
        // Make the renderer the size of the largest scene
        let width = 0;
        let height = 0;
        for (const scene of this.scenes) {
            width = Math.max(width, scene.width);
            height = Math.max(height, scene.height);
        }
        if (width === this.width && height === this.height && dpr === this.dpr) {
            return;
        }
        this.width = width;
        this.height = height;
        this.dpr = dpr;
        width = Math.ceil(width * dpr);
        height = Math.ceil(height * dpr);
        if (this.canRender) {
            this.threeRenderer.setSize(width, height, false);
        }
        // Each scene's canvas must match the renderer size. In general they can be
        // larger than the element that contains them, but the overflow is hidden
        // and only the portion that is shown is copied over.
        for (const scene of this.scenes) {
            const { canvas } = scene;
            canvas.width = width;
            canvas.height = height;
            scene.forceRescale();
        }
    }
    updateRendererScale(delta) {
        const scaleStep = this.scaleStep;
        this.avgFrameDuration += (0,_utilities_js__WEBPACK_IMPORTED_MODULE_2__.clamp)(DURATION_DECAY * (delta - this.avgFrameDuration), -MAX_AVG_CHANGE_MS, MAX_AVG_CHANGE_MS);
        if (this.avgFrameDuration > HIGH_FRAME_DURATION_MS) {
            ++this.scaleStep;
        }
        else if (this.avgFrameDuration < LOW_FRAME_DURATION_MS && this.scaleStep > 0) {
            --this.scaleStep;
        }
        this.scaleStep = Math.min(this.scaleStep, this.lastStep);
        if (scaleStep !== this.scaleStep) {
            this.avgFrameDuration =
                (HIGH_FRAME_DURATION_MS + LOW_FRAME_DURATION_MS) / 2;
        }
    }
    shouldRender(scene) {
        if (!scene.shouldRender()) {
            // The first frame we stop rendering the scene (because it stops moving),
            // trigger one extra render at full scale.
            if (scene.scaleStep != 0) {
                scene.scaleStep = 0;
                this.rescaleCanvas(scene);
            }
            else {
                return false;
            }
        }
        else if (scene.scaleStep != this.scaleStep) {
            // Update render scale
            scene.scaleStep = this.scaleStep;
            this.rescaleCanvas(scene);
        }
        return true;
    }
    rescaleCanvas(scene) {
        const scale = SCALE_STEPS[scene.scaleStep];
        const width = Math.ceil(this.width / scale);
        const height = Math.ceil(this.height / scale);
        const { style } = scene.canvas;
        style.width = `${width}px`;
        style.height = `${height}px`;
        this.canvas3D.style.width = `${width}px`;
        this.canvas3D.style.height = `${height}px`;
        const renderedDpr = this.dpr * scale;
        const reason = scale < 1 ? 'GPU throttling' :
            this.dpr !== window.devicePixelRatio ? 'No meta viewport tag' :
                '';
        scene.element.dispatchEvent(new CustomEvent('render-scale', {
            detail: {
                reportedDpr: window.devicePixelRatio,
                renderedDpr: renderedDpr,
                minimumDpr: this.dpr * SCALE_STEPS[this.lastStep],
                pixelWidth: Math.ceil(scene.width * renderedDpr),
                pixelHeight: Math.ceil(scene.height * renderedDpr),
                reason: reason
            }
        }));
    }
    sceneSize(scene) {
        const { dpr } = this;
        const scaleFactor = SCALE_STEPS[scene.scaleStep];
        // We avoid using the Three.js PixelRatio and handle it ourselves here so
        // that we can do proper rounding and avoid white boundary pixels.
        const width = Math.min(Math.ceil(scene.width * scaleFactor * dpr), this.canvas3D.width);
        const height = Math.min(Math.ceil(scene.height * scaleFactor * dpr), this.canvas3D.height);
        return { width, height };
    }
    copyPixels(scene, width, height) {
        const context2D = scene.context;
        if (context2D == null) {
            console.log('could not acquire 2d context');
            return;
        }
        context2D.clearRect(0, 0, width, height);
        context2D.drawImage(this.canvas3D, 0, 0, width, height, 0, 0, width, height);
        scene.canvas.classList.add('show');
    }
    /**
     * Returns an array version of this.scenes where the non-visible ones are
     * first. This allows eager scenes to be rendered before they are visible,
     * without needing the multi-canvas render path.
     */
    orderedScenes() {
        const scenes = [];
        for (const visible of [false, true]) {
            for (const scene of this.scenes) {
                if (scene.element.modelIsVisible === visible) {
                    scenes.push(scene);
                }
            }
        }
        return scenes;
    }
    get isPresenting() {
        return this.arRenderer.isPresenting;
    }
    /**
     * This method takes care of updating the element and renderer state based on
     * the time that has passed since the last rendered frame.
     */
    preRender(scene, t, delta) {
        const { element, exposure } = scene;
        element[_model_viewer_base_js__WEBPACK_IMPORTED_MODULE_1__.$tick](t, delta);
        const exposureIsNumber = typeof exposure === 'number' && !Number.isNaN(exposure);
        this.threeRenderer.toneMappingExposure = exposureIsNumber ? exposure : 1.0;
    }
    render(t, frame) {
        if (frame != null) {
            this.arRenderer.onWebXRFrame(t, frame);
            return;
        }
        const delta = t - this.lastTick;
        this.lastTick = t;
        if (!this.canRender || this.isPresenting) {
            return;
        }
        this.countVisibleScenes();
        this.updateRendererSize();
        if (this.renderedLastFrame) {
            this.updateRendererScale(delta);
            this.renderedLastFrame = false;
        }
        const { canvas3D } = this;
        for (const scene of this.orderedScenes()) {
            const { element } = scene;
            if (!element.loaded ||
                (!element.modelIsVisible && scene.renderCount > 0)) {
                continue;
            }
            this.preRender(scene, t, delta);
            if (!this.shouldRender(scene)) {
                continue;
            }
            if (scene.externalRenderer != null) {
                const camera = scene.getCamera();
                camera.updateMatrix();
                const { matrix, projectionMatrix } = camera;
                const viewMatrix = matrix.elements.slice();
                const target = scene.getTarget();
                viewMatrix[12] += target.x;
                viewMatrix[13] += target.y;
                viewMatrix[14] += target.z;
                scene.externalRenderer.render({
                    viewMatrix: viewMatrix,
                    projectionMatrix: projectionMatrix.elements
                });
                continue;
            }
            if (!element.modelIsVisible && !this.multipleScenesVisible) {
                // Here we are pre-rendering on the visible canvas, so we must mark the
                // visible scene dirty to ensure it overwrites us.
                for (const visibleScene of this.scenes) {
                    if (visibleScene.element.modelIsVisible) {
                        visibleScene.queueRender();
                    }
                }
            }
            const { width, height } = this.sceneSize(scene);
            scene.renderShadow(this.threeRenderer);
            // Need to set the render target in order to prevent
            // clearing the depth from a different buffer
            this.threeRenderer.setRenderTarget(null);
            this.threeRenderer.setViewport(0, Math.ceil(this.height * this.dpr) - height, width, height);
            this.threeRenderer.render(scene, scene.camera);
            if (this.multipleScenesVisible ||
                (!scene.element.modelIsVisible && scene.renderCount === 0)) {
                this.copyPixels(scene, width, height);
            }
            else if (canvas3D.parentElement !== scene.canvas.parentElement) {
                scene.canvas.parentElement.appendChild(canvas3D);
                scene.canvas.classList.remove('show');
            }
            scene.hasRendered();
            ++scene.renderCount;
            this.renderedLastFrame = true;
        }
    }
    dispose() {
        if (this.textureUtils != null) {
            this.textureUtils.dispose();
        }
        if (this.threeRenderer != null) {
            this.threeRenderer.dispose();
        }
        this.textureUtils = null;
        this.threeRenderer = null;
        const elements = [];
        for (const scene of this.scenes) {
            elements.push(scene.element);
        }
        this.canvas3D.removeEventListener('webglcontextlost', this.onWebGLContextLost);
        this.canvas3D.removeEventListener('webglcontextrestored', this.onWebGLContextRestored);
        return elements;
    }
}
Renderer._singleton = new Renderer({
    powerPreference: (self.ModelViewerElement || {})
        .powerPreference ||
        DEFAULT_POWER_PREFERENCE,
    debug: (0,_utilities_js__WEBPACK_IMPORTED_MODULE_2__.isDebugMode)()
});
//# sourceMappingURL=Renderer.js.map

/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/three-components/Shadow.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/three-components/Shadow.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Shadow": () => (/* binding */ Shadow)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../../node_modules/three/build/three.module.js");
/* harmony import */ var three_examples_jsm_shaders_HorizontalBlurShader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three/examples/jsm/shaders/HorizontalBlurShader.js */ "../../node_modules/three/examples/jsm/shaders/HorizontalBlurShader.js");
/* harmony import */ var three_examples_jsm_shaders_VerticalBlurShader_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three/examples/jsm/shaders/VerticalBlurShader.js */ "../../node_modules/three/examples/jsm/shaders/VerticalBlurShader.js");
/* harmony import */ var three_src_math_MathUtils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three/src/math/MathUtils.js */ "../../node_modules/three/src/math/MathUtils.js");
/* @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




// The softness [0, 1] of the shadow is mapped to a resolution between
// 2^LOG_MAX_RESOLUTION and 2^LOG_MIN_RESOLUTION.
const LOG_MAX_RESOLUTION = 9;
const LOG_MIN_RESOLUTION = 6;
// Animated models are not in general contained in their bounding box, as this
// is calculated only for their resting pose. We create a cubic shadow volume
// for animated models sized to their largest bounding box dimension multiplied
// by this scale factor.
const ANIMATION_SCALING = 2;
// Since hard shadows are not lightened by blurring and depth, set a lower
// default intensity to make them more perceptually similar to the intensity of
// the soft shadows.
const DEFAULT_HARD_INTENSITY = 0.3;
/**
 * The Shadow class creates a shadow that fits a given scene and follows a
 * target. This shadow will follow the scene without any updates needed so long
 * as the shadow and scene are both parented to the same object (call it the
 * scene) and this scene is passed as the target parameter to the shadow's
 * constructor. We also must constrain the scene to motion within the horizontal
 * plane and call the setRotation() method whenever the scene's Y-axis rotation
 * changes. For motion outside of the horizontal plane, this.needsUpdate must be
 * set to true.
 *
 * The softness of the shadow is controlled by changing its resolution, making
 * softer shadows faster, but less precise.
 */
class Shadow extends three__WEBPACK_IMPORTED_MODULE_0__.Object3D {
    constructor(scene, softness, side) {
        super();
        this.camera = new three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera();
        // private cameraHelper = new CameraHelper(this.camera);
        this.renderTarget = null;
        this.renderTargetBlur = null;
        this.depthMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshDepthMaterial();
        this.horizontalBlurMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial(three_examples_jsm_shaders_HorizontalBlurShader_js__WEBPACK_IMPORTED_MODULE_1__.HorizontalBlurShader);
        this.verticalBlurMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial(three_examples_jsm_shaders_VerticalBlurShader_js__WEBPACK_IMPORTED_MODULE_2__.VerticalBlurShader);
        this.intensity = 0;
        this.softness = 1;
        this.boundingBox = new three__WEBPACK_IMPORTED_MODULE_0__.Box3;
        this.size = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3;
        this.maxDimension = 0;
        this.isAnimated = false;
        this.needsUpdate = false;
        const { camera } = this;
        camera.rotation.x = Math.PI / 2;
        camera.left = -0.5;
        camera.right = 0.5;
        camera.bottom = -0.5;
        camera.top = 0.5;
        this.add(camera);
        // this.add(this.cameraHelper);
        // this.cameraHelper.updateMatrixWorld = function() {
        //   this.matrixWorld = this.camera.matrixWorld;
        // };
        const plane = new three__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry();
        const shadowMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({
            // color: new Color(1, 0, 0),
            opacity: 1,
            transparent: true,
            side: three__WEBPACK_IMPORTED_MODULE_0__.BackSide,
        });
        this.floor = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(plane, shadowMaterial);
        this.floor.userData.shadow = true;
        camera.add(this.floor);
        // the plane onto which to blur the texture
        this.blurPlane = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(plane);
        this.blurPlane.visible = false;
        camera.add(this.blurPlane);
        scene.target.add(this);
        // like MeshDepthMaterial, but goes from black to transparent
        this.depthMaterial.onBeforeCompile = function (shader) {
            shader.fragmentShader = shader.fragmentShader.replace('gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );', 'gl_FragColor = vec4( vec3( 0.0 ), ( 1.0 - fragCoordZ ) * opacity );');
        };
        this.horizontalBlurMaterial.depthTest = false;
        this.verticalBlurMaterial.depthTest = false;
        this.setScene(scene, softness, side);
    }
    /**
     * Update the shadow's size and position for a new scene. Softness is also
     * needed, as this controls the shadow's resolution.
     */
    setScene(scene, softness, side) {
        const { boundingBox, size, rotation, position } = this;
        this.isAnimated = scene.animationNames.length > 0;
        this.boundingBox.copy(scene.boundingBox);
        this.size.copy(scene.size);
        this.maxDimension = Math.max(size.x, size.y, size.z) *
            (this.isAnimated ? ANIMATION_SCALING : 1);
        this.boundingBox.getCenter(position);
        if (side === 'back') {
            const { min, max } = boundingBox;
            [min.y, min.z] = [min.z, min.y];
            [max.y, max.z] = [max.z, max.y];
            [size.y, size.z] = [size.z, size.y];
            rotation.x = Math.PI / 2;
            rotation.y = Math.PI;
        }
        else {
            rotation.x = 0;
            rotation.y = 0;
        }
        if (this.isAnimated) {
            const minY = boundingBox.min.y;
            const maxY = boundingBox.max.y;
            size.y = this.maxDimension;
            boundingBox.expandByVector(size.subScalar(this.maxDimension).multiplyScalar(-0.5));
            boundingBox.min.y = minY;
            boundingBox.max.y = maxY;
            size.set(this.maxDimension, maxY - minY, this.maxDimension);
        }
        if (side === 'bottom') {
            position.y = boundingBox.min.y;
        }
        else {
            position.z = boundingBox.min.y;
        }
        this.setSoftness(softness);
    }
    /**
     * Update the shadow's resolution based on softness (between 0 and 1). Should
     * not be called frequently, as this results in reallocation.
     */
    setSoftness(softness) {
        this.softness = softness;
        const { size, camera } = this;
        const scaleY = (this.isAnimated ? ANIMATION_SCALING : 1);
        const resolution = scaleY *
            Math.pow(2, LOG_MAX_RESOLUTION -
                softness * (LOG_MAX_RESOLUTION - LOG_MIN_RESOLUTION));
        this.setMapSize(resolution);
        const softFar = size.y / 2;
        const hardFar = size.y * scaleY;
        camera.near = 0;
        camera.far = (0,three_src_math_MathUtils_js__WEBPACK_IMPORTED_MODULE_3__.lerp)(hardFar, softFar, softness);
        // we have co-opted opacity to scale the depth to clip
        this.depthMaterial.opacity = 1.0 / softness;
        camera.updateProjectionMatrix();
        // this.cameraHelper.update();
        this.setIntensity(this.intensity);
        this.setOffset(0);
    }
    /**
     * Lower-level version of the above function.
     */
    setMapSize(maxMapSize) {
        const { size } = this;
        if (this.isAnimated) {
            maxMapSize *= ANIMATION_SCALING;
        }
        const baseWidth = Math.floor(size.x > size.z ? maxMapSize : maxMapSize * size.x / size.z);
        const baseHeight = Math.floor(size.x > size.z ? maxMapSize * size.z / size.x : maxMapSize);
        // width of blur filter in pixels (not adjustable)
        const TAP_WIDTH = 10;
        const width = TAP_WIDTH + baseWidth;
        const height = TAP_WIDTH + baseHeight;
        if (this.renderTarget != null &&
            (this.renderTarget.width !== width ||
                this.renderTarget.height !== height)) {
            this.renderTarget.dispose();
            this.renderTarget = null;
            this.renderTargetBlur.dispose();
            this.renderTargetBlur = null;
        }
        if (this.renderTarget == null) {
            const params = { format: three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat };
            this.renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(width, height, params);
            this.renderTargetBlur = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(width, height, params);
            this.floor.material.map =
                this.renderTarget.texture;
        }
        // These pads account for the softening radius around the shadow.
        this.camera.scale.set(size.x * (1 + TAP_WIDTH / baseWidth), size.z * (1 + TAP_WIDTH / baseHeight), 1);
        this.needsUpdate = true;
    }
    /**
     * Set the shadow's intensity (0 to 1), which is just its opacity. Turns off
     * shadow rendering if zero.
     */
    setIntensity(intensity) {
        this.intensity = intensity;
        if (intensity > 0) {
            this.visible = true;
            this.floor.visible = true;
            this.floor.material.opacity = intensity *
                (0,three_src_math_MathUtils_js__WEBPACK_IMPORTED_MODULE_3__.lerp)(DEFAULT_HARD_INTENSITY, 1, this.softness * this.softness);
        }
        else {
            this.visible = false;
            this.floor.visible = false;
        }
    }
    getIntensity() {
        return this.intensity;
    }
    /**
     * An offset can be specified to move the
     * shadow vertically relative to the bottom of the scene. Positive is up, so
     * values are generally negative. A small offset keeps our shadow from
     * z-fighting with any baked-in shadow plane.
     */
    setOffset(offset) {
        this.floor.position.z = -offset + 0.001 * this.maxDimension;
    }
    render(renderer, scene) {
        // this.cameraHelper.visible = false;
        // force the depthMaterial to everything
        scene.overrideMaterial = this.depthMaterial;
        // set renderer clear alpha
        const initialClearAlpha = renderer.getClearAlpha();
        renderer.setClearAlpha(0);
        this.floor.visible = false;
        // disable XR for offscreen rendering
        const xrEnabled = renderer.xr.enabled;
        renderer.xr.enabled = false;
        // render to the render target to get the depths
        const oldRenderTarget = renderer.getRenderTarget();
        renderer.setRenderTarget(this.renderTarget);
        renderer.render(scene, this.camera);
        // and reset the override material
        scene.overrideMaterial = null;
        this.floor.visible = true;
        this.blurShadow(renderer);
        // reset and render the normal scene
        renderer.xr.enabled = xrEnabled;
        renderer.setRenderTarget(oldRenderTarget);
        renderer.setClearAlpha(initialClearAlpha);
        // this.cameraHelper.visible = true;
    }
    blurShadow(renderer) {
        const { camera, horizontalBlurMaterial, verticalBlurMaterial, renderTarget, renderTargetBlur, blurPlane } = this;
        blurPlane.visible = true;
        // blur horizontally and draw in the renderTargetBlur
        blurPlane.material = horizontalBlurMaterial;
        horizontalBlurMaterial.uniforms.h.value = 1 / this.renderTarget.width;
        horizontalBlurMaterial.uniforms.tDiffuse.value = this.renderTarget.texture;
        renderer.setRenderTarget(renderTargetBlur);
        renderer.render(blurPlane, camera);
        // blur vertically and draw in the main renderTarget
        blurPlane.material = verticalBlurMaterial;
        verticalBlurMaterial.uniforms.v.value = 1 / this.renderTarget.height;
        verticalBlurMaterial.uniforms.tDiffuse.value =
            this.renderTargetBlur.texture;
        renderer.setRenderTarget(renderTarget);
        renderer.render(blurPlane, camera);
        blurPlane.visible = false;
    }
    dispose() {
        if (this.renderTarget != null) {
            this.renderTarget.dispose();
        }
        if (this.renderTargetBlur != null) {
            this.renderTargetBlur.dispose();
        }
        this.depthMaterial.dispose();
        this.horizontalBlurMaterial.dispose();
        this.verticalBlurMaterial.dispose();
        this.floor.material.dispose();
        this.floor.geometry.dispose();
        this.blurPlane.geometry.dispose();
        this.removeFromParent();
    }
}
//# sourceMappingURL=Shadow.js.map

/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/three-components/SmoothControls.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/three-components/SmoothControls.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ChangeSource": () => (/* binding */ ChangeSource),
/* harmony export */   "DEFAULT_OPTIONS": () => (/* binding */ DEFAULT_OPTIONS),
/* harmony export */   "KeyCode": () => (/* binding */ KeyCode),
/* harmony export */   "SmoothControls": () => (/* binding */ SmoothControls)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ "../../node_modules/three/build/three.module.js");
/* harmony import */ var _features_controls_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../features/controls.js */ "../../node_modules/@google/model-viewer/lib/features/controls.js");
/* harmony import */ var _utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utilities.js */ "../../node_modules/@google/model-viewer/lib/utilities.js");
/* harmony import */ var _Damper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Damper.js */ "../../node_modules/@google/model-viewer/lib/three-components/Damper.js");
/* @license
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




const PAN_SENSITIVITY = 0.018;
const TAP_DISTANCE = 2;
const TAP_MS = 300;
const vector2 = new three__WEBPACK_IMPORTED_MODULE_3__.Vector2();
const vector3 = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3();
const DEFAULT_OPTIONS = Object.freeze({
    minimumRadius: 0,
    maximumRadius: Infinity,
    minimumPolarAngle: Math.PI / 8,
    maximumPolarAngle: Math.PI - Math.PI / 8,
    minimumAzimuthalAngle: -Infinity,
    maximumAzimuthalAngle: Infinity,
    minimumFieldOfView: 10,
    maximumFieldOfView: 45,
    touchAction: 'none'
});
// Constants
const KEYBOARD_ORBIT_INCREMENT = Math.PI / 8;
const ZOOM_SENSITIVITY = 0.04;
// The move size on pan key event
const PAN_KEY_INCREMENT = 10;
const KeyCode = {
    PAGE_UP: 33,
    PAGE_DOWN: 34,
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40
};
const ChangeSource = {
    USER_INTERACTION: 'user-interaction',
    NONE: 'none',
    AUTOMATIC: 'automatic'
};
/**
 * SmoothControls is a Three.js helper for adding delightful pointer and
 * keyboard-based input to a staged Three.js scene. Its API is very similar to
 * OrbitControls, but it offers more opinionated (subjectively more delightful)
 * defaults, easy extensibility and subjectively better out-of-the-box keyboard
 * support.
 *
 * One important change compared to OrbitControls is that the `update` method
 * of SmoothControls must be invoked on every frame, otherwise the controls
 * will not have an effect.
 *
 * Another notable difference compared to OrbitControls is that SmoothControls
 * does not currently support panning (but probably will in a future revision).
 *
 * Like OrbitControls, SmoothControls assumes that the orientation of the camera
 * has been set in terms of position, rotation and scale, so it is important to
 * ensure that the camera's matrixWorld is in sync before using SmoothControls.
 */
class SmoothControls extends three__WEBPACK_IMPORTED_MODULE_3__.EventDispatcher {
    constructor(camera, element, scene) {
        super();
        this.camera = camera;
        this.element = element;
        this.scene = scene;
        this.orbitSensitivity = 1;
        this.inputSensitivity = 1;
        this.changeSource = ChangeSource.NONE;
        this._interactionEnabled = false;
        this._disableZoom = false;
        this.isUserPointing = false;
        // Pan state
        this.enablePan = true;
        this.enableTap = true;
        this.panProjection = new three__WEBPACK_IMPORTED_MODULE_3__.Matrix3();
        this.panPerPixel = 0;
        // Internal orbital position state
        this.spherical = new three__WEBPACK_IMPORTED_MODULE_3__.Spherical();
        this.goalSpherical = new three__WEBPACK_IMPORTED_MODULE_3__.Spherical();
        this.thetaDamper = new _Damper_js__WEBPACK_IMPORTED_MODULE_2__.Damper();
        this.phiDamper = new _Damper_js__WEBPACK_IMPORTED_MODULE_2__.Damper();
        this.radiusDamper = new _Damper_js__WEBPACK_IMPORTED_MODULE_2__.Damper();
        this.logFov = Math.log(DEFAULT_OPTIONS.maximumFieldOfView);
        this.goalLogFov = this.logFov;
        this.fovDamper = new _Damper_js__WEBPACK_IMPORTED_MODULE_2__.Damper();
        // Pointer state
        this.touchMode = null;
        this.pointers = [];
        this.startTime = 0;
        this.startPointerPosition = { clientX: 0, clientY: 0 };
        this.lastSeparation = 0;
        this.touchDecided = false;
        this.onContext = (event) => {
            if (this.enablePan) {
                event.preventDefault();
            }
            else {
                for (const pointer of this.pointers) {
                    // Required because of a common browser bug where the context menu never
                    // fires a pointercancel event.
                    this.onPointerUp(new PointerEvent('pointercancel', Object.assign(Object.assign({}, this.startPointerPosition), { pointerId: pointer.id })));
                }
            }
        };
        this.touchModeZoom = (dx, dy) => {
            if (!this._disableZoom) {
                const touchDistance = this.twoTouchDistance(this.pointers[0], this.pointers[1]);
                const deltaZoom = ZOOM_SENSITIVITY *
                    (this.lastSeparation - touchDistance) * 50 / this.scene.height;
                this.lastSeparation = touchDistance;
                this.userAdjustOrbit(0, 0, deltaZoom);
            }
            if (this.panPerPixel > 0) {
                this.movePan(dx, dy);
            }
        };
        // We implement our own version of the browser's CSS touch-action, enforced by
        // this function, because the iOS implementation of pan-y is bad and doesn't
        // match Android. Specifically, even if a touch gesture begins by panning X,
        // iOS will switch to scrolling as soon as the gesture moves in the Y, rather
        // than staying in the same mode until the end of the gesture.
        this.disableScroll = (event) => {
            event.preventDefault();
        };
        this.touchModeRotate = (dx, dy) => {
            const { touchAction } = this._options;
            if (!this.touchDecided && touchAction !== 'none') {
                this.touchDecided = true;
                const dxMag = Math.abs(dx);
                const dyMag = Math.abs(dy);
                // If motion is mostly vertical, assume scrolling is the intent.
                if (this.changeSource === ChangeSource.USER_INTERACTION &&
                    ((touchAction === 'pan-y' && dyMag > dxMag) ||
                        (touchAction === 'pan-x' && dxMag > dyMag))) {
                    this.touchMode = null;
                    return;
                }
                else {
                    this.element.addEventListener('touchmove', this.disableScroll, { passive: false });
                }
            }
            this.handleSinglePointerMove(dx, dy);
        };
        this.onPointerDown = (event) => {
            if (this.pointers.length > 2) {
                return;
            }
            const { element } = this;
            if (this.pointers.length === 0) {
                element.addEventListener('pointermove', this.onPointerMove);
                element.addEventListener('pointerup', this.onPointerUp);
                this.touchMode = null;
                this.touchDecided = false;
                this.startPointerPosition.clientX = event.clientX;
                this.startPointerPosition.clientY = event.clientY;
                this.startTime = performance.now();
            }
            try {
                element.setPointerCapture(event.pointerId);
            }
            catch (_a) {
            }
            this.pointers.push({ clientX: event.clientX, clientY: event.clientY, id: event.pointerId });
            this.isUserPointing = false;
            if (event.pointerType === 'touch') {
                this.changeSource = event.altKey ? // set by interact() in controls.ts
                    ChangeSource.AUTOMATIC :
                    ChangeSource.USER_INTERACTION;
                this.onTouchChange(event);
            }
            else {
                this.changeSource = ChangeSource.USER_INTERACTION;
                this.onMouseDown(event);
            }
            if (this.changeSource === ChangeSource.USER_INTERACTION) {
                this.dispatchEvent({ type: 'user-interaction' });
            }
        };
        this.onPointerMove = (event) => {
            const pointer = this.pointers.find((pointer) => pointer.id === event.pointerId);
            if (pointer == null) {
                return;
            }
            // In case no one gave us a pointerup or pointercancel event.
            if (event.pointerType === 'mouse' && event.buttons === 0) {
                this.onPointerUp(event);
                return;
            }
            const numTouches = this.pointers.length;
            const dx = (event.clientX - pointer.clientX) / numTouches;
            const dy = (event.clientY - pointer.clientY) / numTouches;
            if (dx === 0 && dy === 0) {
                return;
            }
            pointer.clientX = event.clientX;
            pointer.clientY = event.clientY;
            if (event.pointerType === 'touch') {
                this.changeSource = event.altKey ? // set by interact() in controls.ts
                    ChangeSource.AUTOMATIC :
                    ChangeSource.USER_INTERACTION;
                if (this.touchMode !== null) {
                    this.touchMode(dx, dy);
                }
            }
            else {
                this.changeSource = ChangeSource.USER_INTERACTION;
                if (this.panPerPixel > 0) {
                    this.movePan(dx, dy);
                }
                else {
                    this.handleSinglePointerMove(dx, dy);
                }
            }
        };
        this.onPointerUp = (event) => {
            const { element } = this;
            const index = this.pointers.findIndex((pointer) => pointer.id === event.pointerId);
            if (index !== -1) {
                this.pointers.splice(index, 1);
            }
            // altKey indicates an interaction prompt; don't reset radius in this case
            // as it will cause the camera to drift.
            if (this.panPerPixel > 0 && !event.altKey) {
                this.resetRadius();
            }
            if (this.pointers.length === 0) {
                element.removeEventListener('pointermove', this.onPointerMove);
                element.removeEventListener('pointerup', this.onPointerUp);
                element.removeEventListener('touchmove', this.disableScroll);
                if (this.enablePan && this.enableTap) {
                    this.recenter(event);
                }
            }
            else if (this.touchMode !== null) {
                this.onTouchChange(event);
            }
            this.scene.element[_features_controls_js__WEBPACK_IMPORTED_MODULE_0__.$panElement].style.opacity = 0;
            element.style.cursor = 'grab';
            this.panPerPixel = 0;
            if (this.isUserPointing) {
                this.dispatchEvent({ type: 'pointer-change-end' });
            }
        };
        this.onWheel = (event) => {
            this.changeSource = ChangeSource.USER_INTERACTION;
            const deltaZoom = event.deltaY *
                (event.deltaMode == 1 ? 18 : 1) * ZOOM_SENSITIVITY / 30;
            this.userAdjustOrbit(0, 0, deltaZoom);
            event.preventDefault();
            this.dispatchEvent({ type: 'user-interaction' });
        };
        this.onKeyDown = (event) => {
            // We track if the key is actually one we respond to, so as not to
            // accidentally clobber unrelated key inputs when the <model-viewer> has
            // focus.
            const { changeSource } = this;
            this.changeSource = ChangeSource.USER_INTERACTION;
            const relevantKey = (event.shiftKey && this.enablePan) ?
                this.panKeyCodeHandler(event) :
                this.orbitZoomKeyCodeHandler(event);
            if (relevantKey) {
                event.preventDefault();
                this.dispatchEvent({ type: 'user-interaction' });
            }
            else {
                this.changeSource = changeSource;
            }
        };
        this._options = Object.assign({}, DEFAULT_OPTIONS);
        this.setOrbit(0, Math.PI / 2, 1);
        this.setFieldOfView(100);
        this.jumpToGoal();
    }
    get interactionEnabled() {
        return this._interactionEnabled;
    }
    enableInteraction() {
        if (this._interactionEnabled === false) {
            const { element } = this;
            element.addEventListener('pointerdown', this.onPointerDown);
            element.addEventListener('pointercancel', this.onPointerUp);
            if (!this._disableZoom) {
                element.addEventListener('wheel', this.onWheel);
            }
            element.addEventListener('keydown', this.onKeyDown);
            // This little beauty is to work around a WebKit bug that otherwise makes
            // touch events randomly not cancelable.
            element.addEventListener('touchmove', () => { }, { passive: false });
            element.addEventListener('contextmenu', this.onContext);
            this.element.style.cursor = 'grab';
            this._interactionEnabled = true;
            this.updateTouchActionStyle();
        }
    }
    disableInteraction() {
        if (this._interactionEnabled === true) {
            const { element } = this;
            element.removeEventListener('pointerdown', this.onPointerDown);
            element.removeEventListener('pointermove', this.onPointerMove);
            element.removeEventListener('pointerup', this.onPointerUp);
            element.removeEventListener('pointercancel', this.onPointerUp);
            element.removeEventListener('wheel', this.onWheel);
            element.removeEventListener('keydown', this.onKeyDown);
            element.removeEventListener('contextmenu', this.onContext);
            element.style.cursor = '';
            this.touchMode = null;
            this._interactionEnabled = false;
            this.updateTouchActionStyle();
        }
    }
    /**
     * The options that are currently configured for the controls instance.
     */
    get options() {
        return this._options;
    }
    set disableZoom(disable) {
        if (this._disableZoom != disable) {
            this._disableZoom = disable;
            if (disable === true) {
                this.element.removeEventListener('wheel', this.onWheel);
            }
            else {
                this.element.addEventListener('wheel', this.onWheel);
            }
            this.updateTouchActionStyle();
        }
    }
    /**
     * Copy the spherical values that represent the current camera orbital
     * position relative to the configured target into a provided Spherical
     * instance. If no Spherical is provided, a new Spherical will be allocated
     * to copy the values into. The Spherical that values are copied into is
     * returned.
     */
    getCameraSpherical(target = new three__WEBPACK_IMPORTED_MODULE_3__.Spherical()) {
        return target.copy(this.spherical);
    }
    /**
     * Returns the camera's current vertical field of view in degrees.
     */
    getFieldOfView() {
        return this.camera.fov;
    }
    /**
     * Configure the _options of the controls. Configured _options will be
     * merged with whatever _options have already been configured for this
     * controls instance.
     */
    applyOptions(_options) {
        Object.assign(this._options, _options);
        // Re-evaluates clamping based on potentially new values for min/max
        // polar, azimuth and radius:
        this.setOrbit();
        this.setFieldOfView(Math.exp(this.goalLogFov));
    }
    /**
     * Sets the near and far planes of the camera.
     */
    updateNearFar(nearPlane, farPlane) {
        this.camera.far = farPlane === 0 ? 2 : farPlane;
        this.camera.near = Math.max(nearPlane, this.camera.far / 1000);
        this.camera.updateProjectionMatrix();
    }
    /**
     * Sets the aspect ratio of the camera
     */
    updateAspect(aspect) {
        this.camera.aspect = aspect;
        this.camera.updateProjectionMatrix();
    }
    /**
     * Set the absolute orbital goal of the camera. The change will be
     * applied over a number of frames depending on configured acceleration and
     * dampening _options.
     *
     * Returns true if invoking the method will result in the camera changing
     * position and/or rotation, otherwise false.
     */
    setOrbit(goalTheta = this.goalSpherical.theta, goalPhi = this.goalSpherical.phi, goalRadius = this.goalSpherical.radius) {
        const { minimumAzimuthalAngle, maximumAzimuthalAngle, minimumPolarAngle, maximumPolarAngle, minimumRadius, maximumRadius } = this._options;
        const { theta, phi, radius } = this.goalSpherical;
        const nextTheta = (0,_utilities_js__WEBPACK_IMPORTED_MODULE_1__.clamp)(goalTheta, minimumAzimuthalAngle, maximumAzimuthalAngle);
        if (!isFinite(minimumAzimuthalAngle) &&
            !isFinite(maximumAzimuthalAngle)) {
            this.spherical.theta =
                this.wrapAngle(this.spherical.theta - nextTheta) + nextTheta;
        }
        const nextPhi = (0,_utilities_js__WEBPACK_IMPORTED_MODULE_1__.clamp)(goalPhi, minimumPolarAngle, maximumPolarAngle);
        const nextRadius = (0,_utilities_js__WEBPACK_IMPORTED_MODULE_1__.clamp)(goalRadius, minimumRadius, maximumRadius);
        if (nextTheta === theta && nextPhi === phi && nextRadius === radius) {
            return false;
        }
        if (!isFinite(nextTheta) || !isFinite(nextPhi) || !isFinite(nextRadius)) {
            return false;
        }
        this.goalSpherical.theta = nextTheta;
        this.goalSpherical.phi = nextPhi;
        this.goalSpherical.radius = nextRadius;
        this.goalSpherical.makeSafe();
        return true;
    }
    /**
     * Subset of setOrbit() above, which only sets the camera's radius.
     */
    setRadius(radius) {
        this.goalSpherical.radius = radius;
        this.setOrbit();
    }
    /**
     * Sets the goal field of view for the camera
     */
    setFieldOfView(fov) {
        const { minimumFieldOfView, maximumFieldOfView } = this._options;
        fov = (0,_utilities_js__WEBPACK_IMPORTED_MODULE_1__.clamp)(fov, minimumFieldOfView, maximumFieldOfView);
        this.goalLogFov = Math.log(fov);
    }
    /**
     * Sets the smoothing decay time.
     */
    setDamperDecayTime(decayMilliseconds) {
        this.thetaDamper.setDecayTime(decayMilliseconds);
        this.phiDamper.setDecayTime(decayMilliseconds);
        this.radiusDamper.setDecayTime(decayMilliseconds);
        this.fovDamper.setDecayTime(decayMilliseconds);
    }
    /**
     * Adjust the orbital position of the camera relative to its current orbital
     * position. Does not let the theta goal get more than pi ahead of the current
     * theta, which ensures interpolation continues in the direction of the delta.
     * The deltaZoom parameter adjusts both the field of view and the orbit radius
     * such that they progress across their allowed ranges in sync.
     */
    adjustOrbit(deltaTheta, deltaPhi, deltaZoom) {
        const { theta, phi, radius } = this.goalSpherical;
        const { minimumRadius, maximumRadius, minimumFieldOfView, maximumFieldOfView } = this._options;
        const dTheta = this.spherical.theta - theta;
        const dThetaLimit = Math.PI - 0.001;
        const goalTheta = theta - (0,_utilities_js__WEBPACK_IMPORTED_MODULE_1__.clamp)(deltaTheta, -dThetaLimit - dTheta, dThetaLimit - dTheta);
        const goalPhi = phi - deltaPhi;
        const deltaRatio = deltaZoom === 0 ?
            0 :
            ((deltaZoom > 0 ? maximumRadius : minimumRadius) - radius) /
                (Math.log(deltaZoom > 0 ? maximumFieldOfView : minimumFieldOfView) -
                    this.goalLogFov);
        const goalRadius = radius +
            deltaZoom *
                (isFinite(deltaRatio) ? deltaRatio :
                    (maximumRadius - minimumRadius) * 2);
        this.setOrbit(goalTheta, goalPhi, goalRadius);
        if (deltaZoom !== 0) {
            const goalLogFov = this.goalLogFov + deltaZoom;
            this.setFieldOfView(Math.exp(goalLogFov));
        }
    }
    /**
     * Move the camera instantly instead of accelerating toward the goal
     * parameters.
     */
    jumpToGoal() {
        this.update(0, _Damper_js__WEBPACK_IMPORTED_MODULE_2__.SETTLING_TIME);
    }
    /**
     * Update controls. In most cases, this will result in the camera
     * interpolating its position and rotation until it lines up with the
     * designated goal orbital position. Returns false if the camera did not move.
     *
     * Time and delta are measured in milliseconds.
     */
    update(_time, delta) {
        if (this.isStationary()) {
            return false;
        }
        const { maximumPolarAngle, maximumRadius } = this._options;
        const dTheta = this.spherical.theta - this.goalSpherical.theta;
        if (Math.abs(dTheta) > Math.PI &&
            !isFinite(this._options.minimumAzimuthalAngle) &&
            !isFinite(this._options.maximumAzimuthalAngle)) {
            this.spherical.theta -= Math.sign(dTheta) * 2 * Math.PI;
        }
        this.spherical.theta = this.thetaDamper.update(this.spherical.theta, this.goalSpherical.theta, delta, Math.PI);
        this.spherical.phi = this.phiDamper.update(this.spherical.phi, this.goalSpherical.phi, delta, maximumPolarAngle);
        this.spherical.radius = this.radiusDamper.update(this.spherical.radius, this.goalSpherical.radius, delta, maximumRadius);
        this.logFov = this.fovDamper.update(this.logFov, this.goalLogFov, delta, 1);
        this.moveCamera();
        return true;
    }
    updateTouchActionStyle() {
        const { style } = this.element;
        if (this._interactionEnabled) {
            const { touchAction } = this._options;
            if (this._disableZoom && touchAction !== 'none') {
                style.touchAction = 'manipulation';
            }
            else {
                style.touchAction = touchAction;
            }
        }
        else {
            style.touchAction = '';
        }
    }
    isStationary() {
        return this.goalSpherical.theta === this.spherical.theta &&
            this.goalSpherical.phi === this.spherical.phi &&
            this.goalSpherical.radius === this.spherical.radius &&
            this.goalLogFov === this.logFov;
    }
    moveCamera() {
        // Derive the new camera position from the updated spherical:
        this.spherical.makeSafe();
        this.camera.position.setFromSpherical(this.spherical);
        this.camera.setRotationFromEuler(new three__WEBPACK_IMPORTED_MODULE_3__.Euler(this.spherical.phi - Math.PI / 2, this.spherical.theta, 0, 'YXZ'));
        if (this.camera.fov !== Math.exp(this.logFov)) {
            this.camera.fov = Math.exp(this.logFov);
            this.camera.updateProjectionMatrix();
        }
    }
    userAdjustOrbit(deltaTheta, deltaPhi, deltaZoom) {
        this.adjustOrbit(deltaTheta * this.orbitSensitivity * this.inputSensitivity, deltaPhi * this.orbitSensitivity * this.inputSensitivity, deltaZoom * this.inputSensitivity);
    }
    // Wraps to between -pi and pi
    wrapAngle(radians) {
        const normalized = (radians + Math.PI) / (2 * Math.PI);
        const wrapped = normalized - Math.floor(normalized);
        return wrapped * 2 * Math.PI - Math.PI;
    }
    pixelLengthToSphericalAngle(pixelLength) {
        return 2 * Math.PI * pixelLength / this.scene.height;
    }
    twoTouchDistance(touchOne, touchTwo) {
        const { clientX: xOne, clientY: yOne } = touchOne;
        const { clientX: xTwo, clientY: yTwo } = touchTwo;
        const xDelta = xTwo - xOne;
        const yDelta = yTwo - yOne;
        return Math.sqrt(xDelta * xDelta + yDelta * yDelta);
    }
    handleSinglePointerMove(dx, dy) {
        const deltaTheta = this.pixelLengthToSphericalAngle(dx);
        const deltaPhi = this.pixelLengthToSphericalAngle(dy);
        if (this.isUserPointing === false) {
            this.isUserPointing = true;
            this.dispatchEvent({ type: 'pointer-change-start' });
        }
        this.userAdjustOrbit(deltaTheta, deltaPhi, 0);
    }
    initializePan() {
        const { theta, phi } = this.spherical;
        const psi = theta - this.scene.yaw;
        this.panPerPixel = PAN_SENSITIVITY / this.scene.height;
        this.panProjection.set(-Math.cos(psi), -Math.cos(phi) * Math.sin(psi), 0, 0, Math.sin(phi), 0, Math.sin(psi), -Math.cos(phi) * Math.cos(psi), 0);
    }
    movePan(dx, dy) {
        const { scene } = this;
        const dxy = vector3.set(dx, dy, 0).multiplyScalar(this.inputSensitivity);
        const metersPerPixel = this.spherical.radius * Math.exp(this.logFov) * this.panPerPixel;
        dxy.multiplyScalar(metersPerPixel);
        const target = scene.getTarget();
        target.add(dxy.applyMatrix3(this.panProjection));
        scene.boundingSphere.clampPoint(target, target);
        scene.setTarget(target.x, target.y, target.z);
    }
    recenter(pointer) {
        if (performance.now() > this.startTime + TAP_MS ||
            Math.abs(pointer.clientX - this.startPointerPosition.clientX) >
                TAP_DISTANCE ||
            Math.abs(pointer.clientY - this.startPointerPosition.clientY) >
                TAP_DISTANCE) {
            return;
        }
        const { scene } = this;
        const hit = scene.positionAndNormalFromPoint(scene.getNDC(pointer.clientX, pointer.clientY));
        if (hit == null) {
            const { cameraTarget } = scene.element;
            scene.element.cameraTarget = '';
            scene.element.cameraTarget = cameraTarget;
            // Zoom all the way out.
            this.userAdjustOrbit(0, 0, 1);
        }
        else {
            scene.target.worldToLocal(hit.position);
            scene.setTarget(hit.position.x, hit.position.y, hit.position.z);
        }
    }
    resetRadius() {
        const { scene } = this;
        const hit = scene.positionAndNormalFromPoint(vector2.set(0, 0));
        if (hit == null) {
            return;
        }
        scene.target.worldToLocal(hit.position);
        const goalTarget = scene.getTarget();
        const { theta, phi } = this.spherical;
        // Set target to surface hit point, except the target is still settling,
        // so offset the goal accordingly so the transition is smooth even though
        // this will drift the target slightly away from the hit point.
        const psi = theta - scene.yaw;
        const n = vector3.set(Math.sin(phi) * Math.sin(psi), Math.cos(phi), Math.sin(phi) * Math.cos(psi));
        const dr = n.dot(hit.position.sub(goalTarget));
        goalTarget.add(n.multiplyScalar(dr));
        scene.setTarget(goalTarget.x, goalTarget.y, goalTarget.z);
        // Change the camera radius to match the change in target so that the
        // camera itself does not move, unless it hits a radius bound.
        this.setOrbit(undefined, undefined, this.goalSpherical.radius - dr);
    }
    onTouchChange(event) {
        if (this.pointers.length === 1) {
            this.touchMode = this.touchModeRotate;
        }
        else {
            if (this._disableZoom) {
                this.touchMode = null;
                this.element.removeEventListener('touchmove', this.disableScroll);
                return;
            }
            this.touchMode = (this.touchDecided && this.touchMode === null) ?
                null :
                this.touchModeZoom;
            this.touchDecided = true;
            this.element.addEventListener('touchmove', this.disableScroll, { passive: false });
            this.lastSeparation =
                this.twoTouchDistance(this.pointers[0], this.pointers[1]);
            if (this.enablePan && this.touchMode != null) {
                this.initializePan();
                if (!event.altKey) { // user interaction, not prompt
                    this.scene.element[_features_controls_js__WEBPACK_IMPORTED_MODULE_0__.$panElement].style.opacity = 1;
                }
            }
        }
    }
    onMouseDown(event) {
        this.panPerPixel = 0;
        if (this.enablePan &&
            (event.button === 2 || event.ctrlKey || event.metaKey ||
                event.shiftKey)) {
            this.initializePan();
            this.scene.element[_features_controls_js__WEBPACK_IMPORTED_MODULE_0__.$panElement].style.opacity = 1;
        }
        this.element.style.cursor = 'grabbing';
    }
    /**
     * Handles the orbit and Zoom key presses
     * Uses constants for the increment.
     * @param event The keyboard event for the .key value
     * @returns boolean to indicate if the key event has been handled
     */
    orbitZoomKeyCodeHandler(event) {
        let relevantKey = true;
        switch (event.key) {
            case 'PageUp':
                this.userAdjustOrbit(0, 0, ZOOM_SENSITIVITY);
                break;
            case 'PageDown':
                this.userAdjustOrbit(0, 0, -1 * ZOOM_SENSITIVITY);
                break;
            case 'ArrowUp':
                this.userAdjustOrbit(0, -KEYBOARD_ORBIT_INCREMENT, 0);
                break;
            case 'ArrowDown':
                this.userAdjustOrbit(0, KEYBOARD_ORBIT_INCREMENT, 0);
                break;
            case 'ArrowLeft':
                this.userAdjustOrbit(-KEYBOARD_ORBIT_INCREMENT, 0, 0);
                break;
            case 'ArrowRight':
                this.userAdjustOrbit(KEYBOARD_ORBIT_INCREMENT, 0, 0);
                break;
            default:
                relevantKey = false;
                break;
        }
        return relevantKey;
    }
    /**
     * Handles the Pan key presses
     * Uses constants for the increment.
     * @param event The keyboard event for the .key value
     * @returns boolean to indicate if the key event has been handled
     */
    panKeyCodeHandler(event) {
        this.initializePan();
        let relevantKey = true;
        switch (event.key) {
            case 'ArrowUp':
                this.movePan(0, -1 * PAN_KEY_INCREMENT); // This is the negative one so that the
                // model appears to move as the arrow
                // direction rather than the view moving
                break;
            case 'ArrowDown':
                this.movePan(0, PAN_KEY_INCREMENT);
                break;
            case 'ArrowLeft':
                this.movePan(-1 * PAN_KEY_INCREMENT, 0);
                break;
            case 'ArrowRight':
                this.movePan(PAN_KEY_INCREMENT, 0);
                break;
            default:
                relevantKey = false;
                break;
        }
        return relevantKey;
    }
}
//# sourceMappingURL=SmoothControls.js.map

/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/three-components/TextureUtils.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/three-components/TextureUtils.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TextureUtils)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ "../../node_modules/three/build/three.module.js");
/* harmony import */ var three_examples_jsm_loaders_RGBELoader_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three/examples/jsm/loaders/RGBELoader.js */ "../../node_modules/three/examples/jsm/loaders/RGBELoader.js");
/* harmony import */ var _utilities_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utilities.js */ "../../node_modules/@google/model-viewer/lib/utilities.js");
/* harmony import */ var _EnvironmentScene_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EnvironmentScene.js */ "../../node_modules/@google/model-viewer/lib/three-components/EnvironmentScene.js");
/* harmony import */ var _EnvironmentSceneAlt_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EnvironmentSceneAlt.js */ "../../node_modules/@google/model-viewer/lib/three-components/EnvironmentSceneAlt.js");
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





const GENERATED_SIGMA = 0.04;
// The maximum length of the blur for loop. Smaller sigmas will use fewer
// samples and exit early, but not recompile the shader.
const MAX_SAMPLES = 20;
const HDR_FILE_RE = /\.hdr(\.js)?$/;
class TextureUtils extends three__WEBPACK_IMPORTED_MODULE_3__.EventDispatcher {
    constructor(threeRenderer) {
        super();
        this.threeRenderer = threeRenderer;
        this.lottieLoaderUrl = '';
        this.withCredentials = false;
        this._ldrLoader = null;
        this._hdrLoader = null;
        this._lottieLoader = null;
        this.generatedEnvironmentMap = null;
        this.generatedEnvironmentMapAlt = null;
        this.skyboxCache = new Map();
        this.blurMaterial = null;
        this.blurScene = null;
    }
    get ldrLoader() {
        if (this._ldrLoader == null) {
            this._ldrLoader = new three__WEBPACK_IMPORTED_MODULE_3__.TextureLoader();
        }
        this._ldrLoader.setWithCredentials(this.withCredentials);
        return this._ldrLoader;
    }
    get hdrLoader() {
        if (this._hdrLoader == null) {
            this._hdrLoader = new three_examples_jsm_loaders_RGBELoader_js__WEBPACK_IMPORTED_MODULE_4__.RGBELoader();
            this._hdrLoader.setDataType(three__WEBPACK_IMPORTED_MODULE_3__.HalfFloatType);
        }
        this._hdrLoader.setWithCredentials(this.withCredentials);
        return this._hdrLoader;
    }
    async getLottieLoader() {
        if (this._lottieLoader == null) {
            const { LottieLoader } = await __webpack_require__("../../node_modules/@google/model-viewer/lib/three-components lazy recursive")(this.lottieLoaderUrl);
            this._lottieLoader = new LottieLoader();
        }
        this._lottieLoader.setWithCredentials(this.withCredentials);
        return this._lottieLoader;
    }
    async loadImage(url) {
        const texture = await new Promise((resolve, reject) => this.ldrLoader.load(url, resolve, () => { }, reject));
        texture.name = url;
        texture.flipY = false;
        return texture;
    }
    async loadLottie(url, quality) {
        const loader = await this.getLottieLoader();
        loader.setQuality(quality);
        const texture = await new Promise((resolve, reject) => loader.load(url, resolve, () => { }, reject));
        texture.name = url;
        return texture;
    }
    async loadEquirect(url, progressCallback = () => { }) {
        try {
            const isHDR = HDR_FILE_RE.test(url);
            const loader = isHDR ? this.hdrLoader : this.ldrLoader;
            const texture = await new Promise((resolve, reject) => loader.load(url, resolve, (event) => {
                progressCallback(event.loaded / event.total * 0.9);
            }, reject));
            progressCallback(1.0);
            texture.name = url;
            texture.mapping = three__WEBPACK_IMPORTED_MODULE_3__.EquirectangularReflectionMapping;
            if (!isHDR) {
                texture.encoding = three__WEBPACK_IMPORTED_MODULE_3__.sRGBEncoding;
            }
            return texture;
        }
        finally {
            if (progressCallback) {
                progressCallback(1);
            }
        }
    }
    /**
     * Returns a { skybox, environmentMap } object with the targets/textures
     * accordingly. `skybox` is a WebGLRenderCubeTarget, and `environmentMap`
     * is a Texture from a WebGLRenderCubeTarget.
     */
    async generateEnvironmentMapAndSkybox(skyboxUrl = null, environmentMapUrl = null, progressCallback = () => { }) {
        const useAltEnvironment = environmentMapUrl !== 'legacy';
        if (environmentMapUrl === 'legacy' || environmentMapUrl === 'neutral') {
            environmentMapUrl = null;
        }
        environmentMapUrl = (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.deserializeUrl)(environmentMapUrl);
        let skyboxLoads = Promise.resolve(null);
        let environmentMapLoads;
        // If we have a skybox URL, attempt to load it as a cubemap
        if (!!skyboxUrl) {
            skyboxLoads = this.loadEquirectFromUrl(skyboxUrl, progressCallback);
        }
        if (!!environmentMapUrl) {
            // We have an available environment map URL
            environmentMapLoads =
                this.loadEquirectFromUrl(environmentMapUrl, progressCallback);
        }
        else if (!!skyboxUrl) {
            // Fallback to deriving the environment map from an available skybox
            environmentMapLoads =
                this.loadEquirectFromUrl(skyboxUrl, progressCallback);
        }
        else {
            // Fallback to generating the environment map
            environmentMapLoads = useAltEnvironment ?
                this.loadGeneratedEnvironmentMapAlt() :
                this.loadGeneratedEnvironmentMap();
        }
        const [environmentMap, skybox] = await Promise.all([environmentMapLoads, skyboxLoads]);
        if (environmentMap == null) {
            throw new Error('Failed to load environment map.');
        }
        return { environmentMap, skybox };
    }
    /**
     * Loads an equirect Texture from a given URL, for use as a skybox.
     */
    async loadEquirectFromUrl(url, progressCallback) {
        if (!this.skyboxCache.has(url)) {
            const skyboxMapLoads = this.loadEquirect(url, progressCallback);
            this.skyboxCache.set(url, skyboxMapLoads);
        }
        return this.skyboxCache.get(url);
    }
    async GenerateEnvironmentMap(scene, name) {
        await (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.timePasses)();
        const renderer = this.threeRenderer;
        const cubeTarget = new three__WEBPACK_IMPORTED_MODULE_3__.WebGLCubeRenderTarget(256, {
            generateMipmaps: false,
            type: three__WEBPACK_IMPORTED_MODULE_3__.HalfFloatType,
            format: three__WEBPACK_IMPORTED_MODULE_3__.RGBAFormat,
            encoding: three__WEBPACK_IMPORTED_MODULE_3__.LinearEncoding,
            depthBuffer: true
        });
        const cubeCamera = new three__WEBPACK_IMPORTED_MODULE_3__.CubeCamera(0.1, 100, cubeTarget);
        const generatedEnvironmentMap = cubeCamera.renderTarget.texture;
        generatedEnvironmentMap.name = name;
        const outputEncoding = renderer.outputEncoding;
        const toneMapping = renderer.toneMapping;
        renderer.toneMapping = three__WEBPACK_IMPORTED_MODULE_3__.NoToneMapping;
        renderer.outputEncoding = three__WEBPACK_IMPORTED_MODULE_3__.LinearEncoding;
        cubeCamera.update(renderer, scene);
        this.blurCubemap(cubeTarget, GENERATED_SIGMA);
        renderer.toneMapping = toneMapping;
        renderer.outputEncoding = outputEncoding;
        return generatedEnvironmentMap;
    }
    /**
     * Loads a dynamically generated environment map.
     */
    async loadGeneratedEnvironmentMap() {
        if (this.generatedEnvironmentMap == null) {
            this.generatedEnvironmentMap =
                this.GenerateEnvironmentMap(new _EnvironmentScene_js__WEBPACK_IMPORTED_MODULE_1__["default"](), 'legacy');
        }
        return this.generatedEnvironmentMap;
    }
    /**
     * Loads a dynamically generated environment map, designed to be neutral and
     * color-preserving. Shows less contrast around the different sides of the
     * object.
     */
    async loadGeneratedEnvironmentMapAlt() {
        if (this.generatedEnvironmentMapAlt == null) {
            this.generatedEnvironmentMapAlt =
                this.GenerateEnvironmentMap(new _EnvironmentSceneAlt_js__WEBPACK_IMPORTED_MODULE_2__["default"](), 'neutral');
        }
        return this.generatedEnvironmentMapAlt;
    }
    blurCubemap(cubeTarget, sigma) {
        if (this.blurMaterial == null) {
            this.blurMaterial = this.getBlurShader(MAX_SAMPLES);
            const box = new three__WEBPACK_IMPORTED_MODULE_3__.BoxGeometry();
            const blurMesh = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(box, this.blurMaterial);
            this.blurScene = new three__WEBPACK_IMPORTED_MODULE_3__.Scene();
            this.blurScene.add(blurMesh);
        }
        const tempTarget = cubeTarget.clone();
        this.halfblur(cubeTarget, tempTarget, sigma, 'latitudinal');
        this.halfblur(tempTarget, cubeTarget, sigma, 'longitudinal');
        // Disposing this target after we're done with it somehow corrupts Safari's
        // whole graphics driver. It's random, but occurs more frequently on
        // lower-powered GPUs (macbooks with intel graphics, older iPhones). It goes
        // beyond just messing up the PMREM, as it also occasionally causes
        // visible corruption on the canvas and even on the rest of the page.
        /** tempTarget.dispose(); */
    }
    halfblur(targetIn, targetOut, sigmaRadians, direction) {
        // Number of standard deviations at which to cut off the discrete
        // approximation.
        const STANDARD_DEVIATIONS = 3;
        const pixels = targetIn.width;
        const radiansPerPixel = isFinite(sigmaRadians) ?
            Math.PI / (2 * pixels) :
            2 * Math.PI / (2 * MAX_SAMPLES - 1);
        const sigmaPixels = sigmaRadians / radiansPerPixel;
        const samples = isFinite(sigmaRadians) ?
            1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) :
            MAX_SAMPLES;
        if (samples > MAX_SAMPLES) {
            console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
        }
        const weights = [];
        let sum = 0;
        for (let i = 0; i < MAX_SAMPLES; ++i) {
            const x = i / sigmaPixels;
            const weight = Math.exp(-x * x / 2);
            weights.push(weight);
            if (i == 0) {
                sum += weight;
            }
            else if (i < samples) {
                sum += 2 * weight;
            }
        }
        for (let i = 0; i < weights.length; i++) {
            weights[i] = weights[i] / sum;
        }
        const blurUniforms = this.blurMaterial.uniforms;
        blurUniforms['envMap'].value = targetIn.texture;
        blurUniforms['samples'].value = samples;
        blurUniforms['weights'].value = weights;
        blurUniforms['latitudinal'].value = direction === 'latitudinal';
        blurUniforms['dTheta'].value = radiansPerPixel;
        const cubeCamera = new three__WEBPACK_IMPORTED_MODULE_3__.CubeCamera(0.1, 100, targetOut);
        cubeCamera.update(this.threeRenderer, this.blurScene);
    }
    getBlurShader(maxSamples) {
        const weights = new Float32Array(maxSamples);
        const poleAxis = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(0, 1, 0);
        const shaderMaterial = new three__WEBPACK_IMPORTED_MODULE_3__.ShaderMaterial({
            name: 'SphericalGaussianBlur',
            defines: { 'n': maxSamples },
            uniforms: {
                'envMap': { value: null },
                'samples': { value: 1 },
                'weights': { value: weights },
                'latitudinal': { value: false },
                'dTheta': { value: 0 },
                'poleAxis': { value: poleAxis }
            },
            vertexShader: /* glsl */ `
      
      varying vec3 vOutputDirection;
  
      void main() {
  
        vOutputDirection = vec3( position );
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
  
      }
    `,
            fragmentShader: /* glsl */ `
        varying vec3 vOutputDirection;
  
        uniform samplerCube envMap;
        uniform int samples;
        uniform float weights[ n ];
        uniform bool latitudinal;
        uniform float dTheta;
        uniform vec3 poleAxis;
  
        vec3 getSample( float theta, vec3 axis ) {
  
          float cosTheta = cos( theta );
          // Rodrigues' axis-angle rotation
          vec3 sampleDirection = vOutputDirection * cosTheta
            + cross( axis, vOutputDirection ) * sin( theta )
            + axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );
  
          return vec3( textureCube( envMap, sampleDirection ) );
  
        }
  
        void main() {
  
          vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );
  
          if ( all( equal( axis, vec3( 0.0 ) ) ) ) {
  
            axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );
  
          }
  
          axis = normalize( axis );
  
          gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
          gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );
  
          for ( int i = 1; i < n; i++ ) {
  
            if ( i >= samples ) {
  
              break;
  
            }
  
            float theta = dTheta * float( i );
            gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
            gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );
  
          }
        }
      `,
            blending: three__WEBPACK_IMPORTED_MODULE_3__.NoBlending,
            depthTest: false,
            depthWrite: false,
            side: three__WEBPACK_IMPORTED_MODULE_3__.BackSide
        });
        return shaderMaterial;
    }
    async dispose() {
        for (const [, promise] of this.skyboxCache) {
            const skybox = await promise;
            skybox.dispose();
        }
        if (this.generatedEnvironmentMap != null) {
            (await this.generatedEnvironmentMap).dispose();
            this.generatedEnvironmentMap = null;
        }
        if (this.generatedEnvironmentMapAlt != null) {
            (await this.generatedEnvironmentMapAlt).dispose();
            this.generatedEnvironmentMapAlt = null;
        }
        if (this.blurMaterial != null) {
            this.blurMaterial.dispose();
        }
    }
}
//# sourceMappingURL=TextureUtils.js.map

/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/three-components/gltf-instance/ModelViewerGLTFInstance.js":
/*!*************************************************************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/three-components/gltf-instance/ModelViewerGLTFInstance.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ModelViewerGLTFInstance": () => (/* binding */ ModelViewerGLTFInstance)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ "../../node_modules/three/build/three.module.js");
/* harmony import */ var _GLTFInstance_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../GLTFInstance.js */ "../../node_modules/@google/model-viewer/lib/three-components/GLTFInstance.js");
/* harmony import */ var _correlated_scene_graph_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./correlated-scene-graph.js */ "../../node_modules/@google/model-viewer/lib/three-components/gltf-instance/correlated-scene-graph.js");
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



const $correlatedSceneGraph = Symbol('correlatedSceneGraph');
/**
 * This specialization of GLTFInstance collects all of the processing needed
 * to prepare a model and to clone it making special considerations for
 * <model-viewer> use cases.
 */
class ModelViewerGLTFInstance extends _GLTFInstance_js__WEBPACK_IMPORTED_MODULE_0__.GLTFInstance {
    /**
     * @override
     */
    static [_GLTFInstance_js__WEBPACK_IMPORTED_MODULE_0__.$prepare](source) {
        const prepared = super[_GLTFInstance_js__WEBPACK_IMPORTED_MODULE_0__.$prepare](source);
        if (prepared[$correlatedSceneGraph] == null) {
            prepared[$correlatedSceneGraph] = _correlated_scene_graph_js__WEBPACK_IMPORTED_MODULE_1__.CorrelatedSceneGraph.from(prepared);
        }
        const { scene } = prepared;
        const nullSphere = new three__WEBPACK_IMPORTED_MODULE_2__.Sphere(undefined, Infinity);
        scene.traverse((node) => {
            // Set a high renderOrder while we're here to ensure the model
            // always renders on top of the sky sphere
            node.renderOrder = 1000;
            // Three.js seems to cull some animated models incorrectly. Since we
            // expect to view our whole scene anyway, we turn off the frustum
            // culling optimization here.
            node.frustumCulled = false;
            // Animations for objects without names target their UUID instead. When
            // objects are cloned, they get new UUIDs which the animation can't
            // find. To fix this, we assign their UUID as their name.
            if (!node.name) {
                node.name = node.uuid;
            }
            const mesh = node;
            if (mesh.material) {
                const { geometry } = mesh;
                mesh.castShadow = true;
                if (mesh.isSkinnedMesh) {
                    // Akin to disabling frustum culling above, we have to also manually
                    // disable the bounds to make raycasting correct for skinned meshes.
                    geometry.boundingSphere = nullSphere;
                    // The bounding box is set in GLTFLoader by the accessor bounds, which
                    // are not updated with animation.
                    geometry.boundingBox = null;
                }
                const material = mesh.material;
                if (material.isMeshBasicMaterial === true) {
                    material.toneMapped = false;
                }
                // This makes shadows better for non-manifold meshes
                material.shadowSide = three__WEBPACK_IMPORTED_MODULE_2__.FrontSide;
                // Fixes an edge case with unused extra UV-coords being incorrectly
                // referenced by three.js; remove when
                // https://github.com/mrdoob/three.js/pull/23974 is merged.
                if (material.aoMap) {
                    const { gltf, threeObjectMap } = prepared[$correlatedSceneGraph];
                    const gltfRef = threeObjectMap.get(material);
                    if (gltf.materials != null && gltfRef != null &&
                        gltfRef.materials != null) {
                        const gltfMaterial = gltf.materials[gltfRef.materials];
                        if (gltfMaterial.occlusionTexture &&
                            gltfMaterial.occlusionTexture.texCoord === 0 &&
                            geometry.attributes.uv != null) {
                            geometry.setAttribute('uv2', geometry.attributes.uv);
                        }
                    }
                }
            }
        });
        return prepared;
    }
    get correlatedSceneGraph() {
        return this[_GLTFInstance_js__WEBPACK_IMPORTED_MODULE_0__.$preparedGLTF][$correlatedSceneGraph];
    }
    /**
     * @override
     */
    [_GLTFInstance_js__WEBPACK_IMPORTED_MODULE_0__.$clone]() {
        const clone = super[_GLTFInstance_js__WEBPACK_IMPORTED_MODULE_0__.$clone]();
        const sourceUUIDToClonedMaterial = new Map();
        clone.scene.traverse((node) => {
            // Materials aren't cloned when cloning meshes; geometry
            // and materials are copied by reference. This is necessary
            // for the same model to be used twice with different
            // scene-graph operations.
            const mesh = node;
            if (mesh.material) {
                const material = mesh.material;
                if (material != null) {
                    if (sourceUUIDToClonedMaterial.has(material.uuid)) {
                        mesh.material = sourceUUIDToClonedMaterial.get(material.uuid);
                        return;
                    }
                    mesh.material = material.clone();
                    sourceUUIDToClonedMaterial.set(material.uuid, mesh.material);
                }
            }
        });
        // Cross-correlate the scene graph by relying on information in the
        // current scene graph; without this step, relationships between the
        // Three.js object graph and the glTF scene graph will be lost.
        clone[$correlatedSceneGraph] =
            _correlated_scene_graph_js__WEBPACK_IMPORTED_MODULE_1__.CorrelatedSceneGraph.from(clone, this.correlatedSceneGraph);
        return clone;
    }
}
//# sourceMappingURL=ModelViewerGLTFInstance.js.map

/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/three-components/gltf-instance/VariantMaterialExporterPlugin.js":
/*!*******************************************************************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/three-components/gltf-instance/VariantMaterialExporterPlugin.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ GLTFExporterMaterialsVariantsExtension)
/* harmony export */ });
/* @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @param object {THREE.Object3D}
 * @return {boolean}
 */
const compatibleObject = (object) => {
    // @TODO: Need properer variantMaterials format validation?
    return object.material !==
        undefined && // easier than (!object.isMesh && !object.isLine &&
        // !object.isPoints)
        object.userData && // just in case
        object.userData.variantMaterials &&
        // Is this line costly?
        !!Array
            .from(object.userData.variantMaterials
            .values())
            .filter(m => compatibleMaterial(m.material));
};
/**
 * @param material {THREE.Material}
 * @return {boolean}
 */
const compatibleMaterial = (material) => {
    // @TODO: support multi materials?
    return material && material.isMaterial && !Array.isArray(material);
};
class GLTFExporterMaterialsVariantsExtension {
    constructor(writer) {
        this.writer = writer;
        this.name = 'KHR_materials_variants';
        this.variantNames = [];
    }
    beforeParse(objects) {
        // Find all variant names and store them to the table
        const variantNameSet = new Set();
        for (const object of objects) {
            object.traverse(o => {
                if (!compatibleObject(o)) {
                    return;
                }
                const variantMaterials = o.userData.variantMaterials;
                const variantDataMap = o.userData.variantData;
                for (const [variantName, variantData] of variantDataMap) {
                    const variantMaterial = variantMaterials.get(variantData.index);
                    // Ignore unloaded variant materials
                    if (variantMaterial && compatibleMaterial(variantMaterial.material)) {
                        variantNameSet.add(variantName);
                    }
                }
            });
        }
        // We may want to sort?
        variantNameSet.forEach(name => this.variantNames.push(name));
    }
    writeMesh(mesh, meshDef) {
        if (!compatibleObject(mesh)) {
            return;
        }
        const userData = mesh.userData;
        const variantMaterials = userData.variantMaterials;
        const variantDataMap = userData.variantData;
        const mappingTable = new Map();
        // Removes gaps in the variant indices list (caused by deleting variants).
        const reIndexedVariants = new Map();
        const variants = Array.from(variantDataMap.values()).sort((a, b) => {
            return a.index - b.index;
        });
        for (const [i, variantData] of variants.entries()) {
            reIndexedVariants.set(variantData.index, i);
        }
        for (const variantData of variantDataMap.values()) {
            const variantInstance = variantMaterials.get(variantData.index);
            if (!variantInstance || !compatibleMaterial(variantInstance.material)) {
                continue;
            }
            const materialIndex = this.writer.processMaterial(variantInstance.material);
            if (!mappingTable.has(materialIndex)) {
                mappingTable.set(materialIndex, { material: materialIndex, variants: [] });
            }
            mappingTable.get(materialIndex).variants.push(reIndexedVariants.get(variantData.index));
        }
        const mappingsDef = Array.from(mappingTable.values())
            .map((m => { return m.variants.sort((a, b) => a - b) && m; }))
            .sort((a, b) => a.material - b.material);
        if (mappingsDef.length === 0) {
            return;
        }
        const originalMaterialIndex = compatibleMaterial(userData.originalMaterial) ?
            this.writer.processMaterial(userData.originalMaterial) :
            -1;
        for (const primitiveDef of meshDef.primitives) {
            // Override primitiveDef.material with original material.
            if (originalMaterialIndex >= 0) {
                primitiveDef.material = originalMaterialIndex;
            }
            primitiveDef.extensions = primitiveDef.extensions || {};
            primitiveDef.extensions[this.name] = { mappings: mappingsDef };
        }
    }
    afterParse() {
        if (this.variantNames.length === 0) {
            return;
        }
        const root = this.writer.json;
        root.extensions = root.extensions || {};
        const variantsDef = this.variantNames.map(n => {
            return { name: n };
        });
        root.extensions[this.name] = { variants: variantsDef };
        this.writer.extensionsUsed[this.name] = true;
    }
}
//# sourceMappingURL=VariantMaterialExporterPlugin.js.map

/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/three-components/gltf-instance/VariantMaterialLoaderPlugin.js":
/*!*****************************************************************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/three-components/gltf-instance/VariantMaterialLoaderPlugin.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ GLTFMaterialsVariantsExtension)
/* harmony export */ });
/* @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * KHR_materials_variants specification allows duplicated variant names
 * but it makes handling the extension complex.
 * We ensure tha names and make it easier.
 * If you want to export the extension with the original names
 * you are recommended to write GLTFExporter plugin to restore the names.
 *
 * @param variantNames {Array<string>}
 * @return {Array<string>}
 */
const ensureUniqueNames = (variantNames) => {
    const uniqueNames = [];
    const knownNames = new Set();
    for (const name of variantNames) {
        let uniqueName = name;
        let suffix = 0;
        // @TODO: An easy solution.
        //        O(N^2) in the worst scenario where N is variantNames.length.
        //        Fix me if needed.
        while (knownNames.has(uniqueName)) {
            uniqueName = name + '.' + (++suffix);
        }
        knownNames.add(uniqueName);
        uniqueNames.push(uniqueName);
    }
    return uniqueNames;
};
/**
 * Convert mappings array to table object to make handling the extension easier.
 *
 * @param
 *     extensionDef {glTF.meshes[n].primitive.extensions.KHR_materials_variants}
 * @param variantNames {Array<string>} Required to be unique names
 * @return {Map}
 */
const mappingsArrayToTable = (extensionDef) => {
    const table = new Map();
    for (const mapping of extensionDef.mappings) {
        for (const variant of mapping.variants) {
            table.set(variant, { material: null, gltfMaterialIndex: mapping.material });
        }
    }
    return table;
};
class GLTFMaterialsVariantsExtension {
    constructor(parser) {
        this.parser = parser;
        this.name = 'KHR_materials_variants';
    }
    // Note that the following properties will be overridden even if they are
    // pre-defined
    // - gltf.userData.variants
    // - mesh.userData.variantMaterials
    afterRoot(gltf) {
        const parser = this.parser;
        const json = parser.json;
        if (json.extensions === undefined ||
            json.extensions[this.name] === undefined) {
            return null;
        }
        const extensionDef = json.extensions[this.name];
        const variantsDef = extensionDef.variants || [];
        const variants = ensureUniqueNames(variantsDef.map((v) => v.name));
        for (const scene of gltf.scenes) {
            // Save the variants data under associated mesh.userData
            scene.traverse(object => {
                const mesh = object;
                if (!mesh.material) {
                    return;
                }
                const association = parser.associations.get(mesh);
                if (association == null || association.meshes == null ||
                    association.primitives == null) {
                    return;
                }
                const meshDef = json.meshes[association.meshes];
                const primitivesDef = meshDef.primitives;
                const primitiveDef = primitivesDef[association.primitives];
                const extensionsDef = primitiveDef.extensions;
                if (!extensionsDef || !extensionsDef[this.name]) {
                    return;
                }
                mesh.userData.variantMaterials =
                    mappingsArrayToTable(extensionsDef[this.name]);
            });
        }
        gltf.userData.variants = variants;
        return Promise.resolve();
    }
}
//# sourceMappingURL=VariantMaterialLoaderPlugin.js.map

/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/three-components/gltf-instance/correlated-scene-graph.js":
/*!************************************************************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/three-components/gltf-instance/correlated-scene-graph.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CorrelatedSceneGraph": () => (/* binding */ CorrelatedSceneGraph)
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../../node_modules/three/build/three.module.js");

const $threeGLTF = Symbol('threeGLTF');
const $gltf = Symbol('gltf');
const $gltfElementMap = Symbol('gltfElementMap');
const $threeObjectMap = Symbol('threeObjectMap');
const $parallelTraverseThreeScene = Symbol('parallelTraverseThreeScene');
const $correlateOriginalThreeGLTF = Symbol('correlateOriginalThreeGLTF');
const $correlateCloneThreeGLTF = Symbol('correlateCloneThreeGLTF');
/**
 * The Three.js GLTFLoader provides us with an in-memory representation
 * of a glTF in terms of Three.js constructs. It also provides us with a copy
 * of the deserialized glTF without any Three.js decoration, and a mapping of
 * glTF elements to their corresponding Three.js constructs.
 *
 * A CorrelatedSceneGraph exposes a synchronously available mapping of glTF
 * element references to their corresponding Three.js constructs.
 */
class CorrelatedSceneGraph {
    constructor(threeGLTF, gltf, threeObjectMap, gltfElementMap) {
        this[$threeGLTF] = threeGLTF;
        this[$gltf] = gltf;
        this[$gltfElementMap] = gltfElementMap;
        this[$threeObjectMap] = threeObjectMap;
    }
    /**
     * Produce a CorrelatedSceneGraph from a naturally generated Three.js GLTF.
     * Such GLTFs are produced by Three.js' GLTFLoader, and contain cached
     * details that expedite the correlation step.
     *
     * If a CorrelatedSceneGraph is provided as the second argument, re-correlates
     * a cloned Three.js GLTF with a clone of the glTF hierarchy used to produce
     * the upstream Three.js GLTF that the clone was created from. The result
     * CorrelatedSceneGraph is representative of the cloned hierarchy.
     */
    static from(threeGLTF, upstreamCorrelatedSceneGraph) {
        if (upstreamCorrelatedSceneGraph != null) {
            return this[$correlateCloneThreeGLTF](threeGLTF, upstreamCorrelatedSceneGraph);
        }
        else {
            return this[$correlateOriginalThreeGLTF](threeGLTF);
        }
    }
    static [$correlateOriginalThreeGLTF](threeGLTF) {
        const gltf = threeGLTF.parser.json;
        const associations = threeGLTF.parser.associations;
        const gltfElementMap = new Map();
        const defaultMaterial = { name: 'Default' };
        const defaultReference = { type: 'materials', index: -1 };
        for (const threeMaterial of associations.keys()) {
            // Note: GLTFLoader creates a "default" material that has no
            // corresponding glTF element in the case that no materials are
            // specified in the source glTF. In this case we append a default
            // material to allow this to be operated upon.
            if (threeMaterial instanceof three__WEBPACK_IMPORTED_MODULE_0__.Material &&
                associations.get(threeMaterial) == null) {
                if (defaultReference.index < 0) {
                    if (gltf.materials == null) {
                        gltf.materials = [];
                    }
                    defaultReference.index = gltf.materials.length;
                    gltf.materials.push(defaultMaterial);
                }
                threeMaterial.name = defaultMaterial.name;
                associations.set(threeMaterial, { materials: defaultReference.index });
            }
        }
        // Creates a reverse look up map (gltf-object to Three-object)
        for (const [threeObject, gltfMappings] of associations) {
            if (gltfMappings) {
                const objWithUserData = threeObject;
                objWithUserData.userData = objWithUserData.userData || {};
                objWithUserData.userData.associations = gltfMappings;
            }
            for (const mapping in gltfMappings) {
                if (mapping != null && mapping !== 'primitives') {
                    const type = mapping;
                    const elementArray = gltf[type] || [];
                    const gltfElement = elementArray[gltfMappings[type]];
                    if (gltfElement == null) {
                        // TODO: Maybe throw here...
                        continue;
                    }
                    let threeObjects = gltfElementMap.get(gltfElement);
                    if (threeObjects == null) {
                        threeObjects = new Set();
                        gltfElementMap.set(gltfElement, threeObjects);
                    }
                    threeObjects.add(threeObject);
                }
            }
        }
        return new CorrelatedSceneGraph(threeGLTF, gltf, associations, gltfElementMap);
    }
    /**
     * Transfers the association between a raw glTF and a Three.js scene graph
     * to a clone of the Three.js scene graph, resolved as a new
     * CorrelatedSceneGraph instance.
     */
    static [$correlateCloneThreeGLTF](cloneThreeGLTF, upstreamCorrelatedSceneGraph) {
        const originalThreeGLTF = upstreamCorrelatedSceneGraph.threeGLTF;
        const originalGLTF = upstreamCorrelatedSceneGraph.gltf;
        const cloneGLTF = JSON.parse(JSON.stringify(originalGLTF));
        const cloneThreeObjectMap = new Map();
        const cloneGLTFElementMap = new Map();
        for (let i = 0; i < originalThreeGLTF.scenes.length; i++) {
            this[$parallelTraverseThreeScene](originalThreeGLTF.scenes[i], cloneThreeGLTF.scenes[i], (object, cloneObject) => {
                const elementReference = upstreamCorrelatedSceneGraph.threeObjectMap.get(object);
                if (elementReference == null) {
                    return;
                }
                for (const mapping in elementReference) {
                    if (mapping != null && mapping !== 'primitives') {
                        const type = mapping;
                        const index = elementReference[type];
                        const cloneElement = cloneGLTF[type][index];
                        const mappings = cloneThreeObjectMap.get(cloneObject) || {};
                        mappings[type] = index;
                        cloneThreeObjectMap.set(cloneObject, mappings);
                        const cloneObjects = cloneGLTFElementMap.get(cloneElement) || new Set();
                        cloneObjects.add(cloneObject);
                        cloneGLTFElementMap.set(cloneElement, cloneObjects);
                    }
                }
            });
        }
        return new CorrelatedSceneGraph(cloneThreeGLTF, cloneGLTF, cloneThreeObjectMap, cloneGLTFElementMap);
    }
    /**
     * Traverses two presumably identical Three.js scenes, and invokes a
     * callback for each Object3D or Material encountered, including the initial
     * scene. Adapted from
     * https://github.com/mrdoob/three.js/blob/7c1424c5819ab622a346dd630ee4e6431388021e/examples/jsm/utils/SkeletonUtils.js#L586-L596
     */
    static [$parallelTraverseThreeScene](sceneOne, sceneTwo, callback) {
        const traverse = (a, b) => {
            callback(a, b);
            if (a.isObject3D) {
                const meshA = a;
                const meshB = b;
                if (meshA.material) {
                    if (Array.isArray(meshA.material)) {
                        for (let i = 0; i < meshA.material.length; ++i) {
                            callback(meshA.material[i], meshB.material[i]);
                        }
                    }
                    else {
                        callback(meshA.material, meshB.material);
                    }
                }
                for (let i = 0; i < a.children.length; ++i) {
                    traverse(a.children[i], b.children[i]);
                }
            }
        };
        traverse(sceneOne, sceneTwo);
    }
    /**
     * The source Three.js GLTF result given to us by a Three.js GLTFLoader.
     */
    get threeGLTF() {
        return this[$threeGLTF];
    }
    /**
     * The in-memory deserialized source glTF.
     */
    get gltf() {
        return this[$gltf];
    }
    /**
     * A Map of glTF element references to arrays of corresponding Three.js
     * object references. Three.js objects are kept in arrays to account for
     * cases where more than one Three.js object corresponds to a single glTF
     * element.
     */
    get gltfElementMap() {
        return this[$gltfElementMap];
    }
    /**
     * A map of individual Three.js objects to corresponding elements in the
     * source glTF.
     */
    get threeObjectMap() {
        return this[$threeObjectMap];
    }
}
//# sourceMappingURL=correlated-scene-graph.js.map

/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/three-components/gltf-instance/gltf-2.0.js":
/*!**********************************************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/three-components/gltf-instance/gltf-2.0.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Filter": () => (/* binding */ Filter),
/* harmony export */   "Wrap": () => (/* binding */ Wrap)
/* harmony export */ });
var Filter;
(function (Filter) {
    Filter[Filter["Nearest"] = 9728] = "Nearest";
    Filter[Filter["Linear"] = 9729] = "Linear";
    Filter[Filter["NearestMipmapNearest"] = 9984] = "NearestMipmapNearest";
    Filter[Filter["LinearMipmapNearest"] = 9985] = "LinearMipmapNearest";
    Filter[Filter["NearestMipmapLinear"] = 9986] = "NearestMipmapLinear";
    Filter[Filter["LinearMipmapLinear"] = 9987] = "LinearMipmapLinear";
})(Filter || (Filter = {}));
var Wrap;
(function (Wrap) {
    Wrap[Wrap["ClampToEdge"] = 33071] = "ClampToEdge";
    Wrap[Wrap["MirroredRepeat"] = 33648] = "MirroredRepeat";
    Wrap[Wrap["Repeat"] = 10497] = "Repeat";
})(Wrap || (Wrap = {}));
//# sourceMappingURL=gltf-2.0.js.map

/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/utilities.js":
/*!****************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/utilities.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CAPPED_DEVICE_PIXEL_RATIO": () => (/* binding */ CAPPED_DEVICE_PIXEL_RATIO),
/* harmony export */   "assertIsArCandidate": () => (/* binding */ assertIsArCandidate),
/* harmony export */   "clamp": () => (/* binding */ clamp),
/* harmony export */   "debounce": () => (/* binding */ debounce),
/* harmony export */   "deserializeUrl": () => (/* binding */ deserializeUrl),
/* harmony export */   "getFirstMapKey": () => (/* binding */ getFirstMapKey),
/* harmony export */   "isDebugMode": () => (/* binding */ isDebugMode),
/* harmony export */   "resolveDpr": () => (/* binding */ resolveDpr),
/* harmony export */   "step": () => (/* binding */ step),
/* harmony export */   "throttle": () => (/* binding */ throttle),
/* harmony export */   "timePasses": () => (/* binding */ timePasses),
/* harmony export */   "toFullUrl": () => (/* binding */ toFullUrl),
/* harmony export */   "waitForEvent": () => (/* binding */ waitForEvent)
/* harmony export */ });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ "../../node_modules/@google/model-viewer/lib/constants.js");
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const deserializeUrl = (url) => (!!url && url !== 'null') ? toFullUrl(url) : null;
const assertIsArCandidate = () => {
    if (_constants_js__WEBPACK_IMPORTED_MODULE_0__.IS_WEBXR_AR_CANDIDATE) {
        return;
    }
    const missingApis = [];
    if (!_constants_js__WEBPACK_IMPORTED_MODULE_0__.HAS_WEBXR_DEVICE_API) {
        missingApis.push('WebXR Device API');
    }
    if (!_constants_js__WEBPACK_IMPORTED_MODULE_0__.HAS_WEBXR_HIT_TEST_API) {
        missingApis.push('WebXR Hit Test API');
    }
    throw new Error(`The following APIs are required for AR, but are missing in this browser: ${missingApis.join(', ')}`);
};
/**
 * Converts a partial URL string to a fully qualified URL string.
 *
 * @param {String} url
 * @return {String}
 */
const toFullUrl = (partialUrl) => {
    const url = new URL(partialUrl, window.location.toString());
    return url.toString();
};
/**
 * Returns a throttled version of a given function that is only invoked at most
 * once within a given threshold of time in milliseconds.
 *
 * The throttled version of the function has a "flush" property that resets the
 * threshold for cases when immediate invocation is desired.
 */
const throttle = (fn, ms) => {
    let timer = null;
    const throttled = (...args) => {
        if (timer != null) {
            return;
        }
        fn(...args);
        timer = self.setTimeout(() => timer = null, ms);
    };
    throttled.flush = () => {
        if (timer != null) {
            self.clearTimeout(timer);
            timer = null;
        }
    };
    return throttled;
};
const debounce = (fn, ms) => {
    let timer = null;
    return (...args) => {
        if (timer != null) {
            self.clearTimeout(timer);
        }
        timer = self.setTimeout(() => {
            timer = null;
            fn(...args);
        }, ms);
    };
};
/**
 * @param {Number} edge
 * @param {Number} value
 * @return {Number} 0 if value is less than edge, otherwise 1
 */
const step = (edge, value) => {
    return value < edge ? 0 : 1;
};
/**
 * @param {Number} value
 * @param {Number} lowerLimit
 * @param {Number} upperLimit
 * @return {Number} value clamped within lowerLimit..upperLimit
 */
const clamp = (value, lowerLimit, upperLimit) => Math.max(lowerLimit, Math.min(upperLimit, value));
// The DPR we use for a "capped" scenario (see resolveDpr below):
const CAPPED_DEVICE_PIXEL_RATIO = 1;
/**
 * This helper analyzes the layout of the current page to decide if we should
 * use the natural device pixel ratio, or a capped value.
 *
 * We cap DPR if there is no meta viewport (suggesting that user is not
 * consciously specifying how to scale the viewport relative to the device
 * screen size).
 *
 * The rationale is that this condition typically leads to a pathological
 * outcome on mobile devices. When the window dimensions are scaled up on a
 * device with a high DPR, we create a canvas that is much larger than
 * appropriate to accommodate for the pixel density if we naively use the
 * reported DPR.
 *
 * This value needs to be measured in real time, as device pixel ratio can
 * change over time (e.g., when a user zooms the page). Also, in some cases
 * (such as Firefox on Android), the window's innerWidth is initially reported
 * as the same as the screen's availWidth but changes later.
 *
 * A user who specifies a meta viewport, thereby consciously creating scaling
 * conditions where <model-viewer> is slow, will be encouraged to live their
 * best life.
 */
const resolveDpr = (() => {
    // If true, implies that the user is conscious of the viewport scaling
    // relative to the device screen size.
    const HAS_META_VIEWPORT_TAG = (() => {
        var _a;
        // Search result pages sometimes do not include a meta viewport tag even
        // though they are certainly modern and work properly with devicePixelRatio.
        if ((_a = document.documentElement.getAttribute('itemtype')) === null || _a === void 0 ? void 0 : _a.includes('schema.org/SearchResultsPage')) {
            return true;
        }
        const metas = document.head != null ?
            Array.from(document.head.querySelectorAll('meta')) :
            [];
        for (const meta of metas) {
            if (meta.name === 'viewport') {
                return true;
            }
        }
        return false;
    })();
    if (!HAS_META_VIEWPORT_TAG) {
        console.warn('No <meta name="viewport"> detected; <model-viewer> will cap pixel density at 1.');
    }
    return () => HAS_META_VIEWPORT_TAG ? window.devicePixelRatio :
        CAPPED_DEVICE_PIXEL_RATIO;
})();
/**
 * Debug mode is enabled when one of the two following conditions is true:
 *
 *  1. A 'model-viewer-debug-mode' query parameter is present in the current
 *     search string
 *  2. There is a global object ModelViewerElement with a debugMode property set
 *     to true
 */
const isDebugMode = (() => {
    const debugQueryParameterName = 'model-viewer-debug-mode';
    const debugQueryParameter = new RegExp(`[?&]${debugQueryParameterName}(&|$)`);
    return () => (self.ModelViewerElement &&
        self.ModelViewerElement.debugMode) ||
        (self.location && self.location.search &&
            self.location.search.match(debugQueryParameter));
})();
/**
 * Returns the first key in a Map in iteration order.
 *
 * NOTE(cdata): This is necessary because IE11 does not implement iterator
 * methods of Map, and polymer-build does not polyfill these methods for
 * compatibility and performance reasons. This helper proposes that it is
 * a reasonable compromise to sacrifice a very small amount of runtime
 * performance in IE11 for the sake of code clarity.
 */
const getFirstMapKey = (map) => {
    if (map.keys != null) {
        return map.keys().next().value || null;
    }
    let firstKey = null;
    try {
        map.forEach((_value, key, _map) => {
            firstKey = key;
            // Stop iterating the Map with forEach:
            throw new Error();
        });
    }
    catch (_error) {
    }
    return firstKey;
};
const timePasses = (ms = 0) => new Promise(resolve => setTimeout(resolve, ms));
/**
 * @param {EventTarget|EventDispatcher} target
 * @param {string} eventName
 * @param {?Function} predicate
 */
const waitForEvent = (target, eventName, predicate = null) => new Promise(resolve => {
    function handler(event) {
        if (!predicate || predicate(event)) {
            resolve(event);
            target.removeEventListener(eventName, handler);
        }
    }
    target.addEventListener(eventName, handler);
});
//# sourceMappingURL=utilities.js.map

/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/utilities/animation.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/utilities/animation.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "easeInOutQuad": () => (/* binding */ easeInOutQuad),
/* harmony export */   "interpolate": () => (/* binding */ interpolate),
/* harmony export */   "sequence": () => (/* binding */ sequence),
/* harmony export */   "timeline": () => (/* binding */ timeline)
/* harmony export */ });
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utilities */ "../../node_modules/@google/model-viewer/lib/utilities.js");
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Adapted from https://gist.github.com/gre/1650294
const easeInOutQuad = (t) => t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
/**
 * Creates a TimingFunction that uses a given ease to interpolate between
 * two configured number values.
 */
const interpolate = (start, end, ease = easeInOutQuad) => (time) => start + (end - start) * ease(time);
/**
 * Creates a TimingFunction that interpolates through a weighted list
 * of other TimingFunctions ("tracks"). Tracks are interpolated in order, and
 * allocated a percentage of the total time based on their relative weight.
 */
const sequence = (tracks, weights) => {
    const cumulativeSum = ((sum) => (value) => sum += value);
    const times = weights.map(cumulativeSum(0));
    return (time) => {
        time = (0,_utilities__WEBPACK_IMPORTED_MODULE_0__.clamp)(time, 0, 1);
        time *= times[times.length - 1];
        const i = times.findIndex((val) => val >= time);
        const start = i < 1 ? 0 : times[i - 1];
        const end = times[i];
        return tracks[i]((time - start) / (end - start));
    };
};
/**
 * Creates a "timeline" TimingFunction out of an initial value and a series of
 * Keyframes. The timeline function accepts value from 0-1 and returns the
 * current value based on keyframe interpolation across the total number of
 * frames. Frames are only used to indicate the relative length of each keyframe
 * transition, so interpolated values will be computed for fractional frames.
 */
const timeline = (path) => {
    const tracks = [];
    const weights = [];
    let lastValue = path.initialValue;
    for (let i = 0; i < path.keyframes.length; ++i) {
        const keyframe = path.keyframes[i];
        const { value, frames } = keyframe;
        const ease = keyframe.ease || easeInOutQuad;
        const track = interpolate(lastValue, value, ease);
        tracks.push(track);
        weights.push(frames);
        lastValue = value;
    }
    return sequence(tracks, weights);
};
//# sourceMappingURL=animation.js.map

/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/utilities/cache-eviction-policy.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/utilities/cache-eviction-policy.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CacheEvictionPolicy": () => (/* binding */ CacheEvictionPolicy)
/* harmony export */ });
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var _a, _b;
const $retainerCount = Symbol('retainerCount');
const $recentlyUsed = Symbol('recentlyUsed');
const $evict = Symbol('evict');
const $evictionThreshold = Symbol('evictionThreshold');
const $cache = Symbol('cache');
/**
 * The CacheEvictionPolicy manages the lifecycle for items in a cache,
 * evicting any items outside some threshold bounds in "recently used" order,
 * if they are evictable.
 *
 * Items are considered cached as they are retained. When all retainers
 * of an item release it, that item is considered evictable.
 */
class CacheEvictionPolicy {
    constructor(cache, evictionThreshold = 5) {
        this[_a] = new Map();
        this[_b] = [];
        this[$cache] = cache;
        this[$evictionThreshold] = evictionThreshold;
    }
    /**
     * The eviction threshold is the maximum number of items to hold
     * in cache indefinitely. Items within the threshold (in recently
     * used order) will continue to be cached even if they have zero
     * retainers.
     */
    set evictionThreshold(value) {
        this[$evictionThreshold] = value;
        this[$evict]();
    }
    get evictionThreshold() {
        return this[$evictionThreshold];
    }
    /**
     * A reference to the cache that operates under this policy
     */
    get cache() {
        return this[$cache];
    }
    /**
     * Given an item key, returns the number of retainers of that item
     */
    retainerCount(key) {
        return this[$retainerCount].get(key) || 0;
    }
    /**
     * Resets the internal tracking of cache item retainers. Use only in cases
     * where it is certain that all retained cache items have been accounted for!
     */
    reset() {
        this[$retainerCount].clear();
        this[$recentlyUsed] = [];
    }
    /**
     * Mark a given cache item as retained, where the item is represented
     * by its key. An item can have any number of retainers.
     */
    retain(key) {
        if (!this[$retainerCount].has(key)) {
            this[$retainerCount].set(key, 0);
        }
        this[$retainerCount].set(key, this[$retainerCount].get(key) + 1);
        const recentlyUsedIndex = this[$recentlyUsed].indexOf(key);
        if (recentlyUsedIndex !== -1) {
            this[$recentlyUsed].splice(recentlyUsedIndex, 1);
        }
        this[$recentlyUsed].unshift(key);
        // Evict, in case retaining a new item pushed an evictable item beyond the
        // eviction threshold
        this[$evict]();
    }
    /**
     * Mark a given cache item as released by one of its retainers, where the item
     * is represented by its key. When all retainers of an item have released it,
     * the item is considered evictable.
     */
    release(key) {
        if (this[$retainerCount].has(key)) {
            this[$retainerCount].set(key, Math.max(this[$retainerCount].get(key) - 1, 0));
        }
        this[$evict]();
    }
    [(_a = $retainerCount, _b = $recentlyUsed, $evict)]() {
        if (this[$recentlyUsed].length < this[$evictionThreshold]) {
            return;
        }
        for (let i = this[$recentlyUsed].length - 1; i >= this[$evictionThreshold]; --i) {
            const key = this[$recentlyUsed][i];
            const retainerCount = this[$retainerCount].get(key);
            if (retainerCount === 0) {
                this[$cache].delete(key);
                this[$recentlyUsed].splice(i, 1);
            }
        }
    }
}
//# sourceMappingURL=cache-eviction-policy.js.map

/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/utilities/data-conversion.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/utilities/data-conversion.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "dataUrlToBlob": () => (/* binding */ dataUrlToBlob)
/* harmony export */ });
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Converts a base64 string which represents a data url
 * into a Blob of the same contents.
 */
const dataUrlToBlob = async (base64DataUrl) => {
    return new Promise((resolve, reject) => {
        const sliceSize = 512;
        const typeMatch = base64DataUrl.match(/data:(.*);/);
        if (!typeMatch) {
            return reject(new Error(`${base64DataUrl} is not a valid data Url`));
        }
        const type = typeMatch[1];
        const base64 = base64DataUrl.replace(/data:image\/\w+;base64,/, '');
        const byteCharacters = atob(base64);
        const byteArrays = [];
        for (let offset = 0; offset < byteCharacters.length; offset += sliceSize) {
            const slice = byteCharacters.slice(offset, offset + sliceSize);
            const byteNumbers = new Array(slice.length);
            for (let i = 0; i < slice.length; i++) {
                byteNumbers[i] = slice.charCodeAt(i);
            }
            const byteArray = new Uint8Array(byteNumbers);
            byteArrays.push(byteArray);
        }
        resolve(new Blob(byteArrays, { type }));
    });
};
//# sourceMappingURL=data-conversion.js.map

/***/ }),

/***/ "../../node_modules/@google/model-viewer/lib/utilities/progress-tracker.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/@google/model-viewer/lib/utilities/progress-tracker.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ProgressTracker": () => (/* binding */ ProgressTracker)
/* harmony export */ });
/* harmony import */ var _utilities_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utilities.js */ "../../node_modules/@google/model-viewer/lib/utilities.js");
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * ProgressTracker is an event emitter that helps to track the ongoing progress
 * of many simultaneous actions.
 *
 * ProgressTracker reports progress activity in the form of a progress event.
 * The event.detail.totalProgress value indicates the elapsed progress of all
 * activities being tracked by the ProgressTracker.
 *
 * The value of totalProgress is a number that progresses from 0 to 1. The
 * ProgressTracker allows for the lazy accumulation of tracked actions, so the
 * total progress represents a abstract, non-absolute progress towards the
 * completion of all currently tracked events.
 *
 * When all currently tracked activities are finished, the ProgressTracker
 * emits one final progress event and then resets the list of its currently
 * tracked activities. This means that from an observer's perspective,
 * ongoing activities will accumulate and collectively contribute to the notion
 * of total progress until all currently tracked ongoing activities have
 * completed.
 */
class ProgressTracker extends EventTarget {
    constructor() {
        super(...arguments);
        this.ongoingActivities = new Set();
        this.totalProgress = 0;
    }
    /**
     * The total number of activities currently being tracked.
     */
    get ongoingActivityCount() {
        return this.ongoingActivities.size;
    }
    /**
     * Registers a new activity to be tracked by the progress tracker. The method
     * returns a special callback that should be invoked whenever new progress is
     * ready to be reported. The progress should be reported as a value between 0
     * and 1, where 0 would represent the beginning of the action and 1 would
     * represent its completion.
     *
     * There is no built-in notion of a time-out for ongoing activities, so once
     * an ongoing activity is begun, it is up to the consumer of this API to
     * update the progress until that activity is no longer ongoing.
     *
     * Progress is only allowed to move forward for any given activity. If a lower
     * progress is reported than the previously reported progress, it will be
     * ignored.
     */
    beginActivity() {
        const activity = { progress: 0, completed: false };
        this.ongoingActivities.add(activity);
        if (this.ongoingActivityCount === 1) {
            // Announce the first progress event (which should always be 0 / 1
            // total progress):
            this.announceTotalProgress(activity, 0);
        }
        return (progress) => {
            let nextProgress;
            nextProgress = Math.max((0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.clamp)(progress, 0, 1), activity.progress);
            if (nextProgress !== activity.progress) {
                this.announceTotalProgress(activity, nextProgress);
            }
            return activity.progress;
        };
    }
    announceTotalProgress(updatedActivity, nextProgress) {
        let progressLeft = 0;
        let completedActivities = 0;
        if (nextProgress == 1.0)
            updatedActivity.completed = true;
        for (const activity of this.ongoingActivities) {
            const { progress } = activity;
            progressLeft += 1.0 - progress;
            if (activity.completed === true) {
                completedActivities++;
            }
        }
        const lastProgress = updatedActivity.progress;
        updatedActivity.progress = nextProgress;
        // Advance the total progress by the fraction of total remaining progress
        // due to this activity.
        this.totalProgress += (nextProgress - lastProgress) *
            (1.0 - this.totalProgress) / progressLeft;
        const totalProgress = completedActivities === this.ongoingActivityCount ?
            1.0 :
            this.totalProgress;
        this.dispatchEvent(new CustomEvent('progress', { detail: { totalProgress } }));
        if (completedActivities === this.ongoingActivityCount) {
            this.totalProgress = 0.0;
            this.ongoingActivities.clear();
        }
    }
}
//# sourceMappingURL=progress-tracker.js.map

/***/ }),

/***/ "../../node_modules/dom-align/dist-web/index.js":
/*!******************************************************!*\
  !*** ../../node_modules/dom-align/dist-web/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "alignElement": () => (/* binding */ alignElement),
/* harmony export */   "alignPoint": () => (/* binding */ alignPoint),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

var vendorPrefix;
var jsCssMap = {
  Webkit: '-webkit-',
  Moz: '-moz-',
  // IE did it wrong again ...
  ms: '-ms-',
  O: '-o-'
};
function getVendorPrefix() {
  if (vendorPrefix !== undefined) {
    return vendorPrefix;
  }
  vendorPrefix = '';
  var style = document.createElement('p').style;
  var testProp = 'Transform';
  for (var key in jsCssMap) {
    if (key + testProp in style) {
      vendorPrefix = key;
    }
  }
  return vendorPrefix;
}
function getTransitionName() {
  return getVendorPrefix() ? "".concat(getVendorPrefix(), "TransitionProperty") : 'transitionProperty';
}
function getTransformName() {
  return getVendorPrefix() ? "".concat(getVendorPrefix(), "Transform") : 'transform';
}
function setTransitionProperty(node, value) {
  var name = getTransitionName();
  if (name) {
    node.style[name] = value;
    if (name !== 'transitionProperty') {
      node.style.transitionProperty = value;
    }
  }
}
function setTransform(node, value) {
  var name = getTransformName();
  if (name) {
    node.style[name] = value;
    if (name !== 'transform') {
      node.style.transform = value;
    }
  }
}
function getTransitionProperty(node) {
  return node.style.transitionProperty || node.style[getTransitionName()];
}
function getTransformXY(node) {
  var style = window.getComputedStyle(node, null);
  var transform = style.getPropertyValue('transform') || style.getPropertyValue(getTransformName());
  if (transform && transform !== 'none') {
    var matrix = transform.replace(/[^0-9\-.,]/g, '').split(',');
    return {
      x: parseFloat(matrix[12] || matrix[4], 0),
      y: parseFloat(matrix[13] || matrix[5], 0)
    };
  }
  return {
    x: 0,
    y: 0
  };
}
var matrix2d = /matrix\((.*)\)/;
var matrix3d = /matrix3d\((.*)\)/;
function setTransformXY(node, xy) {
  var style = window.getComputedStyle(node, null);
  var transform = style.getPropertyValue('transform') || style.getPropertyValue(getTransformName());
  if (transform && transform !== 'none') {
    var arr;
    var match2d = transform.match(matrix2d);
    if (match2d) {
      match2d = match2d[1];
      arr = match2d.split(',').map(function (item) {
        return parseFloat(item, 10);
      });
      arr[4] = xy.x;
      arr[5] = xy.y;
      setTransform(node, "matrix(".concat(arr.join(','), ")"));
    } else {
      var match3d = transform.match(matrix3d)[1];
      arr = match3d.split(',').map(function (item) {
        return parseFloat(item, 10);
      });
      arr[12] = xy.x;
      arr[13] = xy.y;
      setTransform(node, "matrix3d(".concat(arr.join(','), ")"));
    }
  } else {
    setTransform(node, "translateX(".concat(xy.x, "px) translateY(").concat(xy.y, "px) translateZ(0)"));
  }
}

var RE_NUM = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source;
var getComputedStyleX;

// https://stackoverflow.com/a/3485654/3040605
function forceRelayout(elem) {
  var originalStyle = elem.style.display;
  elem.style.display = 'none';
  elem.offsetHeight; // eslint-disable-line
  elem.style.display = originalStyle;
}
function css(el, name, v) {
  var value = v;
  if (_typeof(name) === 'object') {
    for (var i in name) {
      if (name.hasOwnProperty(i)) {
        css(el, i, name[i]);
      }
    }
    return undefined;
  }
  if (typeof value !== 'undefined') {
    if (typeof value === 'number') {
      value = "".concat(value, "px");
    }
    el.style[name] = value;
    return undefined;
  }
  return getComputedStyleX(el, name);
}
function getClientPosition(elem) {
  var box;
  var x;
  var y;
  var doc = elem.ownerDocument;
  var body = doc.body;
  var docElem = doc && doc.documentElement;
  //  GBS A-Grade Browsers  getBoundingClientRect 
  box = elem.getBoundingClientRect();

  // jQuery  docElem.clientLeft/clientTop
  //  html  body /
  // ie6  html  margin  html  margin

  x = Math.floor(box.left);
  y = Math.floor(box.top);

  // In IE, most of the time, 2 extra pixels are added to the top and left
  // due to the implicit 2-pixel inset border.  In IE6/7 quirks mode and
  // IE6 standards mode, this border can be overridden by setting the
  // document element's border to zero -- thus, we cannot rely on the
  // offset always being 2 pixels.

  // In quirks mode, the offset can be determined by querying the body's
  // clientLeft/clientTop, but in standards mode, it is found by querying
  // the document element's clientLeft/clientTop.  Since we already called
  // getClientBoundingRect we have already forced a reflow, so it is not
  // too expensive just to query them all.

  // ie  absolute 
  //  documentElement ,quirks  body
  //  body  html   ie < 9 html  2px 
  //  ie body html  ,ie  html,body 
  //  ie  docElem.clientTop  border-top
  // ie7 html  2
  //  firefox/chrome/ie9  docElem.clientTop  border-top  0

  x -= docElem.clientLeft || body.clientLeft || 0;
  y -= docElem.clientTop || body.clientTop || 0;
  return {
    left: x,
    top: y
  };
}
function getScroll(w, top) {
  var ret = w["page".concat(top ? 'Y' : 'X', "Offset")];
  var method = "scroll".concat(top ? 'Top' : 'Left');
  if (typeof ret !== 'number') {
    var d = w.document;
    // ie6,7,8 standard mode
    ret = d.documentElement[method];
    if (typeof ret !== 'number') {
      // quirks mode
      ret = d.body[method];
    }
  }
  return ret;
}
function getScrollLeft(w) {
  return getScroll(w);
}
function getScrollTop(w) {
  return getScroll(w, true);
}
function getOffset(el) {
  var pos = getClientPosition(el);
  var doc = el.ownerDocument;
  var w = doc.defaultView || doc.parentWindow;
  pos.left += getScrollLeft(w);
  pos.top += getScrollTop(w);
  return pos;
}

/**
 * A crude way of determining if an object is a window
 * @member util
 */
function isWindow(obj) {
  // must use == for ie8
  /* eslint eqeqeq:0 */
  return obj !== null && obj !== undefined && obj == obj.window;
}
function getDocument(node) {
  if (isWindow(node)) {
    return node.document;
  }
  if (node.nodeType === 9) {
    return node;
  }
  return node.ownerDocument;
}
function _getComputedStyle(elem, name, cs) {
  var computedStyle = cs;
  var val = '';
  var d = getDocument(elem);
  computedStyle = computedStyle || d.defaultView.getComputedStyle(elem, null);

  // https://github.com/kissyteam/kissy/issues/61
  if (computedStyle) {
    val = computedStyle.getPropertyValue(name) || computedStyle[name];
  }
  return val;
}
var _RE_NUM_NO_PX = new RegExp("^(".concat(RE_NUM, ")(?!px)[a-z%]+$"), 'i');
var RE_POS = /^(top|right|bottom|left)$/;
var CURRENT_STYLE = 'currentStyle';
var RUNTIME_STYLE = 'runtimeStyle';
var LEFT = 'left';
var PX = 'px';
function _getComputedStyleIE(elem, name) {
  // currentStyle maybe null
  // http://msdn.microsoft.com/en-us/library/ms535231.aspx
  var ret = elem[CURRENT_STYLE] && elem[CURRENT_STYLE][name];

  //  width/height  pixelLeft  width/height 
  // ! CUSTOM_STYLE.height,CUSTOM_STYLE.width ,cssHook @2011-08-19
  //  ie  offset 
  // borderWidth  borderWidth 

  // From the awesome hack by Dean Edwards
  // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291
  // If we're not dealing with a regular pixel number
  // but a number that has a weird ending, we need to convert it to pixels
  // exclude left right for relativity
  if (_RE_NUM_NO_PX.test(ret) && !RE_POS.test(name)) {
    // Remember the original values
    var style = elem.style;
    var left = style[LEFT];
    var rsLeft = elem[RUNTIME_STYLE][LEFT];

    // prevent flashing of content
    elem[RUNTIME_STYLE][LEFT] = elem[CURRENT_STYLE][LEFT];

    // Put in the new values to get a computed value out
    style[LEFT] = name === 'fontSize' ? '1em' : ret || 0;
    ret = style.pixelLeft + PX;

    // Revert the changed values
    style[LEFT] = left;
    elem[RUNTIME_STYLE][LEFT] = rsLeft;
  }
  return ret === '' ? 'auto' : ret;
}
if (typeof window !== 'undefined') {
  getComputedStyleX = window.getComputedStyle ? _getComputedStyle : _getComputedStyleIE;
}
function getOffsetDirection(dir, option) {
  if (dir === 'left') {
    return option.useCssRight ? 'right' : dir;
  }
  return option.useCssBottom ? 'bottom' : dir;
}
function oppositeOffsetDirection(dir) {
  if (dir === 'left') {
    return 'right';
  } else if (dir === 'right') {
    return 'left';
  } else if (dir === 'top') {
    return 'bottom';
  } else if (dir === 'bottom') {
    return 'top';
  }
}

//  elem  elem.ownerDocument 
function setLeftTop(elem, offset, option) {
  // set position first, in-case top/left are set even on static elem
  if (css(elem, 'position') === 'static') {
    elem.style.position = 'relative';
  }
  var presetH = -999;
  var presetV = -999;
  var horizontalProperty = getOffsetDirection('left', option);
  var verticalProperty = getOffsetDirection('top', option);
  var oppositeHorizontalProperty = oppositeOffsetDirection(horizontalProperty);
  var oppositeVerticalProperty = oppositeOffsetDirection(verticalProperty);
  if (horizontalProperty !== 'left') {
    presetH = 999;
  }
  if (verticalProperty !== 'top') {
    presetV = 999;
  }
  var originalTransition = '';
  var originalOffset = getOffset(elem);
  if ('left' in offset || 'top' in offset) {
    originalTransition = getTransitionProperty(elem) || '';
    setTransitionProperty(elem, 'none');
  }
  if ('left' in offset) {
    elem.style[oppositeHorizontalProperty] = '';
    elem.style[horizontalProperty] = "".concat(presetH, "px");
  }
  if ('top' in offset) {
    elem.style[oppositeVerticalProperty] = '';
    elem.style[verticalProperty] = "".concat(presetV, "px");
  }
  // force relayout
  forceRelayout(elem);
  var old = getOffset(elem);
  var originalStyle = {};
  for (var key in offset) {
    if (offset.hasOwnProperty(key)) {
      var dir = getOffsetDirection(key, option);
      var preset = key === 'left' ? presetH : presetV;
      var off = originalOffset[key] - old[key];
      if (dir === key) {
        originalStyle[dir] = preset + off;
      } else {
        originalStyle[dir] = preset - off;
      }
    }
  }
  css(elem, originalStyle);
  // force relayout
  forceRelayout(elem);
  if ('left' in offset || 'top' in offset) {
    setTransitionProperty(elem, originalTransition);
  }
  var ret = {};
  for (var _key in offset) {
    if (offset.hasOwnProperty(_key)) {
      var _dir = getOffsetDirection(_key, option);
      var _off = offset[_key] - originalOffset[_key];
      if (_key === _dir) {
        ret[_dir] = originalStyle[_dir] + _off;
      } else {
        ret[_dir] = originalStyle[_dir] - _off;
      }
    }
  }
  css(elem, ret);
}
function setTransform$1(elem, offset) {
  var originalOffset = getOffset(elem);
  var originalXY = getTransformXY(elem);
  var resultXY = {
    x: originalXY.x,
    y: originalXY.y
  };
  if ('left' in offset) {
    resultXY.x = originalXY.x + offset.left - originalOffset.left;
  }
  if ('top' in offset) {
    resultXY.y = originalXY.y + offset.top - originalOffset.top;
  }
  setTransformXY(elem, resultXY);
}
function setOffset(elem, offset, option) {
  if (option.ignoreShake) {
    var oriOffset = getOffset(elem);
    var oLeft = oriOffset.left.toFixed(0);
    var oTop = oriOffset.top.toFixed(0);
    var tLeft = offset.left.toFixed(0);
    var tTop = offset.top.toFixed(0);
    if (oLeft === tLeft && oTop === tTop) {
      return;
    }
  }
  if (option.useCssRight || option.useCssBottom) {
    setLeftTop(elem, offset, option);
  } else if (option.useCssTransform && getTransformName() in document.body.style) {
    setTransform$1(elem, offset);
  } else {
    setLeftTop(elem, offset, option);
  }
}
function each(arr, fn) {
  for (var i = 0; i < arr.length; i++) {
    fn(arr[i]);
  }
}
function isBorderBoxFn(elem) {
  return getComputedStyleX(elem, 'boxSizing') === 'border-box';
}
var BOX_MODELS = ['margin', 'border', 'padding'];
var CONTENT_INDEX = -1;
var PADDING_INDEX = 2;
var BORDER_INDEX = 1;
var MARGIN_INDEX = 0;
function swap(elem, options, callback) {
  var old = {};
  var style = elem.style;
  var name;

  // Remember the old values, and insert the new ones
  for (name in options) {
    if (options.hasOwnProperty(name)) {
      old[name] = style[name];
      style[name] = options[name];
    }
  }
  callback.call(elem);

  // Revert the old values
  for (name in options) {
    if (options.hasOwnProperty(name)) {
      style[name] = old[name];
    }
  }
}
function getPBMWidth(elem, props, which) {
  var value = 0;
  var prop;
  var j;
  var i;
  for (j = 0; j < props.length; j++) {
    prop = props[j];
    if (prop) {
      for (i = 0; i < which.length; i++) {
        var cssProp = void 0;
        if (prop === 'border') {
          cssProp = "".concat(prop).concat(which[i], "Width");
        } else {
          cssProp = prop + which[i];
        }
        value += parseFloat(getComputedStyleX(elem, cssProp)) || 0;
      }
    }
  }
  return value;
}
var domUtils = {
  getParent: function getParent(element) {
    var parent = element;
    do {
      if (parent.nodeType === 11 && parent.host) {
        parent = parent.host;
      } else {
        parent = parent.parentNode;
      }
    } while (parent && parent.nodeType !== 1 && parent.nodeType !== 9);
    return parent;
  }
};
each(['Width', 'Height'], function (name) {
  domUtils["doc".concat(name)] = function (refWin) {
    var d = refWin.document;
    return Math.max(
    // firefox chrome documentElement.scrollHeight< body.scrollHeight
    // ie standard mode : documentElement.scrollHeight> body.scrollHeight
    d.documentElement["scroll".concat(name)],
    // quirks : documentElement.scrollHeight 
    d.body["scroll".concat(name)], domUtils["viewport".concat(name)](d));
  };
  domUtils["viewport".concat(name)] = function (win) {
    // pc browser includes scrollbar in window.innerWidth
    var prop = "client".concat(name);
    var doc = win.document;
    var body = doc.body;
    var documentElement = doc.documentElement;
    var documentElementProp = documentElement[prop];
    //  documentElement
    // backcompat  body
    return doc.compatMode === 'CSS1Compat' && documentElementProp || body && body[prop] || documentElementProp;
  };
});

/*
 
 @param elem
 @param name
 @param {String} [extra]  'padding' : (css width) + padding
 'border' : (css width) + padding + border
 'margin' : (css width) + padding + border + margin
 */
function getWH(elem, name, ex) {
  var extra = ex;
  if (isWindow(elem)) {
    return name === 'width' ? domUtils.viewportWidth(elem) : domUtils.viewportHeight(elem);
  } else if (elem.nodeType === 9) {
    return name === 'width' ? domUtils.docWidth(elem) : domUtils.docHeight(elem);
  }
  var which = name === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'];
  var borderBoxValue = name === 'width' ? Math.floor(elem.getBoundingClientRect().width) : Math.floor(elem.getBoundingClientRect().height);
  var isBorderBox = isBorderBoxFn(elem);
  var cssBoxValue = 0;
  if (borderBoxValue === null || borderBoxValue === undefined || borderBoxValue <= 0) {
    borderBoxValue = undefined;
    // Fall back to computed then un computed css if necessary
    cssBoxValue = getComputedStyleX(elem, name);
    if (cssBoxValue === null || cssBoxValue === undefined || Number(cssBoxValue) < 0) {
      cssBoxValue = elem.style[name] || 0;
    }
    // Normalize '', auto, and prepare for extra
    cssBoxValue = Math.floor(parseFloat(cssBoxValue)) || 0;
  }
  if (extra === undefined) {
    extra = isBorderBox ? BORDER_INDEX : CONTENT_INDEX;
  }
  var borderBoxValueOrIsBorderBox = borderBoxValue !== undefined || isBorderBox;
  var val = borderBoxValue || cssBoxValue;
  if (extra === CONTENT_INDEX) {
    if (borderBoxValueOrIsBorderBox) {
      return val - getPBMWidth(elem, ['border', 'padding'], which);
    }
    return cssBoxValue;
  } else if (borderBoxValueOrIsBorderBox) {
    if (extra === BORDER_INDEX) {
      return val;
    }
    return val + (extra === PADDING_INDEX ? -getPBMWidth(elem, ['border'], which) : getPBMWidth(elem, ['margin'], which));
  }
  return cssBoxValue + getPBMWidth(elem, BOX_MODELS.slice(extra), which);
}
var cssShow = {
  position: 'absolute',
  visibility: 'hidden',
  display: 'block'
};

// fix #119 : https://github.com/kissyteam/kissy/issues/119
function getWHIgnoreDisplay() {
  for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
    args[_key2] = arguments[_key2];
  }
  var val;
  var elem = args[0];
  // in case elem is window
  // elem.offsetWidth === undefined
  if (elem.offsetWidth !== 0) {
    val = getWH.apply(undefined, args);
  } else {
    swap(elem, cssShow, function () {
      val = getWH.apply(undefined, args);
    });
  }
  return val;
}
each(['width', 'height'], function (name) {
  var first = name.charAt(0).toUpperCase() + name.slice(1);
  domUtils["outer".concat(first)] = function (el, includeMargin) {
    return el && getWHIgnoreDisplay(el, name, includeMargin ? MARGIN_INDEX : BORDER_INDEX);
  };
  var which = name === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'];
  domUtils[name] = function (elem, v) {
    var val = v;
    if (val !== undefined) {
      if (elem) {
        var isBorderBox = isBorderBoxFn(elem);
        if (isBorderBox) {
          val += getPBMWidth(elem, ['padding', 'border'], which);
        }
        return css(elem, name, val);
      }
      return undefined;
    }
    return elem && getWHIgnoreDisplay(elem, name, CONTENT_INDEX);
  };
});
function mix(to, from) {
  for (var i in from) {
    if (from.hasOwnProperty(i)) {
      to[i] = from[i];
    }
  }
  return to;
}
var utils = {
  getWindow: function getWindow(node) {
    if (node && node.document && node.setTimeout) {
      return node;
    }
    var doc = node.ownerDocument || node;
    return doc.defaultView || doc.parentWindow;
  },
  getDocument: getDocument,
  offset: function offset(el, value, option) {
    if (typeof value !== 'undefined') {
      setOffset(el, value, option || {});
    } else {
      return getOffset(el);
    }
  },
  isWindow: isWindow,
  each: each,
  css: css,
  clone: function clone(obj) {
    var i;
    var ret = {};
    for (i in obj) {
      if (obj.hasOwnProperty(i)) {
        ret[i] = obj[i];
      }
    }
    var overflow = obj.overflow;
    if (overflow) {
      for (i in obj) {
        if (obj.hasOwnProperty(i)) {
          ret.overflow[i] = obj.overflow[i];
        }
      }
    }
    return ret;
  },
  mix: mix,
  getWindowScrollLeft: function getWindowScrollLeft(w) {
    return getScrollLeft(w);
  },
  getWindowScrollTop: function getWindowScrollTop(w) {
    return getScrollTop(w);
  },
  merge: function merge() {
    var ret = {};
    for (var i = 0; i < arguments.length; i++) {
      utils.mix(ret, i < 0 || arguments.length <= i ? undefined : arguments[i]);
    }
    return ret;
  },
  viewportWidth: 0,
  viewportHeight: 0
};
mix(utils, domUtils);

/**
 * 
 */
var getParent = utils.getParent;
function getOffsetParent(element) {
  if (utils.isWindow(element) || element.nodeType === 9) {
    return null;
  }
  // ie 
  /*
   <div style="width: 50px;height: 100px;overflow: hidden">
   <div style="width: 50px;height: 100px;position: relative;" id="d6">
    6  100px  50px<br/>
   </div>
   </div>
   */
  // element.offsetParent does the right thing in ie7 and below. Return parent with layout!
  //  In other browsers it only includes elements with position absolute, relative or
  // fixed, not elements with overflow set to auto or scroll.
  //        if (UA.ie && ieMode < 8) {
  //            return element.offsetParent;
  //        }
  //  offsetParent 
  var doc = utils.getDocument(element);
  var body = doc.body;
  var parent;
  var positionStyle = utils.css(element, 'position');
  var skipStatic = positionStyle === 'fixed' || positionStyle === 'absolute';
  if (!skipStatic) {
    return element.nodeName.toLowerCase() === 'html' ? null : getParent(element);
  }
  for (parent = getParent(element); parent && parent !== body && parent.nodeType !== 9; parent = getParent(parent)) {
    positionStyle = utils.css(parent, 'position');
    if (positionStyle !== 'static') {
      return parent;
    }
  }
  return null;
}

var getParent$1 = utils.getParent;
function isAncestorFixed(element) {
  if (utils.isWindow(element) || element.nodeType === 9) {
    return false;
  }
  var doc = utils.getDocument(element);
  var body = doc.body;
  var parent = null;
  for (parent = getParent$1(element);
  //  document.documentElement 
  parent && parent !== body && parent !== doc; parent = getParent$1(parent)) {
    var positionStyle = utils.css(parent, 'position');
    if (positionStyle === 'fixed') {
      return true;
    }
  }
  return false;
}

/**
 * 
 */
function getVisibleRectForElement(element, alwaysByViewport) {
  var visibleRect = {
    left: 0,
    right: Infinity,
    top: 0,
    bottom: Infinity
  };
  var el = getOffsetParent(element);
  var doc = utils.getDocument(element);
  var win = doc.defaultView || doc.parentWindow;
  var body = doc.body;
  var documentElement = doc.documentElement;

  // Determine the size of the visible rect by climbing the dom accounting for
  // all scrollable containers.
  while (el) {
    // clientWidth is zero for inline block elements in ie.
    if ((navigator.userAgent.indexOf('MSIE') === -1 || el.clientWidth !== 0) &&
    // body may have overflow set on it, yet we still get the entire
    // viewport. In some browsers, el.offsetParent may be
    // document.documentElement, so check for that too.
    el !== body && el !== documentElement && utils.css(el, 'overflow') !== 'visible') {
      var pos = utils.offset(el);
      // add border
      pos.left += el.clientLeft;
      pos.top += el.clientTop;
      visibleRect.top = Math.max(visibleRect.top, pos.top);
      visibleRect.right = Math.min(visibleRect.right,
      // consider area without scrollBar
      pos.left + el.clientWidth);
      visibleRect.bottom = Math.min(visibleRect.bottom, pos.top + el.clientHeight);
      visibleRect.left = Math.max(visibleRect.left, pos.left);
    } else if (el === body || el === documentElement) {
      break;
    }
    el = getOffsetParent(el);
  }

  // Set element position to fixed
  // make sure absolute element itself don't affect it's visible area
  // https://github.com/ant-design/ant-design/issues/7601
  var originalPosition = null;
  if (!utils.isWindow(element) && element.nodeType !== 9) {
    originalPosition = element.style.position;
    var position = utils.css(element, 'position');
    if (position === 'absolute') {
      element.style.position = 'fixed';
    }
  }
  var scrollX = utils.getWindowScrollLeft(win);
  var scrollY = utils.getWindowScrollTop(win);
  var viewportWidth = utils.viewportWidth(win);
  var viewportHeight = utils.viewportHeight(win);
  var documentWidth = documentElement.scrollWidth;
  var documentHeight = documentElement.scrollHeight;

  // scrollXXX on html is sync with body which means overflow: hidden on body gets wrong scrollXXX.
  // We should cut this ourself.
  var bodyStyle = window.getComputedStyle(body);
  if (bodyStyle.overflowX === 'hidden') {
    documentWidth = win.innerWidth;
  }
  if (bodyStyle.overflowY === 'hidden') {
    documentHeight = win.innerHeight;
  }

  // Reset element position after calculate the visible area
  if (element.style) {
    element.style.position = originalPosition;
  }
  if (alwaysByViewport || isAncestorFixed(element)) {
    // Clip by viewport's size.
    visibleRect.left = Math.max(visibleRect.left, scrollX);
    visibleRect.top = Math.max(visibleRect.top, scrollY);
    visibleRect.right = Math.min(visibleRect.right, scrollX + viewportWidth);
    visibleRect.bottom = Math.min(visibleRect.bottom, scrollY + viewportHeight);
  } else {
    // Clip by document's size.
    var maxVisibleWidth = Math.max(documentWidth, scrollX + viewportWidth);
    visibleRect.right = Math.min(visibleRect.right, maxVisibleWidth);
    var maxVisibleHeight = Math.max(documentHeight, scrollY + viewportHeight);
    visibleRect.bottom = Math.min(visibleRect.bottom, maxVisibleHeight);
  }
  return visibleRect.top >= 0 && visibleRect.left >= 0 && visibleRect.bottom > visibleRect.top && visibleRect.right > visibleRect.left ? visibleRect : null;
}

function adjustForViewport(elFuturePos, elRegion, visibleRect, overflow) {
  var pos = utils.clone(elFuturePos);
  var size = {
    width: elRegion.width,
    height: elRegion.height
  };
  if (overflow.adjustX && pos.left < visibleRect.left) {
    pos.left = visibleRect.left;
  }

  // Left edge inside and right edge outside viewport, try to resize it.
  if (overflow.resizeWidth && pos.left >= visibleRect.left && pos.left + size.width > visibleRect.right) {
    size.width -= pos.left + size.width - visibleRect.right;
  }

  // Right edge outside viewport, try to move it.
  if (overflow.adjustX && pos.left + size.width > visibleRect.right) {
    // 
    pos.left = Math.max(visibleRect.right - size.width, visibleRect.left);
  }

  // Top edge outside viewport, try to move it.
  if (overflow.adjustY && pos.top < visibleRect.top) {
    pos.top = visibleRect.top;
  }

  // Top edge inside and bottom edge outside viewport, try to resize it.
  if (overflow.resizeHeight && pos.top >= visibleRect.top && pos.top + size.height > visibleRect.bottom) {
    size.height -= pos.top + size.height - visibleRect.bottom;
  }

  // Bottom edge outside viewport, try to move it.
  if (overflow.adjustY && pos.top + size.height > visibleRect.bottom) {
    // 
    pos.top = Math.max(visibleRect.bottom - size.height, visibleRect.top);
  }
  return utils.mix(pos, size);
}

function getRegion(node) {
  var offset;
  var w;
  var h;
  if (!utils.isWindow(node) && node.nodeType !== 9) {
    offset = utils.offset(node);
    w = utils.outerWidth(node);
    h = utils.outerHeight(node);
  } else {
    var win = utils.getWindow(node);
    offset = {
      left: utils.getWindowScrollLeft(win),
      top: utils.getWindowScrollTop(win)
    };
    w = utils.viewportWidth(win);
    h = utils.viewportHeight(win);
  }
  offset.width = w;
  offset.height = h;
  return offset;
}

/**
 *  node  align  
 */

function getAlignOffset(region, align) {
  var V = align.charAt(0);
  var H = align.charAt(1);
  var w = region.width;
  var h = region.height;
  var x = region.left;
  var y = region.top;
  if (V === 'c') {
    y += h / 2;
  } else if (V === 'b') {
    y += h;
  }
  if (H === 'c') {
    x += w / 2;
  } else if (H === 'r') {
    x += w;
  }
  return {
    left: x,
    top: y
  };
}

function getElFuturePos(elRegion, refNodeRegion, points, offset, targetOffset) {
  var p1 = getAlignOffset(refNodeRegion, points[1]);
  var p2 = getAlignOffset(elRegion, points[0]);
  var diff = [p2.left - p1.left, p2.top - p1.top];
  return {
    left: Math.round(elRegion.left - diff[0] + offset[0] - targetOffset[0]),
    top: Math.round(elRegion.top - diff[1] + offset[1] - targetOffset[1])
  };
}

/**
 * align dom node flexibly
 * @author yiminghe@gmail.com
 */

// http://yiminghe.iteye.com/blog/1124720

function isFailX(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.left < visibleRect.left || elFuturePos.left + elRegion.width > visibleRect.right;
}
function isFailY(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.top < visibleRect.top || elFuturePos.top + elRegion.height > visibleRect.bottom;
}
function isCompleteFailX(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.left > visibleRect.right || elFuturePos.left + elRegion.width < visibleRect.left;
}
function isCompleteFailY(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.top > visibleRect.bottom || elFuturePos.top + elRegion.height < visibleRect.top;
}
function flip(points, reg, map) {
  var ret = [];
  utils.each(points, function (p) {
    ret.push(p.replace(reg, function (m) {
      return map[m];
    }));
  });
  return ret;
}
function flipOffset(offset, index) {
  offset[index] = -offset[index];
  return offset;
}
function convertOffset(str, offsetLen) {
  var n;
  if (/%$/.test(str)) {
    n = parseInt(str.substring(0, str.length - 1), 10) / 100 * offsetLen;
  } else {
    n = parseInt(str, 10);
  }
  return n || 0;
}
function normalizeOffset(offset, el) {
  offset[0] = convertOffset(offset[0], el.width);
  offset[1] = convertOffset(offset[1], el.height);
}

/**
 * @param el
 * @param tgtRegion : { left, top, width, height }
 * @param align
 */
function doAlign(el, tgtRegion, align, isTgtRegionVisible) {
  var points = align.points;
  var offset = align.offset || [0, 0];
  var targetOffset = align.targetOffset || [0, 0];
  var overflow = align.overflow;
  var source = align.source || el;
  offset = [].concat(offset);
  targetOffset = [].concat(targetOffset);
  overflow = overflow || {};
  var newOverflowCfg = {};
  var fail = 0;
  var alwaysByViewport = !!(overflow && overflow.alwaysByViewport);
  // 
  var visibleRect = getVisibleRectForElement(source, alwaysByViewport);
  // , left/top/width/height
  var elRegion = getRegion(source);
  //  offset 
  normalizeOffset(offset, elRegion);
  normalizeOffset(targetOffset, tgtRegion);
  // 
  var elFuturePos = getElFuturePos(elRegion, tgtRegion, points, offset, targetOffset);
  // 
  var newElRegion = utils.merge(elRegion, elFuturePos);

  // 
  if (visibleRect && (overflow.adjustX || overflow.adjustY) && isTgtRegionVisible) {
    if (overflow.adjustX) {
      // 
      if (isFailX(elFuturePos, elRegion, visibleRect)) {
        // 
        var newPoints = flip(points, /[lr]/gi, {
          l: 'r',
          r: 'l'
        });
        // 
        var newOffset = flipOffset(offset, 0);
        var newTargetOffset = flipOffset(targetOffset, 0);
        var newElFuturePos = getElFuturePos(elRegion, tgtRegion, newPoints, newOffset, newTargetOffset);
        if (!isCompleteFailX(newElFuturePos, elRegion, visibleRect)) {
          fail = 1;
          points = newPoints;
          offset = newOffset;
          targetOffset = newTargetOffset;
        }
      }
    }
    if (overflow.adjustY) {
      // 
      if (isFailY(elFuturePos, elRegion, visibleRect)) {
        // 
        var _newPoints = flip(points, /[tb]/gi, {
          t: 'b',
          b: 't'
        });
        // 
        var _newOffset = flipOffset(offset, 1);
        var _newTargetOffset = flipOffset(targetOffset, 1);
        var _newElFuturePos = getElFuturePos(elRegion, tgtRegion, _newPoints, _newOffset, _newTargetOffset);
        if (!isCompleteFailY(_newElFuturePos, elRegion, visibleRect)) {
          fail = 1;
          points = _newPoints;
          offset = _newOffset;
          targetOffset = _newTargetOffset;
        }
      }
    }

    // 
    if (fail) {
      elFuturePos = getElFuturePos(elRegion, tgtRegion, points, offset, targetOffset);
      utils.mix(newElRegion, elFuturePos);
    }
    var isStillFailX = isFailX(elFuturePos, elRegion, visibleRect);
    var isStillFailY = isFailY(elFuturePos, elRegion, visibleRect);
    // 
    // 1. 
    if (isStillFailX || isStillFailY) {
      var _newPoints2 = points;

      // 
      if (isStillFailX) {
        _newPoints2 = flip(points, /[lr]/gi, {
          l: 'r',
          r: 'l'
        });
      }
      if (isStillFailY) {
        _newPoints2 = flip(points, /[tb]/gi, {
          t: 'b',
          b: 't'
        });
      }
      points = _newPoints2;
      offset = align.offset || [0, 0];
      targetOffset = align.targetOffset || [0, 0];
    }
    // 2. 
    newOverflowCfg.adjustX = overflow.adjustX && isStillFailX;
    newOverflowCfg.adjustY = overflow.adjustY && isStillFailY;

    // 
    if (newOverflowCfg.adjustX || newOverflowCfg.adjustY) {
      newElRegion = adjustForViewport(elFuturePos, elRegion, visibleRect, newOverflowCfg);
    }
  }

  // need judge to in case set fixed with in css on height auto element
  if (newElRegion.width !== elRegion.width) {
    utils.css(source, 'width', utils.width(source) + newElRegion.width - elRegion.width);
  }
  if (newElRegion.height !== elRegion.height) {
    utils.css(source, 'height', utils.height(source) + newElRegion.height - elRegion.height);
  }

  // https://github.com/kissyteam/kissy/issues/190
  //  left/top 
  //  <div 'relative'><el absolute></div>
  utils.offset(source, {
    left: newElRegion.left,
    top: newElRegion.top
  }, {
    useCssRight: align.useCssRight,
    useCssBottom: align.useCssBottom,
    useCssTransform: align.useCssTransform,
    ignoreShake: align.ignoreShake
  });
  return {
    points: points,
    offset: offset,
    targetOffset: targetOffset,
    overflow: newOverflowCfg
  };
}
/**
 *  2012-04-26 yiminghe@gmail.com
 *   - 
 *   -  resizeXX
 *
 *  2011-07-13 yiminghe@gmail.com note:
 *   - 
 **/

function isOutOfVisibleRect(target, alwaysByViewport) {
  var visibleRect = getVisibleRectForElement(target, alwaysByViewport);
  var targetRegion = getRegion(target);
  return !visibleRect || targetRegion.left + targetRegion.width <= visibleRect.left || targetRegion.top + targetRegion.height <= visibleRect.top || targetRegion.left >= visibleRect.right || targetRegion.top >= visibleRect.bottom;
}
function alignElement(el, refNode, align) {
  var target = align.target || refNode;
  var refNodeRegion = getRegion(target);
  var isTargetNotOutOfVisible = !isOutOfVisibleRect(target, align.overflow && align.overflow.alwaysByViewport);
  return doAlign(el, refNodeRegion, align, isTargetNotOutOfVisible);
}
alignElement.__getOffsetParent = getOffsetParent;
alignElement.__getVisibleRectForElement = getVisibleRectForElement;

/**
 * `tgtPoint`: { pageX, pageY } or { clientX, clientY }.
 * If client position provided, will internal convert to page position.
 */

function alignPoint(el, tgtPoint, align) {
  var pageX;
  var pageY;
  var doc = utils.getDocument(el);
  var win = doc.defaultView || doc.parentWindow;
  var scrollX = utils.getWindowScrollLeft(win);
  var scrollY = utils.getWindowScrollTop(win);
  var viewportWidth = utils.viewportWidth(win);
  var viewportHeight = utils.viewportHeight(win);
  if ('pageX' in tgtPoint) {
    pageX = tgtPoint.pageX;
  } else {
    pageX = scrollX + tgtPoint.clientX;
  }
  if ('pageY' in tgtPoint) {
    pageY = tgtPoint.pageY;
  } else {
    pageY = scrollY + tgtPoint.clientY;
  }
  var tgtRegion = {
    left: pageX,
    top: pageY,
    width: 0,
    height: 0
  };
  var pointInView = pageX >= 0 && pageX <= scrollX + viewportWidth && pageY >= 0 && pageY <= scrollY + viewportHeight;

  // Provide default target point
  var points = [align.points[0], 'cc'];
  return doAlign(el, tgtRegion, _objectSpread2(_objectSpread2({}, align), {}, {
    points: points
  }), pointInView);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (alignElement);

//# sourceMappingURL=index.js.map


/***/ }),

/***/ "../../node_modules/dom-helpers/esm/addClass.js":
/*!******************************************************!*\
  !*** ../../node_modules/dom-helpers/esm/addClass.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ addClass)
/* harmony export */ });
/* harmony import */ var _hasClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hasClass */ "../../node_modules/dom-helpers/esm/hasClass.js");

/**
 * Adds a CSS class to a given element.
 * 
 * @param element the element
 * @param className the CSS class name
 */

function addClass(element, className) {
  if (element.classList) element.classList.add(className);else if (!(0,_hasClass__WEBPACK_IMPORTED_MODULE_0__["default"])(element, className)) if (typeof element.className === 'string') element.className = element.className + " " + className;else element.setAttribute('class', (element.className && element.className.baseVal || '') + " " + className);
}

/***/ }),

/***/ "../../node_modules/dom-helpers/esm/hasClass.js":
/*!******************************************************!*\
  !*** ../../node_modules/dom-helpers/esm/hasClass.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ hasClass)
/* harmony export */ });
/**
 * Checks if a given element has a CSS class.
 * 
 * @param element the element
 * @param className the CSS class name
 */
function hasClass(element, className) {
  if (element.classList) return !!className && element.classList.contains(className);
  return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
}

/***/ }),

/***/ "../../node_modules/dom-helpers/esm/removeClass.js":
/*!*********************************************************!*\
  !*** ../../node_modules/dom-helpers/esm/removeClass.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ removeClass)
/* harmony export */ });
function replaceClassName(origClass, classToRemove) {
  return origClass.replace(new RegExp("(^|\\s)" + classToRemove + "(?:\\s|$)", 'g'), '$1').replace(/\s+/g, ' ').replace(/^\s*|\s*$/g, '');
}
/**
 * Removes a CSS class from a given element.
 * 
 * @param element the element
 * @param className the CSS class name
 */


function removeClass(element, className) {
  if (element.classList) {
    element.classList.remove(className);
  } else if (typeof element.className === 'string') {
    element.className = replaceClassName(element.className, className);
  } else {
    element.setAttribute('class', replaceClassName(element.className && element.className.baseVal || '', className));
  }
}

/***/ }),

/***/ "../../node_modules/ethereum-blockies-base64/dist/main.js":
/*!****************************************************************!*\
  !*** ../../node_modules/ethereum-blockies-base64/dist/main.js ***!
  \****************************************************************/
/***/ (function(module) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else {}
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __nested_webpack_require_563__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_563__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__nested_webpack_require_563__.m = modules;

/******/ 	// expose the module cache
/******/ 	__nested_webpack_require_563__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__nested_webpack_require_563__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __nested_webpack_require_563__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __nested_webpack_require_1763__) {

	const pnglib = __nested_webpack_require_1763__(1);
	const hsl2rgb = __nested_webpack_require_1763__(2);

	// The random number is a js implementation of the Xorshift PRNG
	const randseed = new Array(4); // Xorshift: [x, y, z, w] 32 bit values

	function seedrand(seed) {
	  for (let i = 0; i < randseed.length; i++) {
	    randseed[i] = 0;
	  }
	  for (let i = 0; i < seed.length; i++) {
	    randseed[i % 4] = (randseed[i % 4] << 5) - randseed[i % 4] + seed.charCodeAt(i);
	  }
	}

	function rand() {
	  // based on Java's String.hashCode(), expanded to 4 32bit values
	  const t = randseed[0] ^ (randseed[0] << 11);

	  randseed[0] = randseed[1];
	  randseed[1] = randseed[2];
	  randseed[2] = randseed[3];
	  randseed[3] = randseed[3] ^ (randseed[3] >> 19) ^ t ^ (t >> 8);

	  return (randseed[3] >>> 0) / (1 << 31 >>> 0);
	}

	function createColor() {
	  //saturation is the whole color spectrum
	  const h = Math.floor(rand() * 360);
	  //saturation goes from 40 to 100, it avoids greyish colors
	  const s = rand() * 60 + 40;
	  //lightness can be anything from 0 to 100, but probabilities are a bell curve around 50%
	  const l = (rand() + rand() + rand() + rand()) * 25 ;

	  return [h / 360, s / 100, l / 100];
	}

	function createImageData(size) {
	  const width = size; // Only support square icons for now
	  const height = size;

	  const dataWidth = Math.ceil(width / 2);
	  const mirrorWidth = width - dataWidth;

	  const data = [];
	  for (let y = 0; y < height; y++) {
	    let row = [];
	    for (let x = 0; x < dataWidth; x++) {
	      // this makes foreground and background color to have a 43% (1/2.3) probability
	      // spot color has 13% chance
	      row[x] = Math.floor(rand() * 2.3);
	    }
	    const r = row.slice(0, mirrorWidth).reverse();
	    row = row.concat(r);

	    for (let i = 0; i < row.length; i++) {
	      data.push(row[i]);
	    }
	  }

	  return data;
	}

	// Modifies the passed PNG to fill in a specified rectangle
	function fillRect(png, x, y, w, h, color) {
	  for(let i = 0; i < w; i++) {
	    for (let j = 0; j < h; j++) {
	      png.buffer[png.index(x + i, y + j)] = color;
	    }
	  }
	}

	function buildOpts(opts) {
	  if (!opts.seed) {
	    throw new Error('No seed provided');
	  }

	  seedrand(opts.seed);

	  return Object.assign({
	    size: 8,
	    scale: 16,
	    color: createColor(),
	    bgcolor: createColor(),
	    spotcolor: createColor(),
	  }, opts)
	}

	function makeBlockie(address) {
	  const opts = buildOpts({ seed: address.toLowerCase() });

	  const imageData = createImageData(opts.size);
	  const width = Math.sqrt(imageData.length);

	  const p = new pnglib(opts.size * opts.scale, opts.size * opts.scale, 3);
	  const bgcolor = p.color(...hsl2rgb(...opts.bgcolor));
	  const color = p.color(...hsl2rgb(...opts.color));
	  const spotcolor = p.color(...hsl2rgb(...opts.spotcolor));

	  for (let i = 0; i < imageData.length; i++) {
	    const row = Math.floor(i / width);
	    const col = i % width;
	    // if data is 0, leave the background
	    if (imageData[i]) {
	      // if data is 2, choose spot color, if 1 choose foreground
	      const pngColor = imageData[i] == 1 ? color : spotcolor;
	      fillRect(p, col * opts.scale, row * opts.scale, opts.scale, opts.scale, pngColor);
	    }
	  }
	  return `data:image/png;base64,${p.getBase64()}`;
	}

	module.exports = makeBlockie;


/***/ },
/* 1 */
/***/ function(module, exports) {

	/**
	 * A handy class to calculate color values.
	 *
	 * @version 1.0
	 * @author Robert Eisele <robert@xarg.org>
	 * @copyright Copyright (c) 2010, Robert Eisele
	 * @link http://www.xarg.org/2010/03/generate-client-side-png-files-using-javascript/
	 * @license http://www.opensource.org/licenses/bsd-license.php BSD License
	 *
	 */

	// Modified by George Chan <gchan@21cn.com>

	// Further modified by Will O'B <@wbobeirne> to make it
	// UglifyJS and "use strict"; friendly

	module.exports = function(width,height,depth) {


	    // helper functions for that ctx
	    function write(buffer, offs) {
	        for (var i = 2; i < arguments.length; i++) {
	            for (var j = 0; j < arguments[i].length; j++) {
	                buffer[offs++] = arguments[i].charAt(j);
	            }
	        }
	    }

	    function byte2(w) {
	        return String.fromCharCode((w >> 8) & 255, w & 255);
	    }

	    function byte4(w) {
	        return String.fromCharCode((w >> 24) & 255, (w >> 16) & 255, (w >> 8) & 255, w & 255);
	    }

	    function byte2lsb(w) {
	        return String.fromCharCode(w & 255, (w >> 8) & 255);
	    }

	    this.width   = width;
	    this.height  = height;
	    this.depth   = depth;

	    // pixel data and row filter identifier size
	    this.pix_size = height * (width + 1);

	    // deflate header, pix_size, block headers, adler32 checksum
	    this.data_size = 2 + this.pix_size + 5 * Math.floor((0xfffe + this.pix_size) / 0xffff) + 4;

	    // offsets and sizes of Png chunks
	    this.ihdr_offs = 0; // IHDR offset and size
	    this.ihdr_size = 4 + 4 + 13 + 4;
	    this.plte_offs = this.ihdr_offs + this.ihdr_size; // PLTE offset and size
	    this.plte_size = 4 + 4 + 3 * depth + 4;
	    this.trns_offs = this.plte_offs + this.plte_size; // tRNS offset and size
	    this.trns_size = 4 + 4 + depth + 4;
	    this.idat_offs = this.trns_offs + this.trns_size; // IDAT offset and size
	    this.idat_size = 4 + 4 + this.data_size + 4;
	    this.iend_offs = this.idat_offs + this.idat_size; // IEND offset and size
	    this.iend_size = 4 + 4 + 4;
	    this.buffer_size  = this.iend_offs + this.iend_size; // total PNG size

	    this.buffer  = new Array();
	    this.palette = new Object();
	    this.pindex  = 0;

	    var _crc32 = new Array();

	    // initialize buffer with zero bytes
	    for (var i = 0; i < this.buffer_size; i++) {
	        this.buffer[i] = "\x00";
	    }

	    // initialize non-zero elements
	    write(this.buffer, this.ihdr_offs, byte4(this.ihdr_size - 12), 'IHDR', byte4(width), byte4(height), "\x08\x03");
	    write(this.buffer, this.plte_offs, byte4(this.plte_size - 12), 'PLTE');
	    write(this.buffer, this.trns_offs, byte4(this.trns_size - 12), 'tRNS');
	    write(this.buffer, this.idat_offs, byte4(this.idat_size - 12), 'IDAT');
	    write(this.buffer, this.iend_offs, byte4(this.iend_size - 12), 'IEND');

	    // initialize deflate header
	    var header = ((8 + (7 << 4)) << 8) | (3 << 6);
	    header+= 31 - (header % 31);

	    write(this.buffer, this.idat_offs + 8, byte2(header));

	    // initialize deflate block headers
	    for (var i = 0; (i << 16) - 1 < this.pix_size; i++) {
	        var size, bits;
	        if (i + 0xffff < this.pix_size) {
	            size = 0xffff;
	            bits = "\x00";
	        } else {
	            size = this.pix_size - (i << 16) - i;
	            bits = "\x01";
	        }
	        write(this.buffer, this.idat_offs + 8 + 2 + (i << 16) + (i << 2), bits, byte2lsb(size), byte2lsb(~size));
	    }

	    /* Create crc32 lookup table */
	    for (var i = 0; i < 256; i++) {
	        var c = i;
	        for (var j = 0; j < 8; j++) {
	            if (c & 1) {
	                c = -306674912 ^ ((c >> 1) & 0x7fffffff);
	            } else {
	                c = (c >> 1) & 0x7fffffff;
	            }
	        }
	        _crc32[i] = c;
	    }

	    // compute the index into a png for a given pixel
	    this.index = function(x,y) {
	        var i = y * (this.width + 1) + x + 1;
	        var j = this.idat_offs + 8 + 2 + 5 * Math.floor((i / 0xffff) + 1) + i;
	        return j;
	    }

	    // convert a color and build up the palette
	    this.color = function(red, green, blue, alpha) {

	        alpha = alpha >= 0 ? alpha : 255;
	        var color = (((((alpha << 8) | red) << 8) | green) << 8) | blue;

	        if (typeof this.palette[color] == "undefined") {
	            if (this.pindex == this.depth) return "\x00";

	            var ndx = this.plte_offs + 8 + 3 * this.pindex;

	            this.buffer[ndx + 0] = String.fromCharCode(red);
	            this.buffer[ndx + 1] = String.fromCharCode(green);
	            this.buffer[ndx + 2] = String.fromCharCode(blue);
	            this.buffer[this.trns_offs+8+this.pindex] = String.fromCharCode(alpha);

	            this.palette[color] = String.fromCharCode(this.pindex++);
	        }
	        return this.palette[color];
	    }

	    // output a PNG string, Base64 encoded
	    this.getBase64 = function() {

	        var s = this.getDump();

	        var ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
	        var c1, c2, c3, e1, e2, e3, e4;
	        var l = s.length;
	        var i = 0;
	        var r = "";

	        do {
	            c1 = s.charCodeAt(i);
	            e1 = c1 >> 2;
	            c2 = s.charCodeAt(i+1);
	            e2 = ((c1 & 3) << 4) | (c2 >> 4);
	            c3 = s.charCodeAt(i+2);
	            if (l < i+2) { e3 = 64; } else { e3 = ((c2 & 0xf) << 2) | (c3 >> 6); }
	            if (l < i+3) { e4 = 64; } else { e4 = c3 & 0x3f; }
	            r+= ch.charAt(e1) + ch.charAt(e2) + ch.charAt(e3) + ch.charAt(e4);
	        } while ((i+= 3) < l);
	        return r;
	    }

	    // output a PNG string
	    this.getDump = function() {
	        // compute adler32 of output pixels + row filter bytes
	        var BASE = 65521; /* largest prime smaller than 65536 */
	        var NMAX = 5552; /* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */
	        var s1 = 1;
	        var s2 = 0;
	        var n = NMAX;

	        for (var y = 0; y < this.height; y++) {
	            for (var x = -1; x < this.width; x++) {
	                s1+= this.buffer[this.index(x, y)].charCodeAt(0);
	                s2+= s1;
	                if ((n-= 1) == 0) {
	                    s1%= BASE;
	                    s2%= BASE;
	                    n = NMAX;
	                }
	            }
	        }
	        s1%= BASE;
	        s2%= BASE;
	        write(this.buffer, this.idat_offs + this.idat_size - 8, byte4((s2 << 16) | s1));

	        // compute crc32 of the PNG chunks
	        function crc32(png, offs, size) {
	            var crc = -1;
	            for (var i = 4; i < size-4; i += 1) {
	                crc = _crc32[(crc ^ png[offs+i].charCodeAt(0)) & 0xff] ^ ((crc >> 8) & 0x00ffffff);
	            }
	            write(png, offs+size-4, byte4(crc ^ -1));
	        }

	        crc32(this.buffer, this.ihdr_offs, this.ihdr_size);
	        crc32(this.buffer, this.plte_offs, this.plte_size);
	        crc32(this.buffer, this.trns_offs, this.trns_size);
	        crc32(this.buffer, this.idat_offs, this.idat_size);
	        crc32(this.buffer, this.iend_offs, this.iend_size);

	        // convert PNG to string
	        return "\x89PNG\r\n\x1a\n" + this.buffer.join('');
	    }
	};


/***/ },
/* 2 */
/***/ function(module, exports) {

	// https://stackoverflow.com/questions/2353211/hsl-to-rgb-color-conversion
	/**
	 * Converts an HSL color value to RGB. Conversion formula
	 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
	 * Assumes h, s, and l are contained in the set [0, 1] and
	 * returns r, g, and b in the set [0, 255].
	 *
	 * @param   {number}  h       The hue
	 * @param   {number}  s       The saturation
	 * @param   {number}  l       The lightness
	 * @return  {Array}           The RGB representation
	 */

	 function hue2rgb(p, q, t) {
	   if(t < 0) t += 1;
	   if(t > 1) t -= 1;
	   if(t < 1/6) return p + (q - p) * 6 * t;
	   if(t < 1/2) return q;
	   if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
	   return p;
	 }

	function hsl2rgb(h, s, l){
	  let r, g, b;

	  if (s == 0) {
	    r = g = b = l; // achromatic
	  } else {
	    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
	    const p = 2 * l - q;
	    r = hue2rgb(p, q, h + 1/3);
	    g = hue2rgb(p, q, h);
	    b = hue2rgb(p, q, h - 1/3);
	  }

	  return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255), 255];
	}

	module.exports = hsl2rgb;


/***/ }
/******/ ])
});
;

/***/ }),

/***/ "../../node_modules/file-saver/dist/FileSaver.min.js":
/*!***********************************************************!*\
  !*** ../../node_modules/file-saver/dist/FileSaver.min.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(a,b){if(true)!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (b),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}})(this,function(){"use strict";function b(a,b){return"undefined"==typeof b?b={autoBom:!1}:"object"!=typeof b&&(console.warn("Deprecated: Expected third argument to be a object"),b={autoBom:!b}),b.autoBom&&/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a.type)?new Blob(["\uFEFF",a],{type:a.type}):a}function c(a,b,c){var d=new XMLHttpRequest;d.open("GET",a),d.responseType="blob",d.onload=function(){g(d.response,b,c)},d.onerror=function(){console.error("could not download file")},d.send()}function d(a){var b=new XMLHttpRequest;b.open("HEAD",a,!1);try{b.send()}catch(a){}return 200<=b.status&&299>=b.status}function e(a){try{a.dispatchEvent(new MouseEvent("click"))}catch(c){var b=document.createEvent("MouseEvents");b.initMouseEvent("click",!0,!0,window,0,0,0,80,20,!1,!1,!1,!1,0,null),a.dispatchEvent(b)}}var f="object"==typeof window&&window.window===window?window:"object"==typeof self&&self.self===self?self:"object"==typeof __webpack_require__.g&&__webpack_require__.g.global===__webpack_require__.g?__webpack_require__.g:void 0,a=f.navigator&&/Macintosh/.test(navigator.userAgent)&&/AppleWebKit/.test(navigator.userAgent)&&!/Safari/.test(navigator.userAgent),g=f.saveAs||("object"!=typeof window||window!==f?function(){}:"download"in HTMLAnchorElement.prototype&&!a?function(b,g,h){var i=f.URL||f.webkitURL,j=document.createElement("a");g=g||b.name||"download",j.download=g,j.rel="noopener","string"==typeof b?(j.href=b,j.origin===location.origin?e(j):d(j.href)?c(b,g,h):e(j,j.target="_blank")):(j.href=i.createObjectURL(b),setTimeout(function(){i.revokeObjectURL(j.href)},4E4),setTimeout(function(){e(j)},0))}:"msSaveOrOpenBlob"in navigator?function(f,g,h){if(g=g||f.name||"download","string"!=typeof f)navigator.msSaveOrOpenBlob(b(f,h),g);else if(d(f))c(f,g,h);else{var i=document.createElement("a");i.href=f,i.target="_blank",setTimeout(function(){e(i)})}}:function(b,d,e,g){if(g=g||open("","_blank"),g&&(g.document.title=g.document.body.innerText="downloading..."),"string"==typeof b)return c(b,d,e);var h="application/octet-stream"===b.type,i=/constructor/i.test(f.HTMLElement)||f.safari,j=/CriOS\/[\d]+/.test(navigator.userAgent);if((j||h&&i||a)&&"undefined"!=typeof FileReader){var k=new FileReader;k.onloadend=function(){var a=k.result;a=j?a:a.replace(/^data:[^;]*;/,"data:attachment/file;"),g?g.location.href=a:location=a,g=null},k.readAsDataURL(b)}else{var l=f.URL||f.webkitURL,m=l.createObjectURL(b);g?g.location=m:location.href=m,g=null,setTimeout(function(){l.revokeObjectURL(m)},4E4)}});f.saveAs=g.saveAs=g, true&&(module.exports=g)});

//# sourceMappingURL=FileSaver.min.js.map

/***/ }),

/***/ "../../node_modules/flatlist-react/lib/___subComponents/DefaultBlank.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/flatlist-react/lib/___subComponents/DefaultBlank.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var react_1 = __importDefault(__webpack_require__(/*! react */ "../../node_modules/react/index.js"));
function DefaultBlank() {
    return react_1.default.createElement("p", null, "List is empty...");
}
exports["default"] = DefaultBlank;


/***/ }),

/***/ "../../node_modules/flatlist-react/lib/___subComponents/DefaultLoadIndicator.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/flatlist-react/lib/___subComponents/DefaultLoadIndicator.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var react_1 = __importDefault(__webpack_require__(/*! react */ "../../node_modules/react/index.js"));
function DefaultLoadingIndicator() {
    return react_1.default.createElement("div", { className: "loading-indicator" }, "loading...");
}
exports["default"] = DefaultLoadingIndicator;


/***/ }),

/***/ "../../node_modules/flatlist-react/lib/___subComponents/DisplayHandler.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/flatlist-react/lib/___subComponents/DisplayHandler.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var react_1 = __importStar(__webpack_require__(/*! react */ "../../node_modules/react/index.js"));
var defaultProps = {
    display: {
        grid: false,
        gridGap: "20px",
        gridMinColumnWidth: "200px",
        row: false,
        rowGap: "20px",
    },
    displayGrid: false,
    displayRow: false,
    gridGap: "20px",
    minColumnWidth: "200px",
    rowGap: "20px",
};
function DisplayHandler(props) {
    var _a = __assign(__assign({}, defaultProps), props), displayGrid = _a.displayGrid, displayRow = _a.displayRow, display = _a.display, gridGap = _a.gridGap, minColumnWidth = _a.minColumnWidth, rowGap = _a.rowGap;
    var childSpanRef = (0, react_1.createRef)();
    var _b = (0, react_1.useState)(), combo = _b[0], setParentComponent = _b[1];
    var styleParentGrid = function (styleTag, container) {
        if (displayGrid || display.grid) {
            var gap = display.gridGap || gridGap || defaultProps.display.gridGap;
            var column = display.gridMinColumnWidth ||
                minColumnWidth ||
                defaultProps.display.gridMinColumnWidth;
            styleTag.innerHTML = "\n          [data-cont=\"".concat(container.dataset.cont, "\"] {\n              display: grid;\n              grid-gap: ").concat(gap, ";\n              gap: ").concat(gap, ";\n              grid-template-columns: repeat(auto-fill, minmax(").concat(column, ", 1fr));\n              grid-template-rows: auto;\n              align-items: stretch;\n          }\n          \n          [data-cont=\"").concat(container.dataset.cont, "\"] .__infinite-loader,\n          [data-cont=\"").concat(container.dataset.cont, "\"] .___scroll-renderer-anchor,\n          [data-cont=\"").concat(container.dataset.cont, "\"] .___list-separator {\n              grid-column: 1/-1;\n          }\n      ");
        }
        else {
            styleTag.innerHTML = "";
        }
    };
    var styleParentRow = function (styleTag, container) {
        if (displayRow || display.row) {
            var gap = display.rowGap || rowGap || defaultProps.display.rowGap;
            styleTag.innerHTML = "\n          [data-cont=\"".concat(container.dataset.cont, "\"] {\n              display: flex;\n              flex-direction: column;\n          }\n          \n          [data-cont=\"").concat(container.dataset.cont, "\"] > *:not(.__infinite-loader) {\n              display: block;\n              flex: 1;\n              width: 100%;\n              margin-bottom: ").concat(gap, ";\n          }\n      ");
        }
        else {
            styleTag.innerHTML = "";
        }
    };
    var handleDisplayHandlerProps = function (container, style) {
        if (container) {
            if (display.grid || displayGrid) {
                styleParentGrid(style, container);
            }
            else if (display.row || displayRow) {
                styleParentRow(style, container);
            }
        }
    };
    (0, react_1.useEffect)(function () {
        if (combo) {
            handleDisplayHandlerProps(combo[0], combo[1]);
        }
    });
    (0, react_1.useEffect)(function () {
        var current = childSpanRef.current;
        var container;
        var style;
        if (current) {
            var id = "__container-".concat(new Date().getTime());
            container = current.parentNode;
            if (container) {
                container.setAttribute("data-cont", id);
                style = document.createElement("STYLE");
                style.id = id;
                document.head.appendChild(style);
                setParentComponent([container, style]);
                handleDisplayHandlerProps(container, style);
            }
        }
        else {
            console.warn("FlatList: it was not possible to get container's ref. Styling will not be possible");
        }
        return function () {
            if (style) {
                style.remove();
            }
        };
    }, []);
    return (react_1.default.createElement(react_1.default.Fragment, null, !combo && react_1.default.createElement("span", { ref: childSpanRef, style: { display: "none" } })));
}
exports["default"] = DisplayHandler;


/***/ }),

/***/ "../../node_modules/flatlist-react/lib/___subComponents/InfiniteLoader.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/flatlist-react/lib/___subComponents/InfiniteLoader.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var react_1 = __importStar(__webpack_require__(/*! react */ "../../node_modules/react/index.js"));
var isType_1 = __webpack_require__(/*! ../___utils/isType */ "../../node_modules/flatlist-react/lib/___utils/isType.js");
var DefaultLoadIndicator_1 = __importDefault(__webpack_require__(/*! ./DefaultLoadIndicator */ "../../node_modules/flatlist-react/lib/___subComponents/DefaultLoadIndicator.js"));
var InfiniteLoader = /** @class */ (function (_super) {
    __extends(InfiniteLoader, _super);
    function InfiniteLoader() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            prevItemsCount: _this.props.itemsCount,
            loadIndicatorContainer: null,
            loading: false,
            scrollingContainer: null,
        };
        _this.loaderContainerRef = (0, react_1.createRef)();
        // track the last scroll position so when new dom elements are inserted to avoid scroll jump
        _this.lastScrollTop = 0;
        _this.mounted = false;
        // keep track of the dom items in the list
        _this.currentItemsCount = 0;
        _this.getScrollingContainerChildrenCount = function () {
            var scrollingContainer = _this.state.scrollingContainer;
            if (scrollingContainer) {
                return Math.max(0, scrollingContainer.children.length);
            }
            return 0;
        };
        _this.setupScrollingContainerEventsListener = function (removeEvent) {
            if (removeEvent === void 0) { removeEvent = false; }
            var scrollingContainer = _this.state.scrollingContainer;
            if (scrollingContainer) {
                ["scroll", "mousewheel", "touchmove"].forEach(function (event) {
                    scrollingContainer.removeEventListener(event, _this.checkIfLoadingIsNeeded, true);
                    if (!removeEvent) {
                        scrollingContainer.addEventListener(event, _this.checkIfLoadingIsNeeded, true);
                    }
                });
            }
        };
        // show or hide loading indicators based on scroll position
        // calls the "loadMore" function when is needed
        _this.checkIfLoadingIsNeeded = function () {
            if (!_this.mounted || !_this.props.hasMore || _this.state.loading) {
                return;
            }
            var _a = _this.state, scrollingContainer = _a.scrollingContainer, loadIndicatorContainer = _a.loadIndicatorContainer;
            if (scrollingContainer && loadIndicatorContainer) {
                var scrollTop = scrollingContainer.scrollTop, offsetTop = scrollingContainer.offsetTop, offsetHeight = scrollingContainer.offsetHeight;
                _this.lastScrollTop = scrollTop;
                var loaderPosition = loadIndicatorContainer.offsetTop - scrollTop;
                var startingPoint = offsetTop + offsetHeight;
                if (loaderPosition <= startingPoint) {
                    _this.setState({ prevItemsCount: _this.props.itemsCount, loading: true }, function () {
                        _this.props.loadMore();
                    });
                }
            }
        };
        return _this;
    }
    InfiniteLoader.prototype.componentDidMount = function () {
        var _this = this;
        this.mounted = true;
        var loadIndicatorContainer = this.loaderContainerRef.current;
        if (loadIndicatorContainer) {
            this.setState({
                loadIndicatorContainer: loadIndicatorContainer,
                scrollingContainer: loadIndicatorContainer.parentNode,
            }, function () {
                _this.currentItemsCount = _this.getScrollingContainerChildrenCount();
                _this.setupScrollingContainerEventsListener();
            });
        }
        else {
            console.warn("FlatList: it was not possible to get container's ref. " +
                "Infinite scrolling pagination will not be possible");
        }
    };
    InfiniteLoader.prototype.componentDidUpdate = function (prevProps, prevState) {
        // reset scroll position to where last was
        if (this.state.scrollingContainer) {
            this.state.scrollingContainer.scrollTop = this.lastScrollTop;
        }
        // reset loading state when the list size changes
        if (prevProps.itemsCount !== this.props.itemsCount) {
            this.reset();
        }
        this.checkIfLoadingIsNeeded();
    };
    InfiniteLoader.prototype.componentWillUnmount = function () {
        this.setupScrollingContainerEventsListener(true);
        this.mounted = false;
    };
    // update the loading flags and items count whether "hasMore" is false or list changed
    InfiniteLoader.prototype.reset = function () {
        this.setState({ loading: false });
    };
    InfiniteLoader.prototype.render = function () {
        var loading = this.state.loading;
        var _a = this.props, hasMore = _a.hasMore, _b = _a.loadingIndicator, loadingIndicator = _b === void 0 ? DefaultLoadIndicator_1.default : _b, _c = _a.loadingIndicatorPosition, loadingIndicatorPosition = _c === void 0 ? "left" : _c;
        var spinning = hasMore && loading;
        // do not remove the element from the dom so the ref is not broken but set it invisible enough
        var styles = {
            display: "flex",
            height: spinning ? "auto" : 0,
            justifyContent: loadingIndicatorPosition === "center"
                ? loadingIndicatorPosition
                : loadingIndicatorPosition === "right"
                    ? "flex-end"
                    : "flex-start",
            padding: spinning ? "5px 0" : 0,
            visibility: spinning ? "visible" : "hidden",
        };
        var loadingEl = (0, isType_1.isFunction)(loadingIndicator)
            ? loadingIndicator()
            : loadingIndicator;
        return (react_1.default.createElement("div", { ref: this.loaderContainerRef, className: "__infinite-loader", style: styles }, spinning && (loadingIndicator ? loadingEl : react_1.default.createElement(DefaultLoadIndicator_1.default, null))));
    };
    return InfiniteLoader;
}(react_1.Component));
exports["default"] = InfiniteLoader;


/***/ }),

/***/ "../../node_modules/flatlist-react/lib/___subComponents/PlainList.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/flatlist-react/lib/___subComponents/PlainList.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var react_1 = __importStar(__webpack_require__(/*! react */ "../../node_modules/react/index.js"));
var convertListToArray_1 = __importDefault(__webpack_require__(/*! ../___utils/convertListToArray */ "../../node_modules/flatlist-react/lib/___utils/convertListToArray.js"));
var isType_1 = __webpack_require__(/*! ../___utils/isType */ "../../node_modules/flatlist-react/lib/___utils/isType.js");
var ScrollRenderer_1 = __importDefault(__webpack_require__(/*! ./ScrollRenderer */ "../../node_modules/flatlist-react/lib/___subComponents/ScrollRenderer.js"));
var uiFunctions_1 = __webpack_require__(/*! ./uiFunctions */ "../../node_modules/flatlist-react/lib/___subComponents/uiFunctions.js");
function PlainList(props) {
    var list = props.list, renderItem = props.renderItem, renderWhenEmpty = props.renderWhenEmpty, renderOnScroll = props.renderOnScroll, wrapperHtmlTag = props.wrapperHtmlTag, __forwarededRef = props.__forwarededRef, tagProps = __rest(props, ["list", "renderItem", "renderWhenEmpty", "renderOnScroll", "wrapperHtmlTag", "__forwarededRef"]);
    var dataList = (0, convertListToArray_1.default)(list);
    var renderThisItem = (0, react_1.useMemo)(function () { return (0, uiFunctions_1.handleRenderItem)(renderItem, null); }, [renderItem]);
    if (dataList.length === 0) {
        return (0, uiFunctions_1.renderBlank)(renderWhenEmpty);
    }
    var WrapperElement = "".concat((0, isType_1.isString)(wrapperHtmlTag) && wrapperHtmlTag ? wrapperHtmlTag : "");
    var content = (react_1.default.createElement(react_1.default.Fragment, null, renderOnScroll ? (react_1.default.createElement(ScrollRenderer_1.default, { list: dataList, renderItem: renderItem })) : (dataList.map(renderThisItem))));
    return (react_1.default.createElement(react_1.default.Fragment, null, WrapperElement ? (
    // @ts-ignore
    react_1.default.createElement(WrapperElement, __assign({}, tagProps, { ref: __forwarededRef }), content)) : (content)));
}
exports["default"] = (0, react_1.forwardRef)(function (props, ref) {
    ref = ref || (0, react_1.createRef)();
    return react_1.default.createElement(PlainList, __assign({ __forwarededRef: ref }, props));
});


/***/ }),

/***/ "../../node_modules/flatlist-react/lib/___subComponents/ScrollRenderer.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/flatlist-react/lib/___subComponents/ScrollRenderer.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var react_1 = __importStar(__webpack_require__(/*! react */ "../../node_modules/react/index.js"));
var uiFunctions_1 = __webpack_require__(/*! ./uiFunctions */ "../../node_modules/flatlist-react/lib/___subComponents/uiFunctions.js");
function ScrollRenderer(props) {
    var _a = props.list, list = _a === void 0 ? [] : _a, _b = props.renderItem, renderItem = _b === void 0 ? function () { return null; } : _b, _c = props.groupSeparator, groupSeparator = _c === void 0 ? null : _c;
    var _d = (0, react_1.useState)({ renderList: [], index: 0 }), render = _d[0], setRender = _d[1];
    var _e = (0, react_1.useState)(false), mounted = _e[0], setMounted = _e[1];
    var _f = (0, react_1.useState)(-1), setupCount = _f[0], setSetupCount = _f[1];
    var containerRef = (0, react_1.createRef)();
    var renderThisItem = (0, react_1.useMemo)(function () {
        return (0, uiFunctions_1.handleRenderItem)(renderItem, (0, uiFunctions_1.handleRenderGroupSeparator)(groupSeparator));
    }, [renderItem, groupSeparator]);
    var updateRenderInfo = function (count) {
        if (count === void 0) { count = 10; }
        if (render.index < list.length) {
            var index = render.index + count;
            setRender({
                renderList: list.slice(0, index),
                index: index,
            });
        }
    };
    var onScroll = function (span) { return function () {
        requestAnimationFrame(function () {
            if (span) {
                var parent_1 = span.parentNode;
                var startingPoint = parent_1.offsetTop + parent_1.offsetHeight;
                var anchorPos = span.offsetTop - parent_1.scrollTop;
                if (anchorPos <= startingPoint + parent_1.offsetHeight * 2) {
                    updateRenderInfo();
                }
            }
        });
    }; };
    (0, react_1.useEffect)(function () {
        // when mounted
        setMounted(true);
        return function () {
            // when unmounted
            setMounted(false);
        };
    }, []);
    (0, react_1.useLayoutEffect)(function () {
        if (mounted) {
            // reset list on list change
            var span_1 = containerRef.current;
            var pos_1 = span_1.parentNode.scrollTop;
            var index = Math.max(render.renderList.length, setupCount);
            setRender({
                renderList: list.slice(0, index),
                index: index,
            });
            requestAnimationFrame(function () {
                if (span_1 && span_1.parentNode) {
                    span_1.parentNode.scrollTop = pos_1;
                }
            });
        }
    }, [list]);
    (0, react_1.useLayoutEffect)(function () {
        var span = containerRef.current;
        var handleScroll = onScroll(span);
        var container = null;
        if (span) {
            container = span.parentNode;
            requestAnimationFrame(function () {
                // populate double the container height of items
                if (render.index === 0 ||
                    container.scrollHeight <= container.offsetHeight * 2) {
                    updateRenderInfo();
                }
                else if (setupCount === -1) {
                    setSetupCount(render.index);
                }
            });
            container.addEventListener("scroll", handleScroll, { passive: true });
        }
        return function () {
            // when unmounted
            if (span) {
                container.removeEventListener("scroll", handleScroll, {
                    passive: true,
                });
            }
        };
    }, [render.index, list.length]);
    return (react_1.default.createElement(react_1.default.Fragment, null,
        render.renderList.map(function (item, idx) { return renderThisItem(item, "".concat(idx)); }),
        react_1.default.createElement("span", { ref: containerRef, style: { visibility: "hidden", height: 1 }, className: "___scroll-renderer-anchor" })));
}
exports["default"] = ScrollRenderer;


/***/ }),

/***/ "../../node_modules/flatlist-react/lib/___subComponents/ScrollToTopButton.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/flatlist-react/lib/___subComponents/ScrollToTopButton.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var react_1 = __importStar(__webpack_require__(/*! react */ "../../node_modules/react/index.js"));
var isType_1 = __webpack_require__(/*! ../___utils/isType */ "../../node_modules/flatlist-react/lib/___utils/isType.js");
var uiFunctions_1 = __webpack_require__(/*! ./uiFunctions */ "../../node_modules/flatlist-react/lib/___subComponents/uiFunctions.js");
function ScrollToTopButton(props) {
    var anchor = (0, react_1.createRef)();
    var _a = props.button, button = _a === void 0 ? null : _a, _b = props.position, position = _b === void 0 ? "bottom right" : _b, _c = props.padding, padding = _c === void 0 ? 20 : _c, _d = props.offset, offset = _d === void 0 ? 50 : _d, scrollingContainer = props.scrollingContainer;
    var btn = (0, isType_1.isFunction)(button) ? button() : button;
    var _e = (0, react_1.useState)(false), mounted = _e[0], setMounted = _e[1];
    (0, react_1.useEffect)(function () {
        var buttonElement = anchor.current.nextElementSibling;
        var container = anchor.current.parentNode;
        var scrollContainer = scrollingContainer.current;
        var containerStyle = getComputedStyle(container);
        var ogPos = containerStyle.position;
        container.style.position = ["absolute", "fixed", "relative"].includes(ogPos)
            ? ogPos
            : "relative";
        var positionBtn = (0, uiFunctions_1.btnPosition)(scrollContainer, buttonElement);
        var pos = position.split(" ");
        var updateBtnPosition = function () {
            return positionBtn(pos[0], pos[1], padding, offset);
        };
        window.addEventListener("resize", updateBtnPosition);
        scrollContainer.addEventListener("scroll", updateBtnPosition);
        buttonElement.addEventListener("click", function () {
            scrollContainer.scrollTo({
                top: 0,
                behavior: "smooth",
            });
        });
        setTimeout(function () { return updateBtnPosition(); }, 250);
        setMounted(true);
        return function () {
            container.style.position = ogPos;
            window.removeEventListener("resize", updateBtnPosition);
        };
    }, []);
    return (react_1.default.createElement(react_1.default.Fragment, null,
        !mounted && react_1.default.createElement("span", { ref: anchor, style: { display: "none" } }),
        button ? btn : react_1.default.createElement("button", { type: "button" }, "To Top")));
}
exports["default"] = ScrollToTopButton;


/***/ }),

/***/ "../../node_modules/flatlist-react/lib/___subComponents/uiFunctions.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/flatlist-react/lib/___subComponents/uiFunctions.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.btnPosition = exports.handleRenderItem = exports.handleRenderGroupSeparator = exports.renderBlank = void 0;
var react_1 = __importStar(__webpack_require__(/*! react */ "../../node_modules/react/index.js"));
var isType_1 = __webpack_require__(/*! ../___utils/isType */ "../../node_modules/flatlist-react/lib/___utils/isType.js");
var DefaultBlank_1 = __importDefault(__webpack_require__(/*! ./DefaultBlank */ "../../node_modules/flatlist-react/lib/___subComponents/DefaultBlank.js"));
var renderBlank = function (renderWhenEmpty) {
    if (renderWhenEmpty === void 0) { renderWhenEmpty = null; }
    return renderWhenEmpty && (0, isType_1.isFunction)(renderWhenEmpty)
        ? renderWhenEmpty()
        : (0, DefaultBlank_1.default)();
};
exports.renderBlank = renderBlank;
var handleRenderGroupSeparator = function (CustomSeparator) {
    return function (sep, idx) {
        var cls = sep[0], groupLabel = sep[1], group = sep[2];
        var separatorKey = "separator-".concat(idx);
        if (CustomSeparator) {
            if ((0, isType_1.isFunction)(CustomSeparator)) {
                var Sep = CustomSeparator(group, idx, groupLabel);
                return (react_1.default.createElement("div", { key: separatorKey, className: cls },
                    react_1.default.createElement(Sep.type, __assign({}, Sep.props))));
            }
            return (react_1.default.createElement("div", { key: separatorKey, className: cls }, (0, react_1.cloneElement)(CustomSeparator, { groupLabel: groupLabel, group: group })));
        }
        return react_1.default.createElement("hr", { key: separatorKey, className: cls });
    };
};
exports.handleRenderGroupSeparator = handleRenderGroupSeparator;
var handleRenderItem = function (renderItem, renderSeparator) {
    if (renderSeparator === void 0) { renderSeparator = null; }
    return function (item, key) {
        if (!renderItem) {
            return null;
        }
        var itemId = ("".concat(item) === "[object Object]" &&
            item.id) ||
            key;
        if ((0, isType_1.isArray)(item) && item[0] === "___list-separator") {
            return typeof renderSeparator === "function"
                ? renderSeparator(item, itemId)
                : null;
        }
        if (typeof renderItem === "function") {
            return renderItem(item, "".concat(itemId));
        }
        var comp = renderItem;
        return react_1.default.createElement(comp.type, __assign({}, comp.props, { key: itemId, item: item }));
    };
};
exports.handleRenderItem = handleRenderItem;
var btnPosition = function (scrollContainer, btn) {
    var z = window.getComputedStyle(scrollContainer).zIndex;
    btn.style.position = "absolute";
    btn.style.zIndex = "".concat(z === "auto" ? 1 : Number(z) + 1);
    btn.style.visibility = "hidden";
    return function (vertical, horizontal, padding, offset) {
        if (padding === void 0) { padding = 20; }
        if (offset === void 0) { offset = 50; }
        var x = "0px";
        var y = "0px";
        if (vertical === "top") {
            y = "".concat(parseFloat("".concat(padding)), "px");
        }
        else if (vertical === "bottom") {
            y = "calc(100% - ".concat(parseFloat("".concat(padding)) + btn.offsetHeight, "px)");
        }
        if (horizontal === "left") {
            x = "".concat(parseFloat("".concat(padding)), "px");
        }
        else if (horizontal === "right") {
            x = "calc(100% - ".concat(parseFloat("".concat(padding)) + btn.offsetWidth, "px)");
        }
        window.requestAnimationFrame(function () {
            var dist = Number((scrollContainer.scrollHeight - scrollContainer.offsetHeight).toFixed(0));
            offset = Math.min(offset, dist);
            btn.style.top = y;
            btn.style.left = x;
            btn.style.visibility =
                dist !== 0 && // got scrolled
                    Number(scrollContainer.scrollTop.toFixed(0)) >= offset // position meets the offset
                    ? "visible"
                    : "hidden";
        });
    };
};
exports.btnPosition = btnPosition;


/***/ }),

/***/ "../../node_modules/flatlist-react/lib/___utils/convertListToArray.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/flatlist-react/lib/___utils/convertListToArray.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var getType_1 = __importStar(__webpack_require__(/*! ./getType */ "../../node_modules/flatlist-react/lib/___utils/getType.js"));
exports["default"] = (function (list) {
    var listType = (0, getType_1.default)(list);
    switch (listType) {
        case getType_1.types.ARRAY:
            return list;
        case getType_1.types.OBJECT:
            return Object.values(list);
        case getType_1.types.SET:
            return Array.from(list);
        case getType_1.types.MAP:
            return Array.from(list.values());
        default:
            return [];
    }
});


/***/ }),

/***/ "../../node_modules/flatlist-react/lib/___utils/convertMapToObject.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/flatlist-react/lib/___utils/convertMapToObject.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = (function (map) {
    return Array.from(map).reduce(function (obj, _a) {
        var _b;
        var key = _a[0], value = _a[1];
        return Object.assign(obj, (_b = {}, _b[key] = value, _b));
    }, {});
});


/***/ }),

/***/ "../../node_modules/flatlist-react/lib/___utils/filterList.js":
/*!********************************************************************!*\
  !*** ../../node_modules/flatlist-react/lib/___utils/filterList.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var getObjectDeepKeyValue_1 = __importDefault(__webpack_require__(/*! ./getObjectDeepKeyValue */ "../../node_modules/flatlist-react/lib/___utils/getObjectDeepKeyValue.js"));
var isType_1 = __webpack_require__(/*! ./isType */ "../../node_modules/flatlist-react/lib/___utils/isType.js");
var filterList = function (list, by) {
    if (by === void 0) { by = ""; }
    return list.filter(function (item, idx) {
        if ((0, isType_1.isString)(by) && ((0, isType_1.isObject)(item) || (0, isType_1.isArray)(item))) {
            return (0, getObjectDeepKeyValue_1.default)(item, by);
        }
        if ((0, isType_1.isFunction)(by)) {
            return by(item, idx);
        }
        return true;
    });
};
exports["default"] = filterList;


/***/ }),

/***/ "../../node_modules/flatlist-react/lib/___utils/getObjectDeepKeyValue.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/flatlist-react/lib/___utils/getObjectDeepKeyValue.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var getType_1 = __importStar(__webpack_require__(/*! ./getType */ "../../node_modules/flatlist-react/lib/___utils/getType.js"));
var isType_1 = __webpack_require__(/*! ./isType */ "../../node_modules/flatlist-react/lib/___utils/isType.js");
var convertMapToObject_1 = __importDefault(__webpack_require__(/*! ./convertMapToObject */ "../../node_modules/flatlist-react/lib/___utils/convertMapToObject.js"));
var convertAnythingToArrayOrObject = function (obj) {
    return (0, getType_1.default)(obj) === getType_1.types.SET
        ? Array.from(obj)
        : (0, getType_1.default)(obj) === getType_1.types.MAP
            ? (0, convertMapToObject_1.default)(obj)
            : (0, isType_1.isObject)(obj) || (0, isType_1.isArray)(obj)
                ? obj
                : {};
};
var getObjectDeepKeyValue = function (value, dotSeparatedKeys) {
    var convertedValue = convertAnythingToArrayOrObject(value);
    var convertedValueType = "";
    if ((0, isType_1.isString)(dotSeparatedKeys)) {
        var keys = dotSeparatedKeys.split(".");
        for (var i = 0; i < keys.length; i += 1) {
            var key = keys[i];
            if (convertedValue[key] === undefined) {
                console.error("Key \"".concat(key, "\" was not found in"), value);
                convertedValue = null;
                break;
            }
            if ((0, getType_1.default)(convertedValue[key]) === getType_1.types.SET) {
                convertedValue = Array.from(convertedValue[key]);
                convertedValueType = getType_1.types.SET;
            }
            else if ((0, getType_1.default)(convertedValue[key]) === getType_1.types.MAP) {
                convertedValue = (0, convertMapToObject_1.default)(convertedValue[key]);
                convertedValueType = getType_1.types.MAP;
            }
            else {
                convertedValue = convertedValue[key];
                convertedValueType = "";
            }
        }
        // convert convertedValue to its original form
        return convertedValueType === getType_1.types.SET
            ? new Set(convertedValue)
            : convertedValueType === getType_1.types.MAP
                ? new Map(Object.entries(convertedValue))
                : convertedValue;
    }
    throw new Error('getObjectDeepKeyValue: "dotSeparatedKeys" is not a dot separated values string');
};
exports["default"] = getObjectDeepKeyValue;


/***/ }),

/***/ "../../node_modules/flatlist-react/lib/___utils/getType.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/flatlist-react/lib/___utils/getType.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.types = void 0;
var typesMap = {
    array: "ARRAY",
    boolean: "BOOLEAN",
    function: "FUNCTION",
    map: "MAP",
    null: "NULL",
    number: "NUMBER",
    object: "OBJECT",
    set: "SET",
    string: "STRING",
    symbol: "SYMBOL",
    undefined: "UNDEFINED",
    weakMap: "WEAK_MAP",
    weakSet: "WEAK_SET",
};
exports.types = Object.values(typesMap).reduce(function (obj, type) {
    obj[type] = type;
    return obj;
}, {});
var getType = function (x) {
    var type = typeof x;
    switch (type) {
        case "number":
        case "string":
        case "boolean":
        case "undefined":
        case "symbol":
        case "function":
            return typesMap[type];
        default:
            return x === null
                ? typesMap.null
                : x instanceof Set
                    ? typesMap.set
                    : x instanceof WeakSet
                        ? typesMap.weakSet
                        : x instanceof Map
                            ? typesMap.map
                            : x instanceof WeakMap
                                ? typesMap.weakMap
                                : Array.isArray(x)
                                    ? typesMap.array
                                    : typesMap.object; // otherwise it is an object
    }
};
exports["default"] = getType;


/***/ }),

/***/ "../../node_modules/flatlist-react/lib/___utils/groupList.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/flatlist-react/lib/___utils/groupList.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var getObjectDeepKeyValue_1 = __importDefault(__webpack_require__(/*! ./getObjectDeepKeyValue */ "../../node_modules/flatlist-react/lib/___utils/getObjectDeepKeyValue.js"));
var isType_1 = __webpack_require__(/*! ./isType */ "../../node_modules/flatlist-react/lib/___utils/isType.js");
var reverseList_1 = __importDefault(__webpack_require__(/*! ./reverseList */ "../../node_modules/flatlist-react/lib/___utils/reverseList.js"));
var defaultGroupOptions = {
    by: "",
    limit: 0,
    reversed: false,
};
var handleGroupReverse = function (groupedLists, reverse) {
    if (reverse === void 0) { reverse = false; }
    if (reverse && (0, isType_1.isBoolean)(reverse)) {
        return groupedLists.map(function (group) { return (0, reverseList_1.default)(group); });
    }
    return groupedLists;
};
var groupList = function (list, options) {
    if (options === void 0) { options = defaultGroupOptions; }
    var groupLabels = [];
    if ((0, isType_1.isNilOrEmpty)(options)) {
        options = defaultGroupOptions;
    }
    var groupBy = options.by, limit = options.limit;
    if (groupBy && ((0, isType_1.isFunction)(groupBy) || (0, isType_1.isString)(groupBy))) {
        var groupedList = list.reduce(function (prevList, item, idx) {
            var groupLabel = (0, isType_1.isFunction)(groupBy)
                ? groupBy(item, idx)
                : (0, getObjectDeepKeyValue_1.default)(item, groupBy);
            if (!prevList[groupLabel]) {
                prevList[groupLabel] = [];
            }
            if (!limit || (limit > 0 && prevList[groupLabel].length < limit)) {
                prevList[groupLabel].push(item);
            }
            return prevList;
        }, {});
        // using Set here so the order is preserved and prevent duplicates
        groupLabels = Array.from(new Set(Object.keys(groupedList)));
        return {
            groupLabels: groupLabels,
            groupLists: handleGroupReverse(Object.values(groupedList), options.reversed),
        };
    }
    if (limit && (0, isType_1.isNumber)(limit) && limit > 0) {
        var groupLabel_1 = 1;
        var groupLists = list.reduce(function (prevList, item) {
            if (!prevList[groupLabel_1]) {
                prevList[groupLabel_1] = [];
            }
            prevList[groupLabel_1].push(item);
            if (prevList[groupLabel_1].length === limit) {
                groupLabel_1 += 1;
            }
            return prevList;
        }, {});
        groupLabels = Array.from(new Set(Object.keys(groupLists)));
        return {
            groupLabels: groupLabels,
            groupLists: handleGroupReverse(Object.values(groupLists), options.reversed),
        };
    }
    return {
        groupLabels: groupLabels,
        groupLists: handleGroupReverse([list], options.reversed),
    };
};
exports["default"] = groupList;


/***/ }),

/***/ "../../node_modules/flatlist-react/lib/___utils/isType.js":
/*!****************************************************************!*\
  !*** ../../node_modules/flatlist-react/lib/___utils/isType.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isFunction = exports.isNilOrEmpty = exports.isEmpty = exports.isNil = exports.isMap = exports.isSet = exports.isArray = exports.isString = exports.isObjectLiteral = exports.isObject = exports.isNumeric = exports.isNumber = exports.isBoolean = void 0;
var getType_1 = __importStar(__webpack_require__(/*! ./getType */ "../../node_modules/flatlist-react/lib/___utils/getType.js"));
var isBoolean = function (x) { return (0, getType_1.default)(x) === getType_1.types.BOOLEAN; };
exports.isBoolean = isBoolean;
var isNumber = function (x) {
    return (0, getType_1.default)(Number(x)) === getType_1.types.NUMBER && !isNaN(Number(x));
};
exports.isNumber = isNumber;
var isNumeric = function (x) { return isFinite(x) && (0, exports.isNumber)(x); };
exports.isNumeric = isNumeric;
var isObject = function (x) { return (0, getType_1.default)(x) === getType_1.types.OBJECT; };
exports.isObject = isObject;
var isObjectLiteral = function (x) {
    return (0, exports.isObject)(x) && x.constructor === Object;
};
exports.isObjectLiteral = isObjectLiteral;
var isString = function (x) {
    return (0, getType_1.default)(x) === getType_1.types.STRING || x instanceof String;
};
exports.isString = isString;
var isArray = function (x) { return (0, getType_1.default)(x) === getType_1.types.ARRAY; };
exports.isArray = isArray;
var isSet = function (x) { return (0, getType_1.default)(x) === getType_1.types.SET; };
exports.isSet = isSet;
var isMap = function (x) { return (0, getType_1.default)(x) === getType_1.types.MAP; };
exports.isMap = isMap;
var isNil = function (x) {
    return x === null || (0, getType_1.default)(x) === getType_1.types.UNDEFINED;
};
exports.isNil = isNil;
var isEmpty = function (x) {
    return (((0, exports.isString)(x) || (0, exports.isArray)(x)) && x.length === 0) ||
        ((0, exports.isObject)(x) && Object.keys(x).length === 0) ||
        ((0, getType_1.default)(x) === getType_1.types.MAP && x.size === 0) ||
        ((0, getType_1.default)(x) === getType_1.types.SET && x.size === 0) ||
        ((0, getType_1.default)(x) === getType_1.types.NUMBER && isNaN(x));
};
exports.isEmpty = isEmpty;
var isNilOrEmpty = function (x) { return (0, exports.isNil)(x) || (0, exports.isEmpty)(x); };
exports.isNilOrEmpty = isNilOrEmpty;
var isFunction = function (x) { return (0, getType_1.default)(x) === getType_1.types.FUNCTION; };
exports.isFunction = isFunction;
exports["default"] = {
    isArray: exports.isArray,
    isFunction: exports.isFunction,
    isNil: exports.isNil,
    isEmpty: exports.isEmpty,
    isNilOrEmpty: exports.isNilOrEmpty,
    isNumber: exports.isNumber,
    isObject: exports.isObject,
    isString: exports.isString,
    isSet: exports.isSet,
    isMap: exports.isMap,
};


/***/ }),

/***/ "../../node_modules/flatlist-react/lib/___utils/limitList.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/flatlist-react/lib/___utils/limitList.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var isType_1 = __webpack_require__(/*! ./isType */ "../../node_modules/flatlist-react/lib/___utils/isType.js");
var limitList = function (list, limit, to) {
    if (limit === void 0) { limit = 0; }
    if (to === void 0) { to = undefined; }
    if (!limit || Number(limit) <= 0 || Number(limit) >= list.length) {
        return list;
    }
    if (to === undefined) {
        return list.slice(0, Number(limit));
    }
    return !to || !(0, isType_1.isNumber)(to) || Number(to) === 0
        ? list.slice(Number(limit))
        : list.slice(Number(limit), Number(to));
};
exports["default"] = limitList;


/***/ }),

/***/ "../../node_modules/flatlist-react/lib/___utils/reverseList.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/flatlist-react/lib/___utils/reverseList.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// avoid "reverse" array method as it changes in place
// we need to create a new reversed list instead
var reverseList = function (list) {
    return list.map(function (item, i, l) { return l[l.length - (i + 1)]; });
};
exports["default"] = reverseList;


/***/ }),

/***/ "../../node_modules/flatlist-react/lib/___utils/searchList.js":
/*!********************************************************************!*\
  !*** ../../node_modules/flatlist-react/lib/___utils/searchList.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var filterList_1 = __importDefault(__webpack_require__(/*! ./filterList */ "../../node_modules/flatlist-react/lib/___utils/filterList.js"));
var getObjectDeepKeyValue_1 = __importDefault(__webpack_require__(/*! ./getObjectDeepKeyValue */ "../../node_modules/flatlist-react/lib/___utils/getObjectDeepKeyValue.js"));
var isType_1 = __webpack_require__(/*! ./isType */ "../../node_modules/flatlist-react/lib/___utils/isType.js");
var defaultSearchOptions = {
    by: "0",
    caseInsensitive: false,
    everyWord: false,
    minCharactersCount: 3,
    term: "",
};
var defaultFilterByFn = function (item, term, caseInsensitive, by) {
    if (caseInsensitive === void 0) { caseInsensitive = false; }
    if (by === void 0) { by = "0"; }
    var keyValue = (0, isType_1.isObject)(item) || (0, isType_1.isArray)(item)
        ? (0, getObjectDeepKeyValue_1.default)(item, by)
        : item;
    var value = caseInsensitive ? "".concat(keyValue).toLowerCase() : "".concat(keyValue);
    if ((0, isType_1.isArray)(term)) {
        return term.some(function (t) {
            t = caseInsensitive ? t.toLowerCase() : t.trim();
            return value.search(t.trim()) >= 0;
        });
    }
    term = caseInsensitive ? term.toLowerCase() : term;
    return value.search(term.trim()) >= 0;
};
var getFilterByFn = function (term, by, caseInsensitive) {
    if (caseInsensitive === void 0) { caseInsensitive = false; }
    if ((0, isType_1.isFunction)(by)) {
        if ((0, isType_1.isArray)(term)) {
            return function (item, idx) {
                return term.some(function (t) {
                    t = caseInsensitive ? t.toLowerCase() : t;
                    return by(item, t.trim(), idx);
                });
            };
        }
        term = caseInsensitive ? term.toLowerCase() : term;
        return function (item, idx) {
            return by(item, term.trim(), idx);
        };
    }
    if ((0, isType_1.isArray)(by)) {
        return function (item) {
            return by.some(function (key) {
                var keyCaseInsensitive = (0, isType_1.isObject)(key) && key.caseInsensitive !== undefined
                    ? key.caseInsensitive
                    : caseInsensitive;
                var keyBy = ((0, isType_1.isObject)(key) ? key.key : key) || "0";
                return defaultFilterByFn(item, term, keyCaseInsensitive, keyBy);
            });
        };
    }
    return function (item) {
        return defaultFilterByFn(item, term, caseInsensitive, by || "0");
    };
};
var searchList = function (list, options) {
    if ((0, isType_1.isNilOrEmpty)(options)) {
        options = defaultSearchOptions;
    }
    if (list.length > 0) {
        var term = options.term, _a = options.by, by = _a === void 0 ? "0" : _a, _b = options.minCharactersCount, minCharactersCount_1 = _b === void 0 ? 0 : _b;
        if (term && by && term.length >= minCharactersCount_1) {
            var everyWord = options.everyWord, caseInsensitive = options.caseInsensitive;
            if (everyWord) {
                var termWords = term
                    .trim()
                    .split(/\s+/)
                    .filter(function (word) { return word.length >= minCharactersCount_1; });
                if (termWords.length > 0) {
                    var filterByFn = getFilterByFn(Array.from(new Set(termWords)), by, caseInsensitive);
                    return (0, filterList_1.default)(list, filterByFn);
                }
            }
            else {
                var filterByFn = getFilterByFn(term, by, caseInsensitive);
                return (0, filterList_1.default)(list, filterByFn);
            }
        }
    }
    return list;
};
exports["default"] = searchList;


/***/ }),

/***/ "../../node_modules/flatlist-react/lib/___utils/sortList.js":
/*!******************************************************************!*\
  !*** ../../node_modules/flatlist-react/lib/___utils/sortList.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var getObjectDeepKeyValue_1 = __importDefault(__webpack_require__(/*! ./getObjectDeepKeyValue */ "../../node_modules/flatlist-react/lib/___utils/getObjectDeepKeyValue.js"));
var isType_1 = __webpack_require__(/*! ./isType */ "../../node_modules/flatlist-react/lib/___utils/isType.js");
var defaultSortOptions = {
    caseInsensitive: false,
    descending: false,
    by: "",
};
var compareKeys = function (first, second, _a) {
    var _b = _a.key, key = _b === void 0 ? "" : _b, _c = _a.caseInsensitive, caseInsensitive = _c === void 0 ? false : _c, _d = _a.descending, descending = _d === void 0 ? false : _d;
    if (key) {
        first =
            (0, isType_1.isObject)(first) || (0, isType_1.isArray)(first)
                ? (0, getObjectDeepKeyValue_1.default)(first, key)
                : first;
        second =
            (0, isType_1.isObject)(second) || (0, isType_1.isArray)(second)
                ? (0, getObjectDeepKeyValue_1.default)(second, key)
                : second;
    }
    if (caseInsensitive) {
        first = (0, isType_1.isString)(first) ? first.toLowerCase() : first;
        second = (0, isType_1.isString)(second) ? second.toLowerCase() : second;
    }
    return first > second
        ? descending
            ? -1
            : 1
        : first < second
            ? descending
                ? 1
                : -1
            : 0;
};
var sortList = function (list, options) {
    if (options === void 0) { options = defaultSortOptions; }
    var listCopy = __spreadArray([], list, true);
    if ((0, isType_1.isNilOrEmpty)(options)) {
        options = defaultSortOptions;
    }
    options = __assign(__assign({}, defaultSortOptions), options);
    listCopy.sort(function (first, second) {
        if ((0, isType_1.isArray)(options.by)) {
            for (var i = 0; i < options.by.length; i += 1) {
                var key = options.by[i];
                var option = (0, isType_1.isObject)(key) ? key : __assign(__assign({}, options), { key: key });
                var res = compareKeys(first, second, option);
                if (res !== 0) {
                    return res;
                }
            }
            return 0;
        }
        return compareKeys(first, second, __assign(__assign({}, options), { key: options.by }));
    });
    return listCopy;
};
exports["default"] = sortList;


/***/ }),

/***/ "../../node_modules/flatlist-react/lib/flatListProps.js":
/*!**************************************************************!*\
  !*** ../../node_modules/flatlist-react/lib/flatListProps.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultProps = void 0;
exports.defaultProps = {
    __forwarededRef: { current: null },
    // RENDER
    list: [],
    renderItem: function () { return null; },
    limit: 0,
    renderWhenEmpty: null,
    reversed: false,
    renderOnScroll: false,
    wrapperHtmlTag: "",
    // DISPLAY
    display: {
        grid: false,
        gridGap: "",
        gridMinColumnWidth: "",
        row: false,
        rowGap: "",
    },
    displayGrid: false,
    displayRow: false,
    gridGap: "",
    rowGap: "",
    minColumnWidth: "",
    // FILTER
    filterBy: "",
    // GROUPS
    group: {
        by: "",
        limit: 0,
        of: 0,
        reversed: false,
        separator: null,
        separatorAtTheBottom: false,
        sortedBy: "",
        sortBy: "",
        sortedCaseInsensitive: false,
        sortCaseInsensitive: false,
        sortedDescending: false,
        sortDescending: false, // deprecated
    },
    groupBy: "",
    groupOf: 0,
    groupReversed: false,
    groupSeparator: null,
    groupSeparatorAtTheBottom: false,
    groupSorted: false,
    groupSortedBy: "",
    groupSortedDescending: false,
    groupSortedCaseInsensitive: false,
    showGroupSeparatorAtTheBottom: false,
    // PAGINATION
    pagination: {
        hasMore: false,
        loadMore: null,
        loadingIndicator: null,
        loadingIndicatorPosition: "",
    },
    hasMoreItems: false,
    loadMoreItems: null,
    paginationLoadingIndicator: null,
    paginationLoadingIndicatorPosition: "",
    // SCROLL TO TOP
    scrollToTop: {
        button: null,
        offset: undefined,
        padding: undefined,
        position: undefined,
    },
    scrollToTopButton: null,
    scrollToTopOffset: undefined,
    scrollToTopPadding: undefined,
    scrollToTopPosition: undefined,
    // SEARCH
    search: {
        by: "",
        caseInsensitive: false,
        everyWord: false,
        onEveryWord: false,
        minCharactersCount: 0,
        term: "",
    },
    searchBy: "",
    searchCaseInsensitive: false,
    searchOnEveryWord: false,
    searchTerm: "",
    searchMinCharactersCount: 0,
    searchableMinCharactersCount: 0,
    // SORT
    sort: {
        by: "",
        caseInsensitive: false,
        descending: false,
        groupBy: "",
        groupCaseInsensitive: false,
        groupDescending: false, // deprecated
    },
    sortBy: "",
    sortCaseInsensitive: false,
    sortDesc: false,
    sortDescending: false,
    sortGroupBy: "",
    sortGroupDesc: false,
    sortGroupCaseInsensitive: false, // deprecated
};


/***/ }),

/***/ "../../node_modules/flatlist-react/lib/flatlist-react.js":
/*!***************************************************************!*\
  !*** ../../node_modules/flatlist-react/lib/flatlist-react.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var react_1 = __importStar(__webpack_require__(/*! react */ "../../node_modules/react/index.js"));
var DisplayHandler_1 = __importDefault(__webpack_require__(/*! ./___subComponents/DisplayHandler */ "../../node_modules/flatlist-react/lib/___subComponents/DisplayHandler.js"));
var InfiniteLoader_1 = __importDefault(__webpack_require__(/*! ./___subComponents/InfiniteLoader */ "../../node_modules/flatlist-react/lib/___subComponents/InfiniteLoader.js"));
var ScrollRenderer_1 = __importDefault(__webpack_require__(/*! ./___subComponents/ScrollRenderer */ "../../node_modules/flatlist-react/lib/___subComponents/ScrollRenderer.js"));
var ScrollToTopButton_1 = __importDefault(__webpack_require__(/*! ./___subComponents/ScrollToTopButton */ "../../node_modules/flatlist-react/lib/___subComponents/ScrollToTopButton.js"));
var uiFunctions_1 = __webpack_require__(/*! ./___subComponents/uiFunctions */ "../../node_modules/flatlist-react/lib/___subComponents/uiFunctions.js");
var isType_1 = __webpack_require__(/*! ./___utils/isType */ "../../node_modules/flatlist-react/lib/___utils/isType.js");
var flatListProps_1 = __webpack_require__(/*! ./flatListProps */ "../../node_modules/flatlist-react/lib/flatListProps.js");
var use_list_1 = __webpack_require__(/*! ./hooks/use-list */ "../../node_modules/flatlist-react/lib/hooks/use-list.js");
function FlatList(props) {
    var _a = __assign(__assign({}, flatListProps_1.defaultProps), props), list = _a.list, _b = _a.renderWhenEmpty, renderWhenEmpty = _b === void 0 ? null : _b, wrapperHtmlTag = _a.wrapperHtmlTag, renderItem = _a.renderItem, renderOnScroll = _a.renderOnScroll, // render/list related props
    _c = _a.group, // render/list related props
    group = _c === void 0 ? {} : _c, groupSeparator = _a.groupSeparator, // group props
    _d = _a.display, // group props
    display = _d === void 0 ? {} : _d, displayRow = _a.displayRow, rowGap = _a.rowGap, displayGrid = _a.displayGrid, gridGap = _a.gridGap, minColumnWidth = _a.minColumnWidth, // display props,
    hasMoreItems = _a.hasMoreItems, loadMoreItems = _a.loadMoreItems, paginationLoadingIndicator = _a.paginationLoadingIndicator, paginationLoadingIndicatorPosition = _a.paginationLoadingIndicatorPosition, scrollToTop = _a.scrollToTop, _e = _a.scrollToTopButton, scrollToTopButton = _e === void 0 ? null : _e, scrollToTopPadding = _a.scrollToTopPadding, scrollToTopOffset = _a.scrollToTopOffset, scrollToTopPosition = _a.scrollToTopPosition, _f = _a.pagination, pagination = _f === void 0 ? {} : _f, // pagination props
    // eslint-disable-next-line @typescript-eslint/naming-convention
    // @ts-ignore
    __forwarededRef = _a.__forwarededRef, otherProps = __rest(_a, ["list", "renderWhenEmpty", "wrapperHtmlTag", "renderItem", "renderOnScroll", "group", "groupSeparator", "display", "displayRow", "rowGap", "displayGrid", "gridGap", "minColumnWidth", "hasMoreItems", "loadMoreItems", "paginationLoadingIndicator", "paginationLoadingIndicatorPosition", "scrollToTop", "scrollToTopButton", "scrollToTopPadding", "scrollToTopOffset", "scrollToTopPosition", "pagination", "__forwarededRef"]);
    var renderList = (0, use_list_1.useList)(props);
    var tagProps = (0, react_1.useMemo)(function () {
        return Object.keys(otherProps)
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            .filter(function (k) { return flatListProps_1.defaultProps[k] === undefined; })
            .reduce(function (p, k) {
            var _a;
            return (__assign(__assign({}, p), (_a = {}, _a[k] = otherProps[k], _a)));
        }, {});
    }, [otherProps]);
    var renderThisItem = (0, react_1.useMemo)(function () {
        return (0, uiFunctions_1.handleRenderItem)(renderItem, (0, uiFunctions_1.handleRenderGroupSeparator)(group.separator || groupSeparator));
    }, [renderItem, group.separator, groupSeparator]);
    if (renderList.length === 0) {
        return (0, uiFunctions_1.renderBlank)(renderWhenEmpty);
    }
    var content = (react_1.default.createElement(react_1.default.Fragment, null,
        renderOnScroll && !(loadMoreItems || pagination.loadMore) ? (react_1.default.createElement(ScrollRenderer_1.default, { list: renderList, renderItem: renderItem, groupSeparator: group.separator || groupSeparator })) : (renderList.map(renderThisItem)),
        (displayRow || displayGrid || display.grid || display.row) && (react_1.default.createElement(DisplayHandler_1.default, __assign({}, {
            display: display,
            displayRow: displayRow,
            rowGap: rowGap,
            displayGrid: displayGrid,
            gridGap: gridGap,
            minColumnWidth: minColumnWidth,
        }))),
        (loadMoreItems || pagination.loadMore) && !renderOnScroll && (react_1.default.createElement(InfiniteLoader_1.default, { itemsCount: renderList.length, hasMore: hasMoreItems || pagination.hasMore, loadMore: loadMoreItems || pagination.loadMore, loadingIndicator: paginationLoadingIndicator || pagination.loadingIndicator, loadingIndicatorPosition: paginationLoadingIndicatorPosition ||
                pagination.loadingIndicatorPosition }))));
    var showScrollToTopButton = scrollToTop === true ||
        scrollToTop.button ||
        scrollToTopButton;
    var WrapperElement = "";
    if (((0, isType_1.isString)(wrapperHtmlTag) && wrapperHtmlTag) || showScrollToTopButton) {
        WrapperElement = wrapperHtmlTag || "div";
    }
    return (react_1.default.createElement(react_1.default.Fragment, null,
        WrapperElement ? (
        // @ts-ignore
        react_1.default.createElement(WrapperElement, __assign({ ref: __forwarededRef }, tagProps), content)) : (content),
        showScrollToTopButton && (react_1.default.createElement(ScrollToTopButton_1.default, { button: scrollToTopButton !== null && scrollToTopButton !== void 0 ? scrollToTopButton : scrollToTop.button, padding: scrollToTopPadding !== null && scrollToTopPadding !== void 0 ? scrollToTopPadding : scrollToTop.padding, offset: scrollToTopOffset !== null && scrollToTopOffset !== void 0 ? scrollToTopOffset : scrollToTop.offset, position: scrollToTopPosition !== null && scrollToTopPosition !== void 0 ? scrollToTopPosition : scrollToTop.position, scrollingContainer: __forwarededRef }))));
}
// export default FlatList;
exports["default"] = (0, react_1.forwardRef)(function (props, ref) {
    ref = ref || (0, react_1.createRef)();
    return react_1.default.createElement(FlatList, __assign({ __forwarededRef: ref }, props));
});


/***/ }),

/***/ "../../node_modules/flatlist-react/lib/hooks/use-list.js":
/*!***************************************************************!*\
  !*** ../../node_modules/flatlist-react/lib/hooks/use-list.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.useList = void 0;
var react_1 = __webpack_require__(/*! react */ "../../node_modules/react/index.js");
var convertListToArray_1 = __importDefault(__webpack_require__(/*! ../___utils/convertListToArray */ "../../node_modules/flatlist-react/lib/___utils/convertListToArray.js"));
var filterList_1 = __importDefault(__webpack_require__(/*! ../___utils/filterList */ "../../node_modules/flatlist-react/lib/___utils/filterList.js"));
var groupList_1 = __importDefault(__webpack_require__(/*! ../___utils/groupList */ "../../node_modules/flatlist-react/lib/___utils/groupList.js"));
var isType_1 = __webpack_require__(/*! ../___utils/isType */ "../../node_modules/flatlist-react/lib/___utils/isType.js");
var limitList_1 = __importDefault(__webpack_require__(/*! ../___utils/limitList */ "../../node_modules/flatlist-react/lib/___utils/limitList.js"));
var reverseList_1 = __importDefault(__webpack_require__(/*! ../___utils/reverseList */ "../../node_modules/flatlist-react/lib/___utils/reverseList.js"));
var searchList_1 = __importDefault(__webpack_require__(/*! ../___utils/searchList */ "../../node_modules/flatlist-react/lib/___utils/searchList.js"));
var sortList_1 = __importDefault(__webpack_require__(/*! ../___utils/sortList */ "../../node_modules/flatlist-react/lib/___utils/sortList.js"));
var flatListProps_1 = __webpack_require__(/*! ../flatListProps */ "../../node_modules/flatlist-react/lib/flatListProps.js");
var useList = function (_a) {
    var list = _a.list, limit = _a.limit, reversed = _a.reversed, filterBy = _a.filterBy, group = _a.group, groupBy = _a.groupBy, groupOf = _a.groupOf, showGroupSeparatorAtTheBottom = _a.showGroupSeparatorAtTheBottom, groupReversed = _a.groupReversed, groupSeparatorAtTheBottom = _a.groupSeparatorAtTheBottom, groupSortedCaseInsensitive = _a.groupSortedCaseInsensitive, groupSortedDescending = _a.groupSortedDescending, groupSorted = _a.groupSorted, groupSortedBy = _a.groupSortedBy, sortBy = _a.sortBy, sortDesc = _a.sortDesc, sort = _a.sort, sortCaseInsensitive = _a.sortCaseInsensitive, sortGroupBy = _a.sortGroupBy, sortGroupDesc = _a.sortGroupDesc, sortGroupCaseInsensitive = _a.sortGroupCaseInsensitive, sortDescending = _a.sortDescending, search = _a.search, searchBy = _a.searchBy, searchOnEveryWord = _a.searchOnEveryWord, searchTerm = _a.searchTerm, searchCaseInsensitive = _a.searchCaseInsensitive, searchableMinCharactersCount = _a.searchableMinCharactersCount, searchMinCharactersCount = _a.searchMinCharactersCount;
    // convert list to array
    var renderList = (0, react_1.useMemo)(function () { return (0, convertListToArray_1.default)(list); }, [list]);
    // reverse list
    renderList = (0, react_1.useMemo)(function () {
        return typeof reversed === "boolean" && reversed
            ? (0, reverseList_1.default)(renderList)
            : renderList;
    }, [renderList, reversed]);
    // limit list
    renderList = (0, react_1.useMemo)(function () {
        if (!(0, isType_1.isNil)(limit)) {
            var _a = "".concat(limit).split(","), from = _a[0], to = _a[1];
            return (0, limitList_1.default)(renderList, from, to);
        }
        return renderList;
    }, [renderList, limit]);
    // filter list
    renderList = (0, react_1.useMemo)(function () { return (filterBy ? (0, filterList_1.default)(renderList, filterBy) : renderList); }, [renderList, filterBy]);
    // search list
    renderList = (0, react_1.useMemo)(function () {
        if (searchTerm || (search && search.term)) {
            var searchOptions = __assign(__assign({}, flatListProps_1.defaultProps.search), search);
            return (0, searchList_1.default)(renderList, {
                by: searchOptions.by || searchBy || "0",
                caseInsensitive: searchOptions.caseInsensitive || searchCaseInsensitive,
                everyWord: searchOptions.onEveryWord ||
                    searchOptions.everyWord || // deprecated
                    searchOnEveryWord,
                term: searchOptions.term || searchTerm,
                minCharactersCount: 
                // @ts-ignore
                searchOptions.searchableMinCharactersCount || // deprecated
                    searchOptions.minCharactersCount ||
                    searchMinCharactersCount ||
                    searchableMinCharactersCount || // deprecated
                    3,
            });
        }
        return renderList;
    }, [
        renderList,
        search,
        searchBy,
        searchOnEveryWord,
        searchTerm,
        searchCaseInsensitive,
        searchableMinCharactersCount,
        searchMinCharactersCount,
    ]);
    var sortOptions = (0, react_1.useMemo)(function () { return (__assign(__assign({}, flatListProps_1.defaultProps.sort), sort)); }, [renderList, sort]);
    // sort list
    renderList = (0, react_1.useMemo)(function () {
        if (sortOptions.by || sortBy || ((0, isType_1.isBoolean)(sort) && sort)) {
            return (0, sortList_1.default)(renderList, {
                caseInsensitive: sortOptions.caseInsensitive || sortCaseInsensitive || false,
                descending: sortOptions.descending || sortDescending || sortDesc || false,
                by: sortOptions.by || sortBy,
            });
        }
        return renderList;
    }, [
        renderList,
        sortOptions,
        sortBy,
        sortDesc,
        sort,
        sortCaseInsensitive,
        sortDescending,
    ]);
    // group list
    renderList = (0, react_1.useMemo)(function () {
        var groupOptions = __assign(__assign({}, flatListProps_1.defaultProps.group), group);
        if (groupOptions.by ||
            groupBy ||
            groupOf ||
            groupOptions.of ||
            groupOptions.limit) {
            var groupingOptions = {
                by: groupOptions.by || groupBy,
                limit: groupOptions.of || groupOf || groupOptions.limit,
                reversed: groupOptions.reversed || groupReversed,
            };
            var gList_1 = (0, groupList_1.default)(renderList, groupingOptions);
            return gList_1.groupLists.reduce(function (newGList, aGroup, idx) {
                if (groupSorted ||
                    // @ts-ignore
                    groupOptions.sorted ||
                    groupSortedBy ||
                    // @ts-ignore
                    groupOptions.sortedBy ||
                    groupOptions.sortBy ||
                    sortGroupBy ||
                    sortOptions.groupBy // deprecated
                ) {
                    aGroup = (0, sortList_1.default)(aGroup, {
                        caseInsensitive: groupSortedCaseInsensitive ||
                            // @ts-ignore
                            groupOptions.sortedCaseInsensitive ||
                            groupOptions.sortCaseInsensitive || // deprecated
                            sortGroupCaseInsensitive || // deprecated
                            sortOptions.groupCaseInsensitive,
                        descending: groupSortedDescending ||
                            // @ts-ignore
                            groupOptions.sortedDescending ||
                            groupOptions.sortDescending || // deprecated
                            sortGroupDesc,
                        by: groupSortedBy ||
                            // @ts-ignore
                            groupOptions.sortedBy ||
                            groupOptions.sortBy || // deprecated
                            sortGroupBy, // deprecated
                    });
                }
                var separator = ["___list-separator", gList_1.groupLabels[idx], aGroup];
                if (groupOptions.separatorAtTheBottom ||
                    groupSeparatorAtTheBottom ||
                    showGroupSeparatorAtTheBottom) {
                    return __spreadArray(__spreadArray(__spreadArray([], newGList, true), aGroup, true), [separator], false);
                }
                return __spreadArray(__spreadArray(__spreadArray([], newGList, true), [separator], false), aGroup, true);
            }, []);
        }
        return renderList;
    }, [
        renderList,
        group,
        groupReversed,
        groupSeparatorAtTheBottom,
        groupSortedCaseInsensitive,
        groupSortedDescending,
        groupSorted,
        groupSortedBy,
        sortGroupBy,
        sortGroupDesc,
        sortGroupCaseInsensitive,
    ]);
    return renderList;
};
exports.useList = useList;


/***/ }),

/***/ "../../node_modules/flatlist-react/lib/index.js":
/*!******************************************************!*\
  !*** ../../node_modules/flatlist-react/lib/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PlainList = exports.limitList = exports.groupList = exports.filterList = exports.searchList = exports.sortList = void 0;
var flatlist_react_1 = __importDefault(__webpack_require__(/*! ./flatlist-react */ "../../node_modules/flatlist-react/lib/flatlist-react.js"));
var sortList_1 = __webpack_require__(/*! ./___utils/sortList */ "../../node_modules/flatlist-react/lib/___utils/sortList.js");
Object.defineProperty(exports, "sortList", ({ enumerable: true, get: function () { return __importDefault(sortList_1).default; } }));
var searchList_1 = __webpack_require__(/*! ./___utils/searchList */ "../../node_modules/flatlist-react/lib/___utils/searchList.js");
Object.defineProperty(exports, "searchList", ({ enumerable: true, get: function () { return __importDefault(searchList_1).default; } }));
var filterList_1 = __webpack_require__(/*! ./___utils/filterList */ "../../node_modules/flatlist-react/lib/___utils/filterList.js");
Object.defineProperty(exports, "filterList", ({ enumerable: true, get: function () { return __importDefault(filterList_1).default; } }));
var groupList_1 = __webpack_require__(/*! ./___utils/groupList */ "../../node_modules/flatlist-react/lib/___utils/groupList.js");
Object.defineProperty(exports, "groupList", ({ enumerable: true, get: function () { return __importDefault(groupList_1).default; } }));
var limitList_1 = __webpack_require__(/*! ./___utils/limitList */ "../../node_modules/flatlist-react/lib/___utils/limitList.js");
Object.defineProperty(exports, "limitList", ({ enumerable: true, get: function () { return __importDefault(limitList_1).default; } }));
var PlainList_1 = __webpack_require__(/*! ./___subComponents/PlainList */ "../../node_modules/flatlist-react/lib/___subComponents/PlainList.js");
Object.defineProperty(exports, "PlainList", ({ enumerable: true, get: function () { return __importDefault(PlainList_1).default; } }));
exports["default"] = flatlist_react_1.default;


/***/ }),

/***/ "../../node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var reactIs = __webpack_require__(/*! react-is */ "../../node_modules/hoist-non-react-statics/node_modules/react-is/index.js");

/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
var REACT_STATICS = {
  childContextTypes: true,
  contextType: true,
  contextTypes: true,
  defaultProps: true,
  displayName: true,
  getDefaultProps: true,
  getDerivedStateFromError: true,
  getDerivedStateFromProps: true,
  mixins: true,
  propTypes: true,
  type: true
};
var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};
var FORWARD_REF_STATICS = {
  '$$typeof': true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  '$$typeof': true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;

function getStatics(component) {
  // React v16.11 and below
  if (reactIs.isMemo(component)) {
    return MEMO_STATICS;
  } // React v16.12 and above


  return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
}

var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = Object.prototype;
function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
  if (typeof sourceComponent !== 'string') {
    // don't hoist over string (html) components
    if (objectPrototype) {
      var inheritedComponent = getPrototypeOf(sourceComponent);

      if (inheritedComponent && inheritedComponent !== objectPrototype) {
        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
      }
    }

    var keys = getOwnPropertyNames(sourceComponent);

    if (getOwnPropertySymbols) {
      keys = keys.concat(getOwnPropertySymbols(sourceComponent));
    }

    var targetStatics = getStatics(targetComponent);
    var sourceStatics = getStatics(sourceComponent);

    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];

      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);

        try {
          // Avoid failures from read-only properties
          defineProperty(targetComponent, key, descriptor);
        } catch (e) {}
      }
    }
  }

  return targetComponent;
}

module.exports = hoistNonReactStatics;


/***/ }),

/***/ "../../node_modules/hoist-non-react-statics/node_modules/react-is/cjs/react-is.development.js":
/*!****************************************************************************************************!*\
  !*** ../../node_modules/hoist-non-react-statics/node_modules/react-is/cjs/react-is.development.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (true) {
  (function() {
'use strict';

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
// (unstable) APIs that have been removed. Can we remove the symbols?

var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
}

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;

    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_ASYNC_MODE_TYPE:
          case REACT_CONCURRENT_MODE_TYPE:
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
            return type;

          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;

              default:
                return $$typeof;
            }

        }

      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
} // AsyncMode is deprecated along with isAsyncMode

var AsyncMode = REACT_ASYNC_MODE_TYPE;
var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;
var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
    }
  }

  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
}
function isConcurrentMode(object) {
  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}

exports.AsyncMode = AsyncMode;
exports.ConcurrentMode = ConcurrentMode;
exports.ContextConsumer = ContextConsumer;
exports.ContextProvider = ContextProvider;
exports.Element = Element;
exports.ForwardRef = ForwardRef;
exports.Fragment = Fragment;
exports.Lazy = Lazy;
exports.Memo = Memo;
exports.Portal = Portal;
exports.Profiler = Profiler;
exports.StrictMode = StrictMode;
exports.Suspense = Suspense;
exports.isAsyncMode = isAsyncMode;
exports.isConcurrentMode = isConcurrentMode;
exports.isContextConsumer = isContextConsumer;
exports.isContextProvider = isContextProvider;
exports.isElement = isElement;
exports.isForwardRef = isForwardRef;
exports.isFragment = isFragment;
exports.isLazy = isLazy;
exports.isMemo = isMemo;
exports.isPortal = isPortal;
exports.isProfiler = isProfiler;
exports.isStrictMode = isStrictMode;
exports.isSuspense = isSuspense;
exports.isValidElementType = isValidElementType;
exports.typeOf = typeOf;
  })();
}


/***/ }),

/***/ "../../node_modules/hoist-non-react-statics/node_modules/react-is/index.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/hoist-non-react-statics/node_modules/react-is/index.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ "../../node_modules/hoist-non-react-statics/node_modules/react-is/cjs/react-is.development.js");
}


/***/ }),

/***/ "../../node_modules/html-parse-stringify/dist/html-parse-stringify.module.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/html-parse-stringify/dist/html-parse-stringify.module.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var void_elements__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! void-elements */ "../../node_modules/void-elements/index.js");
/* harmony import */ var void_elements__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(void_elements__WEBPACK_IMPORTED_MODULE_0__);
var t=/\s([^'"/\s><]+?)[\s/>]|([^\s=]+)=\s?(".*?"|'.*?')/g;function n(n){var r={type:"tag",name:"",voidElement:!1,attrs:{},children:[]},i=n.match(/<\/?([^\s]+?)[/\s>]/);if(i&&(r.name=i[1],((void_elements__WEBPACK_IMPORTED_MODULE_0___default())[i[1]]||"/"===n.charAt(n.length-2))&&(r.voidElement=!0),r.name.startsWith("!--"))){var s=n.indexOf("--\x3e");return{type:"comment",comment:-1!==s?n.slice(4,s):""}}for(var a=new RegExp(t),c=null;null!==(c=a.exec(n));)if(c[0].trim())if(c[1]){var o=c[1].trim(),l=[o,""];o.indexOf("=")>-1&&(l=o.split("=")),r.attrs[l[0]]=l[1],a.lastIndex--}else c[2]&&(r.attrs[c[2]]=c[3].trim().substring(1,c[3].length-1));return r}var r=/<[a-zA-Z0-9\-\!\/](?:"[^"]*"|'[^']*'|[^'">])*>/g,i=/^\s*$/,s=Object.create(null);function a(e,t){switch(t.type){case"text":return e+t.content;case"tag":return e+="<"+t.name+(t.attrs?function(e){var t=[];for(var n in e)t.push(n+'="'+e[n]+'"');return t.length?" "+t.join(" "):""}(t.attrs):"")+(t.voidElement?"/>":">"),t.voidElement?e:e+t.children.reduce(a,"")+"</"+t.name+">";case"comment":return e+"\x3c!--"+t.comment+"--\x3e"}}var c={parse:function(e,t){t||(t={}),t.components||(t.components=s);var a,c=[],o=[],l=-1,m=!1;if(0!==e.indexOf("<")){var u=e.indexOf("<");c.push({type:"text",content:-1===u?e:e.substring(0,u)})}return e.replace(r,function(r,s){if(m){if(r!=="</"+a.name+">")return;m=!1}var u,f="/"!==r.charAt(1),h=r.startsWith("\x3c!--"),p=s+r.length,d=e.charAt(p);if(h){var v=n(r);return l<0?(c.push(v),c):((u=o[l]).children.push(v),c)}if(f&&(l++,"tag"===(a=n(r)).type&&t.components[a.name]&&(a.type="component",m=!0),a.voidElement||m||!d||"<"===d||a.children.push({type:"text",content:e.slice(p,e.indexOf("<",p))}),0===l&&c.push(a),(u=o[l-1])&&u.children.push(a),o[l]=a),(!f||a.voidElement)&&(l>-1&&(a.voidElement||a.name===r.slice(2,-1))&&(l--,a=-1===l?c:o[l]),!m&&"<"!==d&&d)){u=-1===l?c:o[l].children;var x=e.indexOf("<",p),g=e.slice(p,-1===x?void 0:x);i.test(g)&&(g=" "),(x>-1&&l+u.length>=0||" "!==g)&&u.push({type:"text",content:g})}}),c},stringify:function(e){return e.reduce(function(e,t){return e+a("",t)},"")}};/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (c);
//# sourceMappingURL=html-parse-stringify.module.js.map


/***/ }),

/***/ "../../node_modules/immer/dist/immer.cjs.development.js":
/*!**************************************************************!*\
  !*** ../../node_modules/immer/dist/immer.cjs.development.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var _ref;

// Should be no imports here!
// Some things that should be evaluated before all else...
// We only want to know if non-polyfilled symbols are available
var hasSymbol = typeof Symbol !== "undefined" && typeof
/*#__PURE__*/
Symbol("x") === "symbol";
var hasMap = typeof Map !== "undefined";
var hasSet = typeof Set !== "undefined";
var hasProxies = typeof Proxy !== "undefined" && typeof Proxy.revocable !== "undefined" && typeof Reflect !== "undefined";
/**
 * The sentinel value returned by producers to replace the draft with undefined.
 */

var NOTHING = hasSymbol ?
/*#__PURE__*/
Symbol.for("immer-nothing") : (_ref = {}, _ref["immer-nothing"] = true, _ref);
/**
 * To let Immer treat your class instances as plain immutable objects
 * (albeit with a custom prototype), you must define either an instance property
 * or a static property on each of your custom classes.
 *
 * Otherwise, your class instance will never be drafted, which means it won't be
 * safe to mutate in a produce callback.
 */

var DRAFTABLE = hasSymbol ?
/*#__PURE__*/
Symbol.for("immer-draftable") : "__$immer_draftable";
var DRAFT_STATE = hasSymbol ?
/*#__PURE__*/
Symbol.for("immer-state") : "__$immer_state"; // Even a polyfilled Symbol might provide Symbol.iterator

var iteratorSymbol = typeof Symbol != "undefined" && Symbol.iterator || "@@iterator";

var errors = {
  0: "Illegal state",
  1: "Immer drafts cannot have computed properties",
  2: "This object has been frozen and should not be mutated",
  3: function _(data) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + data;
  },
  4: "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  5: "Immer forbids circular references",
  6: "The first or second argument to `produce` must be a function",
  7: "The third argument to `produce` must be a function or undefined",
  8: "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  9: "First argument to `finishDraft` must be a draft returned by `createDraft`",
  10: "The given draft is already finalized",
  11: "Object.defineProperty() cannot be used on an Immer draft",
  12: "Object.setPrototypeOf() cannot be used on an Immer draft",
  13: "Immer only supports deleting array indices",
  14: "Immer only supports setting array indices and the 'length' property",
  15: function _(path) {
    return "Cannot apply patch, path doesn't resolve: " + path;
  },
  16: 'Sets cannot have "replace" patches.',
  17: function _(op) {
    return "Unsupported patch operation: " + op;
  },
  18: function _(plugin) {
    return "The plugin for '" + plugin + "' has not been loaded into Immer. To enable the plugin, import and call `enable" + plugin + "()` when initializing your application.";
  },
  20: "Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available",
  21: function _(thing) {
    return "produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '" + thing + "'";
  },
  22: function _(thing) {
    return "'current' expects a draft, got: " + thing;
  },
  23: function _(thing) {
    return "'original' expects a draft, got: " + thing;
  },
  24: "Patching reserved attributes like __proto__, prototype and constructor is not allowed"
};
function die(error) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  {
    var e = errors[error];
    var msg = !e ? "unknown error nr: " + error : typeof e === "function" ? e.apply(null, args) : e;
    throw new Error("[Immer] " + msg);
  }
}

/** Returns true if the given value is an Immer draft */

/*#__PURE__*/

function isDraft(value) {
  return !!value && !!value[DRAFT_STATE];
}
/** Returns true if the given value can be drafted by Immer */

/*#__PURE__*/

function isDraftable(value) {
  var _value$constructor;

  if (!value) return false;
  return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!((_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor[DRAFTABLE]) || isMap(value) || isSet(value);
}
var objectCtorString =
/*#__PURE__*/
Object.prototype.constructor.toString();
/*#__PURE__*/

function isPlainObject(value) {
  if (!value || typeof value !== "object") return false;
  var proto = Object.getPrototypeOf(value);

  if (proto === null) {
    return true;
  }

  var Ctor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  if (Ctor === Object) return true;
  return typeof Ctor == "function" && Function.toString.call(Ctor) === objectCtorString;
}
function original(value) {
  if (!isDraft(value)) die(23, value);
  return value[DRAFT_STATE].base_;
}
/*#__PURE__*/

var ownKeys = typeof Reflect !== "undefined" && Reflect.ownKeys ? Reflect.ownKeys : typeof Object.getOwnPropertySymbols !== "undefined" ? function (obj) {
  return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));
} :
/* istanbul ignore next */
Object.getOwnPropertyNames;
var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(target) {
  // Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274
  var res = {};
  ownKeys(target).forEach(function (key) {
    res[key] = Object.getOwnPropertyDescriptor(target, key);
  });
  return res;
};
function each(obj, iter, enumerableOnly) {
  if (enumerableOnly === void 0) {
    enumerableOnly = false;
  }

  if (getArchtype(obj) === 0
  /* Object */
  ) {
      (enumerableOnly ? Object.keys : ownKeys)(obj).forEach(function (key) {
        if (!enumerableOnly || typeof key !== "symbol") iter(key, obj[key], obj);
      });
    } else {
    obj.forEach(function (entry, index) {
      return iter(index, entry, obj);
    });
  }
}
/*#__PURE__*/

function getArchtype(thing) {
  /* istanbul ignore next */
  var state = thing[DRAFT_STATE];
  return state ? state.type_ > 3 ? state.type_ - 4 // cause Object and Array map back from 4 and 5
  : state.type_ // others are the same
  : Array.isArray(thing) ? 1
  /* Array */
  : isMap(thing) ? 2
  /* Map */
  : isSet(thing) ? 3
  /* Set */
  : 0
  /* Object */
  ;
}
/*#__PURE__*/

function has(thing, prop) {
  return getArchtype(thing) === 2
  /* Map */
  ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);
}
/*#__PURE__*/

function get(thing, prop) {
  // @ts-ignore
  return getArchtype(thing) === 2
  /* Map */
  ? thing.get(prop) : thing[prop];
}
/*#__PURE__*/

function set(thing, propOrOldValue, value) {
  var t = getArchtype(thing);
  if (t === 2
  /* Map */
  ) thing.set(propOrOldValue, value);else if (t === 3
  /* Set */
  ) {
      thing.delete(propOrOldValue);
      thing.add(value);
    } else thing[propOrOldValue] = value;
}
/*#__PURE__*/

function is(x, y) {
  // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js
  if (x === y) {
    return x !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}
/*#__PURE__*/

function isMap(target) {
  return hasMap && target instanceof Map;
}
/*#__PURE__*/

function isSet(target) {
  return hasSet && target instanceof Set;
}
/*#__PURE__*/

function latest(state) {
  return state.copy_ || state.base_;
}
/*#__PURE__*/

function shallowCopy(base) {
  if (Array.isArray(base)) return Array.prototype.slice.call(base);
  var descriptors = getOwnPropertyDescriptors(base);
  delete descriptors[DRAFT_STATE];
  var keys = ownKeys(descriptors);

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var desc = descriptors[key];

    if (desc.writable === false) {
      desc.writable = true;
      desc.configurable = true;
    } // like object.assign, we will read any _own_, get/set accessors. This helps in dealing
    // with libraries that trap values, like mobx or vue
    // unlike object.assign, non-enumerables will be copied as well


    if (desc.get || desc.set) descriptors[key] = {
      configurable: true,
      writable: true,
      enumerable: desc.enumerable,
      value: base[key]
    };
  }

  return Object.create(Object.getPrototypeOf(base), descriptors);
}
function freeze(obj, deep) {
  if (deep === void 0) {
    deep = false;
  }

  if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj;

  if (getArchtype(obj) > 1
  /* Map or Set */
  ) {
      obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;
    }

  Object.freeze(obj);
  if (deep) each(obj, function (key, value) {
    return freeze(value, true);
  }, true);
  return obj;
}

function dontMutateFrozenCollections() {
  die(2);
}

function isFrozen(obj) {
  if (obj == null || typeof obj !== "object") return true; // See #600, IE dies on non-objects in Object.isFrozen

  return Object.isFrozen(obj);
}

/** Plugin utilities */

var plugins = {};
function getPlugin(pluginKey) {
  var plugin = plugins[pluginKey];

  if (!plugin) {
    die(18, pluginKey);
  } // @ts-ignore


  return plugin;
}
function loadPlugin(pluginKey, implementation) {
  if (!plugins[pluginKey]) plugins[pluginKey] = implementation;
}

var currentScope;
function getCurrentScope() {
  if ( !currentScope) die(0);
  return currentScope;
}

function createScope(parent_, immer_) {
  return {
    drafts_: [],
    parent_: parent_,
    immer_: immer_,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: true,
    unfinalizedDrafts_: 0
  };
}

function usePatchesInScope(scope, patchListener) {
  if (patchListener) {
    getPlugin("Patches"); // assert we have the plugin

    scope.patches_ = [];
    scope.inversePatches_ = [];
    scope.patchListener_ = patchListener;
  }
}
function revokeScope(scope) {
  leaveScope(scope);
  scope.drafts_.forEach(revokeDraft); // @ts-ignore

  scope.drafts_ = null;
}
function leaveScope(scope) {
  if (scope === currentScope) {
    currentScope = scope.parent_;
  }
}
function enterScope(immer) {
  return currentScope = createScope(currentScope, immer);
}

function revokeDraft(draft) {
  var state = draft[DRAFT_STATE];
  if (state.type_ === 0
  /* ProxyObject */
  || state.type_ === 1
  /* ProxyArray */
  ) state.revoke_();else state.revoked_ = true;
}

function processResult(result, scope) {
  scope.unfinalizedDrafts_ = scope.drafts_.length;
  var baseDraft = scope.drafts_[0];
  var isReplaced = result !== undefined && result !== baseDraft;
  if (!scope.immer_.useProxies_) getPlugin("ES5").willFinalizeES5_(scope, result, isReplaced);

  if (isReplaced) {
    if (baseDraft[DRAFT_STATE].modified_) {
      revokeScope(scope);
      die(4);
    }

    if (isDraftable(result)) {
      // Finalize the result in case it contains (or is) a subset of the draft.
      result = finalize(scope, result);
      if (!scope.parent_) maybeFreeze(scope, result);
    }

    if (scope.patches_) {
      getPlugin("Patches").generateReplacementPatches_(baseDraft[DRAFT_STATE].base_, result, scope.patches_, scope.inversePatches_);
    }
  } else {
    // Finalize the base draft.
    result = finalize(scope, baseDraft, []);
  }

  revokeScope(scope);

  if (scope.patches_) {
    scope.patchListener_(scope.patches_, scope.inversePatches_);
  }

  return result !== NOTHING ? result : undefined;
}

function finalize(rootScope, value, path) {
  // Don't recurse in tho recursive data structures
  if (isFrozen(value)) return value;
  var state = value[DRAFT_STATE]; // A plain object, might need freezing, might contain drafts

  if (!state) {
    each(value, function (key, childValue) {
      return finalizeProperty(rootScope, state, value, key, childValue, path);
    }, true // See #590, don't recurse into non-enumerable of non drafted objects
    );
    return value;
  } // Never finalize drafts owned by another scope.


  if (state.scope_ !== rootScope) return value; // Unmodified draft, return the (frozen) original

  if (!state.modified_) {
    maybeFreeze(rootScope, state.base_, true);
    return state.base_;
  } // Not finalized yet, let's do that now


  if (!state.finalized_) {
    state.finalized_ = true;
    state.scope_.unfinalizedDrafts_--;
    var result = // For ES5, create a good copy from the draft first, with added keys and without deleted keys.
    state.type_ === 4
    /* ES5Object */
    || state.type_ === 5
    /* ES5Array */
    ? state.copy_ = shallowCopy(state.draft_) : state.copy_; // Finalize all children of the copy
    // For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628
    // Although the original test case doesn't seem valid anyway, so if this in the way we can turn the next line
    // back to each(result, ....)

    each(state.type_ === 3
    /* Set */
    ? new Set(result) : result, function (key, childValue) {
      return finalizeProperty(rootScope, state, result, key, childValue, path);
    }); // everything inside is frozen, we can freeze here

    maybeFreeze(rootScope, result, false); // first time finalizing, let's create those patches

    if (path && rootScope.patches_) {
      getPlugin("Patches").generatePatches_(state, path, rootScope.patches_, rootScope.inversePatches_);
    }
  }

  return state.copy_;
}

function finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath) {
  if ( childValue === targetObject) die(5);

  if (isDraft(childValue)) {
    var path = rootPath && parentState && parentState.type_ !== 3
    /* Set */
    && // Set objects are atomic since they have no keys.
    !has(parentState.assigned_, prop) // Skip deep patches for assigned keys.
    ? rootPath.concat(prop) : undefined; // Drafts owned by `scope` are finalized here.

    var res = finalize(rootScope, childValue, path);
    set(targetObject, prop, res); // Drafts from another scope must prevented to be frozen
    // if we got a draft back from finalize, we're in a nested produce and shouldn't freeze

    if (isDraft(res)) {
      rootScope.canAutoFreeze_ = false;
    } else return;
  } // Search new objects for unfinalized drafts. Frozen objects should never contain drafts.


  if (isDraftable(childValue) && !isFrozen(childValue)) {
    if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {
      // optimization: if an object is not a draft, and we don't have to
      // deepfreeze everything, and we are sure that no drafts are left in the remaining object
      // cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.
      // This benefits especially adding large data tree's without further processing.
      // See add-data.js perf test
      return;
    }

    finalize(rootScope, childValue); // immer deep freezes plain objects, so if there is no parent state, we freeze as well

    if (!parentState || !parentState.scope_.parent_) maybeFreeze(rootScope, childValue);
  }
}

function maybeFreeze(scope, value, deep) {
  if (deep === void 0) {
    deep = false;
  }

  if (scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {
    freeze(value, deep);
  }
}

/**
 * Returns a new draft of the `base` object.
 *
 * The second argument is the parent draft-state (used internally).
 */

function createProxyProxy(base, parent) {
  var isArray = Array.isArray(base);
  var state = {
    type_: isArray ? 1
    /* ProxyArray */
    : 0
    /* ProxyObject */
    ,
    // Track which produce call this is associated with.
    scope_: parent ? parent.scope_ : getCurrentScope(),
    // True for both shallow and deep changes.
    modified_: false,
    // Used during finalization.
    finalized_: false,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: parent,
    // The base state.
    base_: base,
    // The base proxy.
    draft_: null,
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: false
  }; // the traps must target something, a bit like the 'real' base.
  // but also, we need to be able to determine from the target what the relevant state is
  // (to avoid creating traps per instance to capture the state in closure,
  // and to avoid creating weird hidden properties as well)
  // So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)
  // Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb

  var target = state;
  var traps = objectTraps;

  if (isArray) {
    target = [state];
    traps = arrayTraps;
  }

  var _Proxy$revocable = Proxy.revocable(target, traps),
      revoke = _Proxy$revocable.revoke,
      proxy = _Proxy$revocable.proxy;

  state.draft_ = proxy;
  state.revoke_ = revoke;
  return proxy;
}
/**
 * Object drafts
 */

var objectTraps = {
  get: function get(state, prop) {
    if (prop === DRAFT_STATE) return state;
    var source = latest(state);

    if (!has(source, prop)) {
      // non-existing or non-own property...
      return readPropFromProto(state, source, prop);
    }

    var value = source[prop];

    if (state.finalized_ || !isDraftable(value)) {
      return value;
    } // Check for existing draft in modified state.
    // Assigned values are never drafted. This catches any drafts we created, too.


    if (value === peek(state.base_, prop)) {
      prepareCopy(state);
      return state.copy_[prop] = createProxy(state.scope_.immer_, value, state);
    }

    return value;
  },
  has: function has(state, prop) {
    return prop in latest(state);
  },
  ownKeys: function ownKeys(state) {
    return Reflect.ownKeys(latest(state));
  },
  set: function set(state, prop
  /* strictly not, but helps TS */
  , value) {
    var desc = getDescriptorFromProto(latest(state), prop);

    if (desc === null || desc === void 0 ? void 0 : desc.set) {
      // special case: if this write is captured by a setter, we have
      // to trigger it with the correct context
      desc.set.call(state.draft_, value);
      return true;
    }

    if (!state.modified_) {
      // the last check is because we need to be able to distinguish setting a non-existing to undefined (which is a change)
      // from setting an existing property with value undefined to undefined (which is not a change)
      var current = peek(latest(state), prop); // special case, if we assigning the original value to a draft, we can ignore the assignment

      var currentState = current === null || current === void 0 ? void 0 : current[DRAFT_STATE];

      if (currentState && currentState.base_ === value) {
        state.copy_[prop] = value;
        state.assigned_[prop] = false;
        return true;
      }

      if (is(value, current) && (value !== undefined || has(state.base_, prop))) return true;
      prepareCopy(state);
      markChanged(state);
    }

    if (state.copy_[prop] === value && // special case: NaN
    typeof value !== "number" && ( // special case: handle new props with value 'undefined'
    value !== undefined || prop in state.copy_)) return true; // @ts-ignore

    state.copy_[prop] = value;
    state.assigned_[prop] = true;
    return true;
  },
  deleteProperty: function deleteProperty(state, prop) {
    // The `undefined` check is a fast path for pre-existing keys.
    if (peek(state.base_, prop) !== undefined || prop in state.base_) {
      state.assigned_[prop] = false;
      prepareCopy(state);
      markChanged(state);
    } else {
      // if an originally not assigned property was deleted
      delete state.assigned_[prop];
    } // @ts-ignore


    if (state.copy_) delete state.copy_[prop];
    return true;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(state, prop) {
    var owner = latest(state);
    var desc = Reflect.getOwnPropertyDescriptor(owner, prop);
    if (!desc) return desc;
    return {
      writable: true,
      configurable: state.type_ !== 1
      /* ProxyArray */
      || prop !== "length",
      enumerable: desc.enumerable,
      value: owner[prop]
    };
  },
  defineProperty: function defineProperty() {
    die(11);
  },
  getPrototypeOf: function getPrototypeOf(state) {
    return Object.getPrototypeOf(state.base_);
  },
  setPrototypeOf: function setPrototypeOf() {
    die(12);
  }
};
/**
 * Array drafts
 */

var arrayTraps = {};
each(objectTraps, function (key, fn) {
  // @ts-ignore
  arrayTraps[key] = function () {
    arguments[0] = arguments[0][0];
    return fn.apply(this, arguments);
  };
});

arrayTraps.deleteProperty = function (state, prop) {
  if ( isNaN(parseInt(prop))) die(13); // @ts-ignore

  return arrayTraps.set.call(this, state, prop, undefined);
};

arrayTraps.set = function (state, prop, value) {
  if ( prop !== "length" && isNaN(parseInt(prop))) die(14);
  return objectTraps.set.call(this, state[0], prop, value, state[0]);
}; // Access a property without creating an Immer draft.


function peek(draft, prop) {
  var state = draft[DRAFT_STATE];
  var source = state ? latest(state) : draft;
  return source[prop];
}

function readPropFromProto(state, source, prop) {
  var _desc$get;

  var desc = getDescriptorFromProto(source, prop);
  return desc ? "value" in desc ? desc.value : // This is a very special case, if the prop is a getter defined by the
  // prototype, we should invoke it with the draft as context!
  (_desc$get = desc.get) === null || _desc$get === void 0 ? void 0 : _desc$get.call(state.draft_) : undefined;
}

function getDescriptorFromProto(source, prop) {
  // 'in' checks proto!
  if (!(prop in source)) return undefined;
  var proto = Object.getPrototypeOf(source);

  while (proto) {
    var desc = Object.getOwnPropertyDescriptor(proto, prop);
    if (desc) return desc;
    proto = Object.getPrototypeOf(proto);
  }

  return undefined;
}

function markChanged(state) {
  if (!state.modified_) {
    state.modified_ = true;

    if (state.parent_) {
      markChanged(state.parent_);
    }
  }
}
function prepareCopy(state) {
  if (!state.copy_) {
    state.copy_ = shallowCopy(state.base_);
  }
}

var Immer =
/*#__PURE__*/
function () {
  function Immer(config) {
    var _this = this;

    this.useProxies_ = hasProxies;
    this.autoFreeze_ = true;
    /**
     * The `produce` function takes a value and a "recipe function" (whose
     * return value often depends on the base state). The recipe function is
     * free to mutate its first argument however it wants. All mutations are
     * only ever applied to a __copy__ of the base state.
     *
     * Pass only a function to create a "curried producer" which relieves you
     * from passing the recipe function every time.
     *
     * Only plain objects and arrays are made mutable. All other objects are
     * considered uncopyable.
     *
     * Note: This function is __bound__ to its `Immer` instance.
     *
     * @param {any} base - the initial state
     * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified
     * @param {Function} patchListener - optional function that will be called with all the patches produced here
     * @returns {any} a new state, or the initial state if nothing was modified
     */

    this.produce = function (base, recipe, patchListener) {
      // curried invocation
      if (typeof base === "function" && typeof recipe !== "function") {
        var defaultBase = recipe;
        recipe = base;
        var self = _this;
        return function curriedProduce(base) {
          var _this2 = this;

          if (base === void 0) {
            base = defaultBase;
          }

          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          return self.produce(base, function (draft) {
            var _recipe;

            return (_recipe = recipe).call.apply(_recipe, [_this2, draft].concat(args));
          }); // prettier-ignore
        };
      }

      if (typeof recipe !== "function") die(6);
      if (patchListener !== undefined && typeof patchListener !== "function") die(7);
      var result; // Only plain objects, arrays, and "immerable classes" are drafted.

      if (isDraftable(base)) {
        var scope = enterScope(_this);
        var proxy = createProxy(_this, base, undefined);
        var hasError = true;

        try {
          result = recipe(proxy);
          hasError = false;
        } finally {
          // finally instead of catch + rethrow better preserves original stack
          if (hasError) revokeScope(scope);else leaveScope(scope);
        }

        if (typeof Promise !== "undefined" && result instanceof Promise) {
          return result.then(function (result) {
            usePatchesInScope(scope, patchListener);
            return processResult(result, scope);
          }, function (error) {
            revokeScope(scope);
            throw error;
          });
        }

        usePatchesInScope(scope, patchListener);
        return processResult(result, scope);
      } else if (!base || typeof base !== "object") {
        result = recipe(base);
        if (result === undefined) result = base;
        if (result === NOTHING) result = undefined;
        if (_this.autoFreeze_) freeze(result, true);

        if (patchListener) {
          var p = [];
          var ip = [];
          getPlugin("Patches").generateReplacementPatches_(base, result, p, ip);
          patchListener(p, ip);
        }

        return result;
      } else die(21, base);
    };

    this.produceWithPatches = function (base, recipe) {
      // curried invocation
      if (typeof base === "function") {
        return function (state) {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }

          return _this.produceWithPatches(state, function (draft) {
            return base.apply(void 0, [draft].concat(args));
          });
        };
      }

      var patches, inversePatches;

      var result = _this.produce(base, recipe, function (p, ip) {
        patches = p;
        inversePatches = ip;
      });

      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then(function (nextState) {
          return [nextState, patches, inversePatches];
        });
      }

      return [result, patches, inversePatches];
    };

    if (typeof (config === null || config === void 0 ? void 0 : config.useProxies) === "boolean") this.setUseProxies(config.useProxies);
    if (typeof (config === null || config === void 0 ? void 0 : config.autoFreeze) === "boolean") this.setAutoFreeze(config.autoFreeze);
  }

  var _proto = Immer.prototype;

  _proto.createDraft = function createDraft(base) {
    if (!isDraftable(base)) die(8);
    if (isDraft(base)) base = current(base);
    var scope = enterScope(this);
    var proxy = createProxy(this, base, undefined);
    proxy[DRAFT_STATE].isManual_ = true;
    leaveScope(scope);
    return proxy;
  };

  _proto.finishDraft = function finishDraft(draft, patchListener) {
    var state = draft && draft[DRAFT_STATE];

    {
      if (!state || !state.isManual_) die(9);
      if (state.finalized_) die(10);
    }

    var scope = state.scope_;
    usePatchesInScope(scope, patchListener);
    return processResult(undefined, scope);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  ;

  _proto.setAutoFreeze = function setAutoFreeze(value) {
    this.autoFreeze_ = value;
  }
  /**
   * Pass true to use the ES2015 `Proxy` class when creating drafts, which is
   * always faster than using ES5 proxies.
   *
   * By default, feature detection is used, so calling this is rarely necessary.
   */
  ;

  _proto.setUseProxies = function setUseProxies(value) {
    if (value && !hasProxies) {
      die(20);
    }

    this.useProxies_ = value;
  };

  _proto.applyPatches = function applyPatches(base, patches) {
    // If a patch replaces the entire state, take that replacement as base
    // before applying patches
    var i;

    for (i = patches.length - 1; i >= 0; i--) {
      var patch = patches[i];

      if (patch.path.length === 0 && patch.op === "replace") {
        base = patch.value;
        break;
      }
    } // If there was a patch that replaced the entire state, start from the
    // patch after that.


    if (i > -1) {
      patches = patches.slice(i + 1);
    }

    var applyPatchesImpl = getPlugin("Patches").applyPatches_;

    if (isDraft(base)) {
      // N.B: never hits if some patch a replacement, patches are never drafts
      return applyPatchesImpl(base, patches);
    } // Otherwise, produce a copy of the base state.


    return this.produce(base, function (draft) {
      return applyPatchesImpl(draft, patches);
    });
  };

  return Immer;
}();
function createProxy(immer, value, parent) {
  // precondition: createProxy should be guarded by isDraftable, so we know we can safely draft
  var draft = isMap(value) ? getPlugin("MapSet").proxyMap_(value, parent) : isSet(value) ? getPlugin("MapSet").proxySet_(value, parent) : immer.useProxies_ ? createProxyProxy(value, parent) : getPlugin("ES5").createES5Proxy_(value, parent);
  var scope = parent ? parent.scope_ : getCurrentScope();
  scope.drafts_.push(draft);
  return draft;
}

function current(value) {
  if (!isDraft(value)) die(22, value);
  return currentImpl(value);
}

function currentImpl(value) {
  if (!isDraftable(value)) return value;
  var state = value[DRAFT_STATE];
  var copy;
  var archType = getArchtype(value);

  if (state) {
    if (!state.modified_ && (state.type_ < 4 || !getPlugin("ES5").hasChanges_(state))) return state.base_; // Optimization: avoid generating new drafts during copying

    state.finalized_ = true;
    copy = copyHelper(value, archType);
    state.finalized_ = false;
  } else {
    copy = copyHelper(value, archType);
  }

  each(copy, function (key, childValue) {
    if (state && get(state.base_, key) === childValue) return; // no need to copy or search in something that didn't change

    set(copy, key, currentImpl(childValue));
  }); // In the future, we might consider freezing here, based on the current settings

  return archType === 3
  /* Set */
  ? new Set(copy) : copy;
}

function copyHelper(value, archType) {
  // creates a shallow copy, even if it is a map or set
  switch (archType) {
    case 2
    /* Map */
    :
      return new Map(value);

    case 3
    /* Set */
    :
      // Set will be cloned as array temporarily, so that we can replace individual items
      return Array.from(value);
  }

  return shallowCopy(value);
}

function enableES5() {
  function willFinalizeES5_(scope, result, isReplaced) {
    if (!isReplaced) {
      if (scope.patches_) {
        markChangesRecursively(scope.drafts_[0]);
      } // This is faster when we don't care about which attributes changed.


      markChangesSweep(scope.drafts_);
    } // When a child draft is returned, look for changes.
    else if (isDraft(result) && result[DRAFT_STATE].scope_ === scope) {
        markChangesSweep(scope.drafts_);
      }
  }

  function createES5Draft(isArray, base) {
    if (isArray) {
      var draft = new Array(base.length);

      for (var i = 0; i < base.length; i++) {
        Object.defineProperty(draft, "" + i, proxyProperty(i, true));
      }

      return draft;
    } else {
      var _descriptors = getOwnPropertyDescriptors(base);

      delete _descriptors[DRAFT_STATE];
      var keys = ownKeys(_descriptors);

      for (var _i = 0; _i < keys.length; _i++) {
        var key = keys[_i];
        _descriptors[key] = proxyProperty(key, isArray || !!_descriptors[key].enumerable);
      }

      return Object.create(Object.getPrototypeOf(base), _descriptors);
    }
  }

  function createES5Proxy_(base, parent) {
    var isArray = Array.isArray(base);
    var draft = createES5Draft(isArray, base);
    var state = {
      type_: isArray ? 5
      /* ES5Array */
      : 4
      /* ES5Object */
      ,
      scope_: parent ? parent.scope_ : getCurrentScope(),
      modified_: false,
      finalized_: false,
      assigned_: {},
      parent_: parent,
      // base is the object we are drafting
      base_: base,
      // draft is the draft object itself, that traps all reads and reads from either the base (if unmodified) or copy (if modified)
      draft_: draft,
      copy_: null,
      revoked_: false,
      isManual_: false
    };
    Object.defineProperty(draft, DRAFT_STATE, {
      value: state,
      // enumerable: false <- the default
      writable: true
    });
    return draft;
  } // property descriptors are recycled to make sure we don't create a get and set closure per property,
  // but share them all instead


  var descriptors = {};

  function proxyProperty(prop, enumerable) {
    var desc = descriptors[prop];

    if (desc) {
      desc.enumerable = enumerable;
    } else {
      descriptors[prop] = desc = {
        configurable: true,
        enumerable: enumerable,
        get: function get() {
          var state = this[DRAFT_STATE];
          assertUnrevoked(state); // @ts-ignore

          return objectTraps.get(state, prop);
        },
        set: function set(value) {
          var state = this[DRAFT_STATE];
          assertUnrevoked(state); // @ts-ignore

          objectTraps.set(state, prop, value);
        }
      };
    }

    return desc;
  } // This looks expensive, but only proxies are visited, and only objects without known changes are scanned.


  function markChangesSweep(drafts) {
    // The natural order of drafts in the `scope` array is based on when they
    // were accessed. By processing drafts in reverse natural order, we have a
    // better chance of processing leaf nodes first. When a leaf node is known to
    // have changed, we can avoid any traversal of its ancestor nodes.
    for (var i = drafts.length - 1; i >= 0; i--) {
      var state = drafts[i][DRAFT_STATE];

      if (!state.modified_) {
        switch (state.type_) {
          case 5
          /* ES5Array */
          :
            if (hasArrayChanges(state)) markChanged(state);
            break;

          case 4
          /* ES5Object */
          :
            if (hasObjectChanges(state)) markChanged(state);
            break;
        }
      }
    }
  }

  function markChangesRecursively(object) {
    if (!object || typeof object !== "object") return;
    var state = object[DRAFT_STATE];
    if (!state) return;
    var base_ = state.base_,
        draft_ = state.draft_,
        assigned_ = state.assigned_,
        type_ = state.type_;

    if (type_ === 4
    /* ES5Object */
    ) {
        // Look for added keys.
        // probably there is a faster way to detect changes, as sweep + recurse seems to do some
        // unnecessary work.
        // also: probably we can store the information we detect here, to speed up tree finalization!
        each(draft_, function (key) {
          if (key === DRAFT_STATE) return; // The `undefined` check is a fast path for pre-existing keys.

          if (base_[key] === undefined && !has(base_, key)) {
            assigned_[key] = true;
            markChanged(state);
          } else if (!assigned_[key]) {
            // Only untouched properties trigger recursion.
            markChangesRecursively(draft_[key]);
          }
        }); // Look for removed keys.

        each(base_, function (key) {
          // The `undefined` check is a fast path for pre-existing keys.
          if (draft_[key] === undefined && !has(draft_, key)) {
            assigned_[key] = false;
            markChanged(state);
          }
        });
      } else if (type_ === 5
    /* ES5Array */
    ) {
        if (hasArrayChanges(state)) {
          markChanged(state);
          assigned_.length = true;
        }

        if (draft_.length < base_.length) {
          for (var i = draft_.length; i < base_.length; i++) {
            assigned_[i] = false;
          }
        } else {
          for (var _i2 = base_.length; _i2 < draft_.length; _i2++) {
            assigned_[_i2] = true;
          }
        } // Minimum count is enough, the other parts has been processed.


        var min = Math.min(draft_.length, base_.length);

        for (var _i3 = 0; _i3 < min; _i3++) {
          // Only untouched indices trigger recursion.
          if (!draft_.hasOwnProperty(_i3)) {
            assigned_[_i3] = true;
          }

          if (assigned_[_i3] === undefined) markChangesRecursively(draft_[_i3]);
        }
      }
  }

  function hasObjectChanges(state) {
    var base_ = state.base_,
        draft_ = state.draft_; // Search for added keys and changed keys. Start at the back, because
    // non-numeric keys are ordered by time of definition on the object.

    var keys = ownKeys(draft_);

    for (var i = keys.length - 1; i >= 0; i--) {
      var key = keys[i];
      if (key === DRAFT_STATE) continue;
      var baseValue = base_[key]; // The `undefined` check is a fast path for pre-existing keys.

      if (baseValue === undefined && !has(base_, key)) {
        return true;
      } // Once a base key is deleted, future changes go undetected, because its
      // descriptor is erased. This branch detects any missed changes.
      else {
          var value = draft_[key];

          var _state = value && value[DRAFT_STATE];

          if (_state ? _state.base_ !== baseValue : !is(value, baseValue)) {
            return true;
          }
        }
    } // At this point, no keys were added or changed.
    // Compare key count to determine if keys were deleted.


    var baseIsDraft = !!base_[DRAFT_STATE];
    return keys.length !== ownKeys(base_).length + (baseIsDraft ? 0 : 1); // + 1 to correct for DRAFT_STATE
  }

  function hasArrayChanges(state) {
    var draft_ = state.draft_;
    if (draft_.length !== state.base_.length) return true; // See #116
    // If we first shorten the length, our array interceptors will be removed.
    // If after that new items are added, result in the same original length,
    // those last items will have no intercepting property.
    // So if there is no own descriptor on the last position, we know that items were removed and added
    // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check
    // the last one
    // last descriptor can be not a trap, if the array was extended

    var descriptor = Object.getOwnPropertyDescriptor(draft_, draft_.length - 1); // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)

    if (descriptor && !descriptor.get) return true; // if we miss a property, it has been deleted, so array probobaly changed

    for (var i = 0; i < draft_.length; i++) {
      if (!draft_.hasOwnProperty(i)) return true;
    } // For all other cases, we don't have to compare, as they would have been picked up by the index setters


    return false;
  }

  function hasChanges_(state) {
    return state.type_ === 4
    /* ES5Object */
    ? hasObjectChanges(state) : hasArrayChanges(state);
  }

  function assertUnrevoked(state
  /*ES5State | MapState | SetState*/
  ) {
    if (state.revoked_) die(3, JSON.stringify(latest(state)));
  }

  loadPlugin("ES5", {
    createES5Proxy_: createES5Proxy_,
    willFinalizeES5_: willFinalizeES5_,
    hasChanges_: hasChanges_
  });
}

function enablePatches() {
  var REPLACE = "replace";
  var ADD = "add";
  var REMOVE = "remove";

  function generatePatches_(state, basePath, patches, inversePatches) {
    switch (state.type_) {
      case 0
      /* ProxyObject */
      :
      case 4
      /* ES5Object */
      :
      case 2
      /* Map */
      :
        return generatePatchesFromAssigned(state, basePath, patches, inversePatches);

      case 5
      /* ES5Array */
      :
      case 1
      /* ProxyArray */
      :
        return generateArrayPatches(state, basePath, patches, inversePatches);

      case 3
      /* Set */
      :
        return generateSetPatches(state, basePath, patches, inversePatches);
    }
  }

  function generateArrayPatches(state, basePath, patches, inversePatches) {
    var base_ = state.base_,
        assigned_ = state.assigned_;
    var copy_ = state.copy_; // Reduce complexity by ensuring `base` is never longer.

    if (copy_.length < base_.length) {
      var _ref = [copy_, base_];
      base_ = _ref[0];
      copy_ = _ref[1];
      var _ref2 = [inversePatches, patches];
      patches = _ref2[0];
      inversePatches = _ref2[1];
    } // Process replaced indices.


    for (var i = 0; i < base_.length; i++) {
      if (assigned_[i] && copy_[i] !== base_[i]) {
        var path = basePath.concat([i]);
        patches.push({
          op: REPLACE,
          path: path,
          // Need to maybe clone it, as it can in fact be the original value
          // due to the base/copy inversion at the start of this function
          value: clonePatchValueIfNeeded(copy_[i])
        });
        inversePatches.push({
          op: REPLACE,
          path: path,
          value: clonePatchValueIfNeeded(base_[i])
        });
      }
    } // Process added indices.


    for (var _i = base_.length; _i < copy_.length; _i++) {
      var _path = basePath.concat([_i]);

      patches.push({
        op: ADD,
        path: _path,
        // Need to maybe clone it, as it can in fact be the original value
        // due to the base/copy inversion at the start of this function
        value: clonePatchValueIfNeeded(copy_[_i])
      });
    }

    if (base_.length < copy_.length) {
      inversePatches.push({
        op: REPLACE,
        path: basePath.concat(["length"]),
        value: base_.length
      });
    }
  } // This is used for both Map objects and normal objects.


  function generatePatchesFromAssigned(state, basePath, patches, inversePatches) {
    var base_ = state.base_,
        copy_ = state.copy_;
    each(state.assigned_, function (key, assignedValue) {
      var origValue = get(base_, key);
      var value = get(copy_, key);
      var op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD;
      if (origValue === value && op === REPLACE) return;
      var path = basePath.concat(key);
      patches.push(op === REMOVE ? {
        op: op,
        path: path
      } : {
        op: op,
        path: path,
        value: value
      });
      inversePatches.push(op === ADD ? {
        op: REMOVE,
        path: path
      } : op === REMOVE ? {
        op: ADD,
        path: path,
        value: clonePatchValueIfNeeded(origValue)
      } : {
        op: REPLACE,
        path: path,
        value: clonePatchValueIfNeeded(origValue)
      });
    });
  }

  function generateSetPatches(state, basePath, patches, inversePatches) {
    var base_ = state.base_,
        copy_ = state.copy_;
    var i = 0;
    base_.forEach(function (value) {
      if (!copy_.has(value)) {
        var path = basePath.concat([i]);
        patches.push({
          op: REMOVE,
          path: path,
          value: value
        });
        inversePatches.unshift({
          op: ADD,
          path: path,
          value: value
        });
      }

      i++;
    });
    i = 0;
    copy_.forEach(function (value) {
      if (!base_.has(value)) {
        var path = basePath.concat([i]);
        patches.push({
          op: ADD,
          path: path,
          value: value
        });
        inversePatches.unshift({
          op: REMOVE,
          path: path,
          value: value
        });
      }

      i++;
    });
  }

  function generateReplacementPatches_(baseValue, replacement, patches, inversePatches) {
    patches.push({
      op: REPLACE,
      path: [],
      value: replacement === NOTHING ? undefined : replacement
    });
    inversePatches.push({
      op: REPLACE,
      path: [],
      value: baseValue
    });
  }

  function applyPatches_(draft, patches) {
    patches.forEach(function (patch) {
      var path = patch.path,
          op = patch.op;
      var base = draft;

      for (var i = 0; i < path.length - 1; i++) {
        var parentType = getArchtype(base);
        var p = "" + path[i]; // See #738, avoid prototype pollution

        if ((parentType === 0
        /* Object */
        || parentType === 1
        /* Array */
        ) && (p === "__proto__" || p === "constructor")) die(24);
        if (typeof base === "function" && p === "prototype") die(24);
        base = get(base, p);
        if (typeof base !== "object") die(15, path.join("/"));
      }

      var type = getArchtype(base);
      var value = deepClonePatchValue(patch.value); // used to clone patch to ensure original patch is not modified, see #411

      var key = path[path.length - 1];

      switch (op) {
        case REPLACE:
          switch (type) {
            case 2
            /* Map */
            :
              return base.set(key, value);

            /* istanbul ignore next */

            case 3
            /* Set */
            :
              die(16);

            default:
              // if value is an object, then it's assigned by reference
              // in the following add or remove ops, the value field inside the patch will also be modifyed
              // so we use value from the cloned patch
              // @ts-ignore
              return base[key] = value;
          }

        case ADD:
          switch (type) {
            case 1
            /* Array */
            :
              return key === "-" ? base.push(value) : base.splice(key, 0, value);

            case 2
            /* Map */
            :
              return base.set(key, value);

            case 3
            /* Set */
            :
              return base.add(value);

            default:
              return base[key] = value;
          }

        case REMOVE:
          switch (type) {
            case 1
            /* Array */
            :
              return base.splice(key, 1);

            case 2
            /* Map */
            :
              return base.delete(key);

            case 3
            /* Set */
            :
              return base.delete(patch.value);

            default:
              return delete base[key];
          }

        default:
          die(17, op);
      }
    });
    return draft;
  }

  function deepClonePatchValue(obj) {
    if (!isDraftable(obj)) return obj;
    if (Array.isArray(obj)) return obj.map(deepClonePatchValue);
    if (isMap(obj)) return new Map(Array.from(obj.entries()).map(function (_ref3) {
      var k = _ref3[0],
          v = _ref3[1];
      return [k, deepClonePatchValue(v)];
    }));
    if (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue));
    var cloned = Object.create(Object.getPrototypeOf(obj));

    for (var key in obj) {
      cloned[key] = deepClonePatchValue(obj[key]);
    }

    if (has(obj, DRAFTABLE)) cloned[DRAFTABLE] = obj[DRAFTABLE];
    return cloned;
  }

  function clonePatchValueIfNeeded(obj) {
    if (isDraft(obj)) {
      return deepClonePatchValue(obj);
    } else return obj;
  }

  loadPlugin("Patches", {
    applyPatches_: applyPatches_,
    generatePatches_: generatePatches_,
    generateReplacementPatches_: generateReplacementPatches_
  });
}

// types only!
function enableMapSet() {
  /* istanbul ignore next */
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  }; // Ugly hack to resolve #502 and inherit built in Map / Set


  function __extends(d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = ( // @ts-ignore
    __.prototype = b.prototype, new __());
  }

  var DraftMap = function (_super) {
    __extends(DraftMap, _super); // Create class manually, cause #502


    function DraftMap(target, parent) {
      this[DRAFT_STATE] = {
        type_: 2
        /* Map */
        ,
        parent_: parent,
        scope_: parent ? parent.scope_ : getCurrentScope(),
        modified_: false,
        finalized_: false,
        copy_: undefined,
        assigned_: undefined,
        base_: target,
        draft_: this,
        isManual_: false,
        revoked_: false
      };
      return this;
    }

    var p = DraftMap.prototype;
    Object.defineProperty(p, "size", {
      get: function get() {
        return latest(this[DRAFT_STATE]).size;
      } // enumerable: false,
      // configurable: true

    });

    p.has = function (key) {
      return latest(this[DRAFT_STATE]).has(key);
    };

    p.set = function (key, value) {
      var state = this[DRAFT_STATE];
      assertUnrevoked(state);

      if (!latest(state).has(key) || latest(state).get(key) !== value) {
        prepareMapCopy(state);
        markChanged(state);
        state.assigned_.set(key, true);
        state.copy_.set(key, value);
        state.assigned_.set(key, true);
      }

      return this;
    };

    p.delete = function (key) {
      if (!this.has(key)) {
        return false;
      }

      var state = this[DRAFT_STATE];
      assertUnrevoked(state);
      prepareMapCopy(state);
      markChanged(state);

      if (state.base_.has(key)) {
        state.assigned_.set(key, false);
      } else {
        state.assigned_.delete(key);
      }

      state.copy_.delete(key);
      return true;
    };

    p.clear = function () {
      var state = this[DRAFT_STATE];
      assertUnrevoked(state);

      if (latest(state).size) {
        prepareMapCopy(state);
        markChanged(state);
        state.assigned_ = new Map();
        each(state.base_, function (key) {
          state.assigned_.set(key, false);
        });
        state.copy_.clear();
      }
    };

    p.forEach = function (cb, thisArg) {
      var _this = this;

      var state = this[DRAFT_STATE];
      latest(state).forEach(function (_value, key, _map) {
        cb.call(thisArg, _this.get(key), key, _this);
      });
    };

    p.get = function (key) {
      var state = this[DRAFT_STATE];
      assertUnrevoked(state);
      var value = latest(state).get(key);

      if (state.finalized_ || !isDraftable(value)) {
        return value;
      }

      if (value !== state.base_.get(key)) {
        return value; // either already drafted or reassigned
      } // despite what it looks, this creates a draft only once, see above condition


      var draft = createProxy(state.scope_.immer_, value, state);
      prepareMapCopy(state);
      state.copy_.set(key, draft);
      return draft;
    };

    p.keys = function () {
      return latest(this[DRAFT_STATE]).keys();
    };

    p.values = function () {
      var _this2 = this,
          _ref;

      var iterator = this.keys();
      return _ref = {}, _ref[iteratorSymbol] = function () {
        return _this2.values();
      }, _ref.next = function next() {
        var r = iterator.next();
        /* istanbul ignore next */

        if (r.done) return r;

        var value = _this2.get(r.value);

        return {
          done: false,
          value: value
        };
      }, _ref;
    };

    p.entries = function () {
      var _this3 = this,
          _ref2;

      var iterator = this.keys();
      return _ref2 = {}, _ref2[iteratorSymbol] = function () {
        return _this3.entries();
      }, _ref2.next = function next() {
        var r = iterator.next();
        /* istanbul ignore next */

        if (r.done) return r;

        var value = _this3.get(r.value);

        return {
          done: false,
          value: [r.value, value]
        };
      }, _ref2;
    };

    p[iteratorSymbol] = function () {
      return this.entries();
    };

    return DraftMap;
  }(Map);

  function proxyMap_(target, parent) {
    // @ts-ignore
    return new DraftMap(target, parent);
  }

  function prepareMapCopy(state) {
    if (!state.copy_) {
      state.assigned_ = new Map();
      state.copy_ = new Map(state.base_);
    }
  }

  var DraftSet = function (_super) {
    __extends(DraftSet, _super); // Create class manually, cause #502


    function DraftSet(target, parent) {
      this[DRAFT_STATE] = {
        type_: 3
        /* Set */
        ,
        parent_: parent,
        scope_: parent ? parent.scope_ : getCurrentScope(),
        modified_: false,
        finalized_: false,
        copy_: undefined,
        base_: target,
        draft_: this,
        drafts_: new Map(),
        revoked_: false,
        isManual_: false
      };
      return this;
    }

    var p = DraftSet.prototype;
    Object.defineProperty(p, "size", {
      get: function get() {
        return latest(this[DRAFT_STATE]).size;
      } // enumerable: true,

    });

    p.has = function (value) {
      var state = this[DRAFT_STATE];
      assertUnrevoked(state); // bit of trickery here, to be able to recognize both the value, and the draft of its value

      if (!state.copy_) {
        return state.base_.has(value);
      }

      if (state.copy_.has(value)) return true;
      if (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value))) return true;
      return false;
    };

    p.add = function (value) {
      var state = this[DRAFT_STATE];
      assertUnrevoked(state);

      if (!this.has(value)) {
        prepareSetCopy(state);
        markChanged(state);
        state.copy_.add(value);
      }

      return this;
    };

    p.delete = function (value) {
      if (!this.has(value)) {
        return false;
      }

      var state = this[DRAFT_STATE];
      assertUnrevoked(state);
      prepareSetCopy(state);
      markChanged(state);
      return state.copy_.delete(value) || (state.drafts_.has(value) ? state.copy_.delete(state.drafts_.get(value)) :
      /* istanbul ignore next */
      false);
    };

    p.clear = function () {
      var state = this[DRAFT_STATE];
      assertUnrevoked(state);

      if (latest(state).size) {
        prepareSetCopy(state);
        markChanged(state);
        state.copy_.clear();
      }
    };

    p.values = function () {
      var state = this[DRAFT_STATE];
      assertUnrevoked(state);
      prepareSetCopy(state);
      return state.copy_.values();
    };

    p.entries = function entries() {
      var state = this[DRAFT_STATE];
      assertUnrevoked(state);
      prepareSetCopy(state);
      return state.copy_.entries();
    };

    p.keys = function () {
      return this.values();
    };

    p[iteratorSymbol] = function () {
      return this.values();
    };

    p.forEach = function forEach(cb, thisArg) {
      var iterator = this.values();
      var result = iterator.next();

      while (!result.done) {
        cb.call(thisArg, result.value, result.value, this);
        result = iterator.next();
      }
    };

    return DraftSet;
  }(Set);

  function proxySet_(target, parent) {
    // @ts-ignore
    return new DraftSet(target, parent);
  }

  function prepareSetCopy(state) {
    if (!state.copy_) {
      // create drafts for all entries to preserve insertion order
      state.copy_ = new Set();
      state.base_.forEach(function (value) {
        if (isDraftable(value)) {
          var draft = createProxy(state.scope_.immer_, value, state);
          state.drafts_.set(value, draft);
          state.copy_.add(draft);
        } else {
          state.copy_.add(value);
        }
      });
    }
  }

  function assertUnrevoked(state
  /*ES5State | MapState | SetState*/
  ) {
    if (state.revoked_) die(3, JSON.stringify(latest(state)));
  }

  loadPlugin("MapSet", {
    proxyMap_: proxyMap_,
    proxySet_: proxySet_
  });
}

function enableAllPlugins() {
  enableES5();
  enableMapSet();
  enablePatches();
}

var immer =
/*#__PURE__*/
new Immer();
/**
 * The `produce` function takes a value and a "recipe function" (whose
 * return value often depends on the base state). The recipe function is
 * free to mutate its first argument however it wants. All mutations are
 * only ever applied to a __copy__ of the base state.
 *
 * Pass only a function to create a "curried producer" which relieves you
 * from passing the recipe function every time.
 *
 * Only plain objects and arrays are made mutable. All other objects are
 * considered uncopyable.
 *
 * Note: This function is __bound__ to its `Immer` instance.
 *
 * @param {any} base - the initial state
 * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified
 * @param {Function} patchListener - optional function that will be called with all the patches produced here
 * @returns {any} a new state, or the initial state if nothing was modified
 */

var produce = immer.produce;
/**
 * Like `produce`, but `produceWithPatches` always returns a tuple
 * [nextState, patches, inversePatches] (instead of just the next state)
 */

var produceWithPatches =
/*#__PURE__*/
immer.produceWithPatches.bind(immer);
/**
 * Pass true to automatically freeze all copies created by Immer.
 *
 * Always freeze by default, even in production mode
 */

var setAutoFreeze =
/*#__PURE__*/
immer.setAutoFreeze.bind(immer);
/**
 * Pass true to use the ES2015 `Proxy` class when creating drafts, which is
 * always faster than using ES5 proxies.
 *
 * By default, feature detection is used, so calling this is rarely necessary.
 */

var setUseProxies =
/*#__PURE__*/
immer.setUseProxies.bind(immer);
/**
 * Apply an array of Immer patches to the first argument.
 *
 * This function is a producer, which means copy-on-write is in effect.
 */

var applyPatches =
/*#__PURE__*/
immer.applyPatches.bind(immer);
/**
 * Create an Immer draft from the given base state, which may be a draft itself.
 * The draft can be modified until you finalize it with the `finishDraft` function.
 */

var createDraft =
/*#__PURE__*/
immer.createDraft.bind(immer);
/**
 * Finalize an Immer draft from a `createDraft` call, returning the base state
 * (if no changes were made) or a modified copy. The draft must *not* be
 * mutated afterwards.
 *
 * Pass a function as the 2nd argument to generate Immer patches based on the
 * changes that were made.
 */

var finishDraft =
/*#__PURE__*/
immer.finishDraft.bind(immer);
/**
 * This function is actually a no-op, but can be used to cast an immutable type
 * to an draft type and make TypeScript happy
 *
 * @param value
 */

function castDraft(value) {
  return value;
}
/**
 * This function is actually a no-op, but can be used to cast a mutable type
 * to an immutable type and make TypeScript happy
 * @param value
 */

function castImmutable(value) {
  return value;
}

exports.Immer = Immer;
exports.applyPatches = applyPatches;
exports.castDraft = castDraft;
exports.castImmutable = castImmutable;
exports.createDraft = createDraft;
exports.current = current;
exports["default"] = produce;
exports.enableAllPlugins = enableAllPlugins;
exports.enableES5 = enableES5;
exports.enableMapSet = enableMapSet;
exports.enablePatches = enablePatches;
exports.finishDraft = finishDraft;
exports.freeze = freeze;
exports.immerable = DRAFTABLE;
exports.isDraft = isDraft;
exports.isDraftable = isDraftable;
exports.nothing = NOTHING;
exports.original = original;
exports.produce = produce;
exports.produceWithPatches = produceWithPatches;
exports.setAutoFreeze = setAutoFreeze;
exports.setUseProxies = setUseProxies;
//# sourceMappingURL=immer.cjs.development.js.map


/***/ }),

/***/ "../../node_modules/immer/dist/index.js":
/*!**********************************************!*\
  !*** ../../node_modules/immer/dist/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";



if (false) {} else {
  module.exports = __webpack_require__(/*! ./immer.cjs.development.js */ "../../node_modules/immer/dist/immer.cjs.development.js")
}


/***/ }),

/***/ "../../node_modules/@fortawesome/fontawesome-svg-core/index.mjs":
/*!**********************************************************************!*\
  !*** ../../node_modules/@fortawesome/fontawesome-svg-core/index.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "api": () => (/* binding */ api),
/* harmony export */   "config": () => (/* binding */ config$1),
/* harmony export */   "counter": () => (/* binding */ counter),
/* harmony export */   "dom": () => (/* binding */ dom$1),
/* harmony export */   "findIconDefinition": () => (/* binding */ findIconDefinition$1),
/* harmony export */   "icon": () => (/* binding */ icon),
/* harmony export */   "layer": () => (/* binding */ layer),
/* harmony export */   "library": () => (/* binding */ library$1),
/* harmony export */   "noAuto": () => (/* binding */ noAuto$1),
/* harmony export */   "parse": () => (/* binding */ parse$1),
/* harmony export */   "text": () => (/* binding */ text),
/* harmony export */   "toHtml": () => (/* binding */ toHtml$1)
/* harmony export */ });
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

function _wrapRegExp() {
  _wrapRegExp = function (re, groups) {
    return new BabelRegExp(re, void 0, groups);
  };

  var _super = RegExp.prototype,
      _groups = new WeakMap();

  function BabelRegExp(re, flags, groups) {
    var _this = new RegExp(re, flags);

    return _groups.set(_this, groups || _groups.get(re)), _setPrototypeOf(_this, BabelRegExp.prototype);
  }

  function buildGroups(result, re) {
    var g = _groups.get(re);

    return Object.keys(g).reduce(function (groups, name) {
      return groups[name] = result[g[name]], groups;
    }, Object.create(null));
  }

  return _inherits(BabelRegExp, RegExp), BabelRegExp.prototype.exec = function (str) {
    var result = _super.exec.call(this, str);

    return result && (result.groups = buildGroups(result, this)), result;
  }, BabelRegExp.prototype[Symbol.replace] = function (str, substitution) {
    if ("string" == typeof substitution) {
      var groups = _groups.get(this);

      return _super[Symbol.replace].call(this, str, substitution.replace(/\$<([^>]+)>/g, function (_, name) {
        return "$" + groups[name];
      }));
    }

    if ("function" == typeof substitution) {
      var _this = this;

      return _super[Symbol.replace].call(this, str, function () {
        var args = arguments;
        return "object" != typeof args[args.length - 1] && (args = [].slice.call(args)).push(buildGroups(args, _this)), substitution.apply(this, args);
      });
    }

    return _super[Symbol.replace].call(this, str, substitution);
  }, _wrapRegExp.apply(this, arguments);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var noop = function noop() {};

var _WINDOW = {};
var _DOCUMENT = {};
var _MUTATION_OBSERVER = null;
var _PERFORMANCE = {
  mark: noop,
  measure: noop
};

try {
  if (typeof window !== 'undefined') _WINDOW = window;
  if (typeof document !== 'undefined') _DOCUMENT = document;
  if (typeof MutationObserver !== 'undefined') _MUTATION_OBSERVER = MutationObserver;
  if (typeof performance !== 'undefined') _PERFORMANCE = performance;
} catch (e) {}

var _ref = _WINDOW.navigator || {},
    _ref$userAgent = _ref.userAgent,
    userAgent = _ref$userAgent === void 0 ? '' : _ref$userAgent;
var WINDOW = _WINDOW;
var DOCUMENT = _DOCUMENT;
var MUTATION_OBSERVER = _MUTATION_OBSERVER;
var PERFORMANCE = _PERFORMANCE;
var IS_BROWSER = !!WINDOW.document;
var IS_DOM = !!DOCUMENT.documentElement && !!DOCUMENT.head && typeof DOCUMENT.addEventListener === 'function' && typeof DOCUMENT.createElement === 'function';
var IS_IE = ~userAgent.indexOf('MSIE') || ~userAgent.indexOf('Trident/');

var _familyProxy, _familyProxy2, _familyProxy3, _familyProxy4, _familyProxy5;

var NAMESPACE_IDENTIFIER = '___FONT_AWESOME___';
var UNITS_IN_GRID = 16;
var DEFAULT_CSS_PREFIX = 'fa';
var DEFAULT_REPLACEMENT_CLASS = 'svg-inline--fa';
var DATA_FA_I2SVG = 'data-fa-i2svg';
var DATA_FA_PSEUDO_ELEMENT = 'data-fa-pseudo-element';
var DATA_FA_PSEUDO_ELEMENT_PENDING = 'data-fa-pseudo-element-pending';
var DATA_PREFIX = 'data-prefix';
var DATA_ICON = 'data-icon';
var HTML_CLASS_I2SVG_BASE_CLASS = 'fontawesome-i2svg';
var MUTATION_APPROACH_ASYNC = 'async';
var TAGNAMES_TO_SKIP_FOR_PSEUDOELEMENTS = ['HTML', 'HEAD', 'STYLE', 'SCRIPT'];
var PRODUCTION = function () {
  try {
    return "development" === 'production';
  } catch (e) {
    return false;
  }
}();
var FAMILY_CLASSIC = 'classic';
var FAMILY_SHARP = 'sharp';
var FAMILIES = [FAMILY_CLASSIC, FAMILY_SHARP];

function familyProxy(obj) {
  // Defaults to the classic family if family is not available
  return new Proxy(obj, {
    get: function get(target, prop) {
      return prop in target ? target[prop] : target[FAMILY_CLASSIC];
    }
  });
}
var PREFIX_TO_STYLE = familyProxy((_familyProxy = {}, _defineProperty(_familyProxy, FAMILY_CLASSIC, {
  'fa': 'solid',
  'fas': 'solid',
  'fa-solid': 'solid',
  'far': 'regular',
  'fa-regular': 'regular',
  'fal': 'light',
  'fa-light': 'light',
  'fat': 'thin',
  'fa-thin': 'thin',
  'fad': 'duotone',
  'fa-duotone': 'duotone',
  'fab': 'brands',
  'fa-brands': 'brands',
  'fak': 'kit',
  'fa-kit': 'kit'
}), _defineProperty(_familyProxy, FAMILY_SHARP, {
  'fa': 'solid',
  'fass': 'solid',
  'fa-solid': 'solid'
}), _familyProxy));
var STYLE_TO_PREFIX = familyProxy((_familyProxy2 = {}, _defineProperty(_familyProxy2, FAMILY_CLASSIC, {
  'solid': 'fas',
  'regular': 'far',
  'light': 'fal',
  'thin': 'fat',
  'duotone': 'fad',
  'brands': 'fab',
  'kit': 'fak'
}), _defineProperty(_familyProxy2, FAMILY_SHARP, {
  'solid': 'fass'
}), _familyProxy2));
var PREFIX_TO_LONG_STYLE = familyProxy((_familyProxy3 = {}, _defineProperty(_familyProxy3, FAMILY_CLASSIC, {
  'fab': 'fa-brands',
  'fad': 'fa-duotone',
  'fak': 'fa-kit',
  'fal': 'fa-light',
  'far': 'fa-regular',
  'fas': 'fa-solid',
  'fat': 'fa-thin'
}), _defineProperty(_familyProxy3, FAMILY_SHARP, {
  'fass': 'fa-solid'
}), _familyProxy3));
var LONG_STYLE_TO_PREFIX = familyProxy((_familyProxy4 = {}, _defineProperty(_familyProxy4, FAMILY_CLASSIC, {
  'fa-brands': 'fab',
  'fa-duotone': 'fad',
  'fa-kit': 'fak',
  'fa-light': 'fal',
  'fa-regular': 'far',
  'fa-solid': 'fas',
  'fa-thin': 'fat'
}), _defineProperty(_familyProxy4, FAMILY_SHARP, {
  'fa-solid': 'fass'
}), _familyProxy4));
var ICON_SELECTION_SYNTAX_PATTERN = /fa(s|r|l|t|d|b|k|ss)?[\-\ ]/; // eslint-disable-line no-useless-escape

var LAYERS_TEXT_CLASSNAME = 'fa-layers-text';
var FONT_FAMILY_PATTERN = /Font ?Awesome ?([56 ]*)(Solid|Regular|Light|Thin|Duotone|Brands|Free|Pro|Sharp|Kit)?.*/i; // TODO: this needs to support fass
// TODO: do we need to handle font-weight for kit SVG pseudo-elements?

var FONT_WEIGHT_TO_PREFIX = familyProxy((_familyProxy5 = {}, _defineProperty(_familyProxy5, FAMILY_CLASSIC, {
  '900': 'fas',
  '400': 'far',
  'normal': 'far',
  '300': 'fal',
  '100': 'fat'
}), _defineProperty(_familyProxy5, FAMILY_SHARP, {
  '900': 'fass'
}), _familyProxy5));
var oneToTen = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
var oneToTwenty = oneToTen.concat([11, 12, 13, 14, 15, 16, 17, 18, 19, 20]);
var ATTRIBUTES_WATCHED_FOR_MUTATION = ['class', 'data-prefix', 'data-icon', 'data-fa-transform', 'data-fa-mask'];
var DUOTONE_CLASSES = {
  GROUP: 'duotone-group',
  SWAP_OPACITY: 'swap-opacity',
  PRIMARY: 'primary',
  SECONDARY: 'secondary'
};
var prefixes = new Set();
Object.keys(STYLE_TO_PREFIX[FAMILY_CLASSIC]).map(prefixes.add.bind(prefixes));
Object.keys(STYLE_TO_PREFIX[FAMILY_SHARP]).map(prefixes.add.bind(prefixes));
var RESERVED_CLASSES = [].concat(FAMILIES, _toConsumableArray(prefixes), ['2xs', 'xs', 'sm', 'lg', 'xl', '2xl', 'beat', 'border', 'fade', 'beat-fade', 'bounce', 'flip-both', 'flip-horizontal', 'flip-vertical', 'flip', 'fw', 'inverse', 'layers-counter', 'layers-text', 'layers', 'li', 'pull-left', 'pull-right', 'pulse', 'rotate-180', 'rotate-270', 'rotate-90', 'rotate-by', 'shake', 'spin-pulse', 'spin-reverse', 'spin', 'stack-1x', 'stack-2x', 'stack', 'ul', DUOTONE_CLASSES.GROUP, DUOTONE_CLASSES.SWAP_OPACITY, DUOTONE_CLASSES.PRIMARY, DUOTONE_CLASSES.SECONDARY]).concat(oneToTen.map(function (n) {
  return "".concat(n, "x");
})).concat(oneToTwenty.map(function (n) {
  return "w-".concat(n);
}));

var initial = WINDOW.FontAwesomeConfig || {};

function getAttrConfig(attr) {
  var element = DOCUMENT.querySelector('script[' + attr + ']');

  if (element) {
    return element.getAttribute(attr);
  }
}

function coerce(val) {
  // Getting an empty string will occur if the attribute is set on the HTML tag but without a value
  // We'll assume that this is an indication that it should be toggled to true
  if (val === '') return true;
  if (val === 'false') return false;
  if (val === 'true') return true;
  return val;
}

if (DOCUMENT && typeof DOCUMENT.querySelector === 'function') {
  var attrs = [['data-family-prefix', 'familyPrefix'], ['data-css-prefix', 'cssPrefix'], ['data-family-default', 'familyDefault'], ['data-style-default', 'styleDefault'], ['data-replacement-class', 'replacementClass'], ['data-auto-replace-svg', 'autoReplaceSvg'], ['data-auto-add-css', 'autoAddCss'], ['data-auto-a11y', 'autoA11y'], ['data-search-pseudo-elements', 'searchPseudoElements'], ['data-observe-mutations', 'observeMutations'], ['data-mutate-approach', 'mutateApproach'], ['data-keep-original-source', 'keepOriginalSource'], ['data-measure-performance', 'measurePerformance'], ['data-show-missing-icons', 'showMissingIcons']];
  attrs.forEach(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        attr = _ref2[0],
        key = _ref2[1];

    var val = coerce(getAttrConfig(attr));

    if (val !== undefined && val !== null) {
      initial[key] = val;
    }
  });
}

var _default = {
  styleDefault: 'solid',
  familyDefault: 'classic',
  cssPrefix: DEFAULT_CSS_PREFIX,
  replacementClass: DEFAULT_REPLACEMENT_CLASS,
  autoReplaceSvg: true,
  autoAddCss: true,
  autoA11y: true,
  searchPseudoElements: false,
  observeMutations: true,
  mutateApproach: 'async',
  keepOriginalSource: true,
  measurePerformance: false,
  showMissingIcons: true
}; // familyPrefix is deprecated but we must still support it if present

if (initial.familyPrefix) {
  initial.cssPrefix = initial.familyPrefix;
}

var _config = _objectSpread2(_objectSpread2({}, _default), initial);

if (!_config.autoReplaceSvg) _config.observeMutations = false;
var config = {};
Object.keys(_default).forEach(function (key) {
  Object.defineProperty(config, key, {
    enumerable: true,
    set: function set(val) {
      _config[key] = val;

      _onChangeCb.forEach(function (cb) {
        return cb(config);
      });
    },
    get: function get() {
      return _config[key];
    }
  });
}); // familyPrefix is deprecated as of 6.2.0 and should be removed in 7.0.0

Object.defineProperty(config, 'familyPrefix', {
  enumerable: true,
  set: function set(val) {
    _config.cssPrefix = val;

    _onChangeCb.forEach(function (cb) {
      return cb(config);
    });
  },
  get: function get() {
    return _config.cssPrefix;
  }
});
WINDOW.FontAwesomeConfig = config;
var _onChangeCb = [];
function onChange(cb) {
  _onChangeCb.push(cb);

  return function () {
    _onChangeCb.splice(_onChangeCb.indexOf(cb), 1);
  };
}

var d = UNITS_IN_GRID;
var meaninglessTransform = {
  size: 16,
  x: 0,
  y: 0,
  rotate: 0,
  flipX: false,
  flipY: false
};
function insertCss(css) {
  if (!css || !IS_DOM) {
    return;
  }

  var style = DOCUMENT.createElement('style');
  style.setAttribute('type', 'text/css');
  style.innerHTML = css;
  var headChildren = DOCUMENT.head.childNodes;
  var beforeChild = null;

  for (var i = headChildren.length - 1; i > -1; i--) {
    var child = headChildren[i];
    var tagName = (child.tagName || '').toUpperCase();

    if (['STYLE', 'LINK'].indexOf(tagName) > -1) {
      beforeChild = child;
    }
  }

  DOCUMENT.head.insertBefore(style, beforeChild);
  return css;
}
var idPool = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
function nextUniqueId() {
  var size = 12;
  var id = '';

  while (size-- > 0) {
    id += idPool[Math.random() * 62 | 0];
  }

  return id;
}
function toArray(obj) {
  var array = [];

  for (var i = (obj || []).length >>> 0; i--;) {
    array[i] = obj[i];
  }

  return array;
}
function classArray(node) {
  if (node.classList) {
    return toArray(node.classList);
  } else {
    return (node.getAttribute('class') || '').split(' ').filter(function (i) {
      return i;
    });
  }
}
function htmlEscape(str) {
  return "".concat(str).replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}
function joinAttributes(attributes) {
  return Object.keys(attributes || {}).reduce(function (acc, attributeName) {
    return acc + "".concat(attributeName, "=\"").concat(htmlEscape(attributes[attributeName]), "\" ");
  }, '').trim();
}
function joinStyles(styles) {
  return Object.keys(styles || {}).reduce(function (acc, styleName) {
    return acc + "".concat(styleName, ": ").concat(styles[styleName].trim(), ";");
  }, '');
}
function transformIsMeaningful(transform) {
  return transform.size !== meaninglessTransform.size || transform.x !== meaninglessTransform.x || transform.y !== meaninglessTransform.y || transform.rotate !== meaninglessTransform.rotate || transform.flipX || transform.flipY;
}
function transformForSvg(_ref) {
  var transform = _ref.transform,
      containerWidth = _ref.containerWidth,
      iconWidth = _ref.iconWidth;
  var outer = {
    transform: "translate(".concat(containerWidth / 2, " 256)")
  };
  var innerTranslate = "translate(".concat(transform.x * 32, ", ").concat(transform.y * 32, ") ");
  var innerScale = "scale(".concat(transform.size / 16 * (transform.flipX ? -1 : 1), ", ").concat(transform.size / 16 * (transform.flipY ? -1 : 1), ") ");
  var innerRotate = "rotate(".concat(transform.rotate, " 0 0)");
  var inner = {
    transform: "".concat(innerTranslate, " ").concat(innerScale, " ").concat(innerRotate)
  };
  var path = {
    transform: "translate(".concat(iconWidth / 2 * -1, " -256)")
  };
  return {
    outer: outer,
    inner: inner,
    path: path
  };
}
function transformForCss(_ref2) {
  var transform = _ref2.transform,
      _ref2$width = _ref2.width,
      width = _ref2$width === void 0 ? UNITS_IN_GRID : _ref2$width,
      _ref2$height = _ref2.height,
      height = _ref2$height === void 0 ? UNITS_IN_GRID : _ref2$height,
      _ref2$startCentered = _ref2.startCentered,
      startCentered = _ref2$startCentered === void 0 ? false : _ref2$startCentered;
  var val = '';

  if (startCentered && IS_IE) {
    val += "translate(".concat(transform.x / d - width / 2, "em, ").concat(transform.y / d - height / 2, "em) ");
  } else if (startCentered) {
    val += "translate(calc(-50% + ".concat(transform.x / d, "em), calc(-50% + ").concat(transform.y / d, "em)) ");
  } else {
    val += "translate(".concat(transform.x / d, "em, ").concat(transform.y / d, "em) ");
  }

  val += "scale(".concat(transform.size / d * (transform.flipX ? -1 : 1), ", ").concat(transform.size / d * (transform.flipY ? -1 : 1), ") ");
  val += "rotate(".concat(transform.rotate, "deg) ");
  return val;
}

var baseStyles = ":root, :host {\n  --fa-font-solid: normal 900 1em/1 \"Font Awesome 6 Solid\";\n  --fa-font-regular: normal 400 1em/1 \"Font Awesome 6 Regular\";\n  --fa-font-light: normal 300 1em/1 \"Font Awesome 6 Light\";\n  --fa-font-thin: normal 100 1em/1 \"Font Awesome 6 Thin\";\n  --fa-font-duotone: normal 900 1em/1 \"Font Awesome 6 Duotone\";\n  --fa-font-sharp-solid: normal 900 1em/1 \"Font Awesome 6 Sharp\";\n  --fa-font-brands: normal 400 1em/1 \"Font Awesome 6 Brands\";\n}\n\nsvg:not(:root).svg-inline--fa, svg:not(:host).svg-inline--fa {\n  overflow: visible;\n  box-sizing: content-box;\n}\n\n.svg-inline--fa {\n  display: var(--fa-display, inline-block);\n  height: 1em;\n  overflow: visible;\n  vertical-align: -0.125em;\n}\n.svg-inline--fa.fa-2xs {\n  vertical-align: 0.1em;\n}\n.svg-inline--fa.fa-xs {\n  vertical-align: 0em;\n}\n.svg-inline--fa.fa-sm {\n  vertical-align: -0.0714285705em;\n}\n.svg-inline--fa.fa-lg {\n  vertical-align: -0.2em;\n}\n.svg-inline--fa.fa-xl {\n  vertical-align: -0.25em;\n}\n.svg-inline--fa.fa-2xl {\n  vertical-align: -0.3125em;\n}\n.svg-inline--fa.fa-pull-left {\n  margin-right: var(--fa-pull-margin, 0.3em);\n  width: auto;\n}\n.svg-inline--fa.fa-pull-right {\n  margin-left: var(--fa-pull-margin, 0.3em);\n  width: auto;\n}\n.svg-inline--fa.fa-li {\n  width: var(--fa-li-width, 2em);\n  top: 0.25em;\n}\n.svg-inline--fa.fa-fw {\n  width: var(--fa-fw-width, 1.25em);\n}\n\n.fa-layers svg.svg-inline--fa {\n  bottom: 0;\n  left: 0;\n  margin: auto;\n  position: absolute;\n  right: 0;\n  top: 0;\n}\n\n.fa-layers-counter, .fa-layers-text {\n  display: inline-block;\n  position: absolute;\n  text-align: center;\n}\n\n.fa-layers {\n  display: inline-block;\n  height: 1em;\n  position: relative;\n  text-align: center;\n  vertical-align: -0.125em;\n  width: 1em;\n}\n.fa-layers svg.svg-inline--fa {\n  -webkit-transform-origin: center center;\n          transform-origin: center center;\n}\n\n.fa-layers-text {\n  left: 50%;\n  top: 50%;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n  -webkit-transform-origin: center center;\n          transform-origin: center center;\n}\n\n.fa-layers-counter {\n  background-color: var(--fa-counter-background-color, #ff253a);\n  border-radius: var(--fa-counter-border-radius, 1em);\n  box-sizing: border-box;\n  color: var(--fa-inverse, #fff);\n  line-height: var(--fa-counter-line-height, 1);\n  max-width: var(--fa-counter-max-width, 5em);\n  min-width: var(--fa-counter-min-width, 1.5em);\n  overflow: hidden;\n  padding: var(--fa-counter-padding, 0.25em 0.5em);\n  right: var(--fa-right, 0);\n  text-overflow: ellipsis;\n  top: var(--fa-top, 0);\n  -webkit-transform: scale(var(--fa-counter-scale, 0.25));\n          transform: scale(var(--fa-counter-scale, 0.25));\n  -webkit-transform-origin: top right;\n          transform-origin: top right;\n}\n\n.fa-layers-bottom-right {\n  bottom: var(--fa-bottom, 0);\n  right: var(--fa-right, 0);\n  top: auto;\n  -webkit-transform: scale(var(--fa-layers-scale, 0.25));\n          transform: scale(var(--fa-layers-scale, 0.25));\n  -webkit-transform-origin: bottom right;\n          transform-origin: bottom right;\n}\n\n.fa-layers-bottom-left {\n  bottom: var(--fa-bottom, 0);\n  left: var(--fa-left, 0);\n  right: auto;\n  top: auto;\n  -webkit-transform: scale(var(--fa-layers-scale, 0.25));\n          transform: scale(var(--fa-layers-scale, 0.25));\n  -webkit-transform-origin: bottom left;\n          transform-origin: bottom left;\n}\n\n.fa-layers-top-right {\n  top: var(--fa-top, 0);\n  right: var(--fa-right, 0);\n  -webkit-transform: scale(var(--fa-layers-scale, 0.25));\n          transform: scale(var(--fa-layers-scale, 0.25));\n  -webkit-transform-origin: top right;\n          transform-origin: top right;\n}\n\n.fa-layers-top-left {\n  left: var(--fa-left, 0);\n  right: auto;\n  top: var(--fa-top, 0);\n  -webkit-transform: scale(var(--fa-layers-scale, 0.25));\n          transform: scale(var(--fa-layers-scale, 0.25));\n  -webkit-transform-origin: top left;\n          transform-origin: top left;\n}\n\n.fa-1x {\n  font-size: 1em;\n}\n\n.fa-2x {\n  font-size: 2em;\n}\n\n.fa-3x {\n  font-size: 3em;\n}\n\n.fa-4x {\n  font-size: 4em;\n}\n\n.fa-5x {\n  font-size: 5em;\n}\n\n.fa-6x {\n  font-size: 6em;\n}\n\n.fa-7x {\n  font-size: 7em;\n}\n\n.fa-8x {\n  font-size: 8em;\n}\n\n.fa-9x {\n  font-size: 9em;\n}\n\n.fa-10x {\n  font-size: 10em;\n}\n\n.fa-2xs {\n  font-size: 0.625em;\n  line-height: 0.1em;\n  vertical-align: 0.225em;\n}\n\n.fa-xs {\n  font-size: 0.75em;\n  line-height: 0.0833333337em;\n  vertical-align: 0.125em;\n}\n\n.fa-sm {\n  font-size: 0.875em;\n  line-height: 0.0714285718em;\n  vertical-align: 0.0535714295em;\n}\n\n.fa-lg {\n  font-size: 1.25em;\n  line-height: 0.05em;\n  vertical-align: -0.075em;\n}\n\n.fa-xl {\n  font-size: 1.5em;\n  line-height: 0.0416666682em;\n  vertical-align: -0.125em;\n}\n\n.fa-2xl {\n  font-size: 2em;\n  line-height: 0.03125em;\n  vertical-align: -0.1875em;\n}\n\n.fa-fw {\n  text-align: center;\n  width: 1.25em;\n}\n\n.fa-ul {\n  list-style-type: none;\n  margin-left: var(--fa-li-margin, 2.5em);\n  padding-left: 0;\n}\n.fa-ul > li {\n  position: relative;\n}\n\n.fa-li {\n  left: calc(var(--fa-li-width, 2em) * -1);\n  position: absolute;\n  text-align: center;\n  width: var(--fa-li-width, 2em);\n  line-height: inherit;\n}\n\n.fa-border {\n  border-color: var(--fa-border-color, #eee);\n  border-radius: var(--fa-border-radius, 0.1em);\n  border-style: var(--fa-border-style, solid);\n  border-width: var(--fa-border-width, 0.08em);\n  padding: var(--fa-border-padding, 0.2em 0.25em 0.15em);\n}\n\n.fa-pull-left {\n  float: left;\n  margin-right: var(--fa-pull-margin, 0.3em);\n}\n\n.fa-pull-right {\n  float: right;\n  margin-left: var(--fa-pull-margin, 0.3em);\n}\n\n.fa-beat {\n  -webkit-animation-name: fa-beat;\n          animation-name: fa-beat;\n  -webkit-animation-delay: var(--fa-animation-delay, 0s);\n          animation-delay: var(--fa-animation-delay, 0s);\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 1s);\n          animation-duration: var(--fa-animation-duration, 1s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, ease-in-out);\n          animation-timing-function: var(--fa-animation-timing, ease-in-out);\n}\n\n.fa-bounce {\n  -webkit-animation-name: fa-bounce;\n          animation-name: fa-bounce;\n  -webkit-animation-delay: var(--fa-animation-delay, 0s);\n          animation-delay: var(--fa-animation-delay, 0s);\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 1s);\n          animation-duration: var(--fa-animation-duration, 1s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));\n          animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));\n}\n\n.fa-fade {\n  -webkit-animation-name: fa-fade;\n          animation-name: fa-fade;\n  -webkit-animation-delay: var(--fa-animation-delay, 0s);\n          animation-delay: var(--fa-animation-delay, 0s);\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 1s);\n          animation-duration: var(--fa-animation-duration, 1s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));\n          animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));\n}\n\n.fa-beat-fade {\n  -webkit-animation-name: fa-beat-fade;\n          animation-name: fa-beat-fade;\n  -webkit-animation-delay: var(--fa-animation-delay, 0s);\n          animation-delay: var(--fa-animation-delay, 0s);\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 1s);\n          animation-duration: var(--fa-animation-duration, 1s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));\n          animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));\n}\n\n.fa-flip {\n  -webkit-animation-name: fa-flip;\n          animation-name: fa-flip;\n  -webkit-animation-delay: var(--fa-animation-delay, 0s);\n          animation-delay: var(--fa-animation-delay, 0s);\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 1s);\n          animation-duration: var(--fa-animation-duration, 1s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, ease-in-out);\n          animation-timing-function: var(--fa-animation-timing, ease-in-out);\n}\n\n.fa-shake {\n  -webkit-animation-name: fa-shake;\n          animation-name: fa-shake;\n  -webkit-animation-delay: var(--fa-animation-delay, 0s);\n          animation-delay: var(--fa-animation-delay, 0s);\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 1s);\n          animation-duration: var(--fa-animation-duration, 1s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, linear);\n          animation-timing-function: var(--fa-animation-timing, linear);\n}\n\n.fa-spin {\n  -webkit-animation-name: fa-spin;\n          animation-name: fa-spin;\n  -webkit-animation-delay: var(--fa-animation-delay, 0s);\n          animation-delay: var(--fa-animation-delay, 0s);\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 2s);\n          animation-duration: var(--fa-animation-duration, 2s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, linear);\n          animation-timing-function: var(--fa-animation-timing, linear);\n}\n\n.fa-spin-reverse {\n  --fa-animation-direction: reverse;\n}\n\n.fa-pulse,\n.fa-spin-pulse {\n  -webkit-animation-name: fa-spin;\n          animation-name: fa-spin;\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 1s);\n          animation-duration: var(--fa-animation-duration, 1s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, steps(8));\n          animation-timing-function: var(--fa-animation-timing, steps(8));\n}\n\n@media (prefers-reduced-motion: reduce) {\n  .fa-beat,\n.fa-bounce,\n.fa-fade,\n.fa-beat-fade,\n.fa-flip,\n.fa-pulse,\n.fa-shake,\n.fa-spin,\n.fa-spin-pulse {\n    -webkit-animation-delay: -1ms;\n            animation-delay: -1ms;\n    -webkit-animation-duration: 1ms;\n            animation-duration: 1ms;\n    -webkit-animation-iteration-count: 1;\n            animation-iteration-count: 1;\n    transition-delay: 0s;\n    transition-duration: 0s;\n  }\n}\n@-webkit-keyframes fa-beat {\n  0%, 90% {\n    -webkit-transform: scale(1);\n            transform: scale(1);\n  }\n  45% {\n    -webkit-transform: scale(var(--fa-beat-scale, 1.25));\n            transform: scale(var(--fa-beat-scale, 1.25));\n  }\n}\n@keyframes fa-beat {\n  0%, 90% {\n    -webkit-transform: scale(1);\n            transform: scale(1);\n  }\n  45% {\n    -webkit-transform: scale(var(--fa-beat-scale, 1.25));\n            transform: scale(var(--fa-beat-scale, 1.25));\n  }\n}\n@-webkit-keyframes fa-bounce {\n  0% {\n    -webkit-transform: scale(1, 1) translateY(0);\n            transform: scale(1, 1) translateY(0);\n  }\n  10% {\n    -webkit-transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);\n            transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);\n  }\n  30% {\n    -webkit-transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));\n            transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));\n  }\n  50% {\n    -webkit-transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);\n            transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);\n  }\n  57% {\n    -webkit-transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));\n            transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));\n  }\n  64% {\n    -webkit-transform: scale(1, 1) translateY(0);\n            transform: scale(1, 1) translateY(0);\n  }\n  100% {\n    -webkit-transform: scale(1, 1) translateY(0);\n            transform: scale(1, 1) translateY(0);\n  }\n}\n@keyframes fa-bounce {\n  0% {\n    -webkit-transform: scale(1, 1) translateY(0);\n            transform: scale(1, 1) translateY(0);\n  }\n  10% {\n    -webkit-transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);\n            transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);\n  }\n  30% {\n    -webkit-transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));\n            transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));\n  }\n  50% {\n    -webkit-transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);\n            transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);\n  }\n  57% {\n    -webkit-transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));\n            transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));\n  }\n  64% {\n    -webkit-transform: scale(1, 1) translateY(0);\n            transform: scale(1, 1) translateY(0);\n  }\n  100% {\n    -webkit-transform: scale(1, 1) translateY(0);\n            transform: scale(1, 1) translateY(0);\n  }\n}\n@-webkit-keyframes fa-fade {\n  50% {\n    opacity: var(--fa-fade-opacity, 0.4);\n  }\n}\n@keyframes fa-fade {\n  50% {\n    opacity: var(--fa-fade-opacity, 0.4);\n  }\n}\n@-webkit-keyframes fa-beat-fade {\n  0%, 100% {\n    opacity: var(--fa-beat-fade-opacity, 0.4);\n    -webkit-transform: scale(1);\n            transform: scale(1);\n  }\n  50% {\n    opacity: 1;\n    -webkit-transform: scale(var(--fa-beat-fade-scale, 1.125));\n            transform: scale(var(--fa-beat-fade-scale, 1.125));\n  }\n}\n@keyframes fa-beat-fade {\n  0%, 100% {\n    opacity: var(--fa-beat-fade-opacity, 0.4);\n    -webkit-transform: scale(1);\n            transform: scale(1);\n  }\n  50% {\n    opacity: 1;\n    -webkit-transform: scale(var(--fa-beat-fade-scale, 1.125));\n            transform: scale(var(--fa-beat-fade-scale, 1.125));\n  }\n}\n@-webkit-keyframes fa-flip {\n  50% {\n    -webkit-transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));\n            transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));\n  }\n}\n@keyframes fa-flip {\n  50% {\n    -webkit-transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));\n            transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));\n  }\n}\n@-webkit-keyframes fa-shake {\n  0% {\n    -webkit-transform: rotate(-15deg);\n            transform: rotate(-15deg);\n  }\n  4% {\n    -webkit-transform: rotate(15deg);\n            transform: rotate(15deg);\n  }\n  8%, 24% {\n    -webkit-transform: rotate(-18deg);\n            transform: rotate(-18deg);\n  }\n  12%, 28% {\n    -webkit-transform: rotate(18deg);\n            transform: rotate(18deg);\n  }\n  16% {\n    -webkit-transform: rotate(-22deg);\n            transform: rotate(-22deg);\n  }\n  20% {\n    -webkit-transform: rotate(22deg);\n            transform: rotate(22deg);\n  }\n  32% {\n    -webkit-transform: rotate(-12deg);\n            transform: rotate(-12deg);\n  }\n  36% {\n    -webkit-transform: rotate(12deg);\n            transform: rotate(12deg);\n  }\n  40%, 100% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n  }\n}\n@keyframes fa-shake {\n  0% {\n    -webkit-transform: rotate(-15deg);\n            transform: rotate(-15deg);\n  }\n  4% {\n    -webkit-transform: rotate(15deg);\n            transform: rotate(15deg);\n  }\n  8%, 24% {\n    -webkit-transform: rotate(-18deg);\n            transform: rotate(-18deg);\n  }\n  12%, 28% {\n    -webkit-transform: rotate(18deg);\n            transform: rotate(18deg);\n  }\n  16% {\n    -webkit-transform: rotate(-22deg);\n            transform: rotate(-22deg);\n  }\n  20% {\n    -webkit-transform: rotate(22deg);\n            transform: rotate(22deg);\n  }\n  32% {\n    -webkit-transform: rotate(-12deg);\n            transform: rotate(-12deg);\n  }\n  36% {\n    -webkit-transform: rotate(12deg);\n            transform: rotate(12deg);\n  }\n  40%, 100% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n  }\n}\n@-webkit-keyframes fa-spin {\n  0% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n  }\n  100% {\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg);\n  }\n}\n@keyframes fa-spin {\n  0% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n  }\n  100% {\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg);\n  }\n}\n.fa-rotate-90 {\n  -webkit-transform: rotate(90deg);\n          transform: rotate(90deg);\n}\n\n.fa-rotate-180 {\n  -webkit-transform: rotate(180deg);\n          transform: rotate(180deg);\n}\n\n.fa-rotate-270 {\n  -webkit-transform: rotate(270deg);\n          transform: rotate(270deg);\n}\n\n.fa-flip-horizontal {\n  -webkit-transform: scale(-1, 1);\n          transform: scale(-1, 1);\n}\n\n.fa-flip-vertical {\n  -webkit-transform: scale(1, -1);\n          transform: scale(1, -1);\n}\n\n.fa-flip-both,\n.fa-flip-horizontal.fa-flip-vertical {\n  -webkit-transform: scale(-1, -1);\n          transform: scale(-1, -1);\n}\n\n.fa-rotate-by {\n  -webkit-transform: rotate(var(--fa-rotate-angle, none));\n          transform: rotate(var(--fa-rotate-angle, none));\n}\n\n.fa-stack {\n  display: inline-block;\n  vertical-align: middle;\n  height: 2em;\n  position: relative;\n  width: 2.5em;\n}\n\n.fa-stack-1x,\n.fa-stack-2x {\n  bottom: 0;\n  left: 0;\n  margin: auto;\n  position: absolute;\n  right: 0;\n  top: 0;\n  z-index: var(--fa-stack-z-index, auto);\n}\n\n.svg-inline--fa.fa-stack-1x {\n  height: 1em;\n  width: 1.25em;\n}\n.svg-inline--fa.fa-stack-2x {\n  height: 2em;\n  width: 2.5em;\n}\n\n.fa-inverse {\n  color: var(--fa-inverse, #fff);\n}\n\n.sr-only,\n.fa-sr-only {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  padding: 0;\n  margin: -1px;\n  overflow: hidden;\n  clip: rect(0, 0, 0, 0);\n  white-space: nowrap;\n  border-width: 0;\n}\n\n.sr-only-focusable:not(:focus),\n.fa-sr-only-focusable:not(:focus) {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  padding: 0;\n  margin: -1px;\n  overflow: hidden;\n  clip: rect(0, 0, 0, 0);\n  white-space: nowrap;\n  border-width: 0;\n}\n\n.svg-inline--fa .fa-primary {\n  fill: var(--fa-primary-color, currentColor);\n  opacity: var(--fa-primary-opacity, 1);\n}\n\n.svg-inline--fa .fa-secondary {\n  fill: var(--fa-secondary-color, currentColor);\n  opacity: var(--fa-secondary-opacity, 0.4);\n}\n\n.svg-inline--fa.fa-swap-opacity .fa-primary {\n  opacity: var(--fa-secondary-opacity, 0.4);\n}\n\n.svg-inline--fa.fa-swap-opacity .fa-secondary {\n  opacity: var(--fa-primary-opacity, 1);\n}\n\n.svg-inline--fa mask .fa-primary,\n.svg-inline--fa mask .fa-secondary {\n  fill: black;\n}\n\n.fad.fa-inverse,\n.fa-duotone.fa-inverse {\n  color: var(--fa-inverse, #fff);\n}";

function css() {
  var dcp = DEFAULT_CSS_PREFIX;
  var drc = DEFAULT_REPLACEMENT_CLASS;
  var fp = config.cssPrefix;
  var rc = config.replacementClass;
  var s = baseStyles;

  if (fp !== dcp || rc !== drc) {
    var dPatt = new RegExp("\\.".concat(dcp, "\\-"), 'g');
    var customPropPatt = new RegExp("\\--".concat(dcp, "\\-"), 'g');
    var rPatt = new RegExp("\\.".concat(drc), 'g');
    s = s.replace(dPatt, ".".concat(fp, "-")).replace(customPropPatt, "--".concat(fp, "-")).replace(rPatt, ".".concat(rc));
  }

  return s;
}

var _cssInserted = false;

function ensureCss() {
  if (config.autoAddCss && !_cssInserted) {
    insertCss(css());
    _cssInserted = true;
  }
}

var InjectCSS = {
  mixout: function mixout() {
    return {
      dom: {
        css: css,
        insertCss: ensureCss
      }
    };
  },
  hooks: function hooks() {
    return {
      beforeDOMElementCreation: function beforeDOMElementCreation() {
        ensureCss();
      },
      beforeI2svg: function beforeI2svg() {
        ensureCss();
      }
    };
  }
};

var w = WINDOW || {};
if (!w[NAMESPACE_IDENTIFIER]) w[NAMESPACE_IDENTIFIER] = {};
if (!w[NAMESPACE_IDENTIFIER].styles) w[NAMESPACE_IDENTIFIER].styles = {};
if (!w[NAMESPACE_IDENTIFIER].hooks) w[NAMESPACE_IDENTIFIER].hooks = {};
if (!w[NAMESPACE_IDENTIFIER].shims) w[NAMESPACE_IDENTIFIER].shims = [];
var namespace = w[NAMESPACE_IDENTIFIER];

var functions = [];

var listener = function listener() {
  DOCUMENT.removeEventListener('DOMContentLoaded', listener);
  loaded = 1;
  functions.map(function (fn) {
    return fn();
  });
};

var loaded = false;

if (IS_DOM) {
  loaded = (DOCUMENT.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(DOCUMENT.readyState);
  if (!loaded) DOCUMENT.addEventListener('DOMContentLoaded', listener);
}

function domready (fn) {
  if (!IS_DOM) return;
  loaded ? setTimeout(fn, 0) : functions.push(fn);
}

function toHtml(abstractNodes) {
  var tag = abstractNodes.tag,
      _abstractNodes$attrib = abstractNodes.attributes,
      attributes = _abstractNodes$attrib === void 0 ? {} : _abstractNodes$attrib,
      _abstractNodes$childr = abstractNodes.children,
      children = _abstractNodes$childr === void 0 ? [] : _abstractNodes$childr;

  if (typeof abstractNodes === 'string') {
    return htmlEscape(abstractNodes);
  } else {
    return "<".concat(tag, " ").concat(joinAttributes(attributes), ">").concat(children.map(toHtml).join(''), "</").concat(tag, ">");
  }
}

function iconFromMapping(mapping, prefix, iconName) {
  if (mapping && mapping[prefix] && mapping[prefix][iconName]) {
    return {
      prefix: prefix,
      iconName: iconName,
      icon: mapping[prefix][iconName]
    };
  }
}

/**
 * Internal helper to bind a function known to have 4 arguments
 * to a given context.
 */

var bindInternal4 = function bindInternal4(func, thisContext) {
  return function (a, b, c, d) {
    return func.call(thisContext, a, b, c, d);
  };
};

/**
 * # Reduce
 *
 * A fast object `.reduce()` implementation.
 *
 * @param  {Object}   subject      The object to reduce over.
 * @param  {Function} fn           The reducer function.
 * @param  {mixed}    initialValue The initial value for the reducer, defaults to subject[0].
 * @param  {Object}   thisContext  The context for the reducer.
 * @return {mixed}                 The final result.
 */


var reduce = function fastReduceObject(subject, fn, initialValue, thisContext) {
  var keys = Object.keys(subject),
      length = keys.length,
      iterator = thisContext !== undefined ? bindInternal4(fn, thisContext) : fn,
      i,
      key,
      result;

  if (initialValue === undefined) {
    i = 1;
    result = subject[keys[0]];
  } else {
    i = 0;
    result = initialValue;
  }

  for (; i < length; i++) {
    key = keys[i];
    result = iterator(result, subject[key], key, subject);
  }

  return result;
};

/**
 * ucs2decode() and codePointAt() are both works of Mathias Bynens and licensed under MIT
 *
 * Copyright Mathias Bynens <https://mathiasbynens.be/>

 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:

 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
function ucs2decode(string) {
  var output = [];
  var counter = 0;
  var length = string.length;

  while (counter < length) {
    var value = string.charCodeAt(counter++);

    if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
      var extra = string.charCodeAt(counter++);

      if ((extra & 0xFC00) == 0xDC00) {
        // eslint-disable-line eqeqeq
        output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
      } else {
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }

  return output;
}

function toHex(unicode) {
  var decoded = ucs2decode(unicode);
  return decoded.length === 1 ? decoded[0].toString(16) : null;
}
function codePointAt(string, index) {
  var size = string.length;
  var first = string.charCodeAt(index);
  var second;

  if (first >= 0xD800 && first <= 0xDBFF && size > index + 1) {
    second = string.charCodeAt(index + 1);

    if (second >= 0xDC00 && second <= 0xDFFF) {
      return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
    }
  }

  return first;
}

function normalizeIcons(icons) {
  return Object.keys(icons).reduce(function (acc, iconName) {
    var icon = icons[iconName];
    var expanded = !!icon.icon;

    if (expanded) {
      acc[icon.iconName] = icon.icon;
    } else {
      acc[iconName] = icon;
    }

    return acc;
  }, {});
}

function defineIcons(prefix, icons) {
  var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var _params$skipHooks = params.skipHooks,
      skipHooks = _params$skipHooks === void 0 ? false : _params$skipHooks;
  var normalized = normalizeIcons(icons);

  if (typeof namespace.hooks.addPack === 'function' && !skipHooks) {
    namespace.hooks.addPack(prefix, normalizeIcons(icons));
  } else {
    namespace.styles[prefix] = _objectSpread2(_objectSpread2({}, namespace.styles[prefix] || {}), normalized);
  }
  /**
   * Font Awesome 4 used the prefix of `fa` for all icons. With the introduction
   * of new styles we needed to differentiate between them. Prefix `fa` is now an alias
   * for `fas` so we'll ease the upgrade process for our users by automatically defining
   * this as well.
   */


  if (prefix === 'fas') {
    defineIcons('fa', icons);
  }
}

var duotonePathRe = [/*#__PURE__*/_wrapRegExp(/path d="((?:(?!")[\s\S])+)".*path d="((?:(?!")[\s\S])+)"/, {
  d1: 1,
  d2: 2
}), /*#__PURE__*/_wrapRegExp(/path class="((?:(?!")[\s\S])+)".*d="((?:(?!")[\s\S])+)".*path class="((?:(?!")[\s\S])+)".*d="((?:(?!")[\s\S])+)"/, {
  cls1: 1,
  d1: 2,
  cls2: 3,
  d2: 4
}), /*#__PURE__*/_wrapRegExp(/path class="((?:(?!")[\s\S])+)".*d="((?:(?!")[\s\S])+)"/, {
  cls1: 1,
  d1: 2
})];

var _LONG_STYLE, _PREFIXES, _PREFIXES_FOR_FAMILY;
var styles = namespace.styles,
    shims = namespace.shims;
var LONG_STYLE = (_LONG_STYLE = {}, _defineProperty(_LONG_STYLE, FAMILY_CLASSIC, Object.values(PREFIX_TO_LONG_STYLE[FAMILY_CLASSIC])), _defineProperty(_LONG_STYLE, FAMILY_SHARP, Object.values(PREFIX_TO_LONG_STYLE[FAMILY_SHARP])), _LONG_STYLE);
var _defaultUsablePrefix = null;
var _byUnicode = {};
var _byLigature = {};
var _byOldName = {};
var _byOldUnicode = {};
var _byAlias = {};
var PREFIXES = (_PREFIXES = {}, _defineProperty(_PREFIXES, FAMILY_CLASSIC, Object.keys(PREFIX_TO_STYLE[FAMILY_CLASSIC])), _defineProperty(_PREFIXES, FAMILY_SHARP, Object.keys(PREFIX_TO_STYLE[FAMILY_SHARP])), _PREFIXES);

function isReserved(name) {
  return ~RESERVED_CLASSES.indexOf(name);
}

function getIconName(cssPrefix, cls) {
  var parts = cls.split('-');
  var prefix = parts[0];
  var iconName = parts.slice(1).join('-');

  if (prefix === cssPrefix && iconName !== '' && !isReserved(iconName)) {
    return iconName;
  } else {
    return null;
  }
}
var build = function build() {
  var lookup = function lookup(reducer) {
    return reduce(styles, function (o, style, prefix) {
      o[prefix] = reduce(style, reducer, {});
      return o;
    }, {});
  };

  _byUnicode = lookup(function (acc, icon, iconName) {
    if (icon[3]) {
      acc[icon[3]] = iconName;
    }

    if (icon[2]) {
      var aliases = icon[2].filter(function (a) {
        return typeof a === 'number';
      });
      aliases.forEach(function (alias) {
        acc[alias.toString(16)] = iconName;
      });
    }

    return acc;
  });
  _byLigature = lookup(function (acc, icon, iconName) {
    acc[iconName] = iconName;

    if (icon[2]) {
      var aliases = icon[2].filter(function (a) {
        return typeof a === 'string';
      });
      aliases.forEach(function (alias) {
        acc[alias] = iconName;
      });
    }

    return acc;
  });
  _byAlias = lookup(function (acc, icon, iconName) {
    var aliases = icon[2];
    acc[iconName] = iconName;
    aliases.forEach(function (alias) {
      acc[alias] = iconName;
    });
    return acc;
  }); // If we have a Kit, we can't determine if regular is available since we
  // could be auto-fetching it. We'll have to assume that it is available.

  var hasRegular = 'far' in styles || config.autoFetchSvg;
  var shimLookups = reduce(shims, function (acc, shim) {
    var maybeNameMaybeUnicode = shim[0];
    var prefix = shim[1];
    var iconName = shim[2];

    if (prefix === 'far' && !hasRegular) {
      prefix = 'fas';
    }

    if (typeof maybeNameMaybeUnicode === 'string') {
      acc.names[maybeNameMaybeUnicode] = {
        prefix: prefix,
        iconName: iconName
      };
    }

    if (typeof maybeNameMaybeUnicode === 'number') {
      acc.unicodes[maybeNameMaybeUnicode.toString(16)] = {
        prefix: prefix,
        iconName: iconName
      };
    }

    return acc;
  }, {
    names: {},
    unicodes: {}
  });
  _byOldName = shimLookups.names;
  _byOldUnicode = shimLookups.unicodes;
  _defaultUsablePrefix = getCanonicalPrefix(config.styleDefault, {
    family: config.familyDefault
  });
};
onChange(function (c) {
  _defaultUsablePrefix = getCanonicalPrefix(c.styleDefault, {
    family: config.familyDefault
  });
});
build();
function byUnicode(prefix, unicode) {
  return (_byUnicode[prefix] || {})[unicode];
}
function byLigature(prefix, ligature) {
  return (_byLigature[prefix] || {})[ligature];
}
function byAlias(prefix, alias) {
  return (_byAlias[prefix] || {})[alias];
}
function byOldName(name) {
  return _byOldName[name] || {
    prefix: null,
    iconName: null
  };
}
function byOldUnicode(unicode) {
  var oldUnicode = _byOldUnicode[unicode];
  var newUnicode = byUnicode('fas', unicode);
  return oldUnicode || (newUnicode ? {
    prefix: 'fas',
    iconName: newUnicode
  } : null) || {
    prefix: null,
    iconName: null
  };
}
function getDefaultUsablePrefix() {
  return _defaultUsablePrefix;
}
var emptyCanonicalIcon = function emptyCanonicalIcon() {
  return {
    prefix: null,
    iconName: null,
    rest: []
  };
};
function getCanonicalPrefix(styleOrPrefix) {
  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _params$family = params.family,
      family = _params$family === void 0 ? FAMILY_CLASSIC : _params$family;
  var style = PREFIX_TO_STYLE[family][styleOrPrefix];
  var prefix = STYLE_TO_PREFIX[family][styleOrPrefix] || STYLE_TO_PREFIX[family][style];
  var defined = styleOrPrefix in namespace.styles ? styleOrPrefix : null;
  return prefix || defined || null;
}
var PREFIXES_FOR_FAMILY = (_PREFIXES_FOR_FAMILY = {}, _defineProperty(_PREFIXES_FOR_FAMILY, FAMILY_CLASSIC, Object.keys(PREFIX_TO_LONG_STYLE[FAMILY_CLASSIC])), _defineProperty(_PREFIXES_FOR_FAMILY, FAMILY_SHARP, Object.keys(PREFIX_TO_LONG_STYLE[FAMILY_SHARP])), _PREFIXES_FOR_FAMILY);
function getCanonicalIcon(values) {
  var _famProps;

  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _params$skipLookups = params.skipLookups,
      skipLookups = _params$skipLookups === void 0 ? false : _params$skipLookups;
  var famProps = (_famProps = {}, _defineProperty(_famProps, FAMILY_CLASSIC, "".concat(config.cssPrefix, "-").concat(FAMILY_CLASSIC)), _defineProperty(_famProps, FAMILY_SHARP, "".concat(config.cssPrefix, "-").concat(FAMILY_SHARP)), _famProps);
  var givenPrefix = null;
  var family = FAMILY_CLASSIC;

  if (values.includes(famProps[FAMILY_CLASSIC]) || values.some(function (v) {
    return PREFIXES_FOR_FAMILY[FAMILY_CLASSIC].includes(v);
  })) {
    family = FAMILY_CLASSIC;
  }

  if (values.includes(famProps[FAMILY_SHARP]) || values.some(function (v) {
    return PREFIXES_FOR_FAMILY[FAMILY_SHARP].includes(v);
  })) {
    family = FAMILY_SHARP;
  }

  var canonical = values.reduce(function (acc, cls) {
    var iconName = getIconName(config.cssPrefix, cls);

    if (styles[cls]) {
      cls = LONG_STYLE[family].includes(cls) ? LONG_STYLE_TO_PREFIX[family][cls] : cls;
      givenPrefix = cls;
      acc.prefix = cls;
    } else if (PREFIXES[family].indexOf(cls) > -1) {
      givenPrefix = cls;
      acc.prefix = getCanonicalPrefix(cls, {
        family: family
      });
    } else if (iconName) {
      acc.iconName = iconName;
    } else if (cls !== config.replacementClass && cls !== famProps[FAMILY_CLASSIC] && cls !== famProps[FAMILY_SHARP]) {
      acc.rest.push(cls);
    }

    if (!skipLookups && acc.prefix && acc.iconName) {
      var shim = givenPrefix === 'fa' ? byOldName(acc.iconName) : {};
      var aliasIconName = byAlias(acc.prefix, acc.iconName);

      if (shim.prefix) {
        givenPrefix = null;
      }

      acc.iconName = shim.iconName || aliasIconName || acc.iconName;
      acc.prefix = shim.prefix || acc.prefix;

      if (acc.prefix === 'far' && !styles['far'] && styles['fas'] && !config.autoFetchSvg) {
        // Allow a fallback from the regular style to solid if regular is not available
        // but only if we aren't auto-fetching SVGs
        acc.prefix = 'fas';
      }
    }

    return acc;
  }, emptyCanonicalIcon());

  if (values.includes('fa-brands') || values.includes('fab')) {
    canonical.prefix = 'fab';
  }

  if (values.includes('fa-duotone') || values.includes('fad')) {
    canonical.prefix = 'fad';
  }

  if (!canonical.prefix && family === FAMILY_SHARP && (styles['fass'] || config.autoFetchSvg)) {
    canonical.prefix = 'fass';
    canonical.iconName = byAlias(canonical.prefix, canonical.iconName) || canonical.iconName;
  }

  if (canonical.prefix === 'fa' || givenPrefix === 'fa') {
    // The fa prefix is not canonical. So if it has made it through until this point
    // we will shift it to the correct prefix.
    canonical.prefix = getDefaultUsablePrefix() || 'fas';
  }

  return canonical;
}

var Library = /*#__PURE__*/function () {
  function Library() {
    _classCallCheck(this, Library);

    this.definitions = {};
  }

  _createClass(Library, [{
    key: "add",
    value: function add() {
      var _this = this;

      for (var _len = arguments.length, definitions = new Array(_len), _key = 0; _key < _len; _key++) {
        definitions[_key] = arguments[_key];
      }

      var additions = definitions.reduce(this._pullDefinitions, {});
      Object.keys(additions).forEach(function (key) {
        _this.definitions[key] = _objectSpread2(_objectSpread2({}, _this.definitions[key] || {}), additions[key]);
        defineIcons(key, additions[key]); // TODO can we stop doing this? We can't get the icons by 'fa-solid' any longer so this probably needs to change

        var longPrefix = PREFIX_TO_LONG_STYLE[FAMILY_CLASSIC][key];
        if (longPrefix) defineIcons(longPrefix, additions[key]);
        build();
      });
    }
  }, {
    key: "reset",
    value: function reset() {
      this.definitions = {};
    }
  }, {
    key: "_pullDefinitions",
    value: function _pullDefinitions(additions, definition) {
      var normalized = definition.prefix && definition.iconName && definition.icon ? {
        0: definition
      } : definition;
      Object.keys(normalized).map(function (key) {
        var _normalized$key = normalized[key],
            prefix = _normalized$key.prefix,
            iconName = _normalized$key.iconName,
            icon = _normalized$key.icon;
        var aliases = icon[2];
        if (!additions[prefix]) additions[prefix] = {};

        if (aliases.length > 0) {
          aliases.forEach(function (alias) {
            if (typeof alias === 'string') {
              additions[prefix][alias] = icon;
            }
          });
        }

        additions[prefix][iconName] = icon;
      });
      return additions;
    }
  }]);

  return Library;
}();

var _plugins = [];
var _hooks = {};
var providers = {};
var defaultProviderKeys = Object.keys(providers);
function registerPlugins(nextPlugins, _ref) {
  var obj = _ref.mixoutsTo;
  _plugins = nextPlugins;
  _hooks = {};
  Object.keys(providers).forEach(function (k) {
    if (defaultProviderKeys.indexOf(k) === -1) {
      delete providers[k];
    }
  });

  _plugins.forEach(function (plugin) {
    var mixout = plugin.mixout ? plugin.mixout() : {};
    Object.keys(mixout).forEach(function (tk) {
      if (typeof mixout[tk] === 'function') {
        obj[tk] = mixout[tk];
      }

      if (_typeof(mixout[tk]) === 'object') {
        Object.keys(mixout[tk]).forEach(function (sk) {
          if (!obj[tk]) {
            obj[tk] = {};
          }

          obj[tk][sk] = mixout[tk][sk];
        });
      }
    });

    if (plugin.hooks) {
      var hooks = plugin.hooks();
      Object.keys(hooks).forEach(function (hook) {
        if (!_hooks[hook]) {
          _hooks[hook] = [];
        }

        _hooks[hook].push(hooks[hook]);
      });
    }

    if (plugin.provides) {
      plugin.provides(providers);
    }
  });

  return obj;
}
function chainHooks(hook, accumulator) {
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }

  var hookFns = _hooks[hook] || [];
  hookFns.forEach(function (hookFn) {
    accumulator = hookFn.apply(null, [accumulator].concat(args)); // eslint-disable-line no-useless-call
  });
  return accumulator;
}
function callHooks(hook) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }

  var hookFns = _hooks[hook] || [];
  hookFns.forEach(function (hookFn) {
    hookFn.apply(null, args);
  });
  return undefined;
}
function callProvided() {
  var hook = arguments[0];
  var args = Array.prototype.slice.call(arguments, 1);
  return providers[hook] ? providers[hook].apply(null, args) : undefined;
}

function findIconDefinition(iconLookup) {
  if (iconLookup.prefix === 'fa') {
    iconLookup.prefix = 'fas';
  }

  var iconName = iconLookup.iconName;
  var prefix = iconLookup.prefix || getDefaultUsablePrefix();
  if (!iconName) return;
  iconName = byAlias(prefix, iconName) || iconName;
  return iconFromMapping(library.definitions, prefix, iconName) || iconFromMapping(namespace.styles, prefix, iconName);
}
var library = new Library();
var noAuto = function noAuto() {
  config.autoReplaceSvg = false;
  config.observeMutations = false;
  callHooks('noAuto');
};
var dom = {
  i2svg: function i2svg() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    if (IS_DOM) {
      callHooks('beforeI2svg', params);
      callProvided('pseudoElements2svg', params);
      return callProvided('i2svg', params);
    } else {
      return Promise.reject('Operation requires a DOM of some kind.');
    }
  },
  watch: function watch() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var autoReplaceSvgRoot = params.autoReplaceSvgRoot;

    if (config.autoReplaceSvg === false) {
      config.autoReplaceSvg = true;
    }

    config.observeMutations = true;
    domready(function () {
      autoReplace({
        autoReplaceSvgRoot: autoReplaceSvgRoot
      });
      callHooks('watch', params);
    });
  }
};
var parse = {
  icon: function icon(_icon) {
    if (_icon === null) {
      return null;
    }

    if (_typeof(_icon) === 'object' && _icon.prefix && _icon.iconName) {
      return {
        prefix: _icon.prefix,
        iconName: byAlias(_icon.prefix, _icon.iconName) || _icon.iconName
      };
    }

    if (Array.isArray(_icon) && _icon.length === 2) {
      var iconName = _icon[1].indexOf('fa-') === 0 ? _icon[1].slice(3) : _icon[1];
      var prefix = getCanonicalPrefix(_icon[0]);
      return {
        prefix: prefix,
        iconName: byAlias(prefix, iconName) || iconName
      };
    }

    if (typeof _icon === 'string' && (_icon.indexOf("".concat(config.cssPrefix, "-")) > -1 || _icon.match(ICON_SELECTION_SYNTAX_PATTERN))) {
      var canonicalIcon = getCanonicalIcon(_icon.split(' '), {
        skipLookups: true
      });
      return {
        prefix: canonicalIcon.prefix || getDefaultUsablePrefix(),
        iconName: byAlias(canonicalIcon.prefix, canonicalIcon.iconName) || canonicalIcon.iconName
      };
    }

    if (typeof _icon === 'string') {
      var _prefix = getDefaultUsablePrefix();

      return {
        prefix: _prefix,
        iconName: byAlias(_prefix, _icon) || _icon
      };
    }
  }
};
var api = {
  noAuto: noAuto,
  config: config,
  dom: dom,
  parse: parse,
  library: library,
  findIconDefinition: findIconDefinition,
  toHtml: toHtml
};

var autoReplace = function autoReplace() {
  var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var _params$autoReplaceSv = params.autoReplaceSvgRoot,
      autoReplaceSvgRoot = _params$autoReplaceSv === void 0 ? DOCUMENT : _params$autoReplaceSv;
  if ((Object.keys(namespace.styles).length > 0 || config.autoFetchSvg) && IS_DOM && config.autoReplaceSvg) api.dom.i2svg({
    node: autoReplaceSvgRoot
  });
};

function domVariants(val, abstractCreator) {
  Object.defineProperty(val, 'abstract', {
    get: abstractCreator
  });
  Object.defineProperty(val, 'html', {
    get: function get() {
      return val.abstract.map(function (a) {
        return toHtml(a);
      });
    }
  });
  Object.defineProperty(val, 'node', {
    get: function get() {
      if (!IS_DOM) return;
      var container = DOCUMENT.createElement('div');
      container.innerHTML = val.html;
      return container.children;
    }
  });
  return val;
}

function asIcon (_ref) {
  var children = _ref.children,
      main = _ref.main,
      mask = _ref.mask,
      attributes = _ref.attributes,
      styles = _ref.styles,
      transform = _ref.transform;

  if (transformIsMeaningful(transform) && main.found && !mask.found) {
    var width = main.width,
        height = main.height;
    var offset = {
      x: width / height / 2,
      y: 0.5
    };
    attributes['style'] = joinStyles(_objectSpread2(_objectSpread2({}, styles), {}, {
      'transform-origin': "".concat(offset.x + transform.x / 16, "em ").concat(offset.y + transform.y / 16, "em")
    }));
  }

  return [{
    tag: 'svg',
    attributes: attributes,
    children: children
  }];
}

function asSymbol (_ref) {
  var prefix = _ref.prefix,
      iconName = _ref.iconName,
      children = _ref.children,
      attributes = _ref.attributes,
      symbol = _ref.symbol;
  var id = symbol === true ? "".concat(prefix, "-").concat(config.cssPrefix, "-").concat(iconName) : symbol;
  return [{
    tag: 'svg',
    attributes: {
      style: 'display: none;'
    },
    children: [{
      tag: 'symbol',
      attributes: _objectSpread2(_objectSpread2({}, attributes), {}, {
        id: id
      }),
      children: children
    }]
  }];
}

function makeInlineSvgAbstract(params) {
  var _params$icons = params.icons,
      main = _params$icons.main,
      mask = _params$icons.mask,
      prefix = params.prefix,
      iconName = params.iconName,
      transform = params.transform,
      symbol = params.symbol,
      title = params.title,
      maskId = params.maskId,
      titleId = params.titleId,
      extra = params.extra,
      _params$watchable = params.watchable,
      watchable = _params$watchable === void 0 ? false : _params$watchable;

  var _ref = mask.found ? mask : main,
      width = _ref.width,
      height = _ref.height;

  var isUploadedIcon = prefix === 'fak';
  var attrClass = [config.replacementClass, iconName ? "".concat(config.cssPrefix, "-").concat(iconName) : ''].filter(function (c) {
    return extra.classes.indexOf(c) === -1;
  }).filter(function (c) {
    return c !== '' || !!c;
  }).concat(extra.classes).join(' ');
  var content = {
    children: [],
    attributes: _objectSpread2(_objectSpread2({}, extra.attributes), {}, {
      'data-prefix': prefix,
      'data-icon': iconName,
      'class': attrClass,
      'role': extra.attributes.role || 'img',
      'xmlns': 'http://www.w3.org/2000/svg',
      'viewBox': "0 0 ".concat(width, " ").concat(height)
    })
  };
  var uploadedIconWidthStyle = isUploadedIcon && !~extra.classes.indexOf('fa-fw') ? {
    width: "".concat(width / height * 16 * 0.0625, "em")
  } : {};

  if (watchable) {
    content.attributes[DATA_FA_I2SVG] = '';
  }

  if (title) {
    content.children.push({
      tag: 'title',
      attributes: {
        id: content.attributes['aria-labelledby'] || "title-".concat(titleId || nextUniqueId())
      },
      children: [title]
    });
    delete content.attributes.title;
  }

  var args = _objectSpread2(_objectSpread2({}, content), {}, {
    prefix: prefix,
    iconName: iconName,
    main: main,
    mask: mask,
    maskId: maskId,
    transform: transform,
    symbol: symbol,
    styles: _objectSpread2(_objectSpread2({}, uploadedIconWidthStyle), extra.styles)
  });

  var _ref2 = mask.found && main.found ? callProvided('generateAbstractMask', args) || {
    children: [],
    attributes: {}
  } : callProvided('generateAbstractIcon', args) || {
    children: [],
    attributes: {}
  },
      children = _ref2.children,
      attributes = _ref2.attributes;

  args.children = children;
  args.attributes = attributes;

  if (symbol) {
    return asSymbol(args);
  } else {
    return asIcon(args);
  }
}
function makeLayersTextAbstract(params) {
  var content = params.content,
      width = params.width,
      height = params.height,
      transform = params.transform,
      title = params.title,
      extra = params.extra,
      _params$watchable2 = params.watchable,
      watchable = _params$watchable2 === void 0 ? false : _params$watchable2;

  var attributes = _objectSpread2(_objectSpread2(_objectSpread2({}, extra.attributes), title ? {
    'title': title
  } : {}), {}, {
    'class': extra.classes.join(' ')
  });

  if (watchable) {
    attributes[DATA_FA_I2SVG] = '';
  }

  var styles = _objectSpread2({}, extra.styles);

  if (transformIsMeaningful(transform)) {
    styles['transform'] = transformForCss({
      transform: transform,
      startCentered: true,
      width: width,
      height: height
    });
    styles['-webkit-transform'] = styles['transform'];
  }

  var styleString = joinStyles(styles);

  if (styleString.length > 0) {
    attributes['style'] = styleString;
  }

  var val = [];
  val.push({
    tag: 'span',
    attributes: attributes,
    children: [content]
  });

  if (title) {
    val.push({
      tag: 'span',
      attributes: {
        class: 'sr-only'
      },
      children: [title]
    });
  }

  return val;
}
function makeLayersCounterAbstract(params) {
  var content = params.content,
      title = params.title,
      extra = params.extra;

  var attributes = _objectSpread2(_objectSpread2(_objectSpread2({}, extra.attributes), title ? {
    'title': title
  } : {}), {}, {
    'class': extra.classes.join(' ')
  });

  var styleString = joinStyles(extra.styles);

  if (styleString.length > 0) {
    attributes['style'] = styleString;
  }

  var val = [];
  val.push({
    tag: 'span',
    attributes: attributes,
    children: [content]
  });

  if (title) {
    val.push({
      tag: 'span',
      attributes: {
        class: 'sr-only'
      },
      children: [title]
    });
  }

  return val;
}

var styles$1 = namespace.styles;
function asFoundIcon(icon) {
  var width = icon[0];
  var height = icon[1];

  var _icon$slice = icon.slice(4),
      _icon$slice2 = _slicedToArray(_icon$slice, 1),
      vectorData = _icon$slice2[0];

  var element = null;

  if (Array.isArray(vectorData)) {
    element = {
      tag: 'g',
      attributes: {
        class: "".concat(config.cssPrefix, "-").concat(DUOTONE_CLASSES.GROUP)
      },
      children: [{
        tag: 'path',
        attributes: {
          class: "".concat(config.cssPrefix, "-").concat(DUOTONE_CLASSES.SECONDARY),
          fill: 'currentColor',
          d: vectorData[0]
        }
      }, {
        tag: 'path',
        attributes: {
          class: "".concat(config.cssPrefix, "-").concat(DUOTONE_CLASSES.PRIMARY),
          fill: 'currentColor',
          d: vectorData[1]
        }
      }]
    };
  } else {
    element = {
      tag: 'path',
      attributes: {
        fill: 'currentColor',
        d: vectorData
      }
    };
  }

  return {
    found: true,
    width: width,
    height: height,
    icon: element
  };
}
var missingIconResolutionMixin = {
  found: false,
  width: 512,
  height: 512
};

function maybeNotifyMissing(iconName, prefix) {
  if (!PRODUCTION && !config.showMissingIcons && iconName) {
    console.error("Icon with name \"".concat(iconName, "\" and prefix \"").concat(prefix, "\" is missing."));
  }
}

function findIcon(iconName, prefix) {
  var givenPrefix = prefix;

  if (prefix === 'fa' && config.styleDefault !== null) {
    prefix = getDefaultUsablePrefix();
  }

  return new Promise(function (resolve, reject) {
    var val = {
      found: false,
      width: 512,
      height: 512,
      icon: callProvided('missingIconAbstract') || {}
    };

    if (givenPrefix === 'fa') {
      var shim = byOldName(iconName) || {};
      iconName = shim.iconName || iconName;
      prefix = shim.prefix || prefix;
    }

    if (iconName && prefix && styles$1[prefix] && styles$1[prefix][iconName]) {
      var icon = styles$1[prefix][iconName];
      return resolve(asFoundIcon(icon));
    }

    maybeNotifyMissing(iconName, prefix);
    resolve(_objectSpread2(_objectSpread2({}, missingIconResolutionMixin), {}, {
      icon: config.showMissingIcons && iconName ? callProvided('missingIconAbstract') || {} : {}
    }));
  });
}

var noop$1 = function noop() {};

var p = config.measurePerformance && PERFORMANCE && PERFORMANCE.mark && PERFORMANCE.measure ? PERFORMANCE : {
  mark: noop$1,
  measure: noop$1
};
var preamble = "FA \"6.2.1\"";

var begin = function begin(name) {
  p.mark("".concat(preamble, " ").concat(name, " begins"));
  return function () {
    return end(name);
  };
};

var end = function end(name) {
  p.mark("".concat(preamble, " ").concat(name, " ends"));
  p.measure("".concat(preamble, " ").concat(name), "".concat(preamble, " ").concat(name, " begins"), "".concat(preamble, " ").concat(name, " ends"));
};

var perf = {
  begin: begin,
  end: end
};

var noop$2 = function noop() {};

function isWatched(node) {
  var i2svg = node.getAttribute ? node.getAttribute(DATA_FA_I2SVG) : null;
  return typeof i2svg === 'string';
}

function hasPrefixAndIcon(node) {
  var prefix = node.getAttribute ? node.getAttribute(DATA_PREFIX) : null;
  var icon = node.getAttribute ? node.getAttribute(DATA_ICON) : null;
  return prefix && icon;
}

function hasBeenReplaced(node) {
  return node && node.classList && node.classList.contains && node.classList.contains(config.replacementClass);
}

function getMutator() {
  if (config.autoReplaceSvg === true) {
    return mutators.replace;
  }

  var mutator = mutators[config.autoReplaceSvg];
  return mutator || mutators.replace;
}

function createElementNS(tag) {
  return DOCUMENT.createElementNS('http://www.w3.org/2000/svg', tag);
}

function createElement(tag) {
  return DOCUMENT.createElement(tag);
}

function convertSVG(abstractObj) {
  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _params$ceFn = params.ceFn,
      ceFn = _params$ceFn === void 0 ? abstractObj.tag === 'svg' ? createElementNS : createElement : _params$ceFn;

  if (typeof abstractObj === 'string') {
    return DOCUMENT.createTextNode(abstractObj);
  }

  var tag = ceFn(abstractObj.tag);
  Object.keys(abstractObj.attributes || []).forEach(function (key) {
    tag.setAttribute(key, abstractObj.attributes[key]);
  });
  var children = abstractObj.children || [];
  children.forEach(function (child) {
    tag.appendChild(convertSVG(child, {
      ceFn: ceFn
    }));
  });
  return tag;
}

function nodeAsComment(node) {
  var comment = " ".concat(node.outerHTML, " ");
  /* BEGIN.ATTRIBUTION */

  comment = "".concat(comment, "Font Awesome fontawesome.com ");
  /* END.ATTRIBUTION */

  return comment;
}

var mutators = {
  replace: function replace(mutation) {
    var node = mutation[0];

    if (node.parentNode) {
      mutation[1].forEach(function (abstract) {
        node.parentNode.insertBefore(convertSVG(abstract), node);
      });

      if (node.getAttribute(DATA_FA_I2SVG) === null && config.keepOriginalSource) {
        var comment = DOCUMENT.createComment(nodeAsComment(node));
        node.parentNode.replaceChild(comment, node);
      } else {
        node.remove();
      }
    }
  },
  nest: function nest(mutation) {
    var node = mutation[0];
    var abstract = mutation[1]; // If we already have a replaced node we do not want to continue nesting within it.
    // Short-circuit to the standard replacement

    if (~classArray(node).indexOf(config.replacementClass)) {
      return mutators.replace(mutation);
    }

    var forSvg = new RegExp("".concat(config.cssPrefix, "-.*"));
    delete abstract[0].attributes.id;

    if (abstract[0].attributes.class) {
      var splitClasses = abstract[0].attributes.class.split(' ').reduce(function (acc, cls) {
        if (cls === config.replacementClass || cls.match(forSvg)) {
          acc.toSvg.push(cls);
        } else {
          acc.toNode.push(cls);
        }

        return acc;
      }, {
        toNode: [],
        toSvg: []
      });
      abstract[0].attributes.class = splitClasses.toSvg.join(' ');

      if (splitClasses.toNode.length === 0) {
        node.removeAttribute('class');
      } else {
        node.setAttribute('class', splitClasses.toNode.join(' '));
      }
    }

    var newInnerHTML = abstract.map(function (a) {
      return toHtml(a);
    }).join('\n');
    node.setAttribute(DATA_FA_I2SVG, '');
    node.innerHTML = newInnerHTML;
  }
};

function performOperationSync(op) {
  op();
}

function perform(mutations, callback) {
  var callbackFunction = typeof callback === 'function' ? callback : noop$2;

  if (mutations.length === 0) {
    callbackFunction();
  } else {
    var frame = performOperationSync;

    if (config.mutateApproach === MUTATION_APPROACH_ASYNC) {
      frame = WINDOW.requestAnimationFrame || performOperationSync;
    }

    frame(function () {
      var mutator = getMutator();
      var mark = perf.begin('mutate');
      mutations.map(mutator);
      mark();
      callbackFunction();
    });
  }
}
var disabled = false;
function disableObservation() {
  disabled = true;
}
function enableObservation() {
  disabled = false;
}
var mo = null;
function observe(options) {
  if (!MUTATION_OBSERVER) {
    return;
  }

  if (!config.observeMutations) {
    return;
  }

  var _options$treeCallback = options.treeCallback,
      treeCallback = _options$treeCallback === void 0 ? noop$2 : _options$treeCallback,
      _options$nodeCallback = options.nodeCallback,
      nodeCallback = _options$nodeCallback === void 0 ? noop$2 : _options$nodeCallback,
      _options$pseudoElemen = options.pseudoElementsCallback,
      pseudoElementsCallback = _options$pseudoElemen === void 0 ? noop$2 : _options$pseudoElemen,
      _options$observeMutat = options.observeMutationsRoot,
      observeMutationsRoot = _options$observeMutat === void 0 ? DOCUMENT : _options$observeMutat;
  mo = new MUTATION_OBSERVER(function (objects) {
    if (disabled) return;
    var defaultPrefix = getDefaultUsablePrefix();
    toArray(objects).forEach(function (mutationRecord) {
      if (mutationRecord.type === 'childList' && mutationRecord.addedNodes.length > 0 && !isWatched(mutationRecord.addedNodes[0])) {
        if (config.searchPseudoElements) {
          pseudoElementsCallback(mutationRecord.target);
        }

        treeCallback(mutationRecord.target);
      }

      if (mutationRecord.type === 'attributes' && mutationRecord.target.parentNode && config.searchPseudoElements) {
        pseudoElementsCallback(mutationRecord.target.parentNode);
      }

      if (mutationRecord.type === 'attributes' && isWatched(mutationRecord.target) && ~ATTRIBUTES_WATCHED_FOR_MUTATION.indexOf(mutationRecord.attributeName)) {
        if (mutationRecord.attributeName === 'class' && hasPrefixAndIcon(mutationRecord.target)) {
          var _getCanonicalIcon = getCanonicalIcon(classArray(mutationRecord.target)),
              prefix = _getCanonicalIcon.prefix,
              iconName = _getCanonicalIcon.iconName;

          mutationRecord.target.setAttribute(DATA_PREFIX, prefix || defaultPrefix);
          if (iconName) mutationRecord.target.setAttribute(DATA_ICON, iconName);
        } else if (hasBeenReplaced(mutationRecord.target)) {
          nodeCallback(mutationRecord.target);
        }
      }
    });
  });
  if (!IS_DOM) return;
  mo.observe(observeMutationsRoot, {
    childList: true,
    attributes: true,
    characterData: true,
    subtree: true
  });
}
function disconnect() {
  if (!mo) return;
  mo.disconnect();
}

function styleParser (node) {
  var style = node.getAttribute('style');
  var val = [];

  if (style) {
    val = style.split(';').reduce(function (acc, style) {
      var styles = style.split(':');
      var prop = styles[0];
      var value = styles.slice(1);

      if (prop && value.length > 0) {
        acc[prop] = value.join(':').trim();
      }

      return acc;
    }, {});
  }

  return val;
}

function classParser (node) {
  var existingPrefix = node.getAttribute('data-prefix');
  var existingIconName = node.getAttribute('data-icon');
  var innerText = node.innerText !== undefined ? node.innerText.trim() : '';
  var val = getCanonicalIcon(classArray(node));

  if (!val.prefix) {
    val.prefix = getDefaultUsablePrefix();
  }

  if (existingPrefix && existingIconName) {
    val.prefix = existingPrefix;
    val.iconName = existingIconName;
  }

  if (val.iconName && val.prefix) {
    return val;
  }

  if (val.prefix && innerText.length > 0) {
    val.iconName = byLigature(val.prefix, node.innerText) || byUnicode(val.prefix, toHex(node.innerText));
  }

  if (!val.iconName && config.autoFetchSvg && node.firstChild && node.firstChild.nodeType === Node.TEXT_NODE) {
    val.iconName = node.firstChild.data;
  }

  return val;
}

function attributesParser (node) {
  var extraAttributes = toArray(node.attributes).reduce(function (acc, attr) {
    if (acc.name !== 'class' && acc.name !== 'style') {
      acc[attr.name] = attr.value;
    }

    return acc;
  }, {});
  var title = node.getAttribute('title');
  var titleId = node.getAttribute('data-fa-title-id');

  if (config.autoA11y) {
    if (title) {
      extraAttributes['aria-labelledby'] = "".concat(config.replacementClass, "-title-").concat(titleId || nextUniqueId());
    } else {
      extraAttributes['aria-hidden'] = 'true';
      extraAttributes['focusable'] = 'false';
    }
  }

  return extraAttributes;
}

function blankMeta() {
  return {
    iconName: null,
    title: null,
    titleId: null,
    prefix: null,
    transform: meaninglessTransform,
    symbol: false,
    mask: {
      iconName: null,
      prefix: null,
      rest: []
    },
    maskId: null,
    extra: {
      classes: [],
      styles: {},
      attributes: {}
    }
  };
}
function parseMeta(node) {
  var parser = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    styleParser: true
  };

  var _classParser = classParser(node),
      iconName = _classParser.iconName,
      prefix = _classParser.prefix,
      extraClasses = _classParser.rest;

  var extraAttributes = attributesParser(node);
  var pluginMeta = chainHooks('parseNodeAttributes', {}, node);
  var extraStyles = parser.styleParser ? styleParser(node) : [];
  return _objectSpread2({
    iconName: iconName,
    title: node.getAttribute('title'),
    titleId: node.getAttribute('data-fa-title-id'),
    prefix: prefix,
    transform: meaninglessTransform,
    mask: {
      iconName: null,
      prefix: null,
      rest: []
    },
    maskId: null,
    symbol: false,
    extra: {
      classes: extraClasses,
      styles: extraStyles,
      attributes: extraAttributes
    }
  }, pluginMeta);
}

var styles$2 = namespace.styles;

function generateMutation(node) {
  var nodeMeta = config.autoReplaceSvg === 'nest' ? parseMeta(node, {
    styleParser: false
  }) : parseMeta(node);

  if (~nodeMeta.extra.classes.indexOf(LAYERS_TEXT_CLASSNAME)) {
    return callProvided('generateLayersText', node, nodeMeta);
  } else {
    return callProvided('generateSvgReplacementMutation', node, nodeMeta);
  }
}

var knownPrefixes = new Set();
FAMILIES.map(function (family) {
  knownPrefixes.add("fa-".concat(family));
});
Object.keys(PREFIX_TO_STYLE[FAMILY_CLASSIC]).map(knownPrefixes.add.bind(knownPrefixes));
Object.keys(PREFIX_TO_STYLE[FAMILY_SHARP]).map(knownPrefixes.add.bind(knownPrefixes));
knownPrefixes = _toConsumableArray(knownPrefixes);

function onTree(root) {
  var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  if (!IS_DOM) return Promise.resolve();
  var htmlClassList = DOCUMENT.documentElement.classList;

  var hclAdd = function hclAdd(suffix) {
    return htmlClassList.add("".concat(HTML_CLASS_I2SVG_BASE_CLASS, "-").concat(suffix));
  };

  var hclRemove = function hclRemove(suffix) {
    return htmlClassList.remove("".concat(HTML_CLASS_I2SVG_BASE_CLASS, "-").concat(suffix));
  };

  var prefixes = config.autoFetchSvg ? knownPrefixes : FAMILIES.map(function (f) {
    return "fa-".concat(f);
  }).concat(Object.keys(styles$2));

  if (!prefixes.includes('fa')) {
    prefixes.push('fa');
  }

  var prefixesDomQuery = [".".concat(LAYERS_TEXT_CLASSNAME, ":not([").concat(DATA_FA_I2SVG, "])")].concat(prefixes.map(function (p) {
    return ".".concat(p, ":not([").concat(DATA_FA_I2SVG, "])");
  })).join(', ');

  if (prefixesDomQuery.length === 0) {
    return Promise.resolve();
  }

  var candidates = [];

  try {
    candidates = toArray(root.querySelectorAll(prefixesDomQuery));
  } catch (e) {// noop
  }

  if (candidates.length > 0) {
    hclAdd('pending');
    hclRemove('complete');
  } else {
    return Promise.resolve();
  }

  var mark = perf.begin('onTree');
  var mutations = candidates.reduce(function (acc, node) {
    try {
      var mutation = generateMutation(node);

      if (mutation) {
        acc.push(mutation);
      }
    } catch (e) {
      if (!PRODUCTION) {
        if (e.name === 'MissingIcon') {
          console.error(e);
        }
      }
    }

    return acc;
  }, []);
  return new Promise(function (resolve, reject) {
    Promise.all(mutations).then(function (resolvedMutations) {
      perform(resolvedMutations, function () {
        hclAdd('active');
        hclAdd('complete');
        hclRemove('pending');
        if (typeof callback === 'function') callback();
        mark();
        resolve();
      });
    }).catch(function (e) {
      mark();
      reject(e);
    });
  });
}

function onNode(node) {
  var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  generateMutation(node).then(function (mutation) {
    if (mutation) {
      perform([mutation], callback);
    }
  });
}

function resolveIcons(next) {
  return function (maybeIconDefinition) {
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var iconDefinition = (maybeIconDefinition || {}).icon ? maybeIconDefinition : findIconDefinition(maybeIconDefinition || {});
    var mask = params.mask;

    if (mask) {
      mask = (mask || {}).icon ? mask : findIconDefinition(mask || {});
    }

    return next(iconDefinition, _objectSpread2(_objectSpread2({}, params), {}, {
      mask: mask
    }));
  };
}

var render = function render(iconDefinition) {
  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _params$transform = params.transform,
      transform = _params$transform === void 0 ? meaninglessTransform : _params$transform,
      _params$symbol = params.symbol,
      symbol = _params$symbol === void 0 ? false : _params$symbol,
      _params$mask = params.mask,
      mask = _params$mask === void 0 ? null : _params$mask,
      _params$maskId = params.maskId,
      maskId = _params$maskId === void 0 ? null : _params$maskId,
      _params$title = params.title,
      title = _params$title === void 0 ? null : _params$title,
      _params$titleId = params.titleId,
      titleId = _params$titleId === void 0 ? null : _params$titleId,
      _params$classes = params.classes,
      classes = _params$classes === void 0 ? [] : _params$classes,
      _params$attributes = params.attributes,
      attributes = _params$attributes === void 0 ? {} : _params$attributes,
      _params$styles = params.styles,
      styles = _params$styles === void 0 ? {} : _params$styles;
  if (!iconDefinition) return;
  var prefix = iconDefinition.prefix,
      iconName = iconDefinition.iconName,
      icon = iconDefinition.icon;
  return domVariants(_objectSpread2({
    type: 'icon'
  }, iconDefinition), function () {
    callHooks('beforeDOMElementCreation', {
      iconDefinition: iconDefinition,
      params: params
    });

    if (config.autoA11y) {
      if (title) {
        attributes['aria-labelledby'] = "".concat(config.replacementClass, "-title-").concat(titleId || nextUniqueId());
      } else {
        attributes['aria-hidden'] = 'true';
        attributes['focusable'] = 'false';
      }
    }

    return makeInlineSvgAbstract({
      icons: {
        main: asFoundIcon(icon),
        mask: mask ? asFoundIcon(mask.icon) : {
          found: false,
          width: null,
          height: null,
          icon: {}
        }
      },
      prefix: prefix,
      iconName: iconName,
      transform: _objectSpread2(_objectSpread2({}, meaninglessTransform), transform),
      symbol: symbol,
      title: title,
      maskId: maskId,
      titleId: titleId,
      extra: {
        attributes: attributes,
        styles: styles,
        classes: classes
      }
    });
  });
};
var ReplaceElements = {
  mixout: function mixout() {
    return {
      icon: resolveIcons(render)
    };
  },
  hooks: function hooks() {
    return {
      mutationObserverCallbacks: function mutationObserverCallbacks(accumulator) {
        accumulator.treeCallback = onTree;
        accumulator.nodeCallback = onNode;
        return accumulator;
      }
    };
  },
  provides: function provides(providers$$1) {
    providers$$1.i2svg = function (params) {
      var _params$node = params.node,
          node = _params$node === void 0 ? DOCUMENT : _params$node,
          _params$callback = params.callback,
          callback = _params$callback === void 0 ? function () {} : _params$callback;
      return onTree(node, callback);
    };

    providers$$1.generateSvgReplacementMutation = function (node, nodeMeta) {
      var iconName = nodeMeta.iconName,
          title = nodeMeta.title,
          titleId = nodeMeta.titleId,
          prefix = nodeMeta.prefix,
          transform = nodeMeta.transform,
          symbol = nodeMeta.symbol,
          mask = nodeMeta.mask,
          maskId = nodeMeta.maskId,
          extra = nodeMeta.extra;
      return new Promise(function (resolve, reject) {
        Promise.all([findIcon(iconName, prefix), mask.iconName ? findIcon(mask.iconName, mask.prefix) : Promise.resolve({
          found: false,
          width: 512,
          height: 512,
          icon: {}
        })]).then(function (_ref) {
          var _ref2 = _slicedToArray(_ref, 2),
              main = _ref2[0],
              mask = _ref2[1];

          resolve([node, makeInlineSvgAbstract({
            icons: {
              main: main,
              mask: mask
            },
            prefix: prefix,
            iconName: iconName,
            transform: transform,
            symbol: symbol,
            maskId: maskId,
            title: title,
            titleId: titleId,
            extra: extra,
            watchable: true
          })]);
        }).catch(reject);
      });
    };

    providers$$1.generateAbstractIcon = function (_ref3) {
      var children = _ref3.children,
          attributes = _ref3.attributes,
          main = _ref3.main,
          transform = _ref3.transform,
          styles = _ref3.styles;
      var styleString = joinStyles(styles);

      if (styleString.length > 0) {
        attributes['style'] = styleString;
      }

      var nextChild;

      if (transformIsMeaningful(transform)) {
        nextChild = callProvided('generateAbstractTransformGrouping', {
          main: main,
          transform: transform,
          containerWidth: main.width,
          iconWidth: main.width
        });
      }

      children.push(nextChild || main.icon);
      return {
        children: children,
        attributes: attributes
      };
    };
  }
};

var Layers = {
  mixout: function mixout() {
    return {
      layer: function layer(assembler) {
        var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var _params$classes = params.classes,
            classes = _params$classes === void 0 ? [] : _params$classes;
        return domVariants({
          type: 'layer'
        }, function () {
          callHooks('beforeDOMElementCreation', {
            assembler: assembler,
            params: params
          });
          var children = [];
          assembler(function (args) {
            Array.isArray(args) ? args.map(function (a) {
              children = children.concat(a.abstract);
            }) : children = children.concat(args.abstract);
          });
          return [{
            tag: 'span',
            attributes: {
              class: ["".concat(config.cssPrefix, "-layers")].concat(_toConsumableArray(classes)).join(' ')
            },
            children: children
          }];
        });
      }
    };
  }
};

var LayersCounter = {
  mixout: function mixout() {
    return {
      counter: function counter(content) {
        var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var _params$title = params.title,
            title = _params$title === void 0 ? null : _params$title,
            _params$classes = params.classes,
            classes = _params$classes === void 0 ? [] : _params$classes,
            _params$attributes = params.attributes,
            attributes = _params$attributes === void 0 ? {} : _params$attributes,
            _params$styles = params.styles,
            styles = _params$styles === void 0 ? {} : _params$styles;
        return domVariants({
          type: 'counter',
          content: content
        }, function () {
          callHooks('beforeDOMElementCreation', {
            content: content,
            params: params
          });
          return makeLayersCounterAbstract({
            content: content.toString(),
            title: title,
            extra: {
              attributes: attributes,
              styles: styles,
              classes: ["".concat(config.cssPrefix, "-layers-counter")].concat(_toConsumableArray(classes))
            }
          });
        });
      }
    };
  }
};

var LayersText = {
  mixout: function mixout() {
    return {
      text: function text(content) {
        var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var _params$transform = params.transform,
            transform = _params$transform === void 0 ? meaninglessTransform : _params$transform,
            _params$title = params.title,
            title = _params$title === void 0 ? null : _params$title,
            _params$classes = params.classes,
            classes = _params$classes === void 0 ? [] : _params$classes,
            _params$attributes = params.attributes,
            attributes = _params$attributes === void 0 ? {} : _params$attributes,
            _params$styles = params.styles,
            styles = _params$styles === void 0 ? {} : _params$styles;
        return domVariants({
          type: 'text',
          content: content
        }, function () {
          callHooks('beforeDOMElementCreation', {
            content: content,
            params: params
          });
          return makeLayersTextAbstract({
            content: content,
            transform: _objectSpread2(_objectSpread2({}, meaninglessTransform), transform),
            title: title,
            extra: {
              attributes: attributes,
              styles: styles,
              classes: ["".concat(config.cssPrefix, "-layers-text")].concat(_toConsumableArray(classes))
            }
          });
        });
      }
    };
  },
  provides: function provides(providers$$1) {
    providers$$1.generateLayersText = function (node, nodeMeta) {
      var title = nodeMeta.title,
          transform = nodeMeta.transform,
          extra = nodeMeta.extra;
      var width = null;
      var height = null;

      if (IS_IE) {
        var computedFontSize = parseInt(getComputedStyle(node).fontSize, 10);
        var boundingClientRect = node.getBoundingClientRect();
        width = boundingClientRect.width / computedFontSize;
        height = boundingClientRect.height / computedFontSize;
      }

      if (config.autoA11y && !title) {
        extra.attributes['aria-hidden'] = 'true';
      }

      return Promise.resolve([node, makeLayersTextAbstract({
        content: node.innerHTML,
        width: width,
        height: height,
        transform: transform,
        title: title,
        extra: extra,
        watchable: true
      })]);
    };
  }
};

var CLEAN_CONTENT_PATTERN = new RegExp("\"", 'ug');
var SECONDARY_UNICODE_RANGE = [1105920, 1112319];
function hexValueFromContent(content) {
  var cleaned = content.replace(CLEAN_CONTENT_PATTERN, '');
  var codePoint = codePointAt(cleaned, 0);
  var isPrependTen = codePoint >= SECONDARY_UNICODE_RANGE[0] && codePoint <= SECONDARY_UNICODE_RANGE[1];
  var isDoubled = cleaned.length === 2 ? cleaned[0] === cleaned[1] : false;
  return {
    value: isDoubled ? toHex(cleaned[0]) : toHex(cleaned),
    isSecondary: isPrependTen || isDoubled
  };
}

function replaceForPosition(node, position) {
  var pendingAttribute = "".concat(DATA_FA_PSEUDO_ELEMENT_PENDING).concat(position.replace(':', '-'));
  return new Promise(function (resolve, reject) {
    if (node.getAttribute(pendingAttribute) !== null) {
      // This node is already being processed
      return resolve();
    }

    var children = toArray(node.children);
    var alreadyProcessedPseudoElement = children.filter(function (c) {
      return c.getAttribute(DATA_FA_PSEUDO_ELEMENT) === position;
    })[0];
    var styles = WINDOW.getComputedStyle(node, position);
    var fontFamily = styles.getPropertyValue('font-family').match(FONT_FAMILY_PATTERN);
    var fontWeight = styles.getPropertyValue('font-weight');
    var content = styles.getPropertyValue('content');

    if (alreadyProcessedPseudoElement && !fontFamily) {
      // If we've already processed it but the current computed style does not result in a font-family,
      // that probably means that a class name that was previously present to make the icon has been
      // removed. So we now should delete the icon.
      node.removeChild(alreadyProcessedPseudoElement);
      return resolve();
    } else if (fontFamily && content !== 'none' && content !== '') {
      var _content = styles.getPropertyValue('content');

      var family = ~['Sharp'].indexOf(fontFamily[2]) ? FAMILY_SHARP : FAMILY_CLASSIC;
      var prefix = ~['Solid', 'Regular', 'Light', 'Thin', 'Duotone', 'Brands', 'Kit'].indexOf(fontFamily[2]) ? STYLE_TO_PREFIX[family][fontFamily[2].toLowerCase()] : FONT_WEIGHT_TO_PREFIX[family][fontWeight];

      var _hexValueFromContent = hexValueFromContent(_content),
          hexValue = _hexValueFromContent.value,
          isSecondary = _hexValueFromContent.isSecondary;

      var isV4 = fontFamily[0].startsWith('FontAwesome');
      var iconName = byUnicode(prefix, hexValue);
      var iconIdentifier = iconName;

      if (isV4) {
        var iconName4 = byOldUnicode(hexValue);

        if (iconName4.iconName && iconName4.prefix) {
          iconName = iconName4.iconName;
          prefix = iconName4.prefix;
        }
      } // Only convert the pseudo element in this ::before/::after position into an icon if we haven't
      // already done so with the same prefix and iconName


      if (iconName && !isSecondary && (!alreadyProcessedPseudoElement || alreadyProcessedPseudoElement.getAttribute(DATA_PREFIX) !== prefix || alreadyProcessedPseudoElement.getAttribute(DATA_ICON) !== iconIdentifier)) {
        node.setAttribute(pendingAttribute, iconIdentifier);

        if (alreadyProcessedPseudoElement) {
          // Delete the old one, since we're replacing it with a new one
          node.removeChild(alreadyProcessedPseudoElement);
        }

        var meta = blankMeta();
        var extra = meta.extra;
        extra.attributes[DATA_FA_PSEUDO_ELEMENT] = position;
        findIcon(iconName, prefix).then(function (main) {
          var abstract = makeInlineSvgAbstract(_objectSpread2(_objectSpread2({}, meta), {}, {
            icons: {
              main: main,
              mask: emptyCanonicalIcon()
            },
            prefix: prefix,
            iconName: iconIdentifier,
            extra: extra,
            watchable: true
          }));
          var element = DOCUMENT.createElement('svg');

          if (position === '::before') {
            node.insertBefore(element, node.firstChild);
          } else {
            node.appendChild(element);
          }

          element.outerHTML = abstract.map(function (a) {
            return toHtml(a);
          }).join('\n');
          node.removeAttribute(pendingAttribute);
          resolve();
        }).catch(reject);
      } else {
        resolve();
      }
    } else {
      resolve();
    }
  });
}

function replace(node) {
  return Promise.all([replaceForPosition(node, '::before'), replaceForPosition(node, '::after')]);
}

function processable(node) {
  return node.parentNode !== document.head && !~TAGNAMES_TO_SKIP_FOR_PSEUDOELEMENTS.indexOf(node.tagName.toUpperCase()) && !node.getAttribute(DATA_FA_PSEUDO_ELEMENT) && (!node.parentNode || node.parentNode.tagName !== 'svg');
}

function searchPseudoElements(root) {
  if (!IS_DOM) return;
  return new Promise(function (resolve, reject) {
    var operations = toArray(root.querySelectorAll('*')).filter(processable).map(replace);
    var end = perf.begin('searchPseudoElements');
    disableObservation();
    Promise.all(operations).then(function () {
      end();
      enableObservation();
      resolve();
    }).catch(function () {
      end();
      enableObservation();
      reject();
    });
  });
}

var PseudoElements = {
  hooks: function hooks() {
    return {
      mutationObserverCallbacks: function mutationObserverCallbacks(accumulator) {
        accumulator.pseudoElementsCallback = searchPseudoElements;
        return accumulator;
      }
    };
  },
  provides: function provides(providers$$1) {
    providers$$1.pseudoElements2svg = function (params) {
      var _params$node = params.node,
          node = _params$node === void 0 ? DOCUMENT : _params$node;

      if (config.searchPseudoElements) {
        searchPseudoElements(node);
      }
    };
  }
};

var _unwatched = false;
var MutationObserver$1 = {
  mixout: function mixout() {
    return {
      dom: {
        unwatch: function unwatch() {
          disableObservation();
          _unwatched = true;
        }
      }
    };
  },
  hooks: function hooks() {
    return {
      bootstrap: function bootstrap() {
        observe(chainHooks('mutationObserverCallbacks', {}));
      },
      noAuto: function noAuto() {
        disconnect();
      },
      watch: function watch(params) {
        var observeMutationsRoot = params.observeMutationsRoot;

        if (_unwatched) {
          enableObservation();
        } else {
          observe(chainHooks('mutationObserverCallbacks', {
            observeMutationsRoot: observeMutationsRoot
          }));
        }
      }
    };
  }
};

var parseTransformString = function parseTransformString(transformString) {
  var transform = {
    size: 16,
    x: 0,
    y: 0,
    flipX: false,
    flipY: false,
    rotate: 0
  };
  return transformString.toLowerCase().split(' ').reduce(function (acc, n) {
    var parts = n.toLowerCase().split('-');
    var first = parts[0];
    var rest = parts.slice(1).join('-');

    if (first && rest === 'h') {
      acc.flipX = true;
      return acc;
    }

    if (first && rest === 'v') {
      acc.flipY = true;
      return acc;
    }

    rest = parseFloat(rest);

    if (isNaN(rest)) {
      return acc;
    }

    switch (first) {
      case 'grow':
        acc.size = acc.size + rest;
        break;

      case 'shrink':
        acc.size = acc.size - rest;
        break;

      case 'left':
        acc.x = acc.x - rest;
        break;

      case 'right':
        acc.x = acc.x + rest;
        break;

      case 'up':
        acc.y = acc.y - rest;
        break;

      case 'down':
        acc.y = acc.y + rest;
        break;

      case 'rotate':
        acc.rotate = acc.rotate + rest;
        break;
    }

    return acc;
  }, transform);
};
var PowerTransforms = {
  mixout: function mixout() {
    return {
      parse: {
        transform: function transform(transformString) {
          return parseTransformString(transformString);
        }
      }
    };
  },
  hooks: function hooks() {
    return {
      parseNodeAttributes: function parseNodeAttributes(accumulator, node) {
        var transformString = node.getAttribute('data-fa-transform');

        if (transformString) {
          accumulator.transform = parseTransformString(transformString);
        }

        return accumulator;
      }
    };
  },
  provides: function provides(providers) {
    providers.generateAbstractTransformGrouping = function (_ref) {
      var main = _ref.main,
          transform = _ref.transform,
          containerWidth = _ref.containerWidth,
          iconWidth = _ref.iconWidth;
      var outer = {
        transform: "translate(".concat(containerWidth / 2, " 256)")
      };
      var innerTranslate = "translate(".concat(transform.x * 32, ", ").concat(transform.y * 32, ") ");
      var innerScale = "scale(".concat(transform.size / 16 * (transform.flipX ? -1 : 1), ", ").concat(transform.size / 16 * (transform.flipY ? -1 : 1), ") ");
      var innerRotate = "rotate(".concat(transform.rotate, " 0 0)");
      var inner = {
        transform: "".concat(innerTranslate, " ").concat(innerScale, " ").concat(innerRotate)
      };
      var path = {
        transform: "translate(".concat(iconWidth / 2 * -1, " -256)")
      };
      var operations = {
        outer: outer,
        inner: inner,
        path: path
      };
      return {
        tag: 'g',
        attributes: _objectSpread2({}, operations.outer),
        children: [{
          tag: 'g',
          attributes: _objectSpread2({}, operations.inner),
          children: [{
            tag: main.icon.tag,
            children: main.icon.children,
            attributes: _objectSpread2(_objectSpread2({}, main.icon.attributes), operations.path)
          }]
        }]
      };
    };
  }
};

var ALL_SPACE = {
  x: 0,
  y: 0,
  width: '100%',
  height: '100%'
};

function fillBlack(abstract) {
  var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  if (abstract.attributes && (abstract.attributes.fill || force)) {
    abstract.attributes.fill = 'black';
  }

  return abstract;
}

function deGroup(abstract) {
  if (abstract.tag === 'g') {
    return abstract.children;
  } else {
    return [abstract];
  }
}

var Masks = {
  hooks: function hooks() {
    return {
      parseNodeAttributes: function parseNodeAttributes(accumulator, node) {
        var maskData = node.getAttribute('data-fa-mask');
        var mask = !maskData ? emptyCanonicalIcon() : getCanonicalIcon(maskData.split(' ').map(function (i) {
          return i.trim();
        }));

        if (!mask.prefix) {
          mask.prefix = getDefaultUsablePrefix();
        }

        accumulator.mask = mask;
        accumulator.maskId = node.getAttribute('data-fa-mask-id');
        return accumulator;
      }
    };
  },
  provides: function provides(providers) {
    providers.generateAbstractMask = function (_ref) {
      var children = _ref.children,
          attributes = _ref.attributes,
          main = _ref.main,
          mask = _ref.mask,
          explicitMaskId = _ref.maskId,
          transform = _ref.transform;
      var mainWidth = main.width,
          mainPath = main.icon;
      var maskWidth = mask.width,
          maskPath = mask.icon;
      var trans = transformForSvg({
        transform: transform,
        containerWidth: maskWidth,
        iconWidth: mainWidth
      });
      var maskRect = {
        tag: 'rect',
        attributes: _objectSpread2(_objectSpread2({}, ALL_SPACE), {}, {
          fill: 'white'
        })
      };
      var maskInnerGroupChildrenMixin = mainPath.children ? {
        children: mainPath.children.map(fillBlack)
      } : {};
      var maskInnerGroup = {
        tag: 'g',
        attributes: _objectSpread2({}, trans.inner),
        children: [fillBlack(_objectSpread2({
          tag: mainPath.tag,
          attributes: _objectSpread2(_objectSpread2({}, mainPath.attributes), trans.path)
        }, maskInnerGroupChildrenMixin))]
      };
      var maskOuterGroup = {
        tag: 'g',
        attributes: _objectSpread2({}, trans.outer),
        children: [maskInnerGroup]
      };
      var maskId = "mask-".concat(explicitMaskId || nextUniqueId());
      var clipId = "clip-".concat(explicitMaskId || nextUniqueId());
      var maskTag = {
        tag: 'mask',
        attributes: _objectSpread2(_objectSpread2({}, ALL_SPACE), {}, {
          id: maskId,
          maskUnits: 'userSpaceOnUse',
          maskContentUnits: 'userSpaceOnUse'
        }),
        children: [maskRect, maskOuterGroup]
      };
      var defs = {
        tag: 'defs',
        children: [{
          tag: 'clipPath',
          attributes: {
            id: clipId
          },
          children: deGroup(maskPath)
        }, maskTag]
      };
      children.push(defs, {
        tag: 'rect',
        attributes: _objectSpread2({
          fill: 'currentColor',
          'clip-path': "url(#".concat(clipId, ")"),
          mask: "url(#".concat(maskId, ")")
        }, ALL_SPACE)
      });
      return {
        children: children,
        attributes: attributes
      };
    };
  }
};

var MissingIconIndicator = {
  provides: function provides(providers) {
    var reduceMotion = false;

    if (WINDOW.matchMedia) {
      reduceMotion = WINDOW.matchMedia('(prefers-reduced-motion: reduce)').matches;
    }

    providers.missingIconAbstract = function () {
      var gChildren = [];
      var FILL = {
        fill: 'currentColor'
      };
      var ANIMATION_BASE = {
        attributeType: 'XML',
        repeatCount: 'indefinite',
        dur: '2s'
      }; // Ring

      gChildren.push({
        tag: 'path',
        attributes: _objectSpread2(_objectSpread2({}, FILL), {}, {
          d: 'M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z'
        })
      });

      var OPACITY_ANIMATE = _objectSpread2(_objectSpread2({}, ANIMATION_BASE), {}, {
        attributeName: 'opacity'
      });

      var dot = {
        tag: 'circle',
        attributes: _objectSpread2(_objectSpread2({}, FILL), {}, {
          cx: '256',
          cy: '364',
          r: '28'
        }),
        children: []
      };

      if (!reduceMotion) {
        dot.children.push({
          tag: 'animate',
          attributes: _objectSpread2(_objectSpread2({}, ANIMATION_BASE), {}, {
            attributeName: 'r',
            values: '28;14;28;28;14;28;'
          })
        }, {
          tag: 'animate',
          attributes: _objectSpread2(_objectSpread2({}, OPACITY_ANIMATE), {}, {
            values: '1;0;1;1;0;1;'
          })
        });
      }

      gChildren.push(dot);
      gChildren.push({
        tag: 'path',
        attributes: _objectSpread2(_objectSpread2({}, FILL), {}, {
          opacity: '1',
          d: 'M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z'
        }),
        children: reduceMotion ? [] : [{
          tag: 'animate',
          attributes: _objectSpread2(_objectSpread2({}, OPACITY_ANIMATE), {}, {
            values: '1;0;0;0;0;1;'
          })
        }]
      });

      if (!reduceMotion) {
        // Exclamation
        gChildren.push({
          tag: 'path',
          attributes: _objectSpread2(_objectSpread2({}, FILL), {}, {
            opacity: '0',
            d: 'M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z'
          }),
          children: [{
            tag: 'animate',
            attributes: _objectSpread2(_objectSpread2({}, OPACITY_ANIMATE), {}, {
              values: '0;0;1;1;0;0;'
            })
          }]
        });
      }

      return {
        tag: 'g',
        attributes: {
          'class': 'missing'
        },
        children: gChildren
      };
    };
  }
};

var SvgSymbols = {
  hooks: function hooks() {
    return {
      parseNodeAttributes: function parseNodeAttributes(accumulator, node) {
        var symbolData = node.getAttribute('data-fa-symbol');
        var symbol = symbolData === null ? false : symbolData === '' ? true : symbolData;
        accumulator['symbol'] = symbol;
        return accumulator;
      }
    };
  }
};

var plugins = [InjectCSS, ReplaceElements, Layers, LayersCounter, LayersText, PseudoElements, MutationObserver$1, PowerTransforms, Masks, MissingIconIndicator, SvgSymbols];

registerPlugins(plugins, {
  mixoutsTo: api
});
var noAuto$1 = api.noAuto;
var config$1 = api.config;
var library$1 = api.library;
var dom$1 = api.dom;
var parse$1 = api.parse;
var findIconDefinition$1 = api.findIconDefinition;
var toHtml$1 = api.toHtml;
var icon = api.icon;
var layer = api.layer;
var text = api.text;
var counter = api.counter;




/***/ }),

/***/ "../../node_modules/immer/dist/immer.esm.mjs":
/*!***************************************************!*\
  !*** ../../node_modules/immer/dist/immer.esm.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Immer": () => (/* binding */ un),
/* harmony export */   "applyPatches": () => (/* binding */ pn),
/* harmony export */   "castDraft": () => (/* binding */ K),
/* harmony export */   "castImmutable": () => (/* binding */ $),
/* harmony export */   "createDraft": () => (/* binding */ ln),
/* harmony export */   "current": () => (/* binding */ D),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "enableAllPlugins": () => (/* binding */ J),
/* harmony export */   "enableES5": () => (/* binding */ N),
/* harmony export */   "enableMapSet": () => (/* binding */ C),
/* harmony export */   "enablePatches": () => (/* binding */ T),
/* harmony export */   "finishDraft": () => (/* binding */ dn),
/* harmony export */   "freeze": () => (/* binding */ d),
/* harmony export */   "immerable": () => (/* binding */ L),
/* harmony export */   "isDraft": () => (/* binding */ r),
/* harmony export */   "isDraftable": () => (/* binding */ t),
/* harmony export */   "nothing": () => (/* binding */ H),
/* harmony export */   "original": () => (/* binding */ e),
/* harmony export */   "produce": () => (/* binding */ fn),
/* harmony export */   "produceWithPatches": () => (/* binding */ cn),
/* harmony export */   "setAutoFreeze": () => (/* binding */ sn),
/* harmony export */   "setUseProxies": () => (/* binding */ vn)
/* harmony export */ });
function n(n){for(var r=arguments.length,t=Array(r>1?r-1:0),e=1;e<r;e++)t[e-1]=arguments[e];if(true){var i=Y[n],o=i?"function"==typeof i?i.apply(null,t):i:"unknown error nr: "+n;throw Error("[Immer] "+o)}throw Error("[Immer] minified error nr: "+n+(t.length?" "+t.map((function(n){return"'"+n+"'"})).join(","):"")+". Find the full error at: https://bit.ly/3cXEKWf")}function r(n){return!!n&&!!n[Q]}function t(n){var r;return!!n&&(function(n){if(!n||"object"!=typeof n)return!1;var r=Object.getPrototypeOf(n);if(null===r)return!0;var t=Object.hasOwnProperty.call(r,"constructor")&&r.constructor;return t===Object||"function"==typeof t&&Function.toString.call(t)===Z}(n)||Array.isArray(n)||!!n[L]||!!(null===(r=n.constructor)||void 0===r?void 0:r[L])||s(n)||v(n))}function e(t){return r(t)||n(23,t),t[Q].t}function i(n,r,t){void 0===t&&(t=!1),0===o(n)?(t?Object.keys:nn)(n).forEach((function(e){t&&"symbol"==typeof e||r(e,n[e],n)})):n.forEach((function(t,e){return r(e,t,n)}))}function o(n){var r=n[Q];return r?r.i>3?r.i-4:r.i:Array.isArray(n)?1:s(n)?2:v(n)?3:0}function u(n,r){return 2===o(n)?n.has(r):Object.prototype.hasOwnProperty.call(n,r)}function a(n,r){return 2===o(n)?n.get(r):n[r]}function f(n,r,t){var e=o(n);2===e?n.set(r,t):3===e?(n.delete(r),n.add(t)):n[r]=t}function c(n,r){return n===r?0!==n||1/n==1/r:n!=n&&r!=r}function s(n){return X&&n instanceof Map}function v(n){return q&&n instanceof Set}function p(n){return n.o||n.t}function l(n){if(Array.isArray(n))return Array.prototype.slice.call(n);var r=rn(n);delete r[Q];for(var t=nn(r),e=0;e<t.length;e++){var i=t[e],o=r[i];!1===o.writable&&(o.writable=!0,o.configurable=!0),(o.get||o.set)&&(r[i]={configurable:!0,writable:!0,enumerable:o.enumerable,value:n[i]})}return Object.create(Object.getPrototypeOf(n),r)}function d(n,e){return void 0===e&&(e=!1),y(n)||r(n)||!t(n)?n:(o(n)>1&&(n.set=n.add=n.clear=n.delete=h),Object.freeze(n),e&&i(n,(function(n,r){return d(r,!0)}),!0),n)}function h(){n(2)}function y(n){return null==n||"object"!=typeof n||Object.isFrozen(n)}function b(r){var t=tn[r];return t||n(18,r),t}function m(n,r){tn[n]||(tn[n]=r)}function _(){return false||U||n(0),U}function j(n,r){r&&(b("Patches"),n.u=[],n.s=[],n.v=r)}function O(n){g(n),n.p.forEach(S),n.p=null}function g(n){n===U&&(U=n.l)}function w(n){return U={p:[],l:U,h:n,m:!0,_:0}}function S(n){var r=n[Q];0===r.i||1===r.i?r.j():r.O=!0}function P(r,e){e._=e.p.length;var i=e.p[0],o=void 0!==r&&r!==i;return e.h.g||b("ES5").S(e,r,o),o?(i[Q].P&&(O(e),n(4)),t(r)&&(r=M(e,r),e.l||x(e,r)),e.u&&b("Patches").M(i[Q].t,r,e.u,e.s)):r=M(e,i,[]),O(e),e.u&&e.v(e.u,e.s),r!==H?r:void 0}function M(n,r,t){if(y(r))return r;var e=r[Q];if(!e)return i(r,(function(i,o){return A(n,e,r,i,o,t)}),!0),r;if(e.A!==n)return r;if(!e.P)return x(n,e.t,!0),e.t;if(!e.I){e.I=!0,e.A._--;var o=4===e.i||5===e.i?e.o=l(e.k):e.o;i(3===e.i?new Set(o):o,(function(r,i){return A(n,e,o,r,i,t)})),x(n,o,!1),t&&n.u&&b("Patches").R(e,t,n.u,n.s)}return e.o}function A(e,i,o,a,c,s){if( true&&c===o&&n(5),r(c)){var v=M(e,c,s&&i&&3!==i.i&&!u(i.D,a)?s.concat(a):void 0);if(f(o,a,v),!r(v))return;e.m=!1}if(t(c)&&!y(c)){if(!e.h.F&&e._<1)return;M(e,c),i&&i.A.l||x(e,c)}}function x(n,r,t){void 0===t&&(t=!1),n.h.F&&n.m&&d(r,t)}function z(n,r){var t=n[Q];return(t?p(t):n)[r]}function I(n,r){if(r in n)for(var t=Object.getPrototypeOf(n);t;){var e=Object.getOwnPropertyDescriptor(t,r);if(e)return e;t=Object.getPrototypeOf(t)}}function k(n){n.P||(n.P=!0,n.l&&k(n.l))}function E(n){n.o||(n.o=l(n.t))}function R(n,r,t){var e=s(r)?b("MapSet").N(r,t):v(r)?b("MapSet").T(r,t):n.g?function(n,r){var t=Array.isArray(n),e={i:t?1:0,A:r?r.A:_(),P:!1,I:!1,D:{},l:r,t:n,k:null,o:null,j:null,C:!1},i=e,o=en;t&&(i=[e],o=on);var u=Proxy.revocable(i,o),a=u.revoke,f=u.proxy;return e.k=f,e.j=a,f}(r,t):b("ES5").J(r,t);return(t?t.A:_()).p.push(e),e}function D(e){return r(e)||n(22,e),function n(r){if(!t(r))return r;var e,u=r[Q],c=o(r);if(u){if(!u.P&&(u.i<4||!b("ES5").K(u)))return u.t;u.I=!0,e=F(r,c),u.I=!1}else e=F(r,c);return i(e,(function(r,t){u&&a(u.t,r)===t||f(e,r,n(t))})),3===c?new Set(e):e}(e)}function F(n,r){switch(r){case 2:return new Map(n);case 3:return Array.from(n)}return l(n)}function N(){function t(n,r){var t=s[n];return t?t.enumerable=r:s[n]=t={configurable:!0,enumerable:r,get:function(){var r=this[Q];return true&&f(r),en.get(r,n)},set:function(r){var t=this[Q]; true&&f(t),en.set(t,n,r)}},t}function e(n){for(var r=n.length-1;r>=0;r--){var t=n[r][Q];if(!t.P)switch(t.i){case 5:a(t)&&k(t);break;case 4:o(t)&&k(t)}}}function o(n){for(var r=n.t,t=n.k,e=nn(t),i=e.length-1;i>=0;i--){var o=e[i];if(o!==Q){var a=r[o];if(void 0===a&&!u(r,o))return!0;var f=t[o],s=f&&f[Q];if(s?s.t!==a:!c(f,a))return!0}}var v=!!r[Q];return e.length!==nn(r).length+(v?0:1)}function a(n){var r=n.k;if(r.length!==n.t.length)return!0;var t=Object.getOwnPropertyDescriptor(r,r.length-1);if(t&&!t.get)return!0;for(var e=0;e<r.length;e++)if(!r.hasOwnProperty(e))return!0;return!1}function f(r){r.O&&n(3,JSON.stringify(p(r)))}var s={};m("ES5",{J:function(n,r){var e=Array.isArray(n),i=function(n,r){if(n){for(var e=Array(r.length),i=0;i<r.length;i++)Object.defineProperty(e,""+i,t(i,!0));return e}var o=rn(r);delete o[Q];for(var u=nn(o),a=0;a<u.length;a++){var f=u[a];o[f]=t(f,n||!!o[f].enumerable)}return Object.create(Object.getPrototypeOf(r),o)}(e,n),o={i:e?5:4,A:r?r.A:_(),P:!1,I:!1,D:{},l:r,t:n,k:i,o:null,O:!1,C:!1};return Object.defineProperty(i,Q,{value:o,writable:!0}),i},S:function(n,t,o){o?r(t)&&t[Q].A===n&&e(n.p):(n.u&&function n(r){if(r&&"object"==typeof r){var t=r[Q];if(t){var e=t.t,o=t.k,f=t.D,c=t.i;if(4===c)i(o,(function(r){r!==Q&&(void 0!==e[r]||u(e,r)?f[r]||n(o[r]):(f[r]=!0,k(t)))})),i(e,(function(n){void 0!==o[n]||u(o,n)||(f[n]=!1,k(t))}));else if(5===c){if(a(t)&&(k(t),f.length=!0),o.length<e.length)for(var s=o.length;s<e.length;s++)f[s]=!1;else for(var v=e.length;v<o.length;v++)f[v]=!0;for(var p=Math.min(o.length,e.length),l=0;l<p;l++)o.hasOwnProperty(l)||(f[l]=!0),void 0===f[l]&&n(o[l])}}}}(n.p[0]),e(n.p))},K:function(n){return 4===n.i?o(n):a(n)}})}function T(){function e(n){if(!t(n))return n;if(Array.isArray(n))return n.map(e);if(s(n))return new Map(Array.from(n.entries()).map((function(n){return[n[0],e(n[1])]})));if(v(n))return new Set(Array.from(n).map(e));var r=Object.create(Object.getPrototypeOf(n));for(var i in n)r[i]=e(n[i]);return u(n,L)&&(r[L]=n[L]),r}function f(n){return r(n)?e(n):n}var c="add";m("Patches",{$:function(r,t){return t.forEach((function(t){for(var i=t.path,u=t.op,f=r,s=0;s<i.length-1;s++){var v=o(f),p=""+i[s];0!==v&&1!==v||"__proto__"!==p&&"constructor"!==p||n(24),"function"==typeof f&&"prototype"===p&&n(24),"object"!=typeof(f=a(f,p))&&n(15,i.join("/"))}var l=o(f),d=e(t.value),h=i[i.length-1];switch(u){case"replace":switch(l){case 2:return f.set(h,d);case 3:n(16);default:return f[h]=d}case c:switch(l){case 1:return"-"===h?f.push(d):f.splice(h,0,d);case 2:return f.set(h,d);case 3:return f.add(d);default:return f[h]=d}case"remove":switch(l){case 1:return f.splice(h,1);case 2:return f.delete(h);case 3:return f.delete(t.value);default:return delete f[h]}default:n(17,u)}})),r},R:function(n,r,t,e){switch(n.i){case 0:case 4:case 2:return function(n,r,t,e){var o=n.t,s=n.o;i(n.D,(function(n,i){var v=a(o,n),p=a(s,n),l=i?u(o,n)?"replace":c:"remove";if(v!==p||"replace"!==l){var d=r.concat(n);t.push("remove"===l?{op:l,path:d}:{op:l,path:d,value:p}),e.push(l===c?{op:"remove",path:d}:"remove"===l?{op:c,path:d,value:f(v)}:{op:"replace",path:d,value:f(v)})}}))}(n,r,t,e);case 5:case 1:return function(n,r,t,e){var i=n.t,o=n.D,u=n.o;if(u.length<i.length){var a=[u,i];i=a[0],u=a[1];var s=[e,t];t=s[0],e=s[1]}for(var v=0;v<i.length;v++)if(o[v]&&u[v]!==i[v]){var p=r.concat([v]);t.push({op:"replace",path:p,value:f(u[v])}),e.push({op:"replace",path:p,value:f(i[v])})}for(var l=i.length;l<u.length;l++){var d=r.concat([l]);t.push({op:c,path:d,value:f(u[l])})}i.length<u.length&&e.push({op:"replace",path:r.concat(["length"]),value:i.length})}(n,r,t,e);case 3:return function(n,r,t,e){var i=n.t,o=n.o,u=0;i.forEach((function(n){if(!o.has(n)){var i=r.concat([u]);t.push({op:"remove",path:i,value:n}),e.unshift({op:c,path:i,value:n})}u++})),u=0,o.forEach((function(n){if(!i.has(n)){var o=r.concat([u]);t.push({op:c,path:o,value:n}),e.unshift({op:"remove",path:o,value:n})}u++}))}(n,r,t,e)}},M:function(n,r,t,e){t.push({op:"replace",path:[],value:r===H?void 0:r}),e.push({op:"replace",path:[],value:n})}})}function C(){function r(n,r){function t(){this.constructor=n}a(n,r),n.prototype=(t.prototype=r.prototype,new t)}function e(n){n.o||(n.D=new Map,n.o=new Map(n.t))}function o(n){n.o||(n.o=new Set,n.t.forEach((function(r){if(t(r)){var e=R(n.A.h,r,n);n.p.set(r,e),n.o.add(e)}else n.o.add(r)})))}function u(r){r.O&&n(3,JSON.stringify(p(r)))}var a=function(n,r){return(a=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,r){n.__proto__=r}||function(n,r){for(var t in r)r.hasOwnProperty(t)&&(n[t]=r[t])})(n,r)},f=function(){function n(n,r){return this[Q]={i:2,l:r,A:r?r.A:_(),P:!1,I:!1,o:void 0,D:void 0,t:n,k:this,C:!1,O:!1},this}r(n,Map);var o=n.prototype;return Object.defineProperty(o,"size",{get:function(){return p(this[Q]).size}}),o.has=function(n){return p(this[Q]).has(n)},o.set=function(n,r){var t=this[Q];return u(t),p(t).has(n)&&p(t).get(n)===r||(e(t),k(t),t.D.set(n,!0),t.o.set(n,r),t.D.set(n,!0)),this},o.delete=function(n){if(!this.has(n))return!1;var r=this[Q];return u(r),e(r),k(r),r.t.has(n)?r.D.set(n,!1):r.D.delete(n),r.o.delete(n),!0},o.clear=function(){var n=this[Q];u(n),p(n).size&&(e(n),k(n),n.D=new Map,i(n.t,(function(r){n.D.set(r,!1)})),n.o.clear())},o.forEach=function(n,r){var t=this;p(this[Q]).forEach((function(e,i){n.call(r,t.get(i),i,t)}))},o.get=function(n){var r=this[Q];u(r);var i=p(r).get(n);if(r.I||!t(i))return i;if(i!==r.t.get(n))return i;var o=R(r.A.h,i,r);return e(r),r.o.set(n,o),o},o.keys=function(){return p(this[Q]).keys()},o.values=function(){var n,r=this,t=this.keys();return(n={})[V]=function(){return r.values()},n.next=function(){var n=t.next();return n.done?n:{done:!1,value:r.get(n.value)}},n},o.entries=function(){var n,r=this,t=this.keys();return(n={})[V]=function(){return r.entries()},n.next=function(){var n=t.next();if(n.done)return n;var e=r.get(n.value);return{done:!1,value:[n.value,e]}},n},o[V]=function(){return this.entries()},n}(),c=function(){function n(n,r){return this[Q]={i:3,l:r,A:r?r.A:_(),P:!1,I:!1,o:void 0,t:n,k:this,p:new Map,O:!1,C:!1},this}r(n,Set);var t=n.prototype;return Object.defineProperty(t,"size",{get:function(){return p(this[Q]).size}}),t.has=function(n){var r=this[Q];return u(r),r.o?!!r.o.has(n)||!(!r.p.has(n)||!r.o.has(r.p.get(n))):r.t.has(n)},t.add=function(n){var r=this[Q];return u(r),this.has(n)||(o(r),k(r),r.o.add(n)),this},t.delete=function(n){if(!this.has(n))return!1;var r=this[Q];return u(r),o(r),k(r),r.o.delete(n)||!!r.p.has(n)&&r.o.delete(r.p.get(n))},t.clear=function(){var n=this[Q];u(n),p(n).size&&(o(n),k(n),n.o.clear())},t.values=function(){var n=this[Q];return u(n),o(n),n.o.values()},t.entries=function(){var n=this[Q];return u(n),o(n),n.o.entries()},t.keys=function(){return this.values()},t[V]=function(){return this.values()},t.forEach=function(n,r){for(var t=this.values(),e=t.next();!e.done;)n.call(r,e.value,e.value,this),e=t.next()},n}();m("MapSet",{N:function(n,r){return new f(n,r)},T:function(n,r){return new c(n,r)}})}function J(){N(),C(),T()}function K(n){return n}function $(n){return n}var G,U,W="undefined"!=typeof Symbol&&"symbol"==typeof Symbol("x"),X="undefined"!=typeof Map,q="undefined"!=typeof Set,B="undefined"!=typeof Proxy&&void 0!==Proxy.revocable&&"undefined"!=typeof Reflect,H=W?Symbol.for("immer-nothing"):((G={})["immer-nothing"]=!0,G),L=W?Symbol.for("immer-draftable"):"__$immer_draftable",Q=W?Symbol.for("immer-state"):"__$immer_state",V="undefined"!=typeof Symbol&&Symbol.iterator||"@@iterator",Y={0:"Illegal state",1:"Immer drafts cannot have computed properties",2:"This object has been frozen and should not be mutated",3:function(n){return"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? "+n},4:"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",5:"Immer forbids circular references",6:"The first or second argument to `produce` must be a function",7:"The third argument to `produce` must be a function or undefined",8:"First argument to `createDraft` must be a plain object, an array, or an immerable object",9:"First argument to `finishDraft` must be a draft returned by `createDraft`",10:"The given draft is already finalized",11:"Object.defineProperty() cannot be used on an Immer draft",12:"Object.setPrototypeOf() cannot be used on an Immer draft",13:"Immer only supports deleting array indices",14:"Immer only supports setting array indices and the 'length' property",15:function(n){return"Cannot apply patch, path doesn't resolve: "+n},16:'Sets cannot have "replace" patches.',17:function(n){return"Unsupported patch operation: "+n},18:function(n){return"The plugin for '"+n+"' has not been loaded into Immer. To enable the plugin, import and call `enable"+n+"()` when initializing your application."},20:"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available",21:function(n){return"produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '"+n+"'"},22:function(n){return"'current' expects a draft, got: "+n},23:function(n){return"'original' expects a draft, got: "+n},24:"Patching reserved attributes like __proto__, prototype and constructor is not allowed"},Z=""+Object.prototype.constructor,nn="undefined"!=typeof Reflect&&Reflect.ownKeys?Reflect.ownKeys:void 0!==Object.getOwnPropertySymbols?function(n){return Object.getOwnPropertyNames(n).concat(Object.getOwnPropertySymbols(n))}:Object.getOwnPropertyNames,rn=Object.getOwnPropertyDescriptors||function(n){var r={};return nn(n).forEach((function(t){r[t]=Object.getOwnPropertyDescriptor(n,t)})),r},tn={},en={get:function(n,r){if(r===Q)return n;var e=p(n);if(!u(e,r))return function(n,r,t){var e,i=I(r,t);return i?"value"in i?i.value:null===(e=i.get)||void 0===e?void 0:e.call(n.k):void 0}(n,e,r);var i=e[r];return n.I||!t(i)?i:i===z(n.t,r)?(E(n),n.o[r]=R(n.A.h,i,n)):i},has:function(n,r){return r in p(n)},ownKeys:function(n){return Reflect.ownKeys(p(n))},set:function(n,r,t){var e=I(p(n),r);if(null==e?void 0:e.set)return e.set.call(n.k,t),!0;if(!n.P){var i=z(p(n),r),o=null==i?void 0:i[Q];if(o&&o.t===t)return n.o[r]=t,n.D[r]=!1,!0;if(c(t,i)&&(void 0!==t||u(n.t,r)))return!0;E(n),k(n)}return n.o[r]===t&&"number"!=typeof t&&(void 0!==t||r in n.o)||(n.o[r]=t,n.D[r]=!0,!0)},deleteProperty:function(n,r){return void 0!==z(n.t,r)||r in n.t?(n.D[r]=!1,E(n),k(n)):delete n.D[r],n.o&&delete n.o[r],!0},getOwnPropertyDescriptor:function(n,r){var t=p(n),e=Reflect.getOwnPropertyDescriptor(t,r);return e?{writable:!0,configurable:1!==n.i||"length"!==r,enumerable:e.enumerable,value:t[r]}:e},defineProperty:function(){n(11)},getPrototypeOf:function(n){return Object.getPrototypeOf(n.t)},setPrototypeOf:function(){n(12)}},on={};i(en,(function(n,r){on[n]=function(){return arguments[0]=arguments[0][0],r.apply(this,arguments)}})),on.deleteProperty=function(r,t){return true&&isNaN(parseInt(t))&&n(13),on.set.call(this,r,t,void 0)},on.set=function(r,t,e){return true&&"length"!==t&&isNaN(parseInt(t))&&n(14),en.set.call(this,r[0],t,e,r[0])};var un=function(){function e(r){var e=this;this.g=B,this.F=!0,this.produce=function(r,i,o){if("function"==typeof r&&"function"!=typeof i){var u=i;i=r;var a=e;return function(n){var r=this;void 0===n&&(n=u);for(var t=arguments.length,e=Array(t>1?t-1:0),o=1;o<t;o++)e[o-1]=arguments[o];return a.produce(n,(function(n){var t;return(t=i).call.apply(t,[r,n].concat(e))}))}}var f;if("function"!=typeof i&&n(6),void 0!==o&&"function"!=typeof o&&n(7),t(r)){var c=w(e),s=R(e,r,void 0),v=!0;try{f=i(s),v=!1}finally{v?O(c):g(c)}return"undefined"!=typeof Promise&&f instanceof Promise?f.then((function(n){return j(c,o),P(n,c)}),(function(n){throw O(c),n})):(j(c,o),P(f,c))}if(!r||"object"!=typeof r){if(void 0===(f=i(r))&&(f=r),f===H&&(f=void 0),e.F&&d(f,!0),o){var p=[],l=[];b("Patches").M(r,f,p,l),o(p,l)}return f}n(21,r)},this.produceWithPatches=function(n,r){if("function"==typeof n)return function(r){for(var t=arguments.length,i=Array(t>1?t-1:0),o=1;o<t;o++)i[o-1]=arguments[o];return e.produceWithPatches(r,(function(r){return n.apply(void 0,[r].concat(i))}))};var t,i,o=e.produce(n,r,(function(n,r){t=n,i=r}));return"undefined"!=typeof Promise&&o instanceof Promise?o.then((function(n){return[n,t,i]})):[o,t,i]},"boolean"==typeof(null==r?void 0:r.useProxies)&&this.setUseProxies(r.useProxies),"boolean"==typeof(null==r?void 0:r.autoFreeze)&&this.setAutoFreeze(r.autoFreeze)}var i=e.prototype;return i.createDraft=function(e){t(e)||n(8),r(e)&&(e=D(e));var i=w(this),o=R(this,e,void 0);return o[Q].C=!0,g(i),o},i.finishDraft=function(r,t){var e=r&&r[Q]; true&&(e&&e.C||n(9),e.I&&n(10));var i=e.A;return j(i,t),P(void 0,i)},i.setAutoFreeze=function(n){this.F=n},i.setUseProxies=function(r){r&&!B&&n(20),this.g=r},i.applyPatches=function(n,t){var e;for(e=t.length-1;e>=0;e--){var i=t[e];if(0===i.path.length&&"replace"===i.op){n=i.value;break}}e>-1&&(t=t.slice(e+1));var o=b("Patches").$;return r(n)?o(n,t):this.produce(n,(function(n){return o(n,t)}))},e}(),an=new un,fn=an.produce,cn=an.produceWithPatches.bind(an),sn=an.setAutoFreeze.bind(an),vn=an.setUseProxies.bind(an),pn=an.applyPatches.bind(an),ln=an.createDraft.bind(an),dn=an.finishDraft.bind(an);/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (fn);
//# sourceMappingURL=immer.esm.js.map


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfZW1vdGlvbl9pcy1wcm9wLXZhbGlkX2Rpc3RfZW1vdGlvbi1pcy1wcm9wLXZhbGlkX2VzbV9qcy1ub2RlX21vZHVsZXNfZW1vLTFiOTg1NS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUF1Qzs7QUFFdkMsMitIQUEyK0g7O0FBRTMrSCxpQ0FBaUMsNERBQU87QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxXQUFXLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUNkM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsT0FBTyxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDUnZCO0FBQ0E7QUFDQSwwS0FBMEssTUFBTTtBQUNoTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixNQUFNO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLGlDQUFpQztBQUMxRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixVQUFVO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsVUFBVTtBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixVQUFVOztBQUVwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtB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dEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtEQUFrRDtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx5RUFBYztBQUN0QjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ087QUFDUDtBQUNBO0FBQ0EsZ0RBQWdELHNGQUFtQztBQUNuRjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLDBEQUEwRCxzRkFBbUM7QUFDN0Y7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9FQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EseUVBQXlFLHNGQUFtQztBQUM1RztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsb0VBQWM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsb0VBQWM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDTztBQUNQLG1EQUFtRCxnQkFBZ0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4WnFEO0FBQ3JELG1DQUFtQyxvRUFBYztBQUNqRCw0QkFBNEIsb0VBQWM7QUFDMUMsMkJBQTJCLG9FQUFjO0FBQ3pDLDJCQUEyQixvRUFBYztBQUN6QyxtQ0FBbUMsb0VBQWM7QUFDakQsa0NBQWtDLG9FQUFjO0FBQ2hELGlDQUFpQyxvRUFBYztBQUMvQyxpQ0FBaUMsb0VBQWM7QUFDd0M7QUFDdkY7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDVnFEO0FBQ0E7QUFDOUM7QUFDUCxXQUFXLG1FQUFTLENBQUMsbUVBQVc7QUFDaEM7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDTGE7QUFDYztBQUNxQjtBQUN6QztBQUNQLGtCQUFrQix5REFBZSxDQUFDLDhEQUFRO0FBQzFDO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ05PO0FBQ1A7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0RhO0FBQ2I7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNEJBQTRCO0FBQ3RCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEI7QUFDL0I7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGtCQUFrQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsb0NBQW9DLEtBQUs7QUFDekMsdUNBQXVDLGFBQWE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELCtDQUFZO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELDZDQUFVO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw4Q0FBOEM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw4Q0FBTTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNI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QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFH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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFHQUFxRyxlQUFlO0FBQ3BIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLFFBQVE7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyR0FBMkc7O0FBRTNHO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EsK0RBQStEOztBQUUvRDtBQUNBLEdBQUcsR0FBRzs7QUFFTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBOztBQUVBLHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJO0FBQ0o7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsU0FBUyxHQUFHOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDLGtCQUFrQjtBQUN4RDtBQUNBO0FBQ0EsVUFBVTtBQUNWLHVDQUF1QyxxQkFBcUI7QUFDNUQ7QUFDQTtBQUNBLFVBQVU7OztBQUdWOztBQUVBLDBCQUEwQixXQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7O0FBRUE7O0FBRUEsa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047OztBQUdBO0FBQ0EsMEVBQTBFO0FBQzFFOztBQUVBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUZBQWlGOztBQUVqRixvREFBb0Q7O0FBRXBELG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQSxNQUFNOzs7QUFHTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTixvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNOzs7QUFHTixnQ0FBZ0MsbUJBQW1CO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IscUJBQXFCO0FBQzNDO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvREFBb0Q7O0FBRXBEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQzs7O0FBR2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQjtBQUN0QixRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQzs7O0FBR2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVIsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRCwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0QsbUVBQW1FOztBQUVuRTtBQUNBLHFIQUFxSDtBQUNySDs7QUFFQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUEsOENBQThDOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQyxHQUFHOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3QyxRQUFRO0FB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O0FBQ0E7QUFDQTtBQUNBLHlGQUF5RixhQUFhO0FBQ3RHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLGVBQWU7QUFDNUc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxhQUFhO0FBQ2xGO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLEtBQUs7QUFDTDtBQUNBO0FBQ0Esa0RBQWtELGlCQUFpQjtBQUNuRTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnREFBZ0QsdUJBQXVCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsNkNBQTZDLGNBQWM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0VBQWtFO0FBQ2xFO0FBQ0EsSUFBSSxJQUFJLEtBQUs7QUFDYjtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtFQUFrRTtBQUNsRTtBQUNBLElBQUksSUFBSSxLQUFLO0FBQ2I7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QyxpQ0FBaUM7QUFDN0UsNEZBQTRGO0FBQzVGLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGdDQUFnQztBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxXQUFXO0FBQzFGO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFELE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QkFBMkIsTUFBTSw0QkFBNEIsa0NBQWtDLDJCQUEyQixPQUFPLE9BQU8sb0JBQW9CLGlCQUFpQiw2REFBNkQsbUNBQW1DLE1BQU0sS0FBbUMseURBQXlELHdCQUF3QixNQUFNLEtBQW1DLDJFQUEyRSxrQkFBa0IsY0FBYyxXQUFXLGdEQUFnRCwrQ0FBK0MsUUFBUSxJQUFJLFFBQVEsbUJBQW1CLFdBQVcsa0JBQWtCLGtEQUFrRCxJQUFJLHdCQUF3QixnQ0FBZ0MsTUFBTSwwQ0FBMEMsSUFBSSxNQUFNLDJFQUEyRSxnQ0FBZ0MsSUFBSSxZQUFZLFFBQVEsWUFBWSw0RUFBNEUscUJBQXFCLGVBQWUsYUFBYSxtQkFBbUIsMkJBQTJCLDhEQUE4RCxjQUFjLCtCQUErQixTQUFTLFFBQVEsdUNBQXVDLDJDQUEyQyxrREFBa0QsSUFBSSx3QkFBd0IsMkNBQTJDLHFDQUFxQyxJQUFJLHVDQUF1QyxRQUFRLEdBQUcsNEVBQTRFLGNBQWMsV0FBVyxtS0FBbUssa0JBQWtCLGlDQUFpQywwQkFBMEIsaUNBQWlDLHdCQUF3Qiw2QkFBNkIsY0FBYyxLQUFtQyw0QkFBNEIsVUFBVSwwQkFBMEIsNkJBQTZCLFNBQVMsNkJBQTZCLHNCQUFzQiw4QkFBOEIsTUFBTSxpQkFBaUIsS0FBSyxLQUFLLFdBQVcsd0NBQXdDLFVBQVUsT0FBTyx1QkFBdUIscUJBQXFCLCtDQUErQyxjQUFjLEdBQUcsR0FBRyx5TUFBeU0saUVBQWUsRUFBRSxFQUF3VztBQUN2MmpCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHN1YndhbGxldC9leHRlbnNpb24ta29uaS8uLi8uLi9ub2RlX21vZHVsZXMvQGVtb3Rpb24vaXMtcHJvcC12YWxpZC9kaXN0L2Vtb3Rpb24taXMtcHJvcC12YWxpZC5lc20uanMiLCJ3ZWJwYWNrOi8vQHN1YndhbGxldC9leHRlbnNpb24ta29uaS8uLi8uLi9ub2RlX21vZHVsZXMvQGVtb3Rpb24vbWVtb2l6ZS9kaXN0L2Vtb3Rpb24tbWVtb2l6ZS5lc20uanMiLCJ3ZWJwYWNrOi8vQHN1YndhbGxldC9leHRlbnNpb24ta29uaS8uLi8uLi9ub2RlX21vZHVsZXMvQGVtb3Rpb24vc3R5bGlzL2Rpc3Qvc3R5bGlzLmJyb3dzZXIuZXNtLmpzIiwid2VicGFjazovL0BzdWJ3YWxsZXQvZXh0ZW5zaW9uLWtvbmkvLi4vLi4vbm9kZV9tb2R1bGVzL0BlbW90aW9uL3VuaXRsZXNzL2Rpc3QvdW5pdGxlc3MuYnJvd3Nlci5lc20uanMiLCJ3ZWJwYWNrOi8vQHN1YndhbGxldC9leHRlbnNpb24ta29uaS8uLi8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYWJpL2xpYi5lc20vX3ZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vQHN1YndhbGxldC9leHRlbnNpb24ta29uaS8uLi8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYWJpL2xpYi5lc20vYWJpLWNvZGVyLmpzIiwid2VicGFjazovL0BzdWJ3YWxsZXQvZXh0ZW5zaW9uLWtvbmkvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2NvZGVycy9hYnN0cmFjdC1jb2Rlci5qcyIsIndlYnBhY2s6Ly9Ac3Vid2FsbGV0L2V4dGVuc2lvbi1rb25pLy4uLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYmkvbGliLmVzbS9jb2RlcnMvYWRkcmVzcy5qcyIsIndlYnBhY2s6Ly9Ac3Vid2FsbGV0L2V4dGVuc2lvbi1rb25pLy4uLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYmkvbGliLmVzbS9jb2RlcnMvYW5vbnltb3VzLmpzIiwid2VicGFjazovL0BzdWJ3YWxsZXQvZXh0ZW5zaW9uLWtvbmkvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2NvZGVycy9hcnJheS5qcyIsIndlYnBhY2s6Ly9Ac3Vid2FsbGV0L2V4dGVuc2lvbi1rb25pLy4uLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYmkvbGliLmVzbS9jb2RlcnMvYm9vbGVhbi5qcyIsIndlYnBhY2s6Ly9Ac3Vid2FsbGV0L2V4dGVuc2lvbi1rb25pLy4uLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYmkvbGliLmVzbS9jb2RlcnMvYnl0ZXMuanMiLCJ3ZWJwYWNrOi8vQHN1YndhbGxldC9leHRlbnNpb24ta29uaS8uLi8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYWJpL2xpYi5lc20vY29kZXJzL2ZpeGVkLWJ5dGVzLmpzIiwid2VicGFjazovL0BzdWJ3YWxsZXQvZXh0ZW5zaW9uLWtvbmkvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2NvZGVycy9udWxsLmpzIiwid2VicGFjazovL0BzdWJ3YWxsZXQvZXh0ZW5zaW9uLWtvbmkvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2NvZGVycy9udW1iZXIuanMiLCJ3ZWJwYWNrOi8vQHN1YndhbGxldC9leHRlbnNpb24ta29uaS8uLi8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYWJpL2xpYi5lc20vY29kZXJzL3N0cmluZy5qcyIsIndlYnBhY2s6Ly9Ac3Vid2FsbGV0L2V4dGVuc2lvbi1rb25pLy4uLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYmkvbGliLmVzbS9jb2RlcnMvdHVwbGUuanMiLCJ3ZWJwYWNrOi8vQHN1YndhbGxldC9leHRlbnNpb24ta29uaS8uLi8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYWJpL2xpYi5lc20vZnJhZ21lbnRzLmpzIiwid2VicGFjazovL0BzdWJ3YWxsZXQvZXh0ZW5zaW9uLWtvbmkvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2ludGVyZmFjZS5qcyIsIndlYnBhY2s6Ly9Ac3Vid2FsbGV0L2V4dGVuc2lvbi1rb25pLy4uLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hZGRyZXNzL2xpYi5lc20vX3ZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vQHN1YndhbGxldC9leHRlbnNpb24ta29uaS8uLi8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYWRkcmVzcy9saWIuZXNtL2luZGV4LmpzIiwid2VicGFjazovL0BzdWJ3YWxsZXQvZXh0ZW5zaW9uLWtvbmkvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2JpZ251bWJlci9saWIuZXNtL192ZXJzaW9uLmpzIiwid2VicGFjazovL0BzdWJ3YWxsZXQvZXh0ZW5zaW9uLWtvbmkvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2JpZ251bWJlci9saWIuZXNtL2JpZ251bWJlci5qcyIsIndlYnBhY2s6Ly9Ac3Vid2FsbGV0L2V4dGVuc2lvbi1rb25pLy4uLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9ieXRlcy9saWIuZXNtL192ZXJzaW9uLmpzIiwid2VicGFjazovL0BzdWJ3YWxsZXQvZXh0ZW5zaW9uLWtvbmkvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2J5dGVzL2xpYi5lc20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vQHN1YndhbGxldC9leHRlbnNpb24ta29uaS8uLi8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvY29uc3RhbnRzL2xpYi5lc20vYmlnbnVtYmVycy5qcyIsIndlYnBhY2s6Ly9Ac3Vid2FsbGV0L2V4dGVuc2lvbi1rb25pLy4uLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9oYXNoL2xpYi5lc20vaWQuanMiLCJ3ZWJwYWNrOi8vQHN1YndhbGxldC9leHRlbnNpb24ta29uaS8uLi8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qva2VjY2FrMjU2L2xpYi5lc20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vQHN1YndhbGxldC9leHRlbnNpb24ta29uaS8uLi8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvbG9nZ2VyL2xpYi5lc20vX3ZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vQHN1YndhbGxldC9leHRlbnNpb24ta29uaS8uLi8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvbG9nZ2VyL2xpYi5lc20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vQHN1YndhbGxldC9leHRlbnNpb24ta29uaS8uLi8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvcGVydGllcy9saWIuZXNtL192ZXJzaW9uLmpzIiwid2VicGFjazovL0BzdWJ3YWxsZXQvZXh0ZW5zaW9uLWtvbmkvLi4vLi4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXMvbGliLmVzbS9pbmRleC5qcyIsIndlYnBhY2s6Ly9Ac3Vid2FsbGV0L2V4dGVuc2lvbi1rb25pLy4uLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9ybHAvbGliLmVzbS9fdmVyc2lvbi5qcyIsIndlYnBhY2s6Ly9Ac3Vid2FsbGV0L2V4dGVuc2lvbi1rb25pLy4uLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9ybHAvbGliLmVzbS9pbmRleC5qcyIsIndlYnBhY2s6Ly9Ac3Vid2FsbGV0L2V4dGVuc2lvbi1rb25pLy4uLy4uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9zdHJpbmdzL2xpYi5lc20vX3ZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vQHN1YndhbGxldC9leHRlbnNpb24ta29uaS8uLi8uLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qvc3RyaW5ncy9saWIuZXNtL3V0ZjguanMiLCJ3ZWJwYWNrOi8vQHN1YndhbGxldC9leHRlbnNpb24ta29uaS8uLi8uLi9ub2RlX21vZHVsZXMvQGZvcnRhd2Vzb21lL3JlYWN0LWZvbnRhd2Vzb21lL2luZGV4LmVzLmpzIiwid2VicGFjazovL0BzdWJ3YWxsZXQvZXh0ZW5zaW9uLWtvbmkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvbW9kZWwtdmlld2VyL2xpYi9hc3NldHMvY2xvc2UtbWF0ZXJpYWwtc3ZnLmpzIiwid2VicGFjazovL0BzdWJ3YWxsZXQvZXh0ZW5zaW9uLWtvbmkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvbW9kZWwtdmlld2VyL2xpYi9hc3NldHMvY29udHJvbHMtc3ZnLmpzIiwid2VicGFjazovL0BzdWJ3YWxsZXQvZXh0ZW5zaW9uLWtvbmkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvbW9kZWwtdmlld2VyL2xpYi9hc3NldHMvdmlldy1pbi1hci1tYXRlcmlhbC1zdmcuanMiLCJ3ZWJwYWNrOi8vQHN1YndhbGxldC9leHRlbnNpb24ta29uaS8uLi8uLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9tb2RlbC12aWV3ZXIvbGliL2NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly9Ac3Vid2FsbGV0L2V4dGVuc2lvbi1rb25pLy4uLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL21vZGVsLXZpZXdlci9saWIvZGVjb3JhdG9ycy5qcyIsIndlYnBhY2s6Ly9Ac3Vid2FsbGV0L2V4dGVuc2lvbi1rb25pLy4uLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL21vZGVsLXZpZXdlci9saWIvZmVhdHVyZXMvYW5pbWF0aW9uLmpzIiwid2VicGFjazovL0BzdWJ3YWxsZXQvZXh0ZW5zaW9uLWtvbmkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvbW9kZWwtdmlld2VyL2xpYi9mZWF0dXJlcy9hbm5vdGF0aW9uLmpzIiwid2VicGFjazovL0BzdWJ3YWxsZXQvZXh0ZW5zaW9uLWtvbmkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvbW9kZWwtdmlld2VyL2xpYi9mZWF0dXJlcy9hci5qcyIsIndlYnBhY2s6Ly9Ac3Vid2FsbGV0L2V4dGVuc2lvbi1rb25pLy4uLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL21vZGVsLXZpZXdlci9saWIvZmVhdHVyZXMvY29udHJvbHMuanMiLCJ3ZWJwYWNrOi8vQHN1YndhbGxldC9leHRlbnNpb24ta29uaS8uLi8uLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9tb2RlbC12aWV3ZXIvbGliL2ZlYXR1cmVzL2Vudmlyb25tZW50LmpzIiwid2VicGFjazovL0BzdWJ3YWxsZXQvZXh0ZW5zaW9uLWtvbmkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvbW9kZWwtdmlld2VyL2xpYi9mZWF0dXJlcy9sb2FkaW5nLmpzIiwid2VicGFjazovL0BzdWJ3YWxsZXQvZXh0ZW5zaW9uLWtvbmkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvbW9kZWwtdmlld2VyL2xpYi9mZWF0dXJlcy9zY2VuZS1ncmFwaC5qcyIsIndlYnBhY2s6Ly9Ac3Vid2FsbGV0L2V4dGVuc2lvbi1rb25pLy4uLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL21vZGVsLXZpZXdlci9saWIvZmVhdHVyZXMvc2NlbmUtZ3JhcGgvaW1hZ2UuanMiLCJ3ZWJwYWNrOi8vQHN1YndhbGxldC9leHRlbnNpb24ta29uaS8uLi8uLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9tb2RlbC12aWV3ZXIvbGliL2ZlYXR1cmVzL3NjZW5lLWdyYXBoL21hdGVyaWFsLmpzIiwid2VicGFjazovL0BzdWJ3YWxsZXQvZXh0ZW5zaW9uLWtvbmkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvbW9kZWwtdmlld2VyL2xpYi9mZWF0dXJlcy9zY2VuZS1ncmFwaC9tb2RlbC5qcyIsIndlYnBhY2s6Ly9Ac3Vid2FsbGV0L2V4dGVuc2lvbi1rb25pLy4uLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL21vZGVsLXZpZXdlci9saWIvZmVhdHVyZXMvc2NlbmUtZ3JhcGgvbm9kZXMvcHJpbWl0aXZlLW5vZGUuanMiLCJ3ZWJwYWNrOi8vQHN1YndhbGxldC9leHRlbnNpb24ta29uaS8uLi8uLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9tb2RlbC12aWV3ZXIvbGliL2ZlYXR1cmVzL3NjZW5lLWdyYXBoL3Bici1tZXRhbGxpYy1yb3VnaG5lc3MuanMiLCJ3ZWJwYWNrOi8vQHN1YndhbGxldC9leHRlbnNpb24ta29uaS8uLi8uLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9tb2RlbC12aWV3ZXIvbGliL2ZlYXR1cmVzL3NjZW5lLWdyYXBoL3NhbXBsZXIuanMiLCJ3ZWJwYWNrOi8vQHN1YndhbGxldC9leHRlbnNpb24ta29uaS8uLi8uLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9tb2RlbC12aWV3ZXIvbGliL2ZlYXR1cmVzL3NjZW5lLWdyYXBoL3RleHR1cmUtaW5mby5qcyIsIndlYnBhY2s6Ly9Ac3Vid2FsbGV0L2V4dGVuc2lvbi1rb25pLy4uLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL21vZGVsLXZpZXdlci9saWIvZmVhdHVyZXMvc2NlbmUtZ3JhcGgvdGV4dHVyZS5qcyIsIndlYnBhY2s6Ly9Ac3Vid2FsbGV0L2V4dGVuc2lvbi1rb25pLy4uLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL21vZGVsLXZpZXdlci9saWIvZmVhdHVyZXMvc2NlbmUtZ3JhcGgvdGhyZWUtZG9tLWVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vQHN1YndhbGxldC9leHRlbnNpb24ta29uaS8uLi8uLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9tb2RlbC12aWV3ZXIvbGliL2ZlYXR1cmVzL3N0YWdpbmcuanMiLCJ3ZWJwYWNrOi8vQHN1YndhbGxldC9leHRlbnNpb24ta29uaS8uLi8uLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9tb2RlbC12aWV3ZXIvbGliL21vZGVsLXZpZXdlci1iYXNlLmpzIiwid2VicGFjazovL0BzdWJ3YWxsZXQvZXh0ZW5zaW9uLWtvbmkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvbW9kZWwtdmlld2VyL2xpYi9tb2RlbC12aWV3ZXIuanMiLCJ3ZWJwYWNrOi8vQHN1YndhbGxldC9leHRlbnNpb24ta29uaS8uLi8uLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9tb2RlbC12aWV3ZXIvbGliL3N0eWxlcy9jb252ZXJzaW9ucy5qcyIsIndlYnBhY2s6Ly9Ac3Vid2FsbGV0L2V4dGVuc2lvbi1rb25pLy4uLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL21vZGVsLXZpZXdlci9saWIvc3R5bGVzL2Rlc2VyaWFsaXplcnMuanMiLCJ3ZWJwYWNrOi8vQHN1YndhbGxldC9leHRlbnNpb24ta29uaS8uLi8uLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9tb2RlbC12aWV3ZXIvbGliL3N0eWxlcy9ldmFsdWF0b3JzLmpzIiwid2VicGFjazovL0BzdWJ3YWxsZXQvZXh0ZW5zaW9uLWtvbmkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvbW9kZWwtdmlld2VyL2xpYi9zdHlsZXMvcGFyc2Vycy5qcyIsIndlYnBhY2s6Ly9Ac3Vid2FsbGV0L2V4dGVuc2lvbi1rb25pLy4uLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL21vZGVsLXZpZXdlci9saWIvc3R5bGVzL3N0eWxlLWVmZmVjdG9yLmpzIiwid2VicGFjazovL0BzdWJ3YWxsZXQvZXh0ZW5zaW9uLWtvbmkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvbW9kZWwtdmlld2VyL2xpYi90ZW1wbGF0ZS5qcyIsIndlYnBhY2s6Ly9Ac3Vid2FsbGV0L2V4dGVuc2lvbi1rb25pLy4uLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL21vZGVsLXZpZXdlci9saWIvdGhyZWUtY29tcG9uZW50cy9BUlJlbmRlcmVyLmpzIiwid2VicGFjazovL0BzdWJ3YWxsZXQvZXh0ZW5zaW9uLWtvbmkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvbW9kZWwtdmlld2VyL2xpYi90aHJlZS1jb21wb25lbnRzL0NhY2hpbmdHTFRGTG9hZGVyLmpzIiwid2VicGFjazovL0BzdWJ3YWxsZXQvZXh0ZW5zaW9uLWtvbmkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvbW9kZWwtdmlld2VyL2xpYi90aHJlZS1jb21wb25lbnRzL0RhbXBlci5qcyIsIndlYnBhY2s6Ly9Ac3Vid2FsbGV0L2V4dGVuc2lvbi1rb25pLy4uLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL21vZGVsLXZpZXdlci9saWIvdGhyZWUtY29tcG9uZW50cy9EZWJ1Z2dlci5qcyIsIndlYnBhY2s6Ly9Ac3Vid2FsbGV0L2V4dGVuc2lvbi1rb25pLy4uLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL21vZGVsLXZpZXdlci9saWIvdGhyZWUtY29tcG9uZW50cy9FbnZpcm9ubWVudFNjZW5lLmpzIiwid2VicGFjazovL0BzdWJ3YWxsZXQvZXh0ZW5zaW9uLWtvbmkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvbW9kZWwtdmlld2VyL2xpYi90aHJlZS1jb21wb25lbnRzL0Vudmlyb25tZW50U2NlbmVBbHQuanMiLCJ3ZWJwYWNrOi8vQHN1YndhbGxldC9leHRlbnNpb24ta29uaS8uLi8uLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9tb2RlbC12aWV3ZXIvbGliL3RocmVlLWNvbXBvbmVudHMvR0xURkluc3RhbmNlLmpzIiwid2VicGFjazovL0BzdWJ3YWxsZXQvZXh0ZW5zaW9uLWtvbmkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvbW9kZWwtdmlld2VyL2xpYi90aHJlZS1jb21wb25lbnRzL0hvdHNwb3QuanMiLCJ3ZWJwYWNrOi8vQHN1YndhbGxldC9leHRlbnNpb24ta29uaS8uLi8uLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9tb2RlbC12aWV3ZXIvbGliL3RocmVlLWNvbXBvbmVudHMvTW9kZWxTY2VuZS5qcyIsIndlYnBhY2s6Ly9Ac3Vid2FsbGV0L2V4dGVuc2lvbi1rb25pLy4uLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL21vZGVsLXZpZXdlci9saWIvdGhyZWUtY29tcG9uZW50cy9QbGFjZW1lbnRCb3guanMiLCJ3ZWJwYWNrOi8vQHN1YndhbGxldC9leHRlbnNpb24ta29uaS8uLi8uLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9tb2RlbC12aWV3ZXIvbGliL3RocmVlLWNvbXBvbmVudHMvUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vQHN1YndhbGxldC9leHRlbnNpb24ta29uaS8uLi8uLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9tb2RlbC12aWV3ZXIvbGliL3RocmVlLWNvbXBvbmVudHMvU2hhZG93LmpzIiwid2VicGFjazovL0BzdWJ3YWxsZXQvZXh0ZW5zaW9uLWtvbmkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvbW9kZWwtdmlld2VyL2xpYi90aHJlZS1jb21wb25lbnRzL1Ntb290aENvbnRyb2xzLmpzIiwid2VicGFjazovL0BzdWJ3YWxsZXQvZXh0ZW5zaW9uLWtvbmkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvbW9kZWwtdmlld2VyL2xpYi90aHJlZS1jb21wb25lbnRzL1RleHR1cmVVdGlscy5qcyIsIndlYnBhY2s6Ly9Ac3Vid2FsbGV0L2V4dGVuc2lvbi1rb25pLy4uLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL21vZGVsLXZpZXdlci9saWIvdGhyZWUtY29tcG9uZW50cy9nbHRmLWluc3RhbmNlL01vZGVsVmlld2VyR0xURkluc3RhbmNlLmpzIiwid2VicGFjazovL0BzdWJ3YWxsZXQvZXh0ZW5zaW9uLWtvbmkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvbW9kZWwtdmlld2VyL2xpYi90aHJlZS1jb21wb25lbnRzL2dsdGYtaW5zdGFuY2UvVmFyaWFudE1hdGVyaWFsRXhwb3J0ZXJQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vQHN1YndhbGxldC9leHRlbnNpb24ta29uaS8uLi8uLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9tb2RlbC12aWV3ZXIvbGliL3RocmVlLWNvbXBvbmVudHMvZ2x0Zi1pbnN0YW5jZS9WYXJpYW50TWF0ZXJpYWxMb2FkZXJQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vQHN1YndhbGxldC9leHRlbnNpb24ta29uaS8uLi8uLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9tb2RlbC12aWV3ZXIvbGliL3RocmVlLWNvbXBvbmVudHMvZ2x0Zi1pbnN0YW5jZS9jb3JyZWxhdGVkLXNjZW5lLWdyYXBoLmpzIiwid2VicGFjazovL0BzdWJ3YWxsZXQvZXh0ZW5zaW9uLWtvbmkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvbW9kZWwtdmlld2VyL2xpYi90aHJlZS1jb21wb25lbnRzL2dsdGYtaW5zdGFuY2UvZ2x0Zi0yLjAuanMiLCJ3ZWJwYWNrOi8vQHN1YndhbGxldC9leHRlbnNpb24ta29uaS8uLi8uLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9tb2RlbC12aWV3ZXIvbGliL3V0aWxpdGllcy5qcyIsIndlYnBhY2s6Ly9Ac3Vid2FsbGV0L2V4dGVuc2lvbi1rb25pLy4uLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL21vZGVsLXZpZXdlci9saWIvdXRpbGl0aWVzL2FuaW1hdGlvbi5qcyIsIndlYnBhY2s6Ly9Ac3Vid2FsbGV0L2V4dGVuc2lvbi1rb25pLy4uLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL21vZGVsLXZpZXdlci9saWIvdXRpbGl0aWVzL2NhY2hlLWV2aWN0aW9uLXBvbGljeS5qcyIsIndlYnBhY2s6Ly9Ac3Vid2FsbGV0L2V4dGVuc2lvbi1rb25pLy4uLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL21vZGVsLXZpZXdlci9saWIvdXRpbGl0aWVzL2RhdGEtY29udmVyc2lvbi5qcyIsIndlYnBhY2s6Ly9Ac3Vid2FsbGV0L2V4dGVuc2lvbi1rb25pLy4uLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL21vZGVsLXZpZXdlci9saWIvdXRpbGl0aWVzL3Byb2dyZXNzLXRyYWNrZXIuanMiLCJ3ZWJwYWNrOi8vQHN1YndhbGxldC9leHRlbnNpb24ta29uaS8uLi8uLi9ub2RlX21vZHVsZXMvZG9tLWFsaWduL2Rpc3Qtd2ViL2luZGV4LmpzIiwid2VicGFjazovL0BzdWJ3YWxsZXQvZXh0ZW5zaW9uLWtvbmkvLi4vLi4vbm9kZV9tb2R1bGVzL2RvbS1oZWxwZXJzL2VzbS9hZGRDbGFzcy5qcyIsIndlYnBhY2s6Ly9Ac3Vid2FsbGV0L2V4dGVuc2lvbi1rb25pLy4uLy4uL25vZGVfbW9kdWxlcy9kb20taGVscGVycy9lc20vaGFzQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vQHN1YndhbGxldC9leHRlbnNpb24ta29uaS8uLi8uLi9ub2RlX21vZHVsZXMvZG9tLWhlbHBlcnMvZXNtL3JlbW92ZUNsYXNzLmpzIiwid2VicGFjazovL0BzdWJ3YWxsZXQvZXh0ZW5zaW9uLWtvbmkvLi4vLi4vbm9kZV9tb2R1bGVzL2V0aGVyZXVtLWJsb2NraWVzLWJhc2U2NC9kaXN0L21haW4uanMiLCJ3ZWJwYWNrOi8vQHN1YndhbGxldC9leHRlbnNpb24ta29uaS8uLi8uLi9ub2RlX21vZHVsZXMvZmlsZS1zYXZlci9kaXN0L0ZpbGVTYXZlci5taW4uanMiLCJ3ZWJwYWNrOi8vQHN1YndhbGxldC9leHRlbnNpb24ta29uaS8uLi8uLi9ub2RlX21vZHVsZXMvZmxhdGxpc3QtcmVhY3QvbGliL19fX3N1YkNvbXBvbmVudHMvRGVmYXVsdEJsYW5rLmpzIiwid2VicGFjazovL0BzdWJ3YWxsZXQvZXh0ZW5zaW9uLWtvbmkvLi4vLi4vbm9kZV9tb2R1bGVzL2ZsYXRsaXN0LXJlYWN0L2xpYi9fX19zdWJDb21wb25lbnRzL0RlZmF1bHRMb2FkSW5kaWNhdG9yLmpzIiwid2VicGFjazovL0BzdWJ3YWxsZXQvZXh0ZW5zaW9uLWtvbmkvLi4vLi4vbm9kZV9tb2R1bGVzL2ZsYXRsaXN0LXJlYWN0L2xpYi9fX19zdWJDb21wb25lbnRzL0Rpc3BsYXlIYW5kbGVyLmpzIiwid2VicGFjazovL0BzdWJ3YWxsZXQvZXh0ZW5zaW9uLWtvbmkvLi4vLi4vbm9kZV9tb2R1bGVzL2ZsYXRsaXN0LXJlYWN0L2xpYi9fX19zdWJDb21wb25lbnRzL0luZmluaXRlTG9hZGVyLmpzIiwid2VicGFjazovL0BzdWJ3YWxsZXQvZXh0ZW5zaW9uLWtvbmkvLi4vLi4vbm9kZV9tb2R1bGVzL2ZsYXRsaXN0LXJlYWN0L2xpYi9fX19zdWJDb21wb25lbnRzL1BsYWluTGlzdC5qcyIsIndlYnBhY2s6Ly9Ac3Vid2FsbGV0L2V4dGVuc2lvbi1rb25pLy4uLy4uL25vZGVfbW9kdWxlcy9mbGF0bGlzdC1yZWFjdC9saWIvX19fc3ViQ29tcG9uZW50cy9TY3JvbGxSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly9Ac3Vid2FsbGV0L2V4dGVuc2lvbi1rb25pLy4uLy4uL25vZGVfbW9kdWxlcy9mbGF0bGlzdC1yZWFjdC9saWIvX19fc3ViQ29tcG9uZW50cy9TY3JvbGxUb1RvcEJ1dHRvbi5qcyIsIndlYnBhY2s6Ly9Ac3Vid2FsbGV0L2V4dGVuc2lvbi1rb25pLy4uLy4uL25vZGVfbW9kdWxlcy9mbGF0bGlzdC1yZWFjdC9saWIvX19fc3ViQ29tcG9uZW50cy91aUZ1bmN0aW9ucy5qcyIsIndlYnBhY2s6Ly9Ac3Vid2FsbGV0L2V4dGVuc2lvbi1rb25pLy4uLy4uL25vZGVfbW9kdWxlcy9mbGF0bGlzdC1yZWFjdC9saWIvX19fdXRpbHMvY29udmVydExpc3RUb0FycmF5LmpzIiwid2VicGFjazovL0BzdWJ3YWxsZXQvZXh0ZW5zaW9uLWtvbmkvLi4vLi4vbm9kZV9tb2R1bGVzL2ZsYXRsaXN0LXJlYWN0L2xpYi9fX191dGlscy9jb252ZXJ0TWFwVG9PYmplY3QuanMiLCJ3ZWJwYWNrOi8vQHN1YndhbGxldC9leHRlbnNpb24ta29uaS8uLi8uLi9ub2RlX21vZHVsZXMvZmxhdGxpc3QtcmVhY3QvbGliL19fX3V0aWxzL2ZpbHRlckxpc3QuanMiLCJ3ZWJwYWNrOi8vQHN1YndhbGxldC9leHRlbnNpb24ta29uaS8uLi8uLi9ub2RlX21vZHVsZXMvZmxhdGxpc3QtcmVhY3QvbGliL19fX3V0aWxzL2dldE9iamVjdERlZXBLZXlWYWx1ZS5qcyIsIndlYnBhY2s6Ly9Ac3Vid2FsbGV0L2V4dGVuc2lvbi1rb25pLy4uLy4uL25vZGVfbW9kdWxlcy9mbGF0bGlzdC1yZWFjdC9saWIvX19fdXRpbHMvZ2V0VHlwZS5qcyIsIndlYnBhY2s6Ly9Ac3Vid2FsbGV0L2V4dGVuc2lvbi1rb25pLy4uLy4uL25vZGVfbW9kdWxlcy9mbGF0bGlzdC1yZWFjdC9saWIvX19fdXRpbHMvZ3JvdXBMaXN0LmpzIiwid2VicGFjazovL0BzdWJ3YWxsZXQvZXh0ZW5zaW9uLWtvbmkvLi4vLi4vbm9kZV9tb2R1bGVzL2ZsYXRsaXN0LXJlYWN0L2xpYi9fX191dGlscy9pc1R5cGUuanMiLCJ3ZWJwYWNrOi8vQHN1YndhbGxldC9leHRlbnNpb24ta29uaS8uLi8uLi9ub2RlX21vZHVsZXMvZmxhdGxpc3QtcmVhY3QvbGliL19fX3V0aWxzL2xpbWl0TGlzdC5qcyIsIndlYnBhY2s6Ly9Ac3Vid2FsbGV0L2V4dGVuc2lvbi1rb25pLy4uLy4uL25vZGVfbW9kdWxlcy9mbGF0bGlzdC1yZWFjdC9saWIvX19fdXRpbHMvcmV2ZXJzZUxpc3QuanMiLCJ3ZWJwYWNrOi8vQHN1YndhbGxldC9leHRlbnNpb24ta29uaS8uLi8uLi9ub2RlX21vZHVsZXMvZmxhdGxpc3QtcmVhY3QvbGliL19fX3V0aWxzL3NlYXJjaExpc3QuanMiLCJ3ZWJwYWNrOi8vQHN1YndhbGxldC9leHRlbnNpb24ta29uaS8uLi8uLi9ub2RlX21vZHVsZXMvZmxhdGxpc3QtcmVhY3QvbGliL19fX3V0aWxzL3NvcnRMaXN0LmpzIiwid2VicGFjazovL0BzdWJ3YWxsZXQvZXh0ZW5zaW9uLWtvbmkvLi4vLi4vbm9kZV9tb2R1bGVzL2ZsYXRsaXN0LXJlYWN0L2xpYi9mbGF0TGlzdFByb3BzLmpzIiwid2VicGFjazovL0BzdWJ3YWxsZXQvZXh0ZW5zaW9uLWtvbmkvLi4vLi4vbm9kZV9tb2R1bGVzL2ZsYXRsaXN0LXJlYWN0L2xpYi9mbGF0bGlzdC1yZWFjdC5qcyIsIndlYnBhY2s6Ly9Ac3Vid2FsbGV0L2V4dGVuc2lvbi1rb25pLy4uLy4uL25vZGVfbW9kdWxlcy9mbGF0bGlzdC1yZWFjdC9saWIvaG9va3MvdXNlLWxpc3QuanMiLCJ3ZWJwYWNrOi8vQHN1YndhbGxldC9leHRlbnNpb24ta29uaS8uLi8uLi9ub2RlX21vZHVsZXMvZmxhdGxpc3QtcmVhY3QvbGliL2luZGV4LmpzIiwid2VicGFjazovL0BzdWJ3YWxsZXQvZXh0ZW5zaW9uLWtvbmkvLi4vLi4vbm9kZV9tb2R1bGVzL2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzL2Rpc3QvaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MuY2pzLmpzIiwid2VicGFjazovL0BzdWJ3YWxsZXQvZXh0ZW5zaW9uLWtvbmkvLi4vLi4vbm9kZV9tb2R1bGVzL2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMiLCJ3ZWJwYWNrOi8vQHN1YndhbGxldC9leHRlbnNpb24ta29uaS8uLi8uLi9ub2RlX21vZHVsZXMvaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3Mvbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2luZGV4LmpzIiwid2VicGFjazovL0BzdWJ3YWxsZXQvZXh0ZW5zaW9uLWtvbmkvLi4vLi4vbm9kZV9tb2R1bGVzL2h0bWwtcGFyc2Utc3RyaW5naWZ5L2Rpc3QvaHRtbC1wYXJzZS1zdHJpbmdpZnkubW9kdWxlLmpzIiwid2VicGFjazovL0BzdWJ3YWxsZXQvZXh0ZW5zaW9uLWtvbmkvLi4vLi4vbm9kZV9tb2R1bGVzL2ltbWVyL2Rpc3QvaW1tZXIuY2pzLmRldmVsb3BtZW50LmpzIiwid2VicGFjazovL0BzdWJ3YWxsZXQvZXh0ZW5zaW9uLWtvbmkvLi4vLi4vbm9kZV9tb2R1bGVzL2ltbWVyL2Rpc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQHN1YndhbGxldC9leHRlbnNpb24ta29uaS8uLi8uLi9ub2RlX21vZHVsZXMvQGZvcnRhd2Vzb21lL2ZvbnRhd2Vzb21lLXN2Zy1jb3JlL2luZGV4Lm1qcyIsIndlYnBhY2s6Ly9Ac3Vid2FsbGV0L2V4dGVuc2lvbi1rb25pLy4uLy4uL25vZGVfbW9kdWxlcy9pbW1lci9kaXN0L2ltbWVyLmVzbS5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG1lbW9pemUgZnJvbSAnQGVtb3Rpb24vbWVtb2l6ZSc7XG5cbnZhciByZWFjdFByb3BzUmVnZXggPSAvXigoY2hpbGRyZW58ZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUx8a2V5fHJlZnxhdXRvRm9jdXN8ZGVmYXVsdFZhbHVlfGRlZmF1bHRDaGVja2VkfGlubmVySFRNTHxzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmd8c3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nfHZhbHVlTGlua3xhYmJyfGFjY2VwdHxhY2NlcHRDaGFyc2V0fGFjY2Vzc0tleXxhY3Rpb258YWxsb3d8YWxsb3dVc2VyTWVkaWF8YWxsb3dQYXltZW50UmVxdWVzdHxhbGxvd0Z1bGxTY3JlZW58YWxsb3dUcmFuc3BhcmVuY3l8YWx0fGFzeW5jfGF1dG9Db21wbGV0ZXxhdXRvUGxheXxjYXB0dXJlfGNlbGxQYWRkaW5nfGNlbGxTcGFjaW5nfGNoYWxsZW5nZXxjaGFyU2V0fGNoZWNrZWR8Y2l0ZXxjbGFzc0lEfGNsYXNzTmFtZXxjb2xzfGNvbFNwYW58Y29udGVudHxjb250ZW50RWRpdGFibGV8Y29udGV4dE1lbnV8Y29udHJvbHN8Y29udHJvbHNMaXN0fGNvb3Jkc3xjcm9zc09yaWdpbnxkYXRhfGRhdGVUaW1lfGRlY29kaW5nfGRlZmF1bHR8ZGVmZXJ8ZGlyfGRpc2FibGVkfGRpc2FibGVQaWN0dXJlSW5QaWN0dXJlfGRvd25sb2FkfGRyYWdnYWJsZXxlbmNUeXBlfGVudGVyS2V5SGludHxmb3JtfGZvcm1BY3Rpb258Zm9ybUVuY1R5cGV8Zm9ybU1ldGhvZHxmb3JtTm9WYWxpZGF0ZXxmb3JtVGFyZ2V0fGZyYW1lQm9yZGVyfGhlYWRlcnN8aGVpZ2h0fGhpZGRlbnxoaWdofGhyZWZ8aHJlZkxhbmd8aHRtbEZvcnxodHRwRXF1aXZ8aWR8aW5wdXRNb2RlfGludGVncml0eXxpc3xrZXlQYXJhbXN8a2V5VHlwZXxraW5kfGxhYmVsfGxhbmd8bGlzdHxsb2FkaW5nfGxvb3B8bG93fG1hcmdpbkhlaWdodHxtYXJnaW5XaWR0aHxtYXh8bWF4TGVuZ3RofG1lZGlhfG1lZGlhR3JvdXB8bWV0aG9kfG1pbnxtaW5MZW5ndGh8bXVsdGlwbGV8bXV0ZWR8bmFtZXxub25jZXxub1ZhbGlkYXRlfG9wZW58b3B0aW11bXxwYXR0ZXJufHBsYWNlaG9sZGVyfHBsYXlzSW5saW5lfHBvc3RlcnxwcmVsb2FkfHByb2ZpbGV8cmFkaW9Hcm91cHxyZWFkT25seXxyZWZlcnJlclBvbGljeXxyZWx8cmVxdWlyZWR8cmV2ZXJzZWR8cm9sZXxyb3dzfHJvd1NwYW58c2FuZGJveHxzY29wZXxzY29wZWR8c2Nyb2xsaW5nfHNlYW1sZXNzfHNlbGVjdGVkfHNoYXBlfHNpemV8c2l6ZXN8c2xvdHxzcGFufHNwZWxsQ2hlY2t8c3JjfHNyY0RvY3xzcmNMYW5nfHNyY1NldHxzdGFydHxzdGVwfHN0eWxlfHN1bW1hcnl8dGFiSW5kZXh8dGFyZ2V0fHRpdGxlfHRyYW5zbGF0ZXx0eXBlfHVzZU1hcHx2YWx1ZXx3aWR0aHx3bW9kZXx3cmFwfGFib3V0fGRhdGF0eXBlfGlubGlzdHxwcmVmaXh8cHJvcGVydHl8cmVzb3VyY2V8dHlwZW9mfHZvY2FifGF1dG9DYXBpdGFsaXplfGF1dG9Db3JyZWN0fGF1dG9TYXZlfGNvbG9yfGluY3JlbWVudGFsfGZhbGxiYWNrfGluZXJ0fGl0ZW1Qcm9wfGl0ZW1TY29wZXxpdGVtVHlwZXxpdGVtSUR8aXRlbVJlZnxvbnxvcHRpb258cmVzdWx0c3xzZWN1cml0eXx1bnNlbGVjdGFibGV8YWNjZW50SGVpZ2h0fGFjY3VtdWxhdGV8YWRkaXRpdmV8YWxpZ25tZW50QmFzZWxpbmV8YWxsb3dSZW9yZGVyfGFscGhhYmV0aWN8YW1wbGl0dWRlfGFyYWJpY0Zvcm18YXNjZW50fGF0dHJpYnV0ZU5hbWV8YXR0cmlidXRlVHlwZXxhdXRvUmV2ZXJzZXxhemltdXRofGJhc2VGcmVxdWVuY3l8YmFzZWxpbmVTaGlmdHxiYXNlUHJvZmlsZXxiYm94fGJlZ2lufGJpYXN8Ynl8Y2FsY01vZGV8Y2FwSGVpZ2h0fGNsaXB8Y2xpcFBhdGhVbml0c3xjbGlwUGF0aHxjbGlwUnVsZXxjb2xvckludGVycG9sYXRpb258Y29sb3JJbnRlcnBvbGF0aW9uRmlsdGVyc3xjb2xvclByb2ZpbGV8Y29sb3JSZW5kZXJpbmd8Y29udGVudFNjcmlwdFR5cGV8Y29udGVudFN0eWxlVHlwZXxjdXJzb3J8Y3h8Y3l8ZHxkZWNlbGVyYXRlfGRlc2NlbnR8ZGlmZnVzZUNvbnN0YW50fGRpcmVjdGlvbnxkaXNwbGF5fGRpdmlzb3J8ZG9taW5hbnRCYXNlbGluZXxkdXJ8ZHh8ZHl8ZWRnZU1vZGV8ZWxldmF0aW9ufGVuYWJsZUJhY2tncm91bmR8ZW5kfGV4cG9uZW50fGV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWR8ZmlsbHxmaWxsT3BhY2l0eXxmaWxsUnVsZXxmaWx0ZXJ8ZmlsdGVyUmVzfGZpbHRlclVuaXRzfGZsb29kQ29sb3J8Zmxvb2RPcGFjaXR5fGZvY3VzYWJsZXxmb250RmFtaWx5fGZvbnRTaXplfGZvbnRTaXplQWRqdXN0fGZvbnRTdHJldGNofGZvbnRTdHlsZXxmb250VmFyaWFudHxmb250V2VpZ2h0fGZvcm1hdHxmcm9tfGZyfGZ4fGZ5fGcxfGcyfGdseXBoTmFtZXxnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbHxnbHlwaE9yaWVudGF0aW9uVmVydGljYWx8Z2x5cGhSZWZ8Z3JhZGllbnRUcmFuc2Zvcm18Z3JhZGllbnRVbml0c3xoYW5naW5nfGhvcml6QWR2WHxob3Jpek9yaWdpblh8aWRlb2dyYXBoaWN8aW1hZ2VSZW5kZXJpbmd8aW58aW4yfGludGVyY2VwdHxrfGsxfGsyfGszfGs0fGtlcm5lbE1hdHJpeHxrZXJuZWxVbml0TGVuZ3RofGtlcm5pbmd8a2V5UG9pbnRzfGtleVNwbGluZXN8a2V5VGltZXN8bGVuZ3RoQWRqdXN0fGxldHRlclNwYWNpbmd8bGlnaHRpbmdDb2xvcnxsaW1pdGluZ0NvbmVBbmdsZXxsb2NhbHxtYXJrZXJFbmR8bWFya2VyTWlkfG1hcmtlclN0YXJ0fG1hcmtlckhlaWdodHxtYXJrZXJVbml0c3xtYXJrZXJXaWR0aHxtYXNrfG1hc2tDb250ZW50VW5pdHN8bWFza1VuaXRzfG1hdGhlbWF0aWNhbHxtb2RlfG51bU9jdGF2ZXN8b2Zmc2V0fG9wYWNpdHl8b3BlcmF0b3J8b3JkZXJ8b3JpZW50fG9yaWVudGF0aW9ufG9yaWdpbnxvdmVyZmxvd3xvdmVybGluZVBvc2l0aW9ufG92ZXJsaW5lVGhpY2tuZXNzfHBhbm9zZTF8cGFpbnRPcmRlcnxwYXRoTGVuZ3RofHBhdHRlcm5Db250ZW50VW5pdHN8cGF0dGVyblRyYW5zZm9ybXxwYXR0ZXJuVW5pdHN8cG9pbnRlckV2ZW50c3xwb2ludHN8cG9pbnRzQXRYfHBvaW50c0F0WXxwb2ludHNBdFp8cHJlc2VydmVBbHBoYXxwcmVzZXJ2ZUFzcGVjdFJhdGlvfHByaW1pdGl2ZVVuaXRzfHJ8cmFkaXVzfHJlZlh8cmVmWXxyZW5kZXJpbmdJbnRlbnR8cmVwZWF0Q291bnR8cmVwZWF0RHVyfHJlcXVpcmVkRXh0ZW5zaW9uc3xyZXF1aXJlZEZlYXR1cmVzfHJlc3RhcnR8cmVzdWx0fHJvdGF0ZXxyeHxyeXxzY2FsZXxzZWVkfHNoYXBlUmVuZGVyaW5nfHNsb3BlfHNwYWNpbmd8c3BlY3VsYXJDb25zdGFudHxzcGVjdWxhckV4cG9uZW50fHNwZWVkfHNwcmVhZE1ldGhvZHxzdGFydE9mZnNldHxzdGREZXZpYXRpb258c3RlbWh8c3RlbXZ8c3RpdGNoVGlsZXN8c3RvcENvbG9yfHN0b3BPcGFjaXR5fHN0cmlrZXRocm91Z2hQb3NpdGlvbnxzdHJpa2V0aHJvdWdoVGhpY2tuZXNzfHN0cmluZ3xzdHJva2V8c3Ryb2tlRGFzaGFycmF5fHN0cm9rZURhc2hvZmZzZXR8c3Ryb2tlTGluZWNhcHxzdHJva2VMaW5lam9pbnxzdHJva2VNaXRlcmxpbWl0fHN0cm9rZU9wYWNpdHl8c3Ryb2tlV2lkdGh8c3VyZmFjZVNjYWxlfHN5c3RlbUxhbmd1YWdlfHRhYmxlVmFsdWVzfHRhcmdldFh8dGFyZ2V0WXx0ZXh0QW5jaG9yfHRleHREZWNvcmF0aW9ufHRleHRSZW5kZXJpbmd8dGV4dExlbmd0aHx0b3x0cmFuc2Zvcm18dTF8dTJ8dW5kZXJsaW5lUG9zaXRpb258dW5kZXJsaW5lVGhpY2tuZXNzfHVuaWNvZGV8dW5pY29kZUJpZGl8dW5pY29kZVJhbmdlfHVuaXRzUGVyRW18dkFscGhhYmV0aWN8dkhhbmdpbmd8dklkZW9ncmFwaGljfHZNYXRoZW1hdGljYWx8dmFsdWVzfHZlY3RvckVmZmVjdHx2ZXJzaW9ufHZlcnRBZHZZfHZlcnRPcmlnaW5YfHZlcnRPcmlnaW5ZfHZpZXdCb3h8dmlld1RhcmdldHx2aXNpYmlsaXR5fHdpZHRoc3x3b3JkU3BhY2luZ3x3cml0aW5nTW9kZXx4fHhIZWlnaHR8eDF8eDJ8eENoYW5uZWxTZWxlY3Rvcnx4bGlua0FjdHVhdGV8eGxpbmtBcmNyb2xlfHhsaW5rSHJlZnx4bGlua1JvbGV8eGxpbmtTaG93fHhsaW5rVGl0bGV8eGxpbmtUeXBlfHhtbEJhc2V8eG1sbnN8eG1sbnNYbGlua3x4bWxMYW5nfHhtbFNwYWNlfHl8eTF8eTJ8eUNoYW5uZWxTZWxlY3Rvcnx6fHpvb21BbmRQYW58Zm9yfGNsYXNzfGF1dG9mb2N1cyl8KChbRGRdW0FhXVtUdF1bQWFdfFtBYV1bUnJdW0lpXVtBYV18eCktLiopKSQvOyAvLyBodHRwczovL2VzYmVuY2guY29tL2JlbmNoLzViZmVlNjhhNGNkN2U2MDA5ZWY2MWQyM1xuXG52YXIgaXNQcm9wVmFsaWQgPSAvKiAjX19QVVJFX18gKi9tZW1vaXplKGZ1bmN0aW9uIChwcm9wKSB7XG4gIHJldHVybiByZWFjdFByb3BzUmVnZXgudGVzdChwcm9wKSB8fCBwcm9wLmNoYXJDb2RlQXQoMCkgPT09IDExMVxuICAvKiBvICovXG4gICYmIHByb3AuY2hhckNvZGVBdCgxKSA9PT0gMTEwXG4gIC8qIG4gKi9cbiAgJiYgcHJvcC5jaGFyQ29kZUF0KDIpIDwgOTE7XG59XG4vKiBaKzEgKi9cbik7XG5cbmV4cG9ydCBkZWZhdWx0IGlzUHJvcFZhbGlkO1xuIiwiZnVuY3Rpb24gbWVtb2l6ZShmbikge1xuICB2YXIgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gZnVuY3Rpb24gKGFyZykge1xuICAgIGlmIChjYWNoZVthcmddID09PSB1bmRlZmluZWQpIGNhY2hlW2FyZ10gPSBmbihhcmcpO1xuICAgIHJldHVybiBjYWNoZVthcmddO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBtZW1vaXplO1xuIiwiZnVuY3Rpb24gc3R5bGlzX21pbiAoVykge1xuICBmdW5jdGlvbiBNKGQsIGMsIGUsIGgsIGEpIHtcbiAgICBmb3IgKHZhciBtID0gMCwgYiA9IDAsIHYgPSAwLCBuID0gMCwgcSwgZywgeCA9IDAsIEsgPSAwLCBrLCB1ID0gayA9IHEgPSAwLCBsID0gMCwgciA9IDAsIEkgPSAwLCB0ID0gMCwgQiA9IGUubGVuZ3RoLCBKID0gQiAtIDEsIHksIGYgPSAnJywgcCA9ICcnLCBGID0gJycsIEcgPSAnJywgQzsgbCA8IEI7KSB7XG4gICAgICBnID0gZS5jaGFyQ29kZUF0KGwpO1xuICAgICAgbCA9PT0gSiAmJiAwICE9PSBiICsgbiArIHYgKyBtICYmICgwICE9PSBiICYmIChnID0gNDcgPT09IGIgPyAxMCA6IDQ3KSwgbiA9IHYgPSBtID0gMCwgQisrLCBKKyspO1xuXG4gICAgICBpZiAoMCA9PT0gYiArIG4gKyB2ICsgbSkge1xuICAgICAgICBpZiAobCA9PT0gSiAmJiAoMCA8IHIgJiYgKGYgPSBmLnJlcGxhY2UoTiwgJycpKSwgMCA8IGYudHJpbSgpLmxlbmd0aCkpIHtcbiAgICAgICAgICBzd2l0Y2ggKGcpIHtcbiAgICAgICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBjYXNlIDU5OlxuICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBmICs9IGUuY2hhckF0KGwpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGcgPSA1OTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoZykge1xuICAgICAgICAgIGNhc2UgMTIzOlxuICAgICAgICAgICAgZiA9IGYudHJpbSgpO1xuICAgICAgICAgICAgcSA9IGYuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgIGsgPSAxO1xuXG4gICAgICAgICAgICBmb3IgKHQgPSArK2w7IGwgPCBCOykge1xuICAgICAgICAgICAgICBzd2l0Y2ggKGcgPSBlLmNoYXJDb2RlQXQobCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDEyMzpcbiAgICAgICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAxMjU6XG4gICAgICAgICAgICAgICAgICBrLS07XG4gICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgNDc6XG4gICAgICAgICAgICAgICAgICBzd2l0Y2ggKGcgPSBlLmNoYXJDb2RlQXQobCArIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDc6XG4gICAgICAgICAgICAgICAgICAgICAgYToge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh1ID0gbCArIDE7IHUgPCBKOyArK3UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChlLmNoYXJDb2RlQXQodSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKDQyID09PSBnICYmIDQyID09PSBlLmNoYXJDb2RlQXQodSAtIDEpICYmIGwgKyAyICE9PSB1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwgPSB1ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKDQ3ID09PSBnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwgPSB1ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGwgPSB1O1xuICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgOTE6XG4gICAgICAgICAgICAgICAgICBnKys7XG5cbiAgICAgICAgICAgICAgICBjYXNlIDQwOlxuICAgICAgICAgICAgICAgICAgZysrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICAgICAgICBjYXNlIDM5OlxuICAgICAgICAgICAgICAgICAgZm9yICg7IGwrKyA8IEogJiYgZS5jaGFyQ29kZUF0KGwpICE9PSBnOykge1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoMCA9PT0gaykgYnJlYWs7XG4gICAgICAgICAgICAgIGwrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgayA9IGUuc3Vic3RyaW5nKHQsIGwpO1xuICAgICAgICAgICAgMCA9PT0gcSAmJiAocSA9IChmID0gZi5yZXBsYWNlKGNhLCAnJykudHJpbSgpKS5jaGFyQ29kZUF0KDApKTtcblxuICAgICAgICAgICAgc3dpdGNoIChxKSB7XG4gICAgICAgICAgICAgIGNhc2UgNjQ6XG4gICAgICAgICAgICAgICAgMCA8IHIgJiYgKGYgPSBmLnJlcGxhY2UoTiwgJycpKTtcbiAgICAgICAgICAgICAgICBnID0gZi5jaGFyQ29kZUF0KDEpO1xuXG4gICAgICAgICAgICAgICAgc3dpdGNoIChnKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDEwMDpcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTA5OlxuICAgICAgICAgICAgICAgICAgY2FzZSAxMTU6XG4gICAgICAgICAgICAgICAgICBjYXNlIDQ1OlxuICAgICAgICAgICAgICAgICAgICByID0gYztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHIgPSBPO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGsgPSBNKGMsIHIsIGssIGcsIGEgKyAxKTtcbiAgICAgICAgICAgICAgICB0ID0gay5sZW5ndGg7XG4gICAgICAgICAgICAgICAgMCA8IEEgJiYgKHIgPSBYKE8sIGYsIEkpLCBDID0gSCgzLCBrLCByLCBjLCBELCB6LCB0LCBnLCBhLCBoKSwgZiA9IHIuam9pbignJyksIHZvaWQgMCAhPT0gQyAmJiAwID09PSAodCA9IChrID0gQy50cmltKCkpLmxlbmd0aCkgJiYgKGcgPSAwLCBrID0gJycpKTtcbiAgICAgICAgICAgICAgICBpZiAoMCA8IHQpIHN3aXRjaCAoZykge1xuICAgICAgICAgICAgICAgICAgY2FzZSAxMTU6XG4gICAgICAgICAgICAgICAgICAgIGYgPSBmLnJlcGxhY2UoZGEsIGVhKTtcblxuICAgICAgICAgICAgICAgICAgY2FzZSAxMDA6XG4gICAgICAgICAgICAgICAgICBjYXNlIDEwOTpcbiAgICAgICAgICAgICAgICAgIGNhc2UgNDU6XG4gICAgICAgICAgICAgICAgICAgIGsgPSBmICsgJ3snICsgayArICd9JztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgIGNhc2UgMTA3OlxuICAgICAgICAgICAgICAgICAgICBmID0gZi5yZXBsYWNlKGZhLCAnJDEgJDInKTtcbiAgICAgICAgICAgICAgICAgICAgayA9IGYgKyAneycgKyBrICsgJ30nO1xuICAgICAgICAgICAgICAgICAgICBrID0gMSA9PT0gdyB8fCAyID09PSB3ICYmIEwoJ0AnICsgaywgMykgPyAnQC13ZWJraXQtJyArIGsgKyAnQCcgKyBrIDogJ0AnICsgaztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGsgPSBmICsgaywgMTEyID09PSBoICYmIChrID0gKHAgKz0gaywgJycpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgayA9ICcnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgayA9IE0oYywgWChjLCBmLCBJKSwgaywgaCwgYSArIDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBGICs9IGs7XG4gICAgICAgICAgICBrID0gSSA9IHIgPSB1ID0gcSA9IDA7XG4gICAgICAgICAgICBmID0gJyc7XG4gICAgICAgICAgICBnID0gZS5jaGFyQ29kZUF0KCsrbCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTI1OlxuICAgICAgICAgIGNhc2UgNTk6XG4gICAgICAgICAgICBmID0gKDAgPCByID8gZi5yZXBsYWNlKE4sICcnKSA6IGYpLnRyaW0oKTtcbiAgICAgICAgICAgIGlmICgxIDwgKHQgPSBmLmxlbmd0aCkpIHN3aXRjaCAoMCA9PT0gdSAmJiAocSA9IGYuY2hhckNvZGVBdCgwKSwgNDUgPT09IHEgfHwgOTYgPCBxICYmIDEyMyA+IHEpICYmICh0ID0gKGYgPSBmLnJlcGxhY2UoJyAnLCAnOicpKS5sZW5ndGgpLCAwIDwgQSAmJiB2b2lkIDAgIT09IChDID0gSCgxLCBmLCBjLCBkLCBELCB6LCBwLmxlbmd0aCwgaCwgYSwgaCkpICYmIDAgPT09ICh0ID0gKGYgPSBDLnRyaW0oKSkubGVuZ3RoKSAmJiAoZiA9ICdcXHgwMFxceDAwJyksIHEgPSBmLmNoYXJDb2RlQXQoMCksIGcgPSBmLmNoYXJDb2RlQXQoMSksIHEpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgNjQ6XG4gICAgICAgICAgICAgICAgaWYgKDEwNSA9PT0gZyB8fCA5OSA9PT0gZykge1xuICAgICAgICAgICAgICAgICAgRyArPSBmICsgZS5jaGFyQXQobCk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICA1OCAhPT0gZi5jaGFyQ29kZUF0KHQgLSAxKSAmJiAocCArPSBQKGYsIHEsIGcsIGYuY2hhckNvZGVBdCgyKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgSSA9IHIgPSB1ID0gcSA9IDA7XG4gICAgICAgICAgICBmID0gJyc7XG4gICAgICAgICAgICBnID0gZS5jaGFyQ29kZUF0KCsrbCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChnKSB7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgNDcgPT09IGIgPyBiID0gMCA6IDAgPT09IDEgKyBxICYmIDEwNyAhPT0gaCAmJiAwIDwgZi5sZW5ndGggJiYgKHIgPSAxLCBmICs9ICdcXHgwMCcpO1xuICAgICAgICAgIDAgPCBBICogWSAmJiBIKDAsIGYsIGMsIGQsIEQsIHosIHAubGVuZ3RoLCBoLCBhLCBoKTtcbiAgICAgICAgICB6ID0gMTtcbiAgICAgICAgICBEKys7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSA1OTpcbiAgICAgICAgY2FzZSAxMjU6XG4gICAgICAgICAgaWYgKDAgPT09IGIgKyBuICsgdiArIG0pIHtcbiAgICAgICAgICAgIHorKztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHorKztcbiAgICAgICAgICB5ID0gZS5jaGFyQXQobCk7XG5cbiAgICAgICAgICBzd2l0Y2ggKGcpIHtcbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgICAgIGlmICgwID09PSBuICsgbSArIGIpIHN3aXRjaCAoeCkge1xuICAgICAgICAgICAgICAgIGNhc2UgNDQ6XG4gICAgICAgICAgICAgICAgY2FzZSA1ODpcbiAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICAgICAgICAgIHkgPSAnJztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIDMyICE9PSBnICYmICh5ID0gJyAnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICB5ID0gJ1xcXFwwJztcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgIHkgPSAnXFxcXGYnO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgeSA9ICdcXFxcdic7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDM4OlxuICAgICAgICAgICAgICAwID09PSBuICsgYiArIG0gJiYgKHIgPSBJID0gMSwgeSA9ICdcXGYnICsgeSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDEwODpcbiAgICAgICAgICAgICAgaWYgKDAgPT09IG4gKyBiICsgbSArIEUgJiYgMCA8IHUpIHN3aXRjaCAobCAtIHUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAxMTIgPT09IHggJiYgNTggPT09IGUuY2hhckNvZGVBdChsIC0gMykgJiYgKEUgPSB4KTtcblxuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgIDExMSA9PT0gSyAmJiAoRSA9IEspO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDU4OlxuICAgICAgICAgICAgICAwID09PSBuICsgYiArIG0gJiYgKHUgPSBsKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgNDQ6XG4gICAgICAgICAgICAgIDAgPT09IGIgKyB2ICsgbiArIG0gJiYgKHIgPSAxLCB5ICs9ICdcXHInKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgICBjYXNlIDM5OlxuICAgICAgICAgICAgICAwID09PSBiICYmIChuID0gbiA9PT0gZyA/IDAgOiAwID09PSBuID8gZyA6IG4pO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA5MTpcbiAgICAgICAgICAgICAgMCA9PT0gbiArIGIgKyB2ICYmIG0rKztcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgOTM6XG4gICAgICAgICAgICAgIDAgPT09IG4gKyBiICsgdiAmJiBtLS07XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDQxOlxuICAgICAgICAgICAgICAwID09PSBuICsgYiArIG0gJiYgdi0tO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA0MDpcbiAgICAgICAgICAgICAgaWYgKDAgPT09IG4gKyBiICsgbSkge1xuICAgICAgICAgICAgICAgIGlmICgwID09PSBxKSBzd2l0Y2ggKDIgKiB4ICsgMyAqIEspIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgNTMzOlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHYrKztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDY0OlxuICAgICAgICAgICAgICAwID09PSBiICsgdiArIG4gKyBtICsgdSArIGsgJiYgKGsgPSAxKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgNDI6XG4gICAgICAgICAgICBjYXNlIDQ3OlxuICAgICAgICAgICAgICBpZiAoISgwIDwgbiArIG0gKyB2KSkgc3dpdGNoIChiKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgc3dpdGNoICgyICogZyArIDMgKiBlLmNoYXJDb2RlQXQobCArIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjM1OlxuICAgICAgICAgICAgICAgICAgICAgIGIgPSA0NztcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlIDIyMDpcbiAgICAgICAgICAgICAgICAgICAgICB0ID0gbCwgYiA9IDQyO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgNDI6XG4gICAgICAgICAgICAgICAgICA0NyA9PT0gZyAmJiA0MiA9PT0geCAmJiB0ICsgMiAhPT0gbCAmJiAoMzMgPT09IGUuY2hhckNvZGVBdCh0ICsgMikgJiYgKHAgKz0gZS5zdWJzdHJpbmcodCwgbCArIDEpKSwgeSA9ICcnLCBiID0gMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAwID09PSBiICYmIChmICs9IHkpO1xuICAgICAgfVxuXG4gICAgICBLID0geDtcbiAgICAgIHggPSBnO1xuICAgICAgbCsrO1xuICAgIH1cblxuICAgIHQgPSBwLmxlbmd0aDtcblxuICAgIGlmICgwIDwgdCkge1xuICAgICAgciA9IGM7XG4gICAgICBpZiAoMCA8IEEgJiYgKEMgPSBIKDIsIHAsIHIsIGQsIEQsIHosIHQsIGgsIGEsIGgpLCB2b2lkIDAgIT09IEMgJiYgMCA9PT0gKHAgPSBDKS5sZW5ndGgpKSByZXR1cm4gRyArIHAgKyBGO1xuICAgICAgcCA9IHIuam9pbignLCcpICsgJ3snICsgcCArICd9JztcblxuICAgICAgaWYgKDAgIT09IHcgKiBFKSB7XG4gICAgICAgIDIgIT09IHcgfHwgTChwLCAyKSB8fCAoRSA9IDApO1xuXG4gICAgICAgIHN3aXRjaCAoRSkge1xuICAgICAgICAgIGNhc2UgMTExOlxuICAgICAgICAgICAgcCA9IHAucmVwbGFjZShoYSwgJzotbW96LSQxJykgKyBwO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDExMjpcbiAgICAgICAgICAgIHAgPSBwLnJlcGxhY2UoUSwgJzo6LXdlYmtpdC1pbnB1dC0kMScpICsgcC5yZXBsYWNlKFEsICc6Oi1tb3otJDEnKSArIHAucmVwbGFjZShRLCAnOi1tcy1pbnB1dC0kMScpICsgcDtcbiAgICAgICAgfVxuXG4gICAgICAgIEUgPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBHICsgcCArIEY7XG4gIH1cblxuICBmdW5jdGlvbiBYKGQsIGMsIGUpIHtcbiAgICB2YXIgaCA9IGMudHJpbSgpLnNwbGl0KGlhKTtcbiAgICBjID0gaDtcbiAgICB2YXIgYSA9IGgubGVuZ3RoLFxuICAgICAgICBtID0gZC5sZW5ndGg7XG5cbiAgICBzd2l0Y2ggKG0pIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgdmFyIGIgPSAwO1xuXG4gICAgICAgIGZvciAoZCA9IDAgPT09IG0gPyAnJyA6IGRbMF0gKyAnICc7IGIgPCBhOyArK2IpIHtcbiAgICAgICAgICBjW2JdID0gWihkLCBjW2JdLCBlKS50cmltKCk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdmFyIHYgPSBiID0gMDtcblxuICAgICAgICBmb3IgKGMgPSBbXTsgYiA8IGE7ICsrYikge1xuICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgbTsgKytuKSB7XG4gICAgICAgICAgICBjW3YrK10gPSBaKGRbbl0gKyAnICcsIGhbYl0sIGUpLnRyaW0oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBjO1xuICB9XG5cbiAgZnVuY3Rpb24gWihkLCBjLCBlKSB7XG4gICAgdmFyIGggPSBjLmNoYXJDb2RlQXQoMCk7XG4gICAgMzMgPiBoICYmIChoID0gKGMgPSBjLnRyaW0oKSkuY2hhckNvZGVBdCgwKSk7XG5cbiAgICBzd2l0Y2ggKGgpIHtcbiAgICAgIGNhc2UgMzg6XG4gICAgICAgIHJldHVybiBjLnJlcGxhY2UoRiwgJyQxJyArIGQudHJpbSgpKTtcblxuICAgICAgY2FzZSA1ODpcbiAgICAgICAgcmV0dXJuIGQudHJpbSgpICsgYy5yZXBsYWNlKEYsICckMScgKyBkLnRyaW0oKSk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmICgwIDwgMSAqIGUgJiYgMCA8IGMuaW5kZXhPZignXFxmJykpIHJldHVybiBjLnJlcGxhY2UoRiwgKDU4ID09PSBkLmNoYXJDb2RlQXQoMCkgPyAnJyA6ICckMScpICsgZC50cmltKCkpO1xuICAgIH1cblxuICAgIHJldHVybiBkICsgYztcbiAgfVxuXG4gIGZ1bmN0aW9uIFAoZCwgYywgZSwgaCkge1xuICAgIHZhciBhID0gZCArICc7JyxcbiAgICAgICAgbSA9IDIgKiBjICsgMyAqIGUgKyA0ICogaDtcblxuICAgIGlmICg5NDQgPT09IG0pIHtcbiAgICAgIGQgPSBhLmluZGV4T2YoJzonLCA5KSArIDE7XG4gICAgICB2YXIgYiA9IGEuc3Vic3RyaW5nKGQsIGEubGVuZ3RoIC0gMSkudHJpbSgpO1xuICAgICAgYiA9IGEuc3Vic3RyaW5nKDAsIGQpLnRyaW0oKSArIGIgKyAnOyc7XG4gICAgICByZXR1cm4gMSA9PT0gdyB8fCAyID09PSB3ICYmIEwoYiwgMSkgPyAnLXdlYmtpdC0nICsgYiArIGIgOiBiO1xuICAgIH1cblxuICAgIGlmICgwID09PSB3IHx8IDIgPT09IHcgJiYgIUwoYSwgMSkpIHJldHVybiBhO1xuXG4gICAgc3dpdGNoIChtKSB7XG4gICAgICBjYXNlIDEwMTU6XG4gICAgICAgIHJldHVybiA5NyA9PT0gYS5jaGFyQ29kZUF0KDEwKSA/ICctd2Via2l0LScgKyBhICsgYSA6IGE7XG5cbiAgICAgIGNhc2UgOTUxOlxuICAgICAgICByZXR1cm4gMTE2ID09PSBhLmNoYXJDb2RlQXQoMykgPyAnLXdlYmtpdC0nICsgYSArIGEgOiBhO1xuXG4gICAgICBjYXNlIDk2MzpcbiAgICAgICAgcmV0dXJuIDExMCA9PT0gYS5jaGFyQ29kZUF0KDUpID8gJy13ZWJraXQtJyArIGEgKyBhIDogYTtcblxuICAgICAgY2FzZSAxMDA5OlxuICAgICAgICBpZiAoMTAwICE9PSBhLmNoYXJDb2RlQXQoNCkpIGJyZWFrO1xuXG4gICAgICBjYXNlIDk2OTpcbiAgICAgIGNhc2UgOTQyOlxuICAgICAgICByZXR1cm4gJy13ZWJraXQtJyArIGEgKyBhO1xuXG4gICAgICBjYXNlIDk3ODpcbiAgICAgICAgcmV0dXJuICctd2Via2l0LScgKyBhICsgJy1tb3otJyArIGEgKyBhO1xuXG4gICAgICBjYXNlIDEwMTk6XG4gICAgICBjYXNlIDk4MzpcbiAgICAgICAgcmV0dXJuICctd2Via2l0LScgKyBhICsgJy1tb3otJyArIGEgKyAnLW1zLScgKyBhICsgYTtcblxuICAgICAgY2FzZSA4ODM6XG4gICAgICAgIGlmICg0NSA9PT0gYS5jaGFyQ29kZUF0KDgpKSByZXR1cm4gJy13ZWJraXQtJyArIGEgKyBhO1xuICAgICAgICBpZiAoMCA8IGEuaW5kZXhPZignaW1hZ2Utc2V0KCcsIDExKSkgcmV0dXJuIGEucmVwbGFjZShqYSwgJyQxLXdlYmtpdC0kMicpICsgYTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgOTMyOlxuICAgICAgICBpZiAoNDUgPT09IGEuY2hhckNvZGVBdCg0KSkgc3dpdGNoIChhLmNoYXJDb2RlQXQoNSkpIHtcbiAgICAgICAgICBjYXNlIDEwMzpcbiAgICAgICAgICAgIHJldHVybiAnLXdlYmtpdC1ib3gtJyArIGEucmVwbGFjZSgnLWdyb3cnLCAnJykgKyAnLXdlYmtpdC0nICsgYSArICctbXMtJyArIGEucmVwbGFjZSgnZ3JvdycsICdwb3NpdGl2ZScpICsgYTtcblxuICAgICAgICAgIGNhc2UgMTE1OlxuICAgICAgICAgICAgcmV0dXJuICctd2Via2l0LScgKyBhICsgJy1tcy0nICsgYS5yZXBsYWNlKCdzaHJpbmsnLCAnbmVnYXRpdmUnKSArIGE7XG5cbiAgICAgICAgICBjYXNlIDk4OlxuICAgICAgICAgICAgcmV0dXJuICctd2Via2l0LScgKyBhICsgJy1tcy0nICsgYS5yZXBsYWNlKCdiYXNpcycsICdwcmVmZXJyZWQtc2l6ZScpICsgYTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJy13ZWJraXQtJyArIGEgKyAnLW1zLScgKyBhICsgYTtcblxuICAgICAgY2FzZSA5NjQ6XG4gICAgICAgIHJldHVybiAnLXdlYmtpdC0nICsgYSArICctbXMtZmxleC0nICsgYSArIGE7XG5cbiAgICAgIGNhc2UgMTAyMzpcbiAgICAgICAgaWYgKDk5ICE9PSBhLmNoYXJDb2RlQXQoOCkpIGJyZWFrO1xuICAgICAgICBiID0gYS5zdWJzdHJpbmcoYS5pbmRleE9mKCc6JywgMTUpKS5yZXBsYWNlKCdmbGV4LScsICcnKS5yZXBsYWNlKCdzcGFjZS1iZXR3ZWVuJywgJ2p1c3RpZnknKTtcbiAgICAgICAgcmV0dXJuICctd2Via2l0LWJveC1wYWNrJyArIGIgKyAnLXdlYmtpdC0nICsgYSArICctbXMtZmxleC1wYWNrJyArIGIgKyBhO1xuXG4gICAgICBjYXNlIDEwMDU6XG4gICAgICAgIHJldHVybiBrYS50ZXN0KGEpID8gYS5yZXBsYWNlKGFhLCAnOi13ZWJraXQtJykgKyBhLnJlcGxhY2UoYWEsICc6LW1vei0nKSArIGEgOiBhO1xuXG4gICAgICBjYXNlIDFlMzpcbiAgICAgICAgYiA9IGEuc3Vic3RyaW5nKDEzKS50cmltKCk7XG4gICAgICAgIGMgPSBiLmluZGV4T2YoJy0nKSArIDE7XG5cbiAgICAgICAgc3dpdGNoIChiLmNoYXJDb2RlQXQoMCkgKyBiLmNoYXJDb2RlQXQoYykpIHtcbiAgICAgICAgICBjYXNlIDIyNjpcbiAgICAgICAgICAgIGIgPSBhLnJlcGxhY2UoRywgJ3RiJyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMjMyOlxuICAgICAgICAgICAgYiA9IGEucmVwbGFjZShHLCAndGItcmwnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAyMjA6XG4gICAgICAgICAgICBiID0gYS5yZXBsYWNlKEcsICdscicpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJy13ZWJraXQtJyArIGEgKyAnLW1zLScgKyBiICsgYTtcblxuICAgICAgY2FzZSAxMDE3OlxuICAgICAgICBpZiAoLTEgPT09IGEuaW5kZXhPZignc3RpY2t5JywgOSkpIGJyZWFrO1xuXG4gICAgICBjYXNlIDk3NTpcbiAgICAgICAgYyA9IChhID0gZCkubGVuZ3RoIC0gMTA7XG4gICAgICAgIGIgPSAoMzMgPT09IGEuY2hhckNvZGVBdChjKSA/IGEuc3Vic3RyaW5nKDAsIGMpIDogYSkuc3Vic3RyaW5nKGQuaW5kZXhPZignOicsIDcpICsgMSkudHJpbSgpO1xuXG4gICAgICAgIHN3aXRjaCAobSA9IGIuY2hhckNvZGVBdCgwKSArIChiLmNoYXJDb2RlQXQoNykgfCAwKSkge1xuICAgICAgICAgIGNhc2UgMjAzOlxuICAgICAgICAgICAgaWYgKDExMSA+IGIuY2hhckNvZGVBdCg4KSkgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDExNTpcbiAgICAgICAgICAgIGEgPSBhLnJlcGxhY2UoYiwgJy13ZWJraXQtJyArIGIpICsgJzsnICsgYTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAyMDc6XG4gICAgICAgICAgY2FzZSAxMDI6XG4gICAgICAgICAgICBhID0gYS5yZXBsYWNlKGIsICctd2Via2l0LScgKyAoMTAyIDwgbSA/ICdpbmxpbmUtJyA6ICcnKSArICdib3gnKSArICc7JyArIGEucmVwbGFjZShiLCAnLXdlYmtpdC0nICsgYikgKyAnOycgKyBhLnJlcGxhY2UoYiwgJy1tcy0nICsgYiArICdib3gnKSArICc7JyArIGE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYSArICc7JztcblxuICAgICAgY2FzZSA5Mzg6XG4gICAgICAgIGlmICg0NSA9PT0gYS5jaGFyQ29kZUF0KDUpKSBzd2l0Y2ggKGEuY2hhckNvZGVBdCg2KSkge1xuICAgICAgICAgIGNhc2UgMTA1OlxuICAgICAgICAgICAgcmV0dXJuIGIgPSBhLnJlcGxhY2UoJy1pdGVtcycsICcnKSwgJy13ZWJraXQtJyArIGEgKyAnLXdlYmtpdC1ib3gtJyArIGIgKyAnLW1zLWZsZXgtJyArIGIgKyBhO1xuXG4gICAgICAgICAgY2FzZSAxMTU6XG4gICAgICAgICAgICByZXR1cm4gJy13ZWJraXQtJyArIGEgKyAnLW1zLWZsZXgtaXRlbS0nICsgYS5yZXBsYWNlKGJhLCAnJykgKyBhO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAnLXdlYmtpdC0nICsgYSArICctbXMtZmxleC1saW5lLXBhY2snICsgYS5yZXBsYWNlKCdhbGlnbi1jb250ZW50JywgJycpLnJlcGxhY2UoYmEsICcnKSArIGE7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgOTczOlxuICAgICAgY2FzZSA5ODk6XG4gICAgICAgIGlmICg0NSAhPT0gYS5jaGFyQ29kZUF0KDMpIHx8IDEyMiA9PT0gYS5jaGFyQ29kZUF0KDQpKSBicmVhaztcblxuICAgICAgY2FzZSA5MzE6XG4gICAgICBjYXNlIDk1MzpcbiAgICAgICAgaWYgKCEwID09PSBsYS50ZXN0KGQpKSByZXR1cm4gMTE1ID09PSAoYiA9IGQuc3Vic3RyaW5nKGQuaW5kZXhPZignOicpICsgMSkpLmNoYXJDb2RlQXQoMCkgPyBQKGQucmVwbGFjZSgnc3RyZXRjaCcsICdmaWxsLWF2YWlsYWJsZScpLCBjLCBlLCBoKS5yZXBsYWNlKCc6ZmlsbC1hdmFpbGFibGUnLCAnOnN0cmV0Y2gnKSA6IGEucmVwbGFjZShiLCAnLXdlYmtpdC0nICsgYikgKyBhLnJlcGxhY2UoYiwgJy1tb3otJyArIGIucmVwbGFjZSgnZmlsbC0nLCAnJykpICsgYTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgOTYyOlxuICAgICAgICBpZiAoYSA9ICctd2Via2l0LScgKyBhICsgKDEwMiA9PT0gYS5jaGFyQ29kZUF0KDUpID8gJy1tcy0nICsgYSA6ICcnKSArIGEsIDIxMSA9PT0gZSArIGggJiYgMTA1ID09PSBhLmNoYXJDb2RlQXQoMTMpICYmIDAgPCBhLmluZGV4T2YoJ3RyYW5zZm9ybScsIDEwKSkgcmV0dXJuIGEuc3Vic3RyaW5nKDAsIGEuaW5kZXhPZignOycsIDI3KSArIDEpLnJlcGxhY2UobWEsICckMS13ZWJraXQtJDInKSArIGE7XG4gICAgfVxuXG4gICAgcmV0dXJuIGE7XG4gIH1cblxuICBmdW5jdGlvbiBMKGQsIGMpIHtcbiAgICB2YXIgZSA9IGQuaW5kZXhPZigxID09PSBjID8gJzonIDogJ3snKSxcbiAgICAgICAgaCA9IGQuc3Vic3RyaW5nKDAsIDMgIT09IGMgPyBlIDogMTApO1xuICAgIGUgPSBkLnN1YnN0cmluZyhlICsgMSwgZC5sZW5ndGggLSAxKTtcbiAgICByZXR1cm4gUigyICE9PSBjID8gaCA6IGgucmVwbGFjZShuYSwgJyQxJyksIGUsIGMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZWEoZCwgYykge1xuICAgIHZhciBlID0gUChjLCBjLmNoYXJDb2RlQXQoMCksIGMuY2hhckNvZGVBdCgxKSwgYy5jaGFyQ29kZUF0KDIpKTtcbiAgICByZXR1cm4gZSAhPT0gYyArICc7JyA/IGUucmVwbGFjZShvYSwgJyBvciAoJDEpJykuc3Vic3RyaW5nKDQpIDogJygnICsgYyArICcpJztcbiAgfVxuXG4gIGZ1bmN0aW9uIEgoZCwgYywgZSwgaCwgYSwgbSwgYiwgdiwgbiwgcSkge1xuICAgIGZvciAodmFyIGcgPSAwLCB4ID0gYywgdzsgZyA8IEE7ICsrZykge1xuICAgICAgc3dpdGNoICh3ID0gU1tnXS5jYWxsKEIsIGQsIHgsIGUsIGgsIGEsIG0sIGIsIHYsIG4sIHEpKSB7XG4gICAgICAgIGNhc2Ugdm9pZCAwOlxuICAgICAgICBjYXNlICExOlxuICAgICAgICBjYXNlICEwOlxuICAgICAgICBjYXNlIG51bGw6XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB4ID0gdztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoeCAhPT0gYykgcmV0dXJuIHg7XG4gIH1cblxuICBmdW5jdGlvbiBUKGQpIHtcbiAgICBzd2l0Y2ggKGQpIHtcbiAgICAgIGNhc2Ugdm9pZCAwOlxuICAgICAgY2FzZSBudWxsOlxuICAgICAgICBBID0gUy5sZW5ndGggPSAwO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBkKSBTW0ErK10gPSBkO2Vsc2UgaWYgKCdvYmplY3QnID09PSB0eXBlb2YgZCkgZm9yICh2YXIgYyA9IDAsIGUgPSBkLmxlbmd0aDsgYyA8IGU7ICsrYykge1xuICAgICAgICAgIFQoZFtjXSk7XG4gICAgICAgIH0gZWxzZSBZID0gISFkIHwgMDtcbiAgICB9XG5cbiAgICByZXR1cm4gVDtcbiAgfVxuXG4gIGZ1bmN0aW9uIFUoZCkge1xuICAgIGQgPSBkLnByZWZpeDtcbiAgICB2b2lkIDAgIT09IGQgJiYgKFIgPSBudWxsLCBkID8gJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIGQgPyB3ID0gMSA6ICh3ID0gMiwgUiA9IGQpIDogdyA9IDApO1xuICAgIHJldHVybiBVO1xuICB9XG5cbiAgZnVuY3Rpb24gQihkLCBjKSB7XG4gICAgdmFyIGUgPSBkO1xuICAgIDMzID4gZS5jaGFyQ29kZUF0KDApICYmIChlID0gZS50cmltKCkpO1xuICAgIFYgPSBlO1xuICAgIGUgPSBbVl07XG5cbiAgICBpZiAoMCA8IEEpIHtcbiAgICAgIHZhciBoID0gSCgtMSwgYywgZSwgZSwgRCwgeiwgMCwgMCwgMCwgMCk7XG4gICAgICB2b2lkIDAgIT09IGggJiYgJ3N0cmluZycgPT09IHR5cGVvZiBoICYmIChjID0gaCk7XG4gICAgfVxuXG4gICAgdmFyIGEgPSBNKE8sIGUsIGMsIDAsIDApO1xuICAgIDAgPCBBICYmIChoID0gSCgtMiwgYSwgZSwgZSwgRCwgeiwgYS5sZW5ndGgsIDAsIDAsIDApLCB2b2lkIDAgIT09IGggJiYgKGEgPSBoKSk7XG4gICAgViA9ICcnO1xuICAgIEUgPSAwO1xuICAgIHogPSBEID0gMTtcbiAgICByZXR1cm4gYTtcbiAgfVxuXG4gIHZhciBjYSA9IC9eXFwwKy9nLFxuICAgICAgTiA9IC9bXFwwXFxyXFxmXS9nLFxuICAgICAgYWEgPSAvOiAqL2csXG4gICAgICBrYSA9IC96b298Z3JhLyxcbiAgICAgIG1hID0gLyhbLDogXSkodHJhbnNmb3JtKS9nLFxuICAgICAgaWEgPSAvLFxccis/L2csXG4gICAgICBGID0gLyhbXFx0XFxyXFxuIF0pKlxcZj8mL2csXG4gICAgICBmYSA9IC9AKGtcXHcrKVxccyooXFxTKilcXHMqLyxcbiAgICAgIFEgPSAvOjoocGxhY2UpL2csXG4gICAgICBoYSA9IC86KHJlYWQtb25seSkvZyxcbiAgICAgIEcgPSAvW3N2aF1cXHcrLVt0YmxyXXsyfS8sXG4gICAgICBkYSA9IC9cXChcXHMqKC4qKVxccypcXCkvZyxcbiAgICAgIG9hID0gLyhbXFxzXFxTXSo/KTsvZyxcbiAgICAgIGJhID0gLy1zZWxmfGZsZXgtL2csXG4gICAgICBuYSA9IC9bXl0qPyg6W3JwXVtlbF1hW1xcdy1dKylbXl0qLyxcbiAgICAgIGxhID0gL3N0cmV0Y2h8OlxccypcXHcrXFwtKD86Y29udGV8YXZhaWwpLyxcbiAgICAgIGphID0gLyhbXi1dKShpbWFnZS1zZXRcXCgpLyxcbiAgICAgIHogPSAxLFxuICAgICAgRCA9IDEsXG4gICAgICBFID0gMCxcbiAgICAgIHcgPSAxLFxuICAgICAgTyA9IFtdLFxuICAgICAgUyA9IFtdLFxuICAgICAgQSA9IDAsXG4gICAgICBSID0gbnVsbCxcbiAgICAgIFkgPSAwLFxuICAgICAgViA9ICcnO1xuICBCLnVzZSA9IFQ7XG4gIEIuc2V0ID0gVTtcbiAgdm9pZCAwICE9PSBXICYmIFUoVyk7XG4gIHJldHVybiBCO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdHlsaXNfbWluO1xuIiwidmFyIHVuaXRsZXNzS2V5cyA9IHtcbiAgYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6IDEsXG4gIGJvcmRlckltYWdlT3V0c2V0OiAxLFxuICBib3JkZXJJbWFnZVNsaWNlOiAxLFxuICBib3JkZXJJbWFnZVdpZHRoOiAxLFxuICBib3hGbGV4OiAxLFxuICBib3hGbGV4R3JvdXA6IDEsXG4gIGJveE9yZGluYWxHcm91cDogMSxcbiAgY29sdW1uQ291bnQ6IDEsXG4gIGNvbHVtbnM6IDEsXG4gIGZsZXg6IDEsXG4gIGZsZXhHcm93OiAxLFxuICBmbGV4UG9zaXRpdmU6IDEsXG4gIGZsZXhTaHJpbms6IDEsXG4gIGZsZXhOZWdhdGl2ZTogMSxcbiAgZmxleE9yZGVyOiAxLFxuICBncmlkUm93OiAxLFxuICBncmlkUm93RW5kOiAxLFxuICBncmlkUm93U3BhbjogMSxcbiAgZ3JpZFJvd1N0YXJ0OiAxLFxuICBncmlkQ29sdW1uOiAxLFxuICBncmlkQ29sdW1uRW5kOiAxLFxuICBncmlkQ29sdW1uU3BhbjogMSxcbiAgZ3JpZENvbHVtblN0YXJ0OiAxLFxuICBtc0dyaWRSb3c6IDEsXG4gIG1zR3JpZFJvd1NwYW46IDEsXG4gIG1zR3JpZENvbHVtbjogMSxcbiAgbXNHcmlkQ29sdW1uU3BhbjogMSxcbiAgZm9udFdlaWdodDogMSxcbiAgbGluZUhlaWdodDogMSxcbiAgb3BhY2l0eTogMSxcbiAgb3JkZXI6IDEsXG4gIG9ycGhhbnM6IDEsXG4gIHRhYlNpemU6IDEsXG4gIHdpZG93czogMSxcbiAgekluZGV4OiAxLFxuICB6b29tOiAxLFxuICBXZWJraXRMaW5lQ2xhbXA6IDEsXG4gIC8vIFNWRy1yZWxhdGVkIHByb3BlcnRpZXNcbiAgZmlsbE9wYWNpdHk6IDEsXG4gIGZsb29kT3BhY2l0eTogMSxcbiAgc3RvcE9wYWNpdHk6IDEsXG4gIHN0cm9rZURhc2hhcnJheTogMSxcbiAgc3Ryb2tlRGFzaG9mZnNldDogMSxcbiAgc3Ryb2tlTWl0ZXJsaW1pdDogMSxcbiAgc3Ryb2tlT3BhY2l0eTogMSxcbiAgc3Ryb2tlV2lkdGg6IDFcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVuaXRsZXNzS2V5cztcbiIsImV4cG9ydCBjb25zdCB2ZXJzaW9uID0gXCJhYmkvNS43LjBcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV92ZXJzaW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vd2lraS93aWtpL0V0aGVyZXVtLUNvbnRyYWN0LUFCSVxuaW1wb3J0IHsgYXJyYXlpZnkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IGRlZmluZVJlYWRPbmx5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmltcG9ydCB7IFJlYWRlciwgV3JpdGVyIH0gZnJvbSBcIi4vY29kZXJzL2Fic3RyYWN0LWNvZGVyXCI7XG5pbXBvcnQgeyBBZGRyZXNzQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvYWRkcmVzc1wiO1xuaW1wb3J0IHsgQXJyYXlDb2RlciB9IGZyb20gXCIuL2NvZGVycy9hcnJheVwiO1xuaW1wb3J0IHsgQm9vbGVhbkNvZGVyIH0gZnJvbSBcIi4vY29kZXJzL2Jvb2xlYW5cIjtcbmltcG9ydCB7IEJ5dGVzQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvYnl0ZXNcIjtcbmltcG9ydCB7IEZpeGVkQnl0ZXNDb2RlciB9IGZyb20gXCIuL2NvZGVycy9maXhlZC1ieXRlc1wiO1xuaW1wb3J0IHsgTnVsbENvZGVyIH0gZnJvbSBcIi4vY29kZXJzL251bGxcIjtcbmltcG9ydCB7IE51bWJlckNvZGVyIH0gZnJvbSBcIi4vY29kZXJzL251bWJlclwiO1xuaW1wb3J0IHsgU3RyaW5nQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvc3RyaW5nXCI7XG5pbXBvcnQgeyBUdXBsZUNvZGVyIH0gZnJvbSBcIi4vY29kZXJzL3R1cGxlXCI7XG5pbXBvcnQgeyBQYXJhbVR5cGUgfSBmcm9tIFwiLi9mcmFnbWVudHNcIjtcbmNvbnN0IHBhcmFtVHlwZUJ5dGVzID0gbmV3IFJlZ0V4cCgvXmJ5dGVzKFswLTldKikkLyk7XG5jb25zdCBwYXJhbVR5cGVOdW1iZXIgPSBuZXcgUmVnRXhwKC9eKHU/aW50KShbMC05XSopJC8pO1xuZXhwb3J0IGNsYXNzIEFiaUNvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb2VyY2VGdW5jKSB7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiY29lcmNlRnVuY1wiLCBjb2VyY2VGdW5jIHx8IG51bGwpO1xuICAgIH1cbiAgICBfZ2V0Q29kZXIocGFyYW0pIHtcbiAgICAgICAgc3dpdGNoIChwYXJhbS5iYXNlVHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImFkZHJlc3NcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFkZHJlc3NDb2RlcihwYXJhbS5uYW1lKTtcbiAgICAgICAgICAgIGNhc2UgXCJib29sXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCb29sZWFuQ29kZXIocGFyYW0ubmFtZSk7XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJpbmdDb2RlcihwYXJhbS5uYW1lKTtcbiAgICAgICAgICAgIGNhc2UgXCJieXRlc1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnl0ZXNDb2RlcihwYXJhbS5uYW1lKTtcbiAgICAgICAgICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXlDb2Rlcih0aGlzLl9nZXRDb2RlcihwYXJhbS5hcnJheUNoaWxkcmVuKSwgcGFyYW0uYXJyYXlMZW5ndGgsIHBhcmFtLm5hbWUpO1xuICAgICAgICAgICAgY2FzZSBcInR1cGxlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUdXBsZUNvZGVyKChwYXJhbS5jb21wb25lbnRzIHx8IFtdKS5tYXAoKGNvbXBvbmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Q29kZXIoY29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICB9KSwgcGFyYW0ubmFtZSk7XG4gICAgICAgICAgICBjYXNlIFwiXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBOdWxsQ29kZXIocGFyYW0ubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdT9pbnRbMC05XSpcbiAgICAgICAgbGV0IG1hdGNoID0gcGFyYW0udHlwZS5tYXRjaChwYXJhbVR5cGVOdW1iZXIpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGxldCBzaXplID0gcGFyc2VJbnQobWF0Y2hbMl0gfHwgXCIyNTZcIik7XG4gICAgICAgICAgICBpZiAoc2l6ZSA9PT0gMCB8fCBzaXplID4gMjU2IHx8IChzaXplICUgOCkgIT09IDApIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBcIiArIG1hdGNoWzFdICsgXCIgYml0IGxlbmd0aFwiLCBcInBhcmFtXCIsIHBhcmFtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgTnVtYmVyQ29kZXIoc2l6ZSAvIDgsIChtYXRjaFsxXSA9PT0gXCJpbnRcIiksIHBhcmFtLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJ5dGVzWzAtOV0rXG4gICAgICAgIG1hdGNoID0gcGFyYW0udHlwZS5tYXRjaChwYXJhbVR5cGVCeXRlcyk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgbGV0IHNpemUgPSBwYXJzZUludChtYXRjaFsxXSk7XG4gICAgICAgICAgICBpZiAoc2l6ZSA9PT0gMCB8fCBzaXplID4gMzIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBieXRlcyBsZW5ndGhcIiwgXCJwYXJhbVwiLCBwYXJhbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZpeGVkQnl0ZXNDb2RlcihzaXplLCBwYXJhbS5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgdHlwZVwiLCBcInR5cGVcIiwgcGFyYW0udHlwZSk7XG4gICAgfVxuICAgIF9nZXRXb3JkU2l6ZSgpIHsgcmV0dXJuIDMyOyB9XG4gICAgX2dldFJlYWRlcihkYXRhLCBhbGxvd0xvb3NlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVhZGVyKGRhdGEsIHRoaXMuX2dldFdvcmRTaXplKCksIHRoaXMuY29lcmNlRnVuYywgYWxsb3dMb29zZSk7XG4gICAgfVxuICAgIF9nZXRXcml0ZXIoKSB7XG4gICAgICAgIHJldHVybiBuZXcgV3JpdGVyKHRoaXMuX2dldFdvcmRTaXplKCkpO1xuICAgIH1cbiAgICBnZXREZWZhdWx0VmFsdWUodHlwZXMpIHtcbiAgICAgICAgY29uc3QgY29kZXJzID0gdHlwZXMubWFwKCh0eXBlKSA9PiB0aGlzLl9nZXRDb2RlcihQYXJhbVR5cGUuZnJvbSh0eXBlKSkpO1xuICAgICAgICBjb25zdCBjb2RlciA9IG5ldyBUdXBsZUNvZGVyKGNvZGVycywgXCJfXCIpO1xuICAgICAgICByZXR1cm4gY29kZXIuZGVmYXVsdFZhbHVlKCk7XG4gICAgfVxuICAgIGVuY29kZSh0eXBlcywgdmFsdWVzKSB7XG4gICAgICAgIGlmICh0eXBlcy5sZW5ndGggIT09IHZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidHlwZXMvdmFsdWVzIGxlbmd0aCBtaXNtYXRjaFwiLCBMb2dnZXIuZXJyb3JzLklOVkFMSURfQVJHVU1FTlQsIHtcbiAgICAgICAgICAgICAgICBjb3VudDogeyB0eXBlczogdHlwZXMubGVuZ3RoLCB2YWx1ZXM6IHZhbHVlcy5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogeyB0eXBlczogdHlwZXMsIHZhbHVlczogdmFsdWVzIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvZGVycyA9IHR5cGVzLm1hcCgodHlwZSkgPT4gdGhpcy5fZ2V0Q29kZXIoUGFyYW1UeXBlLmZyb20odHlwZSkpKTtcbiAgICAgICAgY29uc3QgY29kZXIgPSAobmV3IFR1cGxlQ29kZXIoY29kZXJzLCBcIl9cIikpO1xuICAgICAgICBjb25zdCB3cml0ZXIgPSB0aGlzLl9nZXRXcml0ZXIoKTtcbiAgICAgICAgY29kZXIuZW5jb2RlKHdyaXRlciwgdmFsdWVzKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlci5kYXRhO1xuICAgIH1cbiAgICBkZWNvZGUodHlwZXMsIGRhdGEsIGxvb3NlKSB7XG4gICAgICAgIGNvbnN0IGNvZGVycyA9IHR5cGVzLm1hcCgodHlwZSkgPT4gdGhpcy5fZ2V0Q29kZXIoUGFyYW1UeXBlLmZyb20odHlwZSkpKTtcbiAgICAgICAgY29uc3QgY29kZXIgPSBuZXcgVHVwbGVDb2Rlcihjb2RlcnMsIFwiX1wiKTtcbiAgICAgICAgcmV0dXJuIGNvZGVyLmRlY29kZSh0aGlzLl9nZXRSZWFkZXIoYXJyYXlpZnkoZGF0YSksIGxvb3NlKSk7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IGRlZmF1bHRBYmlDb2RlciA9IG5ldyBBYmlDb2RlcigpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWJpLWNvZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgYXJyYXlpZnksIGNvbmNhdCwgaGV4Q29uY2F0LCBoZXhsaWZ5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyXCI7XG5pbXBvcnQgeyBkZWZpbmVSZWFkT25seSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4uL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrUmVzdWx0RXJyb3JzKHJlc3VsdCkge1xuICAgIC8vIEZpbmQgdGhlIGZpcnN0IGVycm9yIChpZiBhbnkpXG4gICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgY29uc3QgY2hlY2tFcnJvcnMgPSBmdW5jdGlvbiAocGF0aCwgb2JqZWN0KSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQga2V5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgY29uc3QgY2hpbGRQYXRoID0gcGF0aC5zbGljZSgpO1xuICAgICAgICAgICAgY2hpbGRQYXRoLnB1c2goa2V5KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY2hlY2tFcnJvcnMoY2hpbGRQYXRoLCBvYmplY3Rba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh7IHBhdGg6IGNoaWxkUGF0aCwgZXJyb3I6IGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBjaGVja0Vycm9ycyhbXSwgcmVzdWx0KTtcbiAgICByZXR1cm4gZXJyb3JzO1xufVxuZXhwb3J0IGNsYXNzIENvZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCB0eXBlLCBsb2NhbE5hbWUsIGR5bmFtaWMpIHtcbiAgICAgICAgLy8gQFRPRE86IGRlZmluZVJlYWRPbmx5IHRoZXNlXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMubG9jYWxOYW1lID0gbG9jYWxOYW1lO1xuICAgICAgICB0aGlzLmR5bmFtaWMgPSBkeW5hbWljO1xuICAgIH1cbiAgICBfdGhyb3dFcnJvcihtZXNzYWdlLCB2YWx1ZSkge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKG1lc3NhZ2UsIHRoaXMubG9jYWxOYW1lLCB2YWx1ZSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFdyaXRlciB7XG4gICAgY29uc3RydWN0b3Iod29yZFNpemUpIHtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJ3b3JkU2l6ZVwiLCB3b3JkU2l6ZSB8fCAzMik7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBbXTtcbiAgICAgICAgdGhpcy5fZGF0YUxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuX3BhZGRpbmcgPSBuZXcgVWludDhBcnJheSh3b3JkU2l6ZSk7XG4gICAgfVxuICAgIGdldCBkYXRhKCkge1xuICAgICAgICByZXR1cm4gaGV4Q29uY2F0KHRoaXMuX2RhdGEpO1xuICAgIH1cbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy5fZGF0YUxlbmd0aDsgfVxuICAgIF93cml0ZURhdGEoZGF0YSkge1xuICAgICAgICB0aGlzLl9kYXRhLnB1c2goZGF0YSk7XG4gICAgICAgIHRoaXMuX2RhdGFMZW5ndGggKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIHJldHVybiBkYXRhLmxlbmd0aDtcbiAgICB9XG4gICAgYXBwZW5kV3JpdGVyKHdyaXRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGVEYXRhKGNvbmNhdCh3cml0ZXIuX2RhdGEpKTtcbiAgICB9XG4gICAgLy8gQXJyYXlpc2ggaXRlbXM7IHBhZGRlZCBvbiB0aGUgcmlnaHQgdG8gd29yZFNpemVcbiAgICB3cml0ZUJ5dGVzKHZhbHVlKSB7XG4gICAgICAgIGxldCBieXRlcyA9IGFycmF5aWZ5KHZhbHVlKTtcbiAgICAgICAgY29uc3QgcGFkZGluZ09mZnNldCA9IGJ5dGVzLmxlbmd0aCAlIHRoaXMud29yZFNpemU7XG4gICAgICAgIGlmIChwYWRkaW5nT2Zmc2V0KSB7XG4gICAgICAgICAgICBieXRlcyA9IGNvbmNhdChbYnl0ZXMsIHRoaXMuX3BhZGRpbmcuc2xpY2UocGFkZGluZ09mZnNldCldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGVEYXRhKGJ5dGVzKTtcbiAgICB9XG4gICAgX2dldFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGxldCBieXRlcyA9IGFycmF5aWZ5KEJpZ051bWJlci5mcm9tKHZhbHVlKSk7XG4gICAgICAgIGlmIChieXRlcy5sZW5ndGggPiB0aGlzLndvcmRTaXplKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInZhbHVlIG91dC1vZi1ib3VuZHNcIiwgTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge1xuICAgICAgICAgICAgICAgIGxlbmd0aDogdGhpcy53b3JkU2l6ZSxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IGJ5dGVzLmxlbmd0aFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCAlIHRoaXMud29yZFNpemUpIHtcbiAgICAgICAgICAgIGJ5dGVzID0gY29uY2F0KFt0aGlzLl9wYWRkaW5nLnNsaWNlKGJ5dGVzLmxlbmd0aCAlIHRoaXMud29yZFNpemUpLCBieXRlc10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBieXRlcztcbiAgICB9XG4gICAgLy8gQmlnTnVtYmVyaXNoIGl0ZW1zOyBwYWRkZWQgb24gdGhlIGxlZnQgdG8gd29yZFNpemVcbiAgICB3cml0ZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cml0ZURhdGEodGhpcy5fZ2V0VmFsdWUodmFsdWUpKTtcbiAgICB9XG4gICAgd3JpdGVVcGRhdGFibGVWYWx1ZSgpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5fZGF0YS5sZW5ndGg7XG4gICAgICAgIHRoaXMuX2RhdGEucHVzaCh0aGlzLl9wYWRkaW5nKTtcbiAgICAgICAgdGhpcy5fZGF0YUxlbmd0aCArPSB0aGlzLndvcmRTaXplO1xuICAgICAgICByZXR1cm4gKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9kYXRhW29mZnNldF0gPSB0aGlzLl9nZXRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFJlYWRlciB7XG4gICAgY29uc3RydWN0b3IoZGF0YSwgd29yZFNpemUsIGNvZXJjZUZ1bmMsIGFsbG93TG9vc2UpIHtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfZGF0YVwiLCBhcnJheWlmeShkYXRhKSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwid29yZFNpemVcIiwgd29yZFNpemUgfHwgMzIpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9jb2VyY2VGdW5jXCIsIGNvZXJjZUZ1bmMpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImFsbG93TG9vc2VcIiwgYWxsb3dMb29zZSk7XG4gICAgICAgIHRoaXMuX29mZnNldCA9IDA7XG4gICAgfVxuICAgIGdldCBkYXRhKCkgeyByZXR1cm4gaGV4bGlmeSh0aGlzLl9kYXRhKTsgfVxuICAgIGdldCBjb25zdW1lZCgpIHsgcmV0dXJuIHRoaXMuX29mZnNldDsgfVxuICAgIC8vIFRoZSBkZWZhdWx0IENvZXJjZSBmdW5jdGlvblxuICAgIHN0YXRpYyBjb2VyY2UobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgbGV0IG1hdGNoID0gbmFtZS5tYXRjaChcIl51P2ludChbMC05XSspJFwiKTtcbiAgICAgICAgaWYgKG1hdGNoICYmIHBhcnNlSW50KG1hdGNoWzFdKSA8PSA0OCkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b051bWJlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgY29lcmNlKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLl9jb2VyY2VGdW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29lcmNlRnVuYyhuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJlYWRlci5jb2VyY2UobmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgICBfcGVla0J5dGVzKG9mZnNldCwgbGVuZ3RoLCBsb29zZSkge1xuICAgICAgICBsZXQgYWxpZ25lZExlbmd0aCA9IE1hdGguY2VpbChsZW5ndGggLyB0aGlzLndvcmRTaXplKSAqIHRoaXMud29yZFNpemU7XG4gICAgICAgIGlmICh0aGlzLl9vZmZzZXQgKyBhbGlnbmVkTGVuZ3RoID4gdGhpcy5fZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFsbG93TG9vc2UgJiYgbG9vc2UgJiYgdGhpcy5fb2Zmc2V0ICsgbGVuZ3RoIDw9IHRoaXMuX2RhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYWxpZ25lZExlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZGF0YSBvdXQtb2YtYm91bmRzXCIsIExvZ2dlci5lcnJvcnMuQlVGRkVSX09WRVJSVU4sIHtcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoOiB0aGlzLl9kYXRhLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLl9vZmZzZXQgKyBhbGlnbmVkTGVuZ3RoXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuc2xpY2UodGhpcy5fb2Zmc2V0LCB0aGlzLl9vZmZzZXQgKyBhbGlnbmVkTGVuZ3RoKTtcbiAgICB9XG4gICAgc3ViUmVhZGVyKG9mZnNldCkge1xuICAgICAgICByZXR1cm4gbmV3IFJlYWRlcih0aGlzLl9kYXRhLnNsaWNlKHRoaXMuX29mZnNldCArIG9mZnNldCksIHRoaXMud29yZFNpemUsIHRoaXMuX2NvZXJjZUZ1bmMsIHRoaXMuYWxsb3dMb29zZSk7XG4gICAgfVxuICAgIHJlYWRCeXRlcyhsZW5ndGgsIGxvb3NlKSB7XG4gICAgICAgIGxldCBieXRlcyA9IHRoaXMuX3BlZWtCeXRlcygwLCBsZW5ndGgsICEhbG9vc2UpO1xuICAgICAgICB0aGlzLl9vZmZzZXQgKz0gYnl0ZXMubGVuZ3RoO1xuICAgICAgICAvLyBAVE9ETzogTWFrZSBzdXJlIHRoZSBsZW5ndGguLmVuZCBieXRlcyBhcmUgYWxsIDA/XG4gICAgICAgIHJldHVybiBieXRlcy5zbGljZSgwLCBsZW5ndGgpO1xuICAgIH1cbiAgICByZWFkVmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbSh0aGlzLnJlYWRCeXRlcyh0aGlzLndvcmRTaXplKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWJzdHJhY3QtY29kZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2FkZHJlc3NcIjtcbmltcG9ydCB7IGhleFplcm9QYWQgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IENvZGVyIH0gZnJvbSBcIi4vYWJzdHJhY3QtY29kZXJcIjtcbmV4cG9ydCBjbGFzcyBBZGRyZXNzQ29kZXIgZXh0ZW5kcyBDb2RlciB7XG4gICAgY29uc3RydWN0b3IobG9jYWxOYW1lKSB7XG4gICAgICAgIHN1cGVyKFwiYWRkcmVzc1wiLCBcImFkZHJlc3NcIiwgbG9jYWxOYW1lLCBmYWxzZSk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGdldEFkZHJlc3ModmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihlcnJvci5tZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlci53cml0ZVZhbHVlKHZhbHVlKTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gZ2V0QWRkcmVzcyhoZXhaZXJvUGFkKHJlYWRlci5yZWFkVmFsdWUoKS50b0hleFN0cmluZygpLCAyMCkpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZHJlc3MuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyXCI7XG4vLyBDbG9uZXMgdGhlIGZ1bmN0aW9uYWxpdHkgb2YgYW4gZXhpc3RpbmcgQ29kZXIsIGJ1dCB3aXRob3V0IGEgbG9jYWxOYW1lXG5leHBvcnQgY2xhc3MgQW5vbnltb3VzQ29kZXIgZXh0ZW5kcyBDb2RlciB7XG4gICAgY29uc3RydWN0b3IoY29kZXIpIHtcbiAgICAgICAgc3VwZXIoY29kZXIubmFtZSwgY29kZXIudHlwZSwgdW5kZWZpbmVkLCBjb2Rlci5keW5hbWljKTtcbiAgICAgICAgdGhpcy5jb2RlciA9IGNvZGVyO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvZGVyLmRlZmF1bHRWYWx1ZSgpO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2Rlci5lbmNvZGUod3JpdGVyLCB2YWx1ZSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29kZXIuZGVjb2RlKHJlYWRlcik7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YW5vbnltb3VzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmltcG9ydCB7IENvZGVyLCBXcml0ZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2RlclwiO1xuaW1wb3J0IHsgQW5vbnltb3VzQ29kZXIgfSBmcm9tIFwiLi9hbm9ueW1vdXNcIjtcbmV4cG9ydCBmdW5jdGlvbiBwYWNrKHdyaXRlciwgY29kZXJzLCB2YWx1ZXMpIHtcbiAgICBsZXQgYXJyYXlWYWx1ZXMgPSBudWxsO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgICAgYXJyYXlWYWx1ZXMgPSB2YWx1ZXM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlcyAmJiB0eXBlb2YgKHZhbHVlcykgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgbGV0IHVuaXF1ZSA9IHt9O1xuICAgICAgICBhcnJheVZhbHVlcyA9IGNvZGVycy5tYXAoKGNvZGVyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gY29kZXIubG9jYWxOYW1lO1xuICAgICAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3QgZW5jb2RlIG9iamVjdCBmb3Igc2lnbmF0dXJlIHdpdGggbWlzc2luZyBuYW1lc1wiLCBMb2dnZXIuZXJyb3JzLklOVkFMSURfQVJHVU1FTlQsIHtcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnQ6IFwidmFsdWVzXCIsXG4gICAgICAgICAgICAgICAgICAgIGNvZGVyOiBjb2RlcixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVuaXF1ZVtuYW1lXSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IGVuY29kZSBvYmplY3QgZm9yIHNpZ25hdHVyZSB3aXRoIGR1cGxpY2F0ZSBuYW1lc1wiLCBMb2dnZXIuZXJyb3JzLklOVkFMSURfQVJHVU1FTlQsIHtcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnQ6IFwidmFsdWVzXCIsXG4gICAgICAgICAgICAgICAgICAgIGNvZGVyOiBjb2RlcixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdW5pcXVlW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXNbbmFtZV07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgdHVwbGUgdmFsdWVcIiwgXCJ0dXBsZVwiLCB2YWx1ZXMpO1xuICAgIH1cbiAgICBpZiAoY29kZXJzLmxlbmd0aCAhPT0gYXJyYXlWYWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ0eXBlcy92YWx1ZSBsZW5ndGggbWlzbWF0Y2hcIiwgXCJ0dXBsZVwiLCB2YWx1ZXMpO1xuICAgIH1cbiAgICBsZXQgc3RhdGljV3JpdGVyID0gbmV3IFdyaXRlcih3cml0ZXIud29yZFNpemUpO1xuICAgIGxldCBkeW5hbWljV3JpdGVyID0gbmV3IFdyaXRlcih3cml0ZXIud29yZFNpemUpO1xuICAgIGxldCB1cGRhdGVGdW5jcyA9IFtdO1xuICAgIGNvZGVycy5mb3JFYWNoKChjb2RlciwgaW5kZXgpID0+IHtcbiAgICAgICAgbGV0IHZhbHVlID0gYXJyYXlWYWx1ZXNbaW5kZXhdO1xuICAgICAgICBpZiAoY29kZXIuZHluYW1pYykge1xuICAgICAgICAgICAgLy8gR2V0IGN1cnJlbnQgZHluYW1pYyBvZmZzZXQgKGZvciB0aGUgZnV0dXJlIHBvaW50ZXIpXG4gICAgICAgICAgICBsZXQgZHluYW1pY09mZnNldCA9IGR5bmFtaWNXcml0ZXIubGVuZ3RoO1xuICAgICAgICAgICAgLy8gRW5jb2RlIHRoZSBkeW5hbWljIHZhbHVlIGludG8gdGhlIGR5bmFtaWNXcml0ZXJcbiAgICAgICAgICAgIGNvZGVyLmVuY29kZShkeW5hbWljV3JpdGVyLCB2YWx1ZSk7XG4gICAgICAgICAgICAvLyBQcmVwYXJlIHRvIHBvcHVsYXRlIHRoZSBjb3JyZWN0IG9mZnNldCBvbmNlIHdlIGFyZSBkb25lXG4gICAgICAgICAgICBsZXQgdXBkYXRlRnVuYyA9IHN0YXRpY1dyaXRlci53cml0ZVVwZGF0YWJsZVZhbHVlKCk7XG4gICAgICAgICAgICB1cGRhdGVGdW5jcy5wdXNoKChiYXNlT2Zmc2V0KSA9PiB7XG4gICAgICAgICAgICAgICAgdXBkYXRlRnVuYyhiYXNlT2Zmc2V0ICsgZHluYW1pY09mZnNldCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvZGVyLmVuY29kZShzdGF0aWNXcml0ZXIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIEJhY2tmaWxsIGFsbCB0aGUgZHluYW1pYyBvZmZzZXRzLCBub3cgdGhhdCB3ZSBrbm93IHRoZSBzdGF0aWMgbGVuZ3RoXG4gICAgdXBkYXRlRnVuY3MuZm9yRWFjaCgoZnVuYykgPT4geyBmdW5jKHN0YXRpY1dyaXRlci5sZW5ndGgpOyB9KTtcbiAgICBsZXQgbGVuZ3RoID0gd3JpdGVyLmFwcGVuZFdyaXRlcihzdGF0aWNXcml0ZXIpO1xuICAgIGxlbmd0aCArPSB3cml0ZXIuYXBwZW5kV3JpdGVyKGR5bmFtaWNXcml0ZXIpO1xuICAgIHJldHVybiBsZW5ndGg7XG59XG5leHBvcnQgZnVuY3Rpb24gdW5wYWNrKHJlYWRlciwgY29kZXJzKSB7XG4gICAgbGV0IHZhbHVlcyA9IFtdO1xuICAgIC8vIEEgcmVhZGVyIGFuY2hvcmVkIHRvIHRoaXMgYmFzZVxuICAgIGxldCBiYXNlUmVhZGVyID0gcmVhZGVyLnN1YlJlYWRlcigwKTtcbiAgICBjb2RlcnMuZm9yRWFjaCgoY29kZXIpID0+IHtcbiAgICAgICAgbGV0IHZhbHVlID0gbnVsbDtcbiAgICAgICAgaWYgKGNvZGVyLmR5bmFtaWMpIHtcbiAgICAgICAgICAgIGxldCBvZmZzZXQgPSByZWFkZXIucmVhZFZhbHVlKCk7XG4gICAgICAgICAgICBsZXQgb2Zmc2V0UmVhZGVyID0gYmFzZVJlYWRlci5zdWJSZWFkZXIob2Zmc2V0LnRvTnVtYmVyKCkpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGNvZGVyLmRlY29kZShvZmZzZXRSZWFkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2Fubm90IHJlY292ZXIgZnJvbSB0aGlzXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IExvZ2dlci5lcnJvcnMuQlVGRkVSX09WRVJSVU4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgdmFsdWUuYmFzZVR5cGUgPSBjb2Rlci5uYW1lO1xuICAgICAgICAgICAgICAgIHZhbHVlLm5hbWUgPSBjb2Rlci5sb2NhbE5hbWU7XG4gICAgICAgICAgICAgICAgdmFsdWUudHlwZSA9IGNvZGVyLnR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gY29kZXIuZGVjb2RlKHJlYWRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBDYW5ub3QgcmVjb3ZlciBmcm9tIHRoaXNcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICB2YWx1ZS5iYXNlVHlwZSA9IGNvZGVyLm5hbWU7XG4gICAgICAgICAgICAgICAgdmFsdWUubmFtZSA9IGNvZGVyLmxvY2FsTmFtZTtcbiAgICAgICAgICAgICAgICB2YWx1ZS50eXBlID0gY29kZXIudHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBXZSBvbmx5IG91dHB1dCBuYW1lZCBwcm9wZXJ0aWVzIGZvciB1bmlxdWVseSBuYW1lZCBjb2RlcnNcbiAgICBjb25zdCB1bmlxdWVOYW1lcyA9IGNvZGVycy5yZWR1Y2UoKGFjY3VtLCBjb2RlcikgPT4ge1xuICAgICAgICBjb25zdCBuYW1lID0gY29kZXIubG9jYWxOYW1lO1xuICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgaWYgKCFhY2N1bVtuYW1lXSkge1xuICAgICAgICAgICAgICAgIGFjY3VtW25hbWVdID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFjY3VtW25hbWVdKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgIH0sIHt9KTtcbiAgICAvLyBBZGQgYW55IG5hbWVkIHBhcmFtZXRlcnMgKGkuZS4gdHVwbGVzKVxuICAgIGNvZGVycy5mb3JFYWNoKChjb2RlciwgaW5kZXgpID0+IHtcbiAgICAgICAgbGV0IG5hbWUgPSBjb2Rlci5sb2NhbE5hbWU7XG4gICAgICAgIGlmICghbmFtZSB8fCB1bmlxdWVOYW1lc1tuYW1lXSAhPT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lID09PSBcImxlbmd0aFwiKSB7XG4gICAgICAgICAgICBuYW1lID0gXCJfbGVuZ3RoXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbaW5kZXhdO1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbHVlcywgbmFtZSwge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiB7IHRocm93IHZhbHVlOyB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsdWVzLCBpLCB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IHsgdGhyb3cgdmFsdWU7IH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHZhbHVlcyk7XG59XG5leHBvcnQgY2xhc3MgQXJyYXlDb2RlciBleHRlbmRzIENvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb2RlciwgbGVuZ3RoLCBsb2NhbE5hbWUpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IChjb2Rlci50eXBlICsgXCJbXCIgKyAobGVuZ3RoID49IDAgPyBsZW5ndGggOiBcIlwiKSArIFwiXVwiKTtcbiAgICAgICAgY29uc3QgZHluYW1pYyA9IChsZW5ndGggPT09IC0xIHx8IGNvZGVyLmR5bmFtaWMpO1xuICAgICAgICBzdXBlcihcImFycmF5XCIsIHR5cGUsIGxvY2FsTmFtZSwgZHluYW1pYyk7XG4gICAgICAgIHRoaXMuY29kZXIgPSBjb2RlcjtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgLy8gVmVyaWZpZXMgdGhlIGNoaWxkIGNvZGVyIGlzIHZhbGlkIChldmVuIGlmIHRoZSBhcnJheSBpcyBkeW5hbWljIG9yIDAtbGVuZ3RoKVxuICAgICAgICBjb25zdCBkZWZhdWx0Q2hpbGQgPSB0aGlzLmNvZGVyLmRlZmF1bHRWYWx1ZSgpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChkZWZhdWx0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIHZhbHVlKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJleHBlY3RlZCBhcnJheSB2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvdW50ID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIGlmIChjb3VudCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvdW50ID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgd3JpdGVyLndyaXRlVmFsdWUodmFsdWUubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuY2hlY2tBcmd1bWVudENvdW50KHZhbHVlLmxlbmd0aCwgY291bnQsIFwiY29kZXIgYXJyYXlcIiArICh0aGlzLmxvY2FsTmFtZSA/IChcIiBcIiArIHRoaXMubG9jYWxOYW1lKSA6IFwiXCIpKTtcbiAgICAgICAgbGV0IGNvZGVycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb2RlcnMucHVzaCh0aGlzLmNvZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFjayh3cml0ZXIsIGNvZGVycywgdmFsdWUpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIGxldCBjb3VudCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICBpZiAoY291bnQgPT09IC0xKSB7XG4gICAgICAgICAgICBjb3VudCA9IHJlYWRlci5yZWFkVmFsdWUoKS50b051bWJlcigpO1xuICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGVyZSBpcyAqcm91Z2hseSogZW5vdWdoIGRhdGEgdG8gZW5zdXJlXG4gICAgICAgICAgICAvLyBzdHJheSByYW5kb20gZGF0YSBpcyBub3QgYmVpbmcgcmVhZCBhcyBhIGxlbmd0aC4gRWFjaFxuICAgICAgICAgICAgLy8gc2xvdCByZXF1aXJlcyBhdCBsZWFzdCAzMiBieXRlcyBmb3IgdGhlaXIgdmFsdWUgKG9yIDMyXG4gICAgICAgICAgICAvLyBieXRlcyBhcyBhIGxpbmsgdG8gdGhlIGRhdGEpLiBUaGlzIGNvdWxkIHVzZSBhIG11Y2hcbiAgICAgICAgICAgIC8vIHRpZ2h0ZXIgYm91bmQsIGJ1dCB3ZSBhcmUgZXJyb3Jpbmcgb24gdGhlIHNpZGUgb2Ygc2FmZXR5LlxuICAgICAgICAgICAgaWYgKGNvdW50ICogMzIgPiByZWFkZXIuX2RhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJpbnN1ZmZpY2llbnQgZGF0YSBsZW5ndGhcIiwgTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge1xuICAgICAgICAgICAgICAgICAgICBsZW5ndGg6IHJlYWRlci5fZGF0YS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIGNvdW50OiBjb3VudFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBjb2RlcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb2RlcnMucHVzaChuZXcgQW5vbnltb3VzQ29kZXIodGhpcy5jb2RlcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWFkZXIuY29lcmNlKHRoaXMubmFtZSwgdW5wYWNrKHJlYWRlciwgY29kZXJzKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXJyYXkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyXCI7XG5leHBvcnQgY2xhc3MgQm9vbGVhbkNvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsTmFtZSkge1xuICAgICAgICBzdXBlcihcImJvb2xcIiwgXCJib29sXCIsIGxvY2FsTmFtZSwgZmFsc2UpO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlci53cml0ZVZhbHVlKHZhbHVlID8gMSA6IDApO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJldHVybiByZWFkZXIuY29lcmNlKHRoaXMudHlwZSwgIXJlYWRlci5yZWFkVmFsdWUoKS5pc1plcm8oKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ym9vbGVhbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IGFycmF5aWZ5LCBoZXhsaWZ5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyXCI7XG5leHBvcnQgY2xhc3MgRHluYW1pY0J5dGVzQ29kZXIgZXh0ZW5kcyBDb2RlciB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgbG9jYWxOYW1lKSB7XG4gICAgICAgIHN1cGVyKHR5cGUsIHR5cGUsIGxvY2FsTmFtZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiMHhcIjtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgdmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSBhcnJheWlmeSh2YWx1ZSk7XG4gICAgICAgIGxldCBsZW5ndGggPSB3cml0ZXIud3JpdGVWYWx1ZSh2YWx1ZS5sZW5ndGgpO1xuICAgICAgICBsZW5ndGggKz0gd3JpdGVyLndyaXRlQnl0ZXModmFsdWUpO1xuICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJldHVybiByZWFkZXIucmVhZEJ5dGVzKHJlYWRlci5yZWFkVmFsdWUoKS50b051bWJlcigpLCB0cnVlKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQnl0ZXNDb2RlciBleHRlbmRzIER5bmFtaWNCeXRlc0NvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbE5hbWUpIHtcbiAgICAgICAgc3VwZXIoXCJieXRlc1wiLCBsb2NhbE5hbWUpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJldHVybiByZWFkZXIuY29lcmNlKHRoaXMubmFtZSwgaGV4bGlmeShzdXBlci5kZWNvZGUocmVhZGVyKSkpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ5dGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgYXJyYXlpZnksIGhleGxpZnkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IENvZGVyIH0gZnJvbSBcIi4vYWJzdHJhY3QtY29kZXJcIjtcbi8vIEBUT0RPOiBNZXJnZSB0aGlzIHdpdGggYnl0ZXNcbmV4cG9ydCBjbGFzcyBGaXhlZEJ5dGVzQ29kZXIgZXh0ZW5kcyBDb2RlciB7XG4gICAgY29uc3RydWN0b3Ioc2l6ZSwgbG9jYWxOYW1lKSB7XG4gICAgICAgIGxldCBuYW1lID0gXCJieXRlc1wiICsgU3RyaW5nKHNpemUpO1xuICAgICAgICBzdXBlcihuYW1lLCBuYW1lLCBsb2NhbE5hbWUsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gKFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIpLnN1YnN0cmluZygwLCAyICsgdGhpcy5zaXplICogMik7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIHZhbHVlKSB7XG4gICAgICAgIGxldCBkYXRhID0gYXJyYXlpZnkodmFsdWUpO1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGggIT09IHRoaXMuc2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihcImluY29ycmVjdCBkYXRhIGxlbmd0aFwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlci53cml0ZUJ5dGVzKGRhdGEpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJldHVybiByZWFkZXIuY29lcmNlKHRoaXMubmFtZSwgaGV4bGlmeShyZWFkZXIucmVhZEJ5dGVzKHRoaXMuc2l6ZSkpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maXhlZC1ieXRlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IENvZGVyIH0gZnJvbSBcIi4vYWJzdHJhY3QtY29kZXJcIjtcbmV4cG9ydCBjbGFzcyBOdWxsQ29kZXIgZXh0ZW5kcyBDb2RlciB7XG4gICAgY29uc3RydWN0b3IobG9jYWxOYW1lKSB7XG4gICAgICAgIHN1cGVyKFwibnVsbFwiLCBcIlwiLCBsb2NhbE5hbWUsIGZhbHNlKTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJub3QgbnVsbFwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlci53cml0ZUJ5dGVzKFtdKTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZWFkZXIucmVhZEJ5dGVzKDApO1xuICAgICAgICByZXR1cm4gcmVhZGVyLmNvZXJjZSh0aGlzLm5hbWUsIG51bGwpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW51bGwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyXCI7XG5pbXBvcnQgeyBNYXhVaW50MjU2LCBOZWdhdGl2ZU9uZSwgT25lLCBaZXJvIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2RlclwiO1xuZXhwb3J0IGNsYXNzIE51bWJlckNvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKHNpemUsIHNpZ25lZCwgbG9jYWxOYW1lKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSAoKHNpZ25lZCA/IFwiaW50XCIgOiBcInVpbnRcIikgKyAoc2l6ZSAqIDgpKTtcbiAgICAgICAgc3VwZXIobmFtZSwgbmFtZSwgbG9jYWxOYW1lLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgICAgIHRoaXMuc2lnbmVkID0gc2lnbmVkO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCB2YWx1ZSkge1xuICAgICAgICBsZXQgdiA9IEJpZ051bWJlci5mcm9tKHZhbHVlKTtcbiAgICAgICAgLy8gQ2hlY2sgYm91bmRzIGFyZSBzYWZlIGZvciBlbmNvZGluZ1xuICAgICAgICBsZXQgbWF4VWludFZhbHVlID0gTWF4VWludDI1Ni5tYXNrKHdyaXRlci53b3JkU2l6ZSAqIDgpO1xuICAgICAgICBpZiAodGhpcy5zaWduZWQpIHtcbiAgICAgICAgICAgIGxldCBib3VuZHMgPSBtYXhVaW50VmFsdWUubWFzayh0aGlzLnNpemUgKiA4IC0gMSk7XG4gICAgICAgICAgICBpZiAodi5ndChib3VuZHMpIHx8IHYubHQoYm91bmRzLmFkZChPbmUpLm11bChOZWdhdGl2ZU9uZSkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihcInZhbHVlIG91dC1vZi1ib3VuZHNcIiwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHYubHQoWmVybykgfHwgdi5ndChtYXhVaW50VmFsdWUubWFzayh0aGlzLnNpemUgKiA4KSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJ2YWx1ZSBvdXQtb2YtYm91bmRzXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB2ID0gdi50b1R3b3ModGhpcy5zaXplICogOCkubWFzayh0aGlzLnNpemUgKiA4KTtcbiAgICAgICAgaWYgKHRoaXMuc2lnbmVkKSB7XG4gICAgICAgICAgICB2ID0gdi5mcm9tVHdvcyh0aGlzLnNpemUgKiA4KS50b1R3b3MoOCAqIHdyaXRlci53b3JkU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlci53cml0ZVZhbHVlKHYpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHJlYWRlci5yZWFkVmFsdWUoKS5tYXNrKHRoaXMuc2l6ZSAqIDgpO1xuICAgICAgICBpZiAodGhpcy5zaWduZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuZnJvbVR3b3ModGhpcy5zaXplICogOCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlYWRlci5jb2VyY2UodGhpcy5uYW1lLCB2YWx1ZSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bnVtYmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgdG9VdGY4Qnl0ZXMsIHRvVXRmOFN0cmluZyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9zdHJpbmdzXCI7XG5pbXBvcnQgeyBEeW5hbWljQnl0ZXNDb2RlciB9IGZyb20gXCIuL2J5dGVzXCI7XG5leHBvcnQgY2xhc3MgU3RyaW5nQ29kZXIgZXh0ZW5kcyBEeW5hbWljQnl0ZXNDb2RlciB7XG4gICAgY29uc3RydWN0b3IobG9jYWxOYW1lKSB7XG4gICAgICAgIHN1cGVyKFwic3RyaW5nXCIsIGxvY2FsTmFtZSk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5lbmNvZGUod3JpdGVyLCB0b1V0ZjhCeXRlcyh2YWx1ZSkpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJldHVybiB0b1V0ZjhTdHJpbmcoc3VwZXIuZGVjb2RlKHJlYWRlcikpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0cmluZy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IENvZGVyIH0gZnJvbSBcIi4vYWJzdHJhY3QtY29kZXJcIjtcbmltcG9ydCB7IHBhY2ssIHVucGFjayB9IGZyb20gXCIuL2FycmF5XCI7XG5leHBvcnQgY2xhc3MgVHVwbGVDb2RlciBleHRlbmRzIENvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb2RlcnMsIGxvY2FsTmFtZSkge1xuICAgICAgICBsZXQgZHluYW1pYyA9IGZhbHNlO1xuICAgICAgICBjb25zdCB0eXBlcyA9IFtdO1xuICAgICAgICBjb2RlcnMuZm9yRWFjaCgoY29kZXIpID0+IHtcbiAgICAgICAgICAgIGlmIChjb2Rlci5keW5hbWljKSB7XG4gICAgICAgICAgICAgICAgZHluYW1pYyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0eXBlcy5wdXNoKGNvZGVyLnR5cGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdHlwZSA9IChcInR1cGxlKFwiICsgdHlwZXMuam9pbihcIixcIikgKyBcIilcIik7XG4gICAgICAgIHN1cGVyKFwidHVwbGVcIiwgdHlwZSwgbG9jYWxOYW1lLCBkeW5hbWljKTtcbiAgICAgICAgdGhpcy5jb2RlcnMgPSBjb2RlcnM7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgICAgIHRoaXMuY29kZXJzLmZvckVhY2goKGNvZGVyKSA9PiB7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaChjb2Rlci5kZWZhdWx0VmFsdWUoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBXZSBvbmx5IG91dHB1dCBuYW1lZCBwcm9wZXJ0aWVzIGZvciB1bmlxdWVseSBuYW1lZCBjb2RlcnNcbiAgICAgICAgY29uc3QgdW5pcXVlTmFtZXMgPSB0aGlzLmNvZGVycy5yZWR1Y2UoKGFjY3VtLCBjb2RlcikgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGNvZGVyLmxvY2FsTmFtZTtcbiAgICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhY2N1bVtuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBhY2N1bVtuYW1lXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFjY3VtW25hbWVdKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgLy8gQWRkIG5hbWVkIHZhbHVlc1xuICAgICAgICB0aGlzLmNvZGVycy5mb3JFYWNoKChjb2RlciwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGxldCBuYW1lID0gY29kZXIubG9jYWxOYW1lO1xuICAgICAgICAgICAgaWYgKCFuYW1lIHx8IHVuaXF1ZU5hbWVzW25hbWVdICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5hbWUgPT09IFwibGVuZ3RoXCIpIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gXCJfbGVuZ3RoXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWVzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZXNbbmFtZV0gPSB2YWx1ZXNbaW5kZXhdO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUodmFsdWVzKTtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHBhY2sod3JpdGVyLCB0aGlzLmNvZGVycywgdmFsdWUpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJldHVybiByZWFkZXIuY29lcmNlKHRoaXMubmFtZSwgdW5wYWNrKHJlYWRlciwgdGhpcy5jb2RlcnMpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10dXBsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9iaWdudW1iZXJcIjtcbmltcG9ydCB7IGRlZmluZVJlYWRPbmx5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbjtcbmNvbnN0IF9jb25zdHJ1Y3Rvckd1YXJkID0ge307XG5sZXQgTW9kaWZpZXJzQnl0ZXMgPSB7IGNhbGxkYXRhOiB0cnVlLCBtZW1vcnk6IHRydWUsIHN0b3JhZ2U6IHRydWUgfTtcbmxldCBNb2RpZmllcnNOZXN0ID0geyBjYWxsZGF0YTogdHJ1ZSwgbWVtb3J5OiB0cnVlIH07XG5mdW5jdGlvbiBjaGVja01vZGlmaWVyKHR5cGUsIG5hbWUpIHtcbiAgICBpZiAodHlwZSA9PT0gXCJieXRlc1wiIHx8IHR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKE1vZGlmaWVyc0J5dGVzW25hbWVdKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSBcImFkZHJlc3NcIikge1xuICAgICAgICBpZiAobmFtZSA9PT0gXCJwYXlhYmxlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUuaW5kZXhPZihcIltcIikgPj0gMCB8fCB0eXBlID09PSBcInR1cGxlXCIpIHtcbiAgICAgICAgaWYgKE1vZGlmaWVyc05lc3RbbmFtZV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChNb2RpZmllcnNCeXRlc1tuYW1lXSB8fCBuYW1lID09PSBcInBheWFibGVcIikge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBtb2RpZmllclwiLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8vIEBUT0RPOiBNYWtlIHN1cmUgdGhhdCBjaGlsZHJlbiBvZiBhbiBpbmRleGVkIHR1cGxlIGFyZSBtYXJrZWQgd2l0aCBhIG51bGwgaW5kZXhlZFxuZnVuY3Rpb24gcGFyc2VQYXJhbVR5cGUocGFyYW0sIGFsbG93SW5kZXhlZCkge1xuICAgIGxldCBvcmlnaW5hbFBhcmFtID0gcGFyYW07XG4gICAgZnVuY3Rpb24gdGhyb3dFcnJvcihpKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYHVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IHBvc2l0aW9uICR7aX1gLCBcInBhcmFtXCIsIHBhcmFtKTtcbiAgICB9XG4gICAgcGFyYW0gPSBwYXJhbS5yZXBsYWNlKC9cXHMvZywgXCIgXCIpO1xuICAgIGZ1bmN0aW9uIG5ld05vZGUocGFyZW50KSB7XG4gICAgICAgIGxldCBub2RlID0geyB0eXBlOiBcIlwiLCBuYW1lOiBcIlwiLCBwYXJlbnQ6IHBhcmVudCwgc3RhdGU6IHsgYWxsb3dUeXBlOiB0cnVlIH0gfTtcbiAgICAgICAgaWYgKGFsbG93SW5kZXhlZCkge1xuICAgICAgICAgICAgbm9kZS5pbmRleGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIGxldCBwYXJlbnQgPSB7IHR5cGU6IFwiXCIsIG5hbWU6IFwiXCIsIHN0YXRlOiB7IGFsbG93VHlwZTogdHJ1ZSB9IH07XG4gICAgbGV0IG5vZGUgPSBwYXJlbnQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJhbS5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgYyA9IHBhcmFtW2ldO1xuICAgICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgICAgIGNhc2UgXCIoXCI6XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuc3RhdGUuYWxsb3dUeXBlICYmIG5vZGUudHlwZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnR5cGUgPSBcInR1cGxlXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFub2RlLnN0YXRlLmFsbG93UGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUuYWxsb3dUeXBlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbm9kZS50eXBlID0gdmVyaWZ5VHlwZShub2RlLnR5cGUpO1xuICAgICAgICAgICAgICAgIG5vZGUuY29tcG9uZW50cyA9IFtuZXdOb2RlKG5vZGUpXTtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5jb21wb25lbnRzWzBdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIilcIjpcbiAgICAgICAgICAgICAgICBkZWxldGUgbm9kZS5zdGF0ZTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5uYW1lID09PSBcImluZGV4ZWRcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFsbG93SW5kZXhlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBub2RlLmluZGV4ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBub2RlLm5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tNb2RpZmllcihub2RlLnR5cGUsIG5vZGUubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5uYW1lID0gXCJcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZS50eXBlID0gdmVyaWZ5VHlwZShub2RlLnR5cGUpO1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgICAgICAgICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWxldGUgY2hpbGQucGFyZW50O1xuICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUuYWxsb3dQYXJhbXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBub2RlLnN0YXRlLmFsbG93TmFtZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgbm9kZS5zdGF0ZS5hbGxvd0FycmF5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCIsXCI6XG4gICAgICAgICAgICAgICAgZGVsZXRlIG5vZGUuc3RhdGU7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubmFtZSA9PT0gXCJpbmRleGVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhbGxvd0luZGV4ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoaSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbm9kZS5pbmRleGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5uYW1lID0gXCJcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrTW9kaWZpZXIobm9kZS50eXBlLCBub2RlLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUubmFtZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vZGUudHlwZSA9IHZlcmlmeVR5cGUobm9kZS50eXBlKTtcbiAgICAgICAgICAgICAgICBsZXQgc2libGluZyA9IG5ld05vZGUobm9kZS5wYXJlbnQpO1xuICAgICAgICAgICAgICAgIC8veyB0eXBlOiBcIlwiLCBuYW1lOiBcIlwiLCBwYXJlbnQ6IG5vZGUucGFyZW50LCBzdGF0ZTogeyBhbGxvd1R5cGU6IHRydWUgfSB9O1xuICAgICAgICAgICAgICAgIG5vZGUucGFyZW50LmNvbXBvbmVudHMucHVzaChzaWJsaW5nKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgbm9kZS5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHNpYmxpbmc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBIaXQgYSBzcGFjZS4uLlxuICAgICAgICAgICAgY2FzZSBcIiBcIjpcbiAgICAgICAgICAgICAgICAvLyBJZiByZWFkaW5nIHR5cGUsIHRoZSB0eXBlIGlzIGRvbmUgYW5kIG1heSByZWFkIGEgcGFyYW0gb3IgbmFtZVxuICAgICAgICAgICAgICAgIGlmIChub2RlLnN0YXRlLmFsbG93VHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS50eXBlICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnR5cGUgPSB2ZXJpZnlUeXBlKG5vZGUudHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgbm9kZS5zdGF0ZS5hbGxvd1R5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnN0YXRlLmFsbG93TmFtZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnN0YXRlLmFsbG93UGFyYW1zID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiByZWFkaW5nIG5hbWUsIHRoZSBuYW1lIGlzIGRvbmVcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5zdGF0ZS5hbGxvd05hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubmFtZSAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubmFtZSA9PT0gXCJpbmRleGVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFsbG93SW5kZXhlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5pbmRleGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuaW5kZXhlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5uYW1lID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrTW9kaWZpZXIobm9kZS50eXBlLCBub2RlLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5uYW1lID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUuYWxsb3dOYW1lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiW1wiOlxuICAgICAgICAgICAgICAgIGlmICghbm9kZS5zdGF0ZS5hbGxvd0FycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vZGUudHlwZSArPSBjO1xuICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUuYWxsb3dBcnJheSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUuYWxsb3dOYW1lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbm9kZS5zdGF0ZS5yZWFkQXJyYXkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIl1cIjpcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGUuc3RhdGUucmVhZEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vZGUudHlwZSArPSBjO1xuICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUucmVhZEFycmF5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbm9kZS5zdGF0ZS5hbGxvd0FycmF5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBub2RlLnN0YXRlLmFsbG93TmFtZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmIChub2RlLnN0YXRlLmFsbG93VHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnR5cGUgKz0gYztcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zdGF0ZS5hbGxvd1BhcmFtcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUuYWxsb3dBcnJheSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUuc3RhdGUuYWxsb3dOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUubmFtZSArPSBjO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbm9kZS5zdGF0ZS5hbGxvd0FycmF5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChub2RlLnN0YXRlLnJlYWRBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnR5cGUgKz0gYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLnBhcmVudCkge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5leHBlY3RlZCBlb2ZcIiwgXCJwYXJhbVwiLCBwYXJhbSk7XG4gICAgfVxuICAgIGRlbGV0ZSBwYXJlbnQuc3RhdGU7XG4gICAgaWYgKG5vZGUubmFtZSA9PT0gXCJpbmRleGVkXCIpIHtcbiAgICAgICAgaWYgKCFhbGxvd0luZGV4ZWQpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Iob3JpZ2luYWxQYXJhbS5sZW5ndGggLSA3KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5pbmRleGVkKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKG9yaWdpbmFsUGFyYW0ubGVuZ3RoIC0gNyk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5pbmRleGVkID0gdHJ1ZTtcbiAgICAgICAgbm9kZS5uYW1lID0gXCJcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2hlY2tNb2RpZmllcihub2RlLnR5cGUsIG5vZGUubmFtZSkpIHtcbiAgICAgICAgbm9kZS5uYW1lID0gXCJcIjtcbiAgICB9XG4gICAgcGFyZW50LnR5cGUgPSB2ZXJpZnlUeXBlKHBhcmVudC50eXBlKTtcbiAgICByZXR1cm4gcGFyZW50O1xufVxuZnVuY3Rpb24gcG9wdWxhdGUob2JqZWN0LCBwYXJhbXMpIHtcbiAgICBmb3IgKGxldCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KG9iamVjdCwga2V5LCBwYXJhbXNba2V5XSk7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IEZvcm1hdFR5cGVzID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgLy8gQmFyZSBmb3JtYXR0aW5nLCBhcyBpcyBuZWVkZWQgZm9yIGNvbXB1dGluZyBhIHNpZ2hhc2ggb2YgYW4gZXZlbnQgb3IgZnVuY3Rpb25cbiAgICBzaWdoYXNoOiBcInNpZ2hhc2hcIixcbiAgICAvLyBIdW1hbi1SZWFkYWJsZSB3aXRoIE1pbmltYWwgc3BhY2luZyBhbmQgd2l0aG91dCBuYW1lcyAoY29tcGFjdCBodW1hbi1yZWFkYWJsZSlcbiAgICBtaW5pbWFsOiBcIm1pbmltYWxcIixcbiAgICAvLyBIdW1hbi1SZWFkYWJsZSB3aXRoIG5pY2Ugc3BhY2luZywgaW5jbHVkaW5nIGFsbCBuYW1lc1xuICAgIGZ1bGw6IFwiZnVsbFwiLFxuICAgIC8vIEpTT04tZm9ybWF0IGEgbGEgU29saWRpdHlcbiAgICBqc29uOiBcImpzb25cIlxufSk7XG5jb25zdCBwYXJhbVR5cGVBcnJheSA9IG5ldyBSZWdFeHAoL14oLiopXFxbKFswLTldKilcXF0kLyk7XG5leHBvcnQgY2xhc3MgUGFyYW1UeXBlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25zdHJ1Y3Rvckd1YXJkLCBwYXJhbXMpIHtcbiAgICAgICAgaWYgKGNvbnN0cnVjdG9yR3VhcmQgIT09IF9jb25zdHJ1Y3Rvckd1YXJkKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInVzZSBmcm9tU3RyaW5nXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcIm5ldyBQYXJhbVR5cGUoKVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBwb3B1bGF0ZSh0aGlzLCBwYXJhbXMpO1xuICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLnR5cGUubWF0Y2gocGFyYW1UeXBlQXJyYXkpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHBvcHVsYXRlKHRoaXMsIHtcbiAgICAgICAgICAgICAgICBhcnJheUxlbmd0aDogcGFyc2VJbnQobWF0Y2hbMl0gfHwgXCItMVwiKSxcbiAgICAgICAgICAgICAgICBhcnJheUNoaWxkcmVuOiBQYXJhbVR5cGUuZnJvbU9iamVjdCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IG1hdGNoWzFdLFxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzOiB0aGlzLmNvbXBvbmVudHNcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBiYXNlVHlwZTogXCJhcnJheVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBvcHVsYXRlKHRoaXMsIHtcbiAgICAgICAgICAgICAgICBhcnJheUxlbmd0aDogbnVsbCxcbiAgICAgICAgICAgICAgICBhcnJheUNoaWxkcmVuOiBudWxsLFxuICAgICAgICAgICAgICAgIGJhc2VUeXBlOiAoKHRoaXMuY29tcG9uZW50cyAhPSBudWxsKSA/IFwidHVwbGVcIiA6IHRoaXMudHlwZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzUGFyYW1UeXBlID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICB9XG4gICAgLy8gRm9ybWF0IHRoZSBwYXJhbWV0ZXIgZnJhZ21lbnRcbiAgICAvLyAgIC0gc2lnaGFzaDogXCIodWludDI1NixhZGRyZXNzKVwiXG4gICAgLy8gICAtIG1pbmltYWw6IFwidHVwbGUodWludDI1NixhZGRyZXNzKSBpbmRleGVkXCJcbiAgICAvLyAgIC0gZnVsbDogICAgXCJ0dXBsZSh1aW50MjU2IGZvbywgYWRkcmVzcyBiYXIpIGluZGV4ZWQgYmF6XCJcbiAgICBmb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmICghZm9ybWF0KSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBGb3JtYXRUeXBlcy5zaWdoYXNoO1xuICAgICAgICB9XG4gICAgICAgIGlmICghRm9ybWF0VHlwZXNbZm9ybWF0XSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZm9ybWF0IHR5cGVcIiwgXCJmb3JtYXRcIiwgZm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBGb3JtYXRUeXBlcy5qc29uKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICgodGhpcy5iYXNlVHlwZSA9PT0gXCJ0dXBsZVwiKSA/IFwidHVwbGVcIiA6IHRoaXMudHlwZSksXG4gICAgICAgICAgICAgICAgbmFtZTogKHRoaXMubmFtZSB8fCB1bmRlZmluZWQpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAodGhpcy5pbmRleGVkKSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuaW5kZXhlZCA9IHRoaXMuaW5kZXhlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuY29tcG9uZW50cyA9IHRoaXMuY29tcG9uZW50cy5tYXAoKGNvbXApID0+IEpTT04ucGFyc2UoY29tcC5mb3JtYXQoZm9ybWF0KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIC8vIEFycmF5XG4gICAgICAgIGlmICh0aGlzLmJhc2VUeXBlID09PSBcImFycmF5XCIpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLmFycmF5Q2hpbGRyZW4uZm9ybWF0KGZvcm1hdCk7XG4gICAgICAgICAgICByZXN1bHQgKz0gXCJbXCIgKyAodGhpcy5hcnJheUxlbmd0aCA8IDAgPyBcIlwiIDogU3RyaW5nKHRoaXMuYXJyYXlMZW5ndGgpKSArIFwiXVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuYmFzZVR5cGUgPT09IFwidHVwbGVcIikge1xuICAgICAgICAgICAgICAgIGlmIChmb3JtYXQgIT09IEZvcm1hdFR5cGVzLnNpZ2hhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMudHlwZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiKFwiICsgdGhpcy5jb21wb25lbnRzLm1hcCgoY29tcCkgPT4gY29tcC5mb3JtYXQoZm9ybWF0KSkuam9pbigoZm9ybWF0ID09PSBGb3JtYXRUeXBlcy5mdWxsKSA/IFwiLCBcIiA6IFwiLFwiKSArIFwiKVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMudHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ICE9PSBGb3JtYXRUeXBlcy5zaWdoYXNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbmRleGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiIGluZGV4ZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09IEZvcm1hdFR5cGVzLmZ1bGwgJiYgdGhpcy5uYW1lKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiIFwiICsgdGhpcy5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKHZhbHVlLCBhbGxvd0luZGV4ZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gUGFyYW1UeXBlLmZyb21TdHJpbmcodmFsdWUsIGFsbG93SW5kZXhlZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFBhcmFtVHlwZS5mcm9tT2JqZWN0KHZhbHVlKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21PYmplY3QodmFsdWUpIHtcbiAgICAgICAgaWYgKFBhcmFtVHlwZS5pc1BhcmFtVHlwZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBhcmFtVHlwZShfY29uc3RydWN0b3JHdWFyZCwge1xuICAgICAgICAgICAgbmFtZTogKHZhbHVlLm5hbWUgfHwgbnVsbCksXG4gICAgICAgICAgICB0eXBlOiB2ZXJpZnlUeXBlKHZhbHVlLnR5cGUpLFxuICAgICAgICAgICAgaW5kZXhlZDogKCh2YWx1ZS5pbmRleGVkID09IG51bGwpID8gbnVsbCA6ICEhdmFsdWUuaW5kZXhlZCksXG4gICAgICAgICAgICBjb21wb25lbnRzOiAodmFsdWUuY29tcG9uZW50cyA/IHZhbHVlLmNvbXBvbmVudHMubWFwKFBhcmFtVHlwZS5mcm9tT2JqZWN0KSA6IG51bGwpXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVN0cmluZyh2YWx1ZSwgYWxsb3dJbmRleGVkKSB7XG4gICAgICAgIGZ1bmN0aW9uIFBhcmFtVHlwaWZ5KG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBQYXJhbVR5cGUuZnJvbU9iamVjdCh7XG4gICAgICAgICAgICAgICAgbmFtZTogbm9kZS5uYW1lLFxuICAgICAgICAgICAgICAgIHR5cGU6IG5vZGUudHlwZSxcbiAgICAgICAgICAgICAgICBpbmRleGVkOiBub2RlLmluZGV4ZWQsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50czogbm9kZS5jb21wb25lbnRzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUGFyYW1UeXBpZnkocGFyc2VQYXJhbVR5cGUodmFsdWUsICEhYWxsb3dJbmRleGVkKSk7XG4gICAgfVxuICAgIHN0YXRpYyBpc1BhcmFtVHlwZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gISEodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZS5faXNQYXJhbVR5cGUpO1xuICAgIH1cbn1cbjtcbmZ1bmN0aW9uIHBhcnNlUGFyYW1zKHZhbHVlLCBhbGxvd0luZGV4KSB7XG4gICAgcmV0dXJuIHNwbGl0TmVzdGluZyh2YWx1ZSkubWFwKChwYXJhbSkgPT4gUGFyYW1UeXBlLmZyb21TdHJpbmcocGFyYW0sIGFsbG93SW5kZXgpKTtcbn1cbmV4cG9ydCBjbGFzcyBGcmFnbWVudCB7XG4gICAgY29uc3RydWN0b3IoY29uc3RydWN0b3JHdWFyZCwgcGFyYW1zKSB7XG4gICAgICAgIGlmIChjb25zdHJ1Y3Rvckd1YXJkICE9PSBfY29uc3RydWN0b3JHdWFyZCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ1c2UgYSBzdGF0aWMgZnJvbSBtZXRob2RcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwibmV3IEZyYWdtZW50KClcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcG9wdWxhdGUodGhpcywgcGFyYW1zKTtcbiAgICAgICAgdGhpcy5faXNGcmFnbWVudCA9IHRydWU7XG4gICAgICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKHZhbHVlKSB7XG4gICAgICAgIGlmIChGcmFnbWVudC5pc0ZyYWdtZW50KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIEZyYWdtZW50LmZyb21TdHJpbmcodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBGcmFnbWVudC5mcm9tT2JqZWN0KHZhbHVlKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21PYmplY3QodmFsdWUpIHtcbiAgICAgICAgaWYgKEZyYWdtZW50LmlzRnJhZ21lbnQodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh2YWx1ZS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb25GcmFnbWVudC5mcm9tT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgXCJldmVudFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBFdmVudEZyYWdtZW50LmZyb21PYmplY3QodmFsdWUpO1xuICAgICAgICAgICAgY2FzZSBcImNvbnN0cnVjdG9yXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yRnJhZ21lbnQuZnJvbU9iamVjdCh2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gRXJyb3JGcmFnbWVudC5mcm9tT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgXCJmYWxsYmFja1wiOlxuICAgICAgICAgICAgY2FzZSBcInJlY2VpdmVcIjpcbiAgICAgICAgICAgICAgICAvLyBAVE9ETzogU29tZXRoaW5nPyBNYXliZSByZXR1cm4gYSBGdW5jdGlvbkZyYWdtZW50PyBBIGN1c3RvbSBEZWZhdWx0RnVuY3Rpb25GcmFnbWVudD9cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZnJhZ21lbnQgb2JqZWN0XCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVN0cmluZyh2YWx1ZSkge1xuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIFwicmV0dXJuc1wiIGlzIHN1cnJvdW5kZWQgYnkgYSBzcGFjZSBhbmQgYWxsIHdoaXRlc3BhY2UgaXMgZXhhY3RseSBvbmUgc3BhY2VcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXHMvZywgXCIgXCIpO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcKC9nLCBcIiAoXCIpLnJlcGxhY2UoL1xcKS9nLCBcIikgXCIpLnJlcGxhY2UoL1xccysvZywgXCIgXCIpO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgICAgICAgaWYgKHZhbHVlLnNwbGl0KFwiIFwiKVswXSA9PT0gXCJldmVudFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gRXZlbnRGcmFnbWVudC5mcm9tU3RyaW5nKHZhbHVlLnN1YnN0cmluZyg1KS50cmltKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlLnNwbGl0KFwiIFwiKVswXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gRnVuY3Rpb25GcmFnbWVudC5mcm9tU3RyaW5nKHZhbHVlLnN1YnN0cmluZyg4KS50cmltKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlLnNwbGl0KFwiKFwiKVswXS50cmltKCkgPT09IFwiY29uc3RydWN0b3JcIikge1xuICAgICAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yRnJhZ21lbnQuZnJvbVN0cmluZyh2YWx1ZS50cmltKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlLnNwbGl0KFwiIFwiKVswXSA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgICByZXR1cm4gRXJyb3JGcmFnbWVudC5mcm9tU3RyaW5nKHZhbHVlLnN1YnN0cmluZyg1KS50cmltKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5zdXBwb3J0ZWQgZnJhZ21lbnRcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgfVxuICAgIHN0YXRpYyBpc0ZyYWdtZW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5faXNGcmFnbWVudCk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEV2ZW50RnJhZ21lbnQgZXh0ZW5kcyBGcmFnbWVudCB7XG4gICAgZm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBpZiAoIWZvcm1hdCkge1xuICAgICAgICAgICAgZm9ybWF0ID0gRm9ybWF0VHlwZXMuc2lnaGFzaDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUZvcm1hdFR5cGVzW2Zvcm1hdF0pIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGZvcm1hdCB0eXBlXCIsIFwiZm9ybWF0XCIsIGZvcm1hdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gRm9ybWF0VHlwZXMuanNvbikge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImV2ZW50XCIsXG4gICAgICAgICAgICAgICAgYW5vbnltb3VzOiB0aGlzLmFub255bW91cyxcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICAgICAgaW5wdXRzOiB0aGlzLmlucHV0cy5tYXAoKGlucHV0KSA9PiBKU09OLnBhcnNlKGlucHV0LmZvcm1hdChmb3JtYXQpKSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgICBpZiAoZm9ybWF0ICE9PSBGb3JtYXRUeXBlcy5zaWdoYXNoKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gXCJldmVudCBcIjtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gdGhpcy5uYW1lICsgXCIoXCIgKyB0aGlzLmlucHV0cy5tYXAoKGlucHV0KSA9PiBpbnB1dC5mb3JtYXQoZm9ybWF0KSkuam9pbigoZm9ybWF0ID09PSBGb3JtYXRUeXBlcy5mdWxsKSA/IFwiLCBcIiA6IFwiLFwiKSArIFwiKSBcIjtcbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gRm9ybWF0VHlwZXMuc2lnaGFzaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYW5vbnltb3VzKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiYW5vbnltb3VzIFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQudHJpbSgpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbSh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBFdmVudEZyYWdtZW50LmZyb21TdHJpbmcodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBFdmVudEZyYWdtZW50LmZyb21PYmplY3QodmFsdWUpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbU9iamVjdCh2YWx1ZSkge1xuICAgICAgICBpZiAoRXZlbnRGcmFnbWVudC5pc0V2ZW50RnJhZ21lbnQodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlLnR5cGUgIT09IFwiZXZlbnRcIikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZXZlbnQgb2JqZWN0XCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgICAgIG5hbWU6IHZlcmlmeUlkZW50aWZpZXIodmFsdWUubmFtZSksXG4gICAgICAgICAgICBhbm9ueW1vdXM6IHZhbHVlLmFub255bW91cyxcbiAgICAgICAgICAgIGlucHV0czogKHZhbHVlLmlucHV0cyA/IHZhbHVlLmlucHV0cy5tYXAoUGFyYW1UeXBlLmZyb21PYmplY3QpIDogW10pLFxuICAgICAgICAgICAgdHlwZTogXCJldmVudFwiXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgRXZlbnRGcmFnbWVudChfY29uc3RydWN0b3JHdWFyZCwgcGFyYW1zKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21TdHJpbmcodmFsdWUpIHtcbiAgICAgICAgbGV0IG1hdGNoID0gdmFsdWUubWF0Y2gocmVnZXhQYXJlbik7XG4gICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGV2ZW50IHN0cmluZ1wiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYW5vbnltb3VzID0gZmFsc2U7XG4gICAgICAgIG1hdGNoWzNdLnNwbGl0KFwiIFwiKS5mb3JFYWNoKChtb2RpZmllcikgPT4ge1xuICAgICAgICAgICAgc3dpdGNoIChtb2RpZmllci50cmltKCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiYW5vbnltb3VzXCI6XG4gICAgICAgICAgICAgICAgICAgIGFub255bW91cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJcIjpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oXCJ1bmtub3duIG1vZGlmaWVyOiBcIiArIG1vZGlmaWVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBFdmVudEZyYWdtZW50LmZyb21PYmplY3Qoe1xuICAgICAgICAgICAgbmFtZTogbWF0Y2hbMV0udHJpbSgpLFxuICAgICAgICAgICAgYW5vbnltb3VzOiBhbm9ueW1vdXMsXG4gICAgICAgICAgICBpbnB1dHM6IHBhcnNlUGFyYW1zKG1hdGNoWzJdLCB0cnVlKSxcbiAgICAgICAgICAgIHR5cGU6IFwiZXZlbnRcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGlzRXZlbnRGcmFnbWVudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlLl9pc0ZyYWdtZW50ICYmIHZhbHVlLnR5cGUgPT09IFwiZXZlbnRcIik7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VHYXModmFsdWUsIHBhcmFtcykge1xuICAgIHBhcmFtcy5nYXMgPSBudWxsO1xuICAgIGxldCBjb21wcyA9IHZhbHVlLnNwbGl0KFwiQFwiKTtcbiAgICBpZiAoY29tcHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIGlmIChjb21wcy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBodW1hbi1yZWFkYWJsZSBBQkkgc2lnbmF0dXJlXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29tcHNbMV0ubWF0Y2goL15bMC05XSskLykpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGh1bWFuLXJlYWRhYmxlIEFCSSBzaWduYXR1cmUgZ2FzXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtcy5nYXMgPSBCaWdOdW1iZXIuZnJvbShjb21wc1sxXSk7XG4gICAgICAgIHJldHVybiBjb21wc1swXTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gcGFyc2VNb2RpZmllcnModmFsdWUsIHBhcmFtcykge1xuICAgIHBhcmFtcy5jb25zdGFudCA9IGZhbHNlO1xuICAgIHBhcmFtcy5wYXlhYmxlID0gZmFsc2U7XG4gICAgcGFyYW1zLnN0YXRlTXV0YWJpbGl0eSA9IFwibm9ucGF5YWJsZVwiO1xuICAgIHZhbHVlLnNwbGl0KFwiIFwiKS5mb3JFYWNoKChtb2RpZmllcikgPT4ge1xuICAgICAgICBzd2l0Y2ggKG1vZGlmaWVyLnRyaW0oKSkge1xuICAgICAgICAgICAgY2FzZSBcImNvbnN0YW50XCI6XG4gICAgICAgICAgICAgICAgcGFyYW1zLmNvbnN0YW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJwYXlhYmxlXCI6XG4gICAgICAgICAgICAgICAgcGFyYW1zLnBheWFibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHBhcmFtcy5zdGF0ZU11dGFiaWxpdHkgPSBcInBheWFibGVcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJub25wYXlhYmxlXCI6XG4gICAgICAgICAgICAgICAgcGFyYW1zLnBheWFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBwYXJhbXMuc3RhdGVNdXRhYmlsaXR5ID0gXCJub25wYXlhYmxlXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicHVyZVwiOlxuICAgICAgICAgICAgICAgIHBhcmFtcy5jb25zdGFudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcGFyYW1zLnN0YXRlTXV0YWJpbGl0eSA9IFwicHVyZVwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInZpZXdcIjpcbiAgICAgICAgICAgICAgICBwYXJhbXMuY29uc3RhbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHBhcmFtcy5zdGF0ZU11dGFiaWxpdHkgPSBcInZpZXdcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJleHRlcm5hbFwiOlxuICAgICAgICAgICAgY2FzZSBcInB1YmxpY1wiOlxuICAgICAgICAgICAgY2FzZSBcIlwiOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInVua25vd24gbW9kaWZpZXI6IFwiICsgbW9kaWZpZXIpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiB2ZXJpZnlTdGF0ZSh2YWx1ZSkge1xuICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgIGNvbnN0YW50OiBmYWxzZSxcbiAgICAgICAgcGF5YWJsZTogdHJ1ZSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInBheWFibGVcIlxuICAgIH07XG4gICAgaWYgKHZhbHVlLnN0YXRlTXV0YWJpbGl0eSAhPSBudWxsKSB7XG4gICAgICAgIHJlc3VsdC5zdGF0ZU11dGFiaWxpdHkgPSB2YWx1ZS5zdGF0ZU11dGFiaWxpdHk7XG4gICAgICAgIC8vIFNldCAoYW5kIGNoZWNrIHRoaW5ncyBhcmUgY29uc2lzdGVudCkgdGhlIGNvbnN0YW50IHByb3BlcnR5XG4gICAgICAgIHJlc3VsdC5jb25zdGFudCA9IChyZXN1bHQuc3RhdGVNdXRhYmlsaXR5ID09PSBcInZpZXdcIiB8fCByZXN1bHQuc3RhdGVNdXRhYmlsaXR5ID09PSBcInB1cmVcIik7XG4gICAgICAgIGlmICh2YWx1ZS5jb25zdGFudCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoKCEhdmFsdWUuY29uc3RhbnQpICE9PSByZXN1bHQuY29uc3RhbnQpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiY2Fubm90IGhhdmUgY29uc3RhbnQgZnVuY3Rpb24gd2l0aCBtdXRhYmlsaXR5IFwiICsgcmVzdWx0LnN0YXRlTXV0YWJpbGl0eSwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IChhbmQgY2hlY2sgdGhpbmdzIGFyZSBjb25zaXN0ZW50KSB0aGUgcGF5YWJsZSBwcm9wZXJ0eVxuICAgICAgICByZXN1bHQucGF5YWJsZSA9IChyZXN1bHQuc3RhdGVNdXRhYmlsaXR5ID09PSBcInBheWFibGVcIik7XG4gICAgICAgIGlmICh2YWx1ZS5wYXlhYmxlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICgoISF2YWx1ZS5wYXlhYmxlKSAhPT0gcmVzdWx0LnBheWFibGUpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiY2Fubm90IGhhdmUgcGF5YWJsZSBmdW5jdGlvbiB3aXRoIG11dGFiaWxpdHkgXCIgKyByZXN1bHQuc3RhdGVNdXRhYmlsaXR5LCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZS5wYXlhYmxlICE9IG51bGwpIHtcbiAgICAgICAgcmVzdWx0LnBheWFibGUgPSAhIXZhbHVlLnBheWFibGU7XG4gICAgICAgIC8vIElmIHBheWFibGUgd2UgY2FuIGFzc3VtZSBub24tY29uc3RhbnQ7IG90aGVyd2lzZSB3ZSBjYW4ndCBhc3N1bWVcbiAgICAgICAgaWYgKHZhbHVlLmNvbnN0YW50ID09IG51bGwgJiYgIXJlc3VsdC5wYXlhYmxlICYmIHZhbHVlLnR5cGUgIT09IFwiY29uc3RydWN0b3JcIikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVuYWJsZSB0byBkZXRlcm1pbmUgc3RhdGVNdXRhYmlsaXR5XCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5jb25zdGFudCA9ICEhdmFsdWUuY29uc3RhbnQ7XG4gICAgICAgIGlmIChyZXN1bHQuY29uc3RhbnQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zdGF0ZU11dGFiaWxpdHkgPSBcInZpZXdcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5zdGF0ZU11dGFiaWxpdHkgPSAocmVzdWx0LnBheWFibGUgPyBcInBheWFibGVcIiA6IFwibm9ucGF5YWJsZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0LnBheWFibGUgJiYgcmVzdWx0LmNvbnN0YW50KSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiY2Fubm90IGhhdmUgY29uc3RhbnQgcGF5YWJsZSBmdW5jdGlvblwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZS5jb25zdGFudCAhPSBudWxsKSB7XG4gICAgICAgIHJlc3VsdC5jb25zdGFudCA9ICEhdmFsdWUuY29uc3RhbnQ7XG4gICAgICAgIHJlc3VsdC5wYXlhYmxlID0gIXJlc3VsdC5jb25zdGFudDtcbiAgICAgICAgcmVzdWx0LnN0YXRlTXV0YWJpbGl0eSA9IChyZXN1bHQuY29uc3RhbnQgPyBcInZpZXdcIiA6IFwicGF5YWJsZVwiKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUudHlwZSAhPT0gXCJjb25zdHJ1Y3RvclwiKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bmFibGUgdG8gZGV0ZXJtaW5lIHN0YXRlTXV0YWJpbGl0eVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBjbGFzcyBDb25zdHJ1Y3RvckZyYWdtZW50IGV4dGVuZHMgRnJhZ21lbnQge1xuICAgIGZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFmb3JtYXQpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IEZvcm1hdFR5cGVzLnNpZ2hhc2g7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFGb3JtYXRUeXBlc1tmb3JtYXRdKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmb3JtYXQgdHlwZVwiLCBcImZvcm1hdFwiLCBmb3JtYXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IEZvcm1hdFR5cGVzLmpzb24pIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb25zdHJ1Y3RvclwiLFxuICAgICAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eTogKCh0aGlzLnN0YXRlTXV0YWJpbGl0eSAhPT0gXCJub25wYXlhYmxlXCIpID8gdGhpcy5zdGF0ZU11dGFiaWxpdHkgOiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgIHBheWFibGU6IHRoaXMucGF5YWJsZSxcbiAgICAgICAgICAgICAgICBnYXM6ICh0aGlzLmdhcyA/IHRoaXMuZ2FzLnRvTnVtYmVyKCkgOiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgIGlucHV0czogdGhpcy5pbnB1dHMubWFwKChpbnB1dCkgPT4gSlNPTi5wYXJzZShpbnB1dC5mb3JtYXQoZm9ybWF0KSkpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBGb3JtYXRUeXBlcy5zaWdoYXNoKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImNhbm5vdCBmb3JtYXQgYSBjb25zdHJ1Y3RvciBmb3Igc2lnaGFzaFwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJmb3JtYXQoc2lnaGFzaClcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiY29uc3RydWN0b3IoXCIgKyB0aGlzLmlucHV0cy5tYXAoKGlucHV0KSA9PiBpbnB1dC5mb3JtYXQoZm9ybWF0KSkuam9pbigoZm9ybWF0ID09PSBGb3JtYXRUeXBlcy5mdWxsKSA/IFwiLCBcIiA6IFwiLFwiKSArIFwiKSBcIjtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGVNdXRhYmlsaXR5ICYmIHRoaXMuc3RhdGVNdXRhYmlsaXR5ICE9PSBcIm5vbnBheWFibGVcIikge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuc3RhdGVNdXRhYmlsaXR5ICsgXCIgXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC50cmltKCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yRnJhZ21lbnQuZnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yRnJhZ21lbnQuZnJvbU9iamVjdCh2YWx1ZSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tT2JqZWN0KHZhbHVlKSB7XG4gICAgICAgIGlmIChDb25zdHJ1Y3RvckZyYWdtZW50LmlzQ29uc3RydWN0b3JGcmFnbWVudCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUudHlwZSAhPT0gXCJjb25zdHJ1Y3RvclwiKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBjb25zdHJ1Y3RvciBvYmplY3RcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXRlID0gdmVyaWZ5U3RhdGUodmFsdWUpO1xuICAgICAgICBpZiAoc3RhdGUuY29uc3RhbnQpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY29uc3RhbnRcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgICAgbmFtZTogbnVsbCxcbiAgICAgICAgICAgIHR5cGU6IHZhbHVlLnR5cGUsXG4gICAgICAgICAgICBpbnB1dHM6ICh2YWx1ZS5pbnB1dHMgPyB2YWx1ZS5pbnB1dHMubWFwKFBhcmFtVHlwZS5mcm9tT2JqZWN0KSA6IFtdKSxcbiAgICAgICAgICAgIHBheWFibGU6IHN0YXRlLnBheWFibGUsXG4gICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IHN0YXRlLnN0YXRlTXV0YWJpbGl0eSxcbiAgICAgICAgICAgIGdhczogKHZhbHVlLmdhcyA/IEJpZ051bWJlci5mcm9tKHZhbHVlLmdhcykgOiBudWxsKVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yRnJhZ21lbnQoX2NvbnN0cnVjdG9yR3VhcmQsIHBhcmFtcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIGxldCBwYXJhbXMgPSB7IHR5cGU6IFwiY29uc3RydWN0b3JcIiB9O1xuICAgICAgICB2YWx1ZSA9IHBhcnNlR2FzKHZhbHVlLCBwYXJhbXMpO1xuICAgICAgICBsZXQgcGFyZW5zID0gdmFsdWUubWF0Y2gocmVnZXhQYXJlbik7XG4gICAgICAgIGlmICghcGFyZW5zIHx8IHBhcmVuc1sxXS50cmltKCkgIT09IFwiY29uc3RydWN0b3JcIikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgY29uc3RydWN0b3Igc3RyaW5nXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtcy5pbnB1dHMgPSBwYXJzZVBhcmFtcyhwYXJlbnNbMl0udHJpbSgpLCBmYWxzZSk7XG4gICAgICAgIHBhcnNlTW9kaWZpZXJzKHBhcmVuc1szXS50cmltKCksIHBhcmFtcyk7XG4gICAgICAgIHJldHVybiBDb25zdHJ1Y3RvckZyYWdtZW50LmZyb21PYmplY3QocGFyYW1zKTtcbiAgICB9XG4gICAgc3RhdGljIGlzQ29uc3RydWN0b3JGcmFnbWVudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlLl9pc0ZyYWdtZW50ICYmIHZhbHVlLnR5cGUgPT09IFwiY29uc3RydWN0b3JcIik7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEZ1bmN0aW9uRnJhZ21lbnQgZXh0ZW5kcyBDb25zdHJ1Y3RvckZyYWdtZW50IHtcbiAgICBmb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmICghZm9ybWF0KSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBGb3JtYXRUeXBlcy5zaWdoYXNoO1xuICAgICAgICB9XG4gICAgICAgIGlmICghRm9ybWF0VHlwZXNbZm9ybWF0XSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZm9ybWF0IHR5cGVcIiwgXCJmb3JtYXRcIiwgZm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBGb3JtYXRUeXBlcy5qc29uKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICAgICAgY29uc3RhbnQ6IHRoaXMuY29uc3RhbnQsXG4gICAgICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAoKHRoaXMuc3RhdGVNdXRhYmlsaXR5ICE9PSBcIm5vbnBheWFibGVcIikgPyB0aGlzLnN0YXRlTXV0YWJpbGl0eSA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgcGF5YWJsZTogdGhpcy5wYXlhYmxlLFxuICAgICAgICAgICAgICAgIGdhczogKHRoaXMuZ2FzID8gdGhpcy5nYXMudG9OdW1iZXIoKSA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgaW5wdXRzOiB0aGlzLmlucHV0cy5tYXAoKGlucHV0KSA9PiBKU09OLnBhcnNlKGlucHV0LmZvcm1hdChmb3JtYXQpKSksXG4gICAgICAgICAgICAgICAgb3V0cHV0czogdGhpcy5vdXRwdXRzLm1hcCgob3V0cHV0KSA9PiBKU09OLnBhcnNlKG91dHB1dC5mb3JtYXQoZm9ybWF0KSkpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIGlmIChmb3JtYXQgIT09IEZvcm1hdFR5cGVzLnNpZ2hhc2gpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBcImZ1bmN0aW9uIFwiO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSB0aGlzLm5hbWUgKyBcIihcIiArIHRoaXMuaW5wdXRzLm1hcCgoaW5wdXQpID0+IGlucHV0LmZvcm1hdChmb3JtYXQpKS5qb2luKChmb3JtYXQgPT09IEZvcm1hdFR5cGVzLmZ1bGwpID8gXCIsIFwiIDogXCIsXCIpICsgXCIpIFwiO1xuICAgICAgICBpZiAoZm9ybWF0ICE9PSBGb3JtYXRUeXBlcy5zaWdoYXNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZU11dGFiaWxpdHkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZU11dGFiaWxpdHkgIT09IFwibm9ucGF5YWJsZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAodGhpcy5zdGF0ZU11dGFiaWxpdHkgKyBcIiBcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jb25zdGFudCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcInZpZXcgXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRzICYmIHRoaXMub3V0cHV0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCJyZXR1cm5zIChcIiArIHRoaXMub3V0cHV0cy5tYXAoKG91dHB1dCkgPT4gb3V0cHV0LmZvcm1hdChmb3JtYXQpKS5qb2luKFwiLCBcIikgKyBcIikgXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5nYXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIkBcIiArIHRoaXMuZ2FzLnRvU3RyaW5nKCkgKyBcIiBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LnRyaW0oKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb20odmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gRnVuY3Rpb25GcmFnbWVudC5mcm9tU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRnVuY3Rpb25GcmFnbWVudC5mcm9tT2JqZWN0KHZhbHVlKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21PYmplY3QodmFsdWUpIHtcbiAgICAgICAgaWYgKEZ1bmN0aW9uRnJhZ21lbnQuaXNGdW5jdGlvbkZyYWdtZW50KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS50eXBlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGZ1bmN0aW9uIG9iamVjdFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhdGUgPSB2ZXJpZnlTdGF0ZSh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgICAgIHR5cGU6IHZhbHVlLnR5cGUsXG4gICAgICAgICAgICBuYW1lOiB2ZXJpZnlJZGVudGlmaWVyKHZhbHVlLm5hbWUpLFxuICAgICAgICAgICAgY29uc3RhbnQ6IHN0YXRlLmNvbnN0YW50LFxuICAgICAgICAgICAgaW5wdXRzOiAodmFsdWUuaW5wdXRzID8gdmFsdWUuaW5wdXRzLm1hcChQYXJhbVR5cGUuZnJvbU9iamVjdCkgOiBbXSksXG4gICAgICAgICAgICBvdXRwdXRzOiAodmFsdWUub3V0cHV0cyA/IHZhbHVlLm91dHB1dHMubWFwKFBhcmFtVHlwZS5mcm9tT2JqZWN0KSA6IFtdKSxcbiAgICAgICAgICAgIHBheWFibGU6IHN0YXRlLnBheWFibGUsXG4gICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IHN0YXRlLnN0YXRlTXV0YWJpbGl0eSxcbiAgICAgICAgICAgIGdhczogKHZhbHVlLmdhcyA/IEJpZ051bWJlci5mcm9tKHZhbHVlLmdhcykgOiBudWxsKVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uRnJhZ21lbnQoX2NvbnN0cnVjdG9yR3VhcmQsIHBhcmFtcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIGxldCBwYXJhbXMgPSB7IHR5cGU6IFwiZnVuY3Rpb25cIiB9O1xuICAgICAgICB2YWx1ZSA9IHBhcnNlR2FzKHZhbHVlLCBwYXJhbXMpO1xuICAgICAgICBsZXQgY29tcHMgPSB2YWx1ZS5zcGxpdChcIiByZXR1cm5zIFwiKTtcbiAgICAgICAgaWYgKGNvbXBzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGZ1bmN0aW9uIHN0cmluZ1wiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGFyZW5zID0gY29tcHNbMF0ubWF0Y2gocmVnZXhQYXJlbik7XG4gICAgICAgIGlmICghcGFyZW5zKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmdW5jdGlvbiBzaWduYXR1cmVcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zLm5hbWUgPSBwYXJlbnNbMV0udHJpbSgpO1xuICAgICAgICBpZiAocGFyYW1zLm5hbWUpIHtcbiAgICAgICAgICAgIHZlcmlmeUlkZW50aWZpZXIocGFyYW1zLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtcy5pbnB1dHMgPSBwYXJzZVBhcmFtcyhwYXJlbnNbMl0sIGZhbHNlKTtcbiAgICAgICAgcGFyc2VNb2RpZmllcnMocGFyZW5zWzNdLnRyaW0oKSwgcGFyYW1zKTtcbiAgICAgICAgLy8gV2UgaGF2ZSBvdXRwdXRzXG4gICAgICAgIGlmIChjb21wcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBsZXQgcmV0dXJucyA9IGNvbXBzWzFdLm1hdGNoKHJlZ2V4UGFyZW4pO1xuICAgICAgICAgICAgaWYgKHJldHVybnNbMV0udHJpbSgpICE9IFwiXCIgfHwgcmV0dXJuc1szXS50cmltKCkgIT0gXCJcIikge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bmV4cGVjdGVkIHRva2Vuc1wiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmFtcy5vdXRwdXRzID0gcGFyc2VQYXJhbXMocmV0dXJuc1syXSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zLm91dHB1dHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRnVuY3Rpb25GcmFnbWVudC5mcm9tT2JqZWN0KHBhcmFtcyk7XG4gICAgfVxuICAgIHN0YXRpYyBpc0Z1bmN0aW9uRnJhZ21lbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZS5faXNGcmFnbWVudCAmJiB2YWx1ZS50eXBlID09PSBcImZ1bmN0aW9uXCIpO1xuICAgIH1cbn1cbi8vZXhwb3J0IGNsYXNzIFN0cnVjdEZyYWdtZW50IGV4dGVuZHMgRnJhZ21lbnQge1xuLy99XG5mdW5jdGlvbiBjaGVja0ZvcmJpZGRlbihmcmFnbWVudCkge1xuICAgIGNvbnN0IHNpZyA9IGZyYWdtZW50LmZvcm1hdCgpO1xuICAgIGlmIChzaWcgPT09IFwiRXJyb3Ioc3RyaW5nKVwiIHx8IHNpZyA9PT0gXCJQYW5pYyh1aW50MjU2KVwiKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYGNhbm5vdCBzcGVjaWZ5IHVzZXIgZGVmaW5lZCAke3NpZ30gZXJyb3JgLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIGZyYWdtZW50O1xufVxuZXhwb3J0IGNsYXNzIEVycm9yRnJhZ21lbnQgZXh0ZW5kcyBGcmFnbWVudCB7XG4gICAgZm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBpZiAoIWZvcm1hdCkge1xuICAgICAgICAgICAgZm9ybWF0ID0gRm9ybWF0VHlwZXMuc2lnaGFzaDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUZvcm1hdFR5cGVzW2Zvcm1hdF0pIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGZvcm1hdCB0eXBlXCIsIFwiZm9ybWF0XCIsIGZvcm1hdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gRm9ybWF0VHlwZXMuanNvbikge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgICAgIGlucHV0czogdGhpcy5pbnB1dHMubWFwKChpbnB1dCkgPT4gSlNPTi5wYXJzZShpbnB1dC5mb3JtYXQoZm9ybWF0KSkpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIGlmIChmb3JtYXQgIT09IEZvcm1hdFR5cGVzLnNpZ2hhc2gpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBcImVycm9yIFwiO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSB0aGlzLm5hbWUgKyBcIihcIiArIHRoaXMuaW5wdXRzLm1hcCgoaW5wdXQpID0+IGlucHV0LmZvcm1hdChmb3JtYXQpKS5qb2luKChmb3JtYXQgPT09IEZvcm1hdFR5cGVzLmZ1bGwpID8gXCIsIFwiIDogXCIsXCIpICsgXCIpIFwiO1xuICAgICAgICByZXR1cm4gcmVzdWx0LnRyaW0oKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb20odmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gRXJyb3JGcmFnbWVudC5mcm9tU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRXJyb3JGcmFnbWVudC5mcm9tT2JqZWN0KHZhbHVlKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21PYmplY3QodmFsdWUpIHtcbiAgICAgICAgaWYgKEVycm9yRnJhZ21lbnQuaXNFcnJvckZyYWdtZW50KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS50eXBlICE9PSBcImVycm9yXCIpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGVycm9yIG9iamVjdFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgICB0eXBlOiB2YWx1ZS50eXBlLFxuICAgICAgICAgICAgbmFtZTogdmVyaWZ5SWRlbnRpZmllcih2YWx1ZS5uYW1lKSxcbiAgICAgICAgICAgIGlucHV0czogKHZhbHVlLmlucHV0cyA/IHZhbHVlLmlucHV0cy5tYXAoUGFyYW1UeXBlLmZyb21PYmplY3QpIDogW10pXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjaGVja0ZvcmJpZGRlbihuZXcgRXJyb3JGcmFnbWVudChfY29uc3RydWN0b3JHdWFyZCwgcGFyYW1zKSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIGxldCBwYXJhbXMgPSB7IHR5cGU6IFwiZXJyb3JcIiB9O1xuICAgICAgICBsZXQgcGFyZW5zID0gdmFsdWUubWF0Y2gocmVnZXhQYXJlbik7XG4gICAgICAgIGlmICghcGFyZW5zKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBlcnJvciBzaWduYXR1cmVcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zLm5hbWUgPSBwYXJlbnNbMV0udHJpbSgpO1xuICAgICAgICBpZiAocGFyYW1zLm5hbWUpIHtcbiAgICAgICAgICAgIHZlcmlmeUlkZW50aWZpZXIocGFyYW1zLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtcy5pbnB1dHMgPSBwYXJzZVBhcmFtcyhwYXJlbnNbMl0sIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIGNoZWNrRm9yYmlkZGVuKEVycm9yRnJhZ21lbnQuZnJvbU9iamVjdChwYXJhbXMpKTtcbiAgICB9XG4gICAgc3RhdGljIGlzRXJyb3JGcmFnbWVudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlLl9pc0ZyYWdtZW50ICYmIHZhbHVlLnR5cGUgPT09IFwiZXJyb3JcIik7XG4gICAgfVxufVxuZnVuY3Rpb24gdmVyaWZ5VHlwZSh0eXBlKSB7XG4gICAgLy8gVGhlc2UgbmVlZCB0byBiZSB0cmFuc2Zvcm1lZCB0byB0aGVpciBmdWxsIGRlc2NyaXB0aW9uXG4gICAgaWYgKHR5cGUubWF0Y2goL151aW50KCR8W14xLTldKS8pKSB7XG4gICAgICAgIHR5cGUgPSBcInVpbnQyNTZcIiArIHR5cGUuc3Vic3RyaW5nKDQpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlLm1hdGNoKC9eaW50KCR8W14xLTldKS8pKSB7XG4gICAgICAgIHR5cGUgPSBcImludDI1NlwiICsgdHlwZS5zdWJzdHJpbmcoMyk7XG4gICAgfVxuICAgIC8vIEBUT0RPOiBtb3JlIHZlcmlmaWNhdGlvblxuICAgIHJldHVybiB0eXBlO1xufVxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vc29saWRpdHkvYmxvYi8xZjhmMWEzZGI5M2E1NDhkMDU1NWUzZTE0Y2ZjNTVhMTBlMjViNjBlL2RvY3MvZ3JhbW1hci9Tb2xpZGl0eUxleGVyLmc0I0wyMzRcbmNvbnN0IHJlZ2V4SWRlbnRpZmllciA9IG5ldyBSZWdFeHAoXCJeW2EtekEtWiRfXVthLXpBLVowLTkkX10qJFwiKTtcbmZ1bmN0aW9uIHZlcmlmeUlkZW50aWZpZXIodmFsdWUpIHtcbiAgICBpZiAoIXZhbHVlIHx8ICF2YWx1ZS5tYXRjaChyZWdleElkZW50aWZpZXIpKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYGludmFsaWQgaWRlbnRpZmllciBcIiR7dmFsdWV9XCJgLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuY29uc3QgcmVnZXhQYXJlbiA9IG5ldyBSZWdFeHAoXCJeKFteKShdKilcXFxcKCguKilcXFxcKShbXikoXSopJFwiKTtcbmZ1bmN0aW9uIHNwbGl0TmVzdGluZyh2YWx1ZSkge1xuICAgIHZhbHVlID0gdmFsdWUudHJpbSgpO1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBsZXQgYWNjdW0gPSBcIlwiO1xuICAgIGxldCBkZXB0aCA9IDA7XG4gICAgZm9yIChsZXQgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgdmFsdWUubGVuZ3RoOyBvZmZzZXQrKykge1xuICAgICAgICBsZXQgYyA9IHZhbHVlW29mZnNldF07XG4gICAgICAgIGlmIChjID09PSBcIixcIiAmJiBkZXB0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYWNjdW0pO1xuICAgICAgICAgICAgYWNjdW0gPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWNjdW0gKz0gYztcbiAgICAgICAgICAgIGlmIChjID09PSBcIihcIikge1xuICAgICAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjID09PSBcIilcIikge1xuICAgICAgICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgICAgICAgICAgaWYgKGRlcHRoID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5iYWxhbmNlZCBwYXJlbnRoZXNpc1wiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFjY3VtKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGFjY3VtKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZyYWdtZW50cy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYWRkcmVzc1wiO1xuaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2JpZ251bWJlclwiO1xuaW1wb3J0IHsgYXJyYXlpZnksIGNvbmNhdCwgaGV4RGF0YVNsaWNlLCBoZXhsaWZ5LCBoZXhaZXJvUGFkLCBpc0hleFN0cmluZyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuaW1wb3J0IHsgaWQgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvaGFzaFwiO1xuaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2tlY2NhazI1NlwiO1xuaW1wb3J0IHsgZGVmaW5lUmVhZE9ubHksIERlc2NyaXB0aW9uLCBnZXRTdGF0aWMgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiO1xuaW1wb3J0IHsgZGVmYXVsdEFiaUNvZGVyIH0gZnJvbSBcIi4vYWJpLWNvZGVyXCI7XG5pbXBvcnQgeyBjaGVja1Jlc3VsdEVycm9ycyB9IGZyb20gXCIuL2NvZGVycy9hYnN0cmFjdC1jb2RlclwiO1xuaW1wb3J0IHsgQ29uc3RydWN0b3JGcmFnbWVudCwgRXZlbnRGcmFnbWVudCwgRm9ybWF0VHlwZXMsIEZyYWdtZW50LCBGdW5jdGlvbkZyYWdtZW50LCBQYXJhbVR5cGUgfSBmcm9tIFwiLi9mcmFnbWVudHNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmV4cG9ydCB7IGNoZWNrUmVzdWx0RXJyb3JzIH07XG5leHBvcnQgY2xhc3MgTG9nRGVzY3JpcHRpb24gZXh0ZW5kcyBEZXNjcmlwdGlvbiB7XG59XG5leHBvcnQgY2xhc3MgVHJhbnNhY3Rpb25EZXNjcmlwdGlvbiBleHRlbmRzIERlc2NyaXB0aW9uIHtcbn1cbmV4cG9ydCBjbGFzcyBFcnJvckRlc2NyaXB0aW9uIGV4dGVuZHMgRGVzY3JpcHRpb24ge1xufVxuZXhwb3J0IGNsYXNzIEluZGV4ZWQgZXh0ZW5kcyBEZXNjcmlwdGlvbiB7XG4gICAgc3RhdGljIGlzSW5kZXhlZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX2lzSW5kZXhlZCk7XG4gICAgfVxufVxuY29uc3QgQnVpbHRpbkVycm9ycyA9IHtcbiAgICBcIjB4MDhjMzc5YTBcIjogeyBzaWduYXR1cmU6IFwiRXJyb3Ioc3RyaW5nKVwiLCBuYW1lOiBcIkVycm9yXCIsIGlucHV0czogW1wic3RyaW5nXCJdLCByZWFzb246IHRydWUgfSxcbiAgICBcIjB4NGU0ODdiNzFcIjogeyBzaWduYXR1cmU6IFwiUGFuaWModWludDI1NilcIiwgbmFtZTogXCJQYW5pY1wiLCBpbnB1dHM6IFtcInVpbnQyNTZcIl0gfVxufTtcbmZ1bmN0aW9uIHdyYXBBY2Nlc3NFcnJvcihwcm9wZXJ0eSwgZXJyb3IpIHtcbiAgICBjb25zdCB3cmFwID0gbmV3IEVycm9yKGBkZWZlcnJlZCBlcnJvciBkdXJpbmcgQUJJIGRlY29kaW5nIHRyaWdnZXJlZCBhY2Nlc3NpbmcgJHtwcm9wZXJ0eX1gKTtcbiAgICB3cmFwLmVycm9yID0gZXJyb3I7XG4gICAgcmV0dXJuIHdyYXA7XG59XG4vKlxuZnVuY3Rpb24gY2hlY2tOYW1lcyhmcmFnbWVudDogRnJhZ21lbnQsIHR5cGU6IFwiaW5wdXRcIiB8IFwib3V0cHV0XCIsIHBhcmFtczogQXJyYXk8UGFyYW1UeXBlPik6IHZvaWQge1xuICAgIHBhcmFtcy5yZWR1Y2UoKGFjY3VtLCBwYXJhbSkgPT4ge1xuICAgICAgICBpZiAocGFyYW0ubmFtZSkge1xuICAgICAgICAgICAgaWYgKGFjY3VtW3BhcmFtLm5hbWVdKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgZHVwbGljYXRlICR7IHR5cGUgfSBwYXJhbWV0ZXIgJHsgSlNPTi5zdHJpbmdpZnkocGFyYW0ubmFtZSkgfSBpbiAkeyBmcmFnbWVudC5mb3JtYXQoXCJmdWxsXCIpIH1gLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFjY3VtW3BhcmFtLm5hbWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgfSwgPHsgWyBuYW1lOiBzdHJpbmcgXTogYm9vbGVhbiB9PnsgfSk7XG59XG4qL1xuZXhwb3J0IGNsYXNzIEludGVyZmFjZSB7XG4gICAgY29uc3RydWN0b3IoZnJhZ21lbnRzKSB7XG4gICAgICAgIGxldCBhYmkgPSBbXTtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnRzKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgYWJpID0gSlNPTi5wYXJzZShmcmFnbWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWJpID0gZnJhZ21lbnRzO1xuICAgICAgICB9XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiZnJhZ21lbnRzXCIsIGFiaS5tYXAoKGZyYWdtZW50KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gRnJhZ21lbnQuZnJvbShmcmFnbWVudCk7XG4gICAgICAgIH0pLmZpbHRlcigoZnJhZ21lbnQpID0+IChmcmFnbWVudCAhPSBudWxsKSkpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9hYmlDb2RlclwiLCBnZXRTdGF0aWMobmV3LnRhcmdldCwgXCJnZXRBYmlDb2RlclwiKSgpKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJmdW5jdGlvbnNcIiwge30pO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImVycm9yc1wiLCB7fSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiZXZlbnRzXCIsIHt9KTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJzdHJ1Y3RzXCIsIHt9KTtcbiAgICAgICAgLy8gQWRkIGFsbCBmcmFnbWVudHMgYnkgdGhlaXIgc2lnbmF0dXJlXG4gICAgICAgIHRoaXMuZnJhZ21lbnRzLmZvckVhY2goKGZyYWdtZW50KSA9PiB7XG4gICAgICAgICAgICBsZXQgYnVja2V0ID0gbnVsbDtcbiAgICAgICAgICAgIHN3aXRjaCAoZnJhZ21lbnQudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjb25zdHJ1Y3RvclwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kZXBsb3kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiZHVwbGljYXRlIGRlZmluaXRpb24gLSBjb25zdHJ1Y3RvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvL2NoZWNrTmFtZXMoZnJhZ21lbnQsIFwiaW5wdXRcIiwgZnJhZ21lbnQuaW5wdXRzKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJkZXBsb3lcIiwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2tOYW1lcyhmcmFnbWVudCwgXCJpbnB1dFwiLCBmcmFnbWVudC5pbnB1dHMpO1xuICAgICAgICAgICAgICAgICAgICAvL2NoZWNrTmFtZXMoZnJhZ21lbnQsIFwib3V0cHV0XCIsICg8RnVuY3Rpb25GcmFnbWVudD5mcmFnbWVudCkub3V0cHV0cyk7XG4gICAgICAgICAgICAgICAgICAgIGJ1Y2tldCA9IHRoaXMuZnVuY3Rpb25zO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXZlbnRcIjpcbiAgICAgICAgICAgICAgICAgICAgLy9jaGVja05hbWVzKGZyYWdtZW50LCBcImlucHV0XCIsIGZyYWdtZW50LmlucHV0cyk7XG4gICAgICAgICAgICAgICAgICAgIGJ1Y2tldCA9IHRoaXMuZXZlbnRzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgICAgICAgYnVja2V0ID0gdGhpcy5lcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzaWduYXR1cmUgPSBmcmFnbWVudC5mb3JtYXQoKTtcbiAgICAgICAgICAgIGlmIChidWNrZXRbc2lnbmF0dXJlXSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiZHVwbGljYXRlIGRlZmluaXRpb24gLSBcIiArIHNpZ25hdHVyZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVja2V0W3NpZ25hdHVyZV0gPSBmcmFnbWVudDtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIElmIHdlIGRvIG5vdCBoYXZlIGEgY29uc3RydWN0b3IgYWRkIGEgZGVmYXVsdFxuICAgICAgICBpZiAoIXRoaXMuZGVwbG95KSB7XG4gICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImRlcGxveVwiLCBDb25zdHJ1Y3RvckZyYWdtZW50LmZyb20oe1xuICAgICAgICAgICAgICAgIHBheWFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29uc3RydWN0b3JcIlxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX2lzSW50ZXJmYWNlXCIsIHRydWUpO1xuICAgIH1cbiAgICBmb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmICghZm9ybWF0KSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBGb3JtYXRUeXBlcy5mdWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IEZvcm1hdFR5cGVzLnNpZ2hhc2gpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnRlcmZhY2UgZG9lcyBub3Qgc3VwcG9ydCBmb3JtYXR0aW5nIHNpZ2hhc2hcIiwgXCJmb3JtYXRcIiwgZm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhYmkgPSB0aGlzLmZyYWdtZW50cy5tYXAoKGZyYWdtZW50KSA9PiBmcmFnbWVudC5mb3JtYXQoZm9ybWF0KSk7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gcmUtYnVuZGxlIHRoZSBKU09OIGZyYWdtZW50cyBhIGJpdFxuICAgICAgICBpZiAoZm9ybWF0ID09PSBGb3JtYXRUeXBlcy5qc29uKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYWJpLm1hcCgoaikgPT4gSlNPTi5wYXJzZShqKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhYmk7XG4gICAgfVxuICAgIC8vIFN1Yi1jbGFzc2VzIGNhbiBvdmVycmlkZSB0aGVzZSB0byBoYW5kbGUgb3RoZXIgYmxvY2tjaGFpbnNcbiAgICBzdGF0aWMgZ2V0QWJpQ29kZXIoKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0QWJpQ29kZXI7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIGdldEFkZHJlc3MoYWRkcmVzcyk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRTaWdoYXNoKGZyYWdtZW50KSB7XG4gICAgICAgIHJldHVybiBoZXhEYXRhU2xpY2UoaWQoZnJhZ21lbnQuZm9ybWF0KCkpLCAwLCA0KTtcbiAgICB9XG4gICAgc3RhdGljIGdldEV2ZW50VG9waWMoZXZlbnRGcmFnbWVudCkge1xuICAgICAgICByZXR1cm4gaWQoZXZlbnRGcmFnbWVudC5mb3JtYXQoKSk7XG4gICAgfVxuICAgIC8vIEZpbmQgYSBmdW5jdGlvbiBkZWZpbml0aW9uIGJ5IGFueSBtZWFucyBuZWNlc3NhcnkgKHVubGVzcyBpdCBpcyBhbWJpZ3VvdXMpXG4gICAgZ2V0RnVuY3Rpb24obmFtZU9yU2lnbmF0dXJlT3JTaWdoYXNoKSB7XG4gICAgICAgIGlmIChpc0hleFN0cmluZyhuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2gpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdGhpcy5mdW5jdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAobmFtZU9yU2lnbmF0dXJlT3JTaWdoYXNoID09PSB0aGlzLmdldFNpZ2hhc2gobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnVuY3Rpb25zW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJubyBtYXRjaGluZyBmdW5jdGlvblwiLCBcInNpZ2hhc2hcIiwgbmFtZU9yU2lnbmF0dXJlT3JTaWdoYXNoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJdCBpcyBhIGJhcmUgbmFtZSwgbG9vayB1cCB0aGUgZnVuY3Rpb24gKHdpbGwgcmV0dXJuIG51bGwgaWYgYW1iaWd1b3VzKVxuICAgICAgICBpZiAobmFtZU9yU2lnbmF0dXJlT3JTaWdoYXNoLmluZGV4T2YoXCIoXCIpID09PSAtMSkge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IG5hbWVPclNpZ25hdHVyZU9yU2lnaGFzaC50cmltKCk7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGluZyA9IE9iamVjdC5rZXlzKHRoaXMuZnVuY3Rpb25zKS5maWx0ZXIoKGYpID0+IChmLnNwbGl0KFwiKFwiIC8qIGZpeDopICovKVswXSA9PT0gbmFtZSkpO1xuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJubyBtYXRjaGluZyBmdW5jdGlvblwiLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtYXRjaGluZy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm11bHRpcGxlIG1hdGNoaW5nIGZ1bmN0aW9uc1wiLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mdW5jdGlvbnNbbWF0Y2hpbmdbMF1dO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgc2lnbmF0dXJlIGFuZCBsb29rdXAgdGhlIGZ1bmN0aW9uXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZnVuY3Rpb25zW0Z1bmN0aW9uRnJhZ21lbnQuZnJvbVN0cmluZyhuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2gpLmZvcm1hdCgpXTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJubyBtYXRjaGluZyBmdW5jdGlvblwiLCBcInNpZ25hdHVyZVwiLCBuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2gpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIEZpbmQgYW4gZXZlbnQgZGVmaW5pdGlvbiBieSBhbnkgbWVhbnMgbmVjZXNzYXJ5ICh1bmxlc3MgaXQgaXMgYW1iaWd1b3VzKVxuICAgIGdldEV2ZW50KG5hbWVPclNpZ25hdHVyZU9yVG9waWMpIHtcbiAgICAgICAgaWYgKGlzSGV4U3RyaW5nKG5hbWVPclNpZ25hdHVyZU9yVG9waWMpKSB7XG4gICAgICAgICAgICBjb25zdCB0b3BpY2hhc2ggPSBuYW1lT3JTaWduYXR1cmVPclRvcGljLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdGhpcy5ldmVudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9waWNoYXNoID09PSB0aGlzLmdldEV2ZW50VG9waWMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRzW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJubyBtYXRjaGluZyBldmVudFwiLCBcInRvcGljaGFzaFwiLCB0b3BpY2hhc2gpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEl0IGlzIGEgYmFyZSBuYW1lLCBsb29rIHVwIHRoZSBmdW5jdGlvbiAod2lsbCByZXR1cm4gbnVsbCBpZiBhbWJpZ3VvdXMpXG4gICAgICAgIGlmIChuYW1lT3JTaWduYXR1cmVPclRvcGljLmluZGV4T2YoXCIoXCIpID09PSAtMSkge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IG5hbWVPclNpZ25hdHVyZU9yVG9waWMudHJpbSgpO1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hpbmcgPSBPYmplY3Qua2V5cyh0aGlzLmV2ZW50cykuZmlsdGVyKChmKSA9PiAoZi5zcGxpdChcIihcIiAvKiBmaXg6KSAqLylbMF0gPT09IG5hbWUpKTtcbiAgICAgICAgICAgIGlmIChtYXRjaGluZy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwibm8gbWF0Y2hpbmcgZXZlbnRcIiwgXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobWF0Y2hpbmcubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJtdWx0aXBsZSBtYXRjaGluZyBldmVudHNcIiwgXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRzW21hdGNoaW5nWzBdXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIHNpZ25hdHVyZSBhbmQgbG9va3VwIHRoZSBmdW5jdGlvblxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmV2ZW50c1tFdmVudEZyYWdtZW50LmZyb21TdHJpbmcobmFtZU9yU2lnbmF0dXJlT3JUb3BpYykuZm9ybWF0KCldO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm5vIG1hdGNoaW5nIGV2ZW50XCIsIFwic2lnbmF0dXJlXCIsIG5hbWVPclNpZ25hdHVyZU9yVG9waWMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIEZpbmQgYSBmdW5jdGlvbiBkZWZpbml0aW9uIGJ5IGFueSBtZWFucyBuZWNlc3NhcnkgKHVubGVzcyBpdCBpcyBhbWJpZ3VvdXMpXG4gICAgZ2V0RXJyb3IobmFtZU9yU2lnbmF0dXJlT3JTaWdoYXNoKSB7XG4gICAgICAgIGlmIChpc0hleFN0cmluZyhuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2gpKSB7XG4gICAgICAgICAgICBjb25zdCBnZXRTaWdoYXNoID0gZ2V0U3RhdGljKHRoaXMuY29uc3RydWN0b3IsIFwiZ2V0U2lnaGFzaFwiKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiB0aGlzLmVycm9ycykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5lcnJvcnNbbmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKG5hbWVPclNpZ25hdHVyZU9yU2lnaGFzaCA9PT0gZ2V0U2lnaGFzaChlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3JzW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJubyBtYXRjaGluZyBlcnJvclwiLCBcInNpZ2hhc2hcIiwgbmFtZU9yU2lnbmF0dXJlT3JTaWdoYXNoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJdCBpcyBhIGJhcmUgbmFtZSwgbG9vayB1cCB0aGUgZnVuY3Rpb24gKHdpbGwgcmV0dXJuIG51bGwgaWYgYW1iaWd1b3VzKVxuICAgICAgICBpZiAobmFtZU9yU2lnbmF0dXJlT3JTaWdoYXNoLmluZGV4T2YoXCIoXCIpID09PSAtMSkge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IG5hbWVPclNpZ25hdHVyZU9yU2lnaGFzaC50cmltKCk7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGluZyA9IE9iamVjdC5rZXlzKHRoaXMuZXJyb3JzKS5maWx0ZXIoKGYpID0+IChmLnNwbGl0KFwiKFwiIC8qIGZpeDopICovKVswXSA9PT0gbmFtZSkpO1xuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJubyBtYXRjaGluZyBlcnJvclwiLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtYXRjaGluZy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm11bHRpcGxlIG1hdGNoaW5nIGVycm9yc1wiLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcnNbbWF0Y2hpbmdbMF1dO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgc2lnbmF0dXJlIGFuZCBsb29rdXAgdGhlIGZ1bmN0aW9uXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZXJyb3JzW0Z1bmN0aW9uRnJhZ21lbnQuZnJvbVN0cmluZyhuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2gpLmZvcm1hdCgpXTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJubyBtYXRjaGluZyBlcnJvclwiLCBcInNpZ25hdHVyZVwiLCBuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2gpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIEdldCB0aGUgc2lnaGFzaCAodGhlIGJ5dGVzNCBzZWxlY3RvcikgdXNlZCBieSBTb2xpZGl0eSB0byBpZGVudGlmeSBhIGZ1bmN0aW9uXG4gICAgZ2V0U2lnaGFzaChmcmFnbWVudCkge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQgPSB0aGlzLmdldEZ1bmN0aW9uKGZyYWdtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gdGhpcy5nZXRFcnJvcihmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0U3RhdGljKHRoaXMuY29uc3RydWN0b3IsIFwiZ2V0U2lnaGFzaFwiKShmcmFnbWVudCk7XG4gICAgfVxuICAgIC8vIEdldCB0aGUgdG9waWMgKHRoZSBieXRlczMyIGhhc2gpIHVzZWQgYnkgU29saWRpdHkgdG8gaWRlbnRpZnkgYW4gZXZlbnRcbiAgICBnZXRFdmVudFRvcGljKGV2ZW50RnJhZ21lbnQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZXZlbnRGcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGV2ZW50RnJhZ21lbnQgPSB0aGlzLmdldEV2ZW50KGV2ZW50RnJhZ21lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRTdGF0aWModGhpcy5jb25zdHJ1Y3RvciwgXCJnZXRFdmVudFRvcGljXCIpKGV2ZW50RnJhZ21lbnQpO1xuICAgIH1cbiAgICBfZGVjb2RlUGFyYW1zKHBhcmFtcywgZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWJpQ29kZXIuZGVjb2RlKHBhcmFtcywgZGF0YSk7XG4gICAgfVxuICAgIF9lbmNvZGVQYXJhbXMocGFyYW1zLCB2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FiaUNvZGVyLmVuY29kZShwYXJhbXMsIHZhbHVlcyk7XG4gICAgfVxuICAgIGVuY29kZURlcGxveSh2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuY29kZVBhcmFtcyh0aGlzLmRlcGxveS5pbnB1dHMsIHZhbHVlcyB8fCBbXSk7XG4gICAgfVxuICAgIGRlY29kZUVycm9yUmVzdWx0KGZyYWdtZW50LCBkYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZnJhZ21lbnQgPSB0aGlzLmdldEVycm9yKGZyYWdtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBieXRlcyA9IGFycmF5aWZ5KGRhdGEpO1xuICAgICAgICBpZiAoaGV4bGlmeShieXRlcy5zbGljZSgwLCA0KSkgIT09IHRoaXMuZ2V0U2lnaGFzaChmcmFnbWVudCkpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYGRhdGEgc2lnbmF0dXJlIGRvZXMgbm90IG1hdGNoIGVycm9yICR7ZnJhZ21lbnQubmFtZX0uYCwgXCJkYXRhXCIsIGhleGxpZnkoYnl0ZXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGVjb2RlUGFyYW1zKGZyYWdtZW50LmlucHV0cywgYnl0ZXMuc2xpY2UoNCkpO1xuICAgIH1cbiAgICBlbmNvZGVFcnJvclJlc3VsdChmcmFnbWVudCwgdmFsdWVzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZnJhZ21lbnQgPSB0aGlzLmdldEVycm9yKGZyYWdtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGV4bGlmeShjb25jYXQoW1xuICAgICAgICAgICAgdGhpcy5nZXRTaWdoYXNoKGZyYWdtZW50KSxcbiAgICAgICAgICAgIHRoaXMuX2VuY29kZVBhcmFtcyhmcmFnbWVudC5pbnB1dHMsIHZhbHVlcyB8fCBbXSlcbiAgICAgICAgXSkpO1xuICAgIH1cbiAgICAvLyBEZWNvZGUgdGhlIGRhdGEgZm9yIGEgZnVuY3Rpb24gY2FsbCAoZS5nLiB0eC5kYXRhKVxuICAgIGRlY29kZUZ1bmN0aW9uRGF0YShmdW5jdGlvbkZyYWdtZW50LCBkYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGZ1bmN0aW9uRnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBmdW5jdGlvbkZyYWdtZW50ID0gdGhpcy5nZXRGdW5jdGlvbihmdW5jdGlvbkZyYWdtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBieXRlcyA9IGFycmF5aWZ5KGRhdGEpO1xuICAgICAgICBpZiAoaGV4bGlmeShieXRlcy5zbGljZSgwLCA0KSkgIT09IHRoaXMuZ2V0U2lnaGFzaChmdW5jdGlvbkZyYWdtZW50KSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgZGF0YSBzaWduYXR1cmUgZG9lcyBub3QgbWF0Y2ggZnVuY3Rpb24gJHtmdW5jdGlvbkZyYWdtZW50Lm5hbWV9LmAsIFwiZGF0YVwiLCBoZXhsaWZ5KGJ5dGVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlY29kZVBhcmFtcyhmdW5jdGlvbkZyYWdtZW50LmlucHV0cywgYnl0ZXMuc2xpY2UoNCkpO1xuICAgIH1cbiAgICAvLyBFbmNvZGUgdGhlIGRhdGEgZm9yIGEgZnVuY3Rpb24gY2FsbCAoZS5nLiB0eC5kYXRhKVxuICAgIGVuY29kZUZ1bmN0aW9uRGF0YShmdW5jdGlvbkZyYWdtZW50LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnVuY3Rpb25GcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uRnJhZ21lbnQgPSB0aGlzLmdldEZ1bmN0aW9uKGZ1bmN0aW9uRnJhZ21lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KGNvbmNhdChbXG4gICAgICAgICAgICB0aGlzLmdldFNpZ2hhc2goZnVuY3Rpb25GcmFnbWVudCksXG4gICAgICAgICAgICB0aGlzLl9lbmNvZGVQYXJhbXMoZnVuY3Rpb25GcmFnbWVudC5pbnB1dHMsIHZhbHVlcyB8fCBbXSlcbiAgICAgICAgXSkpO1xuICAgIH1cbiAgICAvLyBEZWNvZGUgdGhlIHJlc3VsdCBmcm9tIGEgZnVuY3Rpb24gY2FsbCAoZS5nLiBmcm9tIGV0aF9jYWxsKVxuICAgIGRlY29kZUZ1bmN0aW9uUmVzdWx0KGZ1bmN0aW9uRnJhZ21lbnQsIGRhdGEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnVuY3Rpb25GcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uRnJhZ21lbnQgPSB0aGlzLmdldEZ1bmN0aW9uKGZ1bmN0aW9uRnJhZ21lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBieXRlcyA9IGFycmF5aWZ5KGRhdGEpO1xuICAgICAgICBsZXQgcmVhc29uID0gbnVsbDtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSBcIlwiO1xuICAgICAgICBsZXQgZXJyb3JBcmdzID0gbnVsbDtcbiAgICAgICAgbGV0IGVycm9yTmFtZSA9IG51bGw7XG4gICAgICAgIGxldCBlcnJvclNpZ25hdHVyZSA9IG51bGw7XG4gICAgICAgIHN3aXRjaCAoYnl0ZXMubGVuZ3RoICUgdGhpcy5fYWJpQ29kZXIuX2dldFdvcmRTaXplKCkpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYWJpQ29kZXIuZGVjb2RlKGZ1bmN0aW9uRnJhZ21lbnQub3V0cHV0cywgYnl0ZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0OiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBoZXhsaWZ5KGJ5dGVzLnNsaWNlKDAsIDQpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBidWlsdGluID0gQnVpbHRpbkVycm9yc1tzZWxlY3Rvcl07XG4gICAgICAgICAgICAgICAgaWYgKGJ1aWx0aW4pIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JBcmdzID0gdGhpcy5fYWJpQ29kZXIuZGVjb2RlKGJ1aWx0aW4uaW5wdXRzLCBieXRlcy5zbGljZSg0KSk7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yTmFtZSA9IGJ1aWx0aW4ubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JTaWduYXR1cmUgPSBidWlsdGluLnNpZ25hdHVyZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ1aWx0aW4ucmVhc29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFzb24gPSBlcnJvckFyZ3NbMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yTmFtZSA9PT0gXCJFcnJvclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gYDsgVk0gRXhjZXB0aW9uIHdoaWxlIHByb2Nlc3NpbmcgdHJhbnNhY3Rpb246IHJldmVydGVkIHdpdGggcmVhc29uIHN0cmluZyAke0pTT04uc3RyaW5naWZ5KGVycm9yQXJnc1swXSl9YDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlcnJvck5hbWUgPT09IFwiUGFuaWNcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGA7IFZNIEV4Y2VwdGlvbiB3aGlsZSBwcm9jZXNzaW5nIHRyYW5zYWN0aW9uOiByZXZlcnRlZCB3aXRoIHBhbmljIGNvZGUgJHtlcnJvckFyZ3NbMF19YDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5nZXRFcnJvcihzZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvckFyZ3MgPSB0aGlzLl9hYmlDb2Rlci5kZWNvZGUoZXJyb3IuaW5wdXRzLCBieXRlcy5zbGljZSg0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvck5hbWUgPSBlcnJvci5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JTaWduYXR1cmUgPSBlcnJvci5mb3JtYXQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoXCJjYWxsIHJldmVydCBleGNlcHRpb25cIiArIG1lc3NhZ2UsIExvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04sIHtcbiAgICAgICAgICAgIG1ldGhvZDogZnVuY3Rpb25GcmFnbWVudC5mb3JtYXQoKSxcbiAgICAgICAgICAgIGRhdGE6IGhleGxpZnkoZGF0YSksIGVycm9yQXJncywgZXJyb3JOYW1lLCBlcnJvclNpZ25hdHVyZSwgcmVhc29uXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBFbmNvZGUgdGhlIHJlc3VsdCBmb3IgYSBmdW5jdGlvbiBjYWxsIChlLmcuIGZvciBldGhfY2FsbClcbiAgICBlbmNvZGVGdW5jdGlvblJlc3VsdChmdW5jdGlvbkZyYWdtZW50LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnVuY3Rpb25GcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uRnJhZ21lbnQgPSB0aGlzLmdldEZ1bmN0aW9uKGZ1bmN0aW9uRnJhZ21lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KHRoaXMuX2FiaUNvZGVyLmVuY29kZShmdW5jdGlvbkZyYWdtZW50Lm91dHB1dHMsIHZhbHVlcyB8fCBbXSkpO1xuICAgIH1cbiAgICAvLyBDcmVhdGUgdGhlIGZpbHRlciBmb3IgdGhlIGV2ZW50IHdpdGggc2VhcmNoIGNyaXRlcmlhIChlLmcuIGZvciBldGhfZmlsdGVyTG9nKVxuICAgIGVuY29kZUZpbHRlclRvcGljcyhldmVudEZyYWdtZW50LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZXZlbnRGcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGV2ZW50RnJhZ21lbnQgPSB0aGlzLmdldEV2ZW50KGV2ZW50RnJhZ21lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoID4gZXZlbnRGcmFnbWVudC5pbnB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInRvbyBtYW55IGFyZ3VtZW50cyBmb3IgXCIgKyBldmVudEZyYWdtZW50LmZvcm1hdCgpLCBMb2dnZXIuZXJyb3JzLlVORVhQRUNURURfQVJHVU1FTlQsIHtcbiAgICAgICAgICAgICAgICBhcmd1bWVudDogXCJ2YWx1ZXNcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdG9waWNzID0gW107XG4gICAgICAgIGlmICghZXZlbnRGcmFnbWVudC5hbm9ueW1vdXMpIHtcbiAgICAgICAgICAgIHRvcGljcy5wdXNoKHRoaXMuZ2V0RXZlbnRUb3BpYyhldmVudEZyYWdtZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW5jb2RlVG9waWMgPSAocGFyYW0sIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpZCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJhbS50eXBlID09PSBcImJ5dGVzXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ga2VjY2FrMjU2KGhleGxpZnkodmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJhbS50eXBlID09PSBcImJvb2xcIiAmJiB0eXBlb2YgKHZhbHVlKSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICh2YWx1ZSA/IFwiMHgwMVwiIDogXCIweDAwXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmFtLnR5cGUubWF0Y2goL151P2ludC8pKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBCaWdOdW1iZXIuZnJvbSh2YWx1ZSkudG9IZXhTdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIGFkZHJlc3NlcyBhcmUgdmFsaWRcbiAgICAgICAgICAgIGlmIChwYXJhbS50eXBlID09PSBcImFkZHJlc3NcIikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FiaUNvZGVyLmVuY29kZShbXCJhZGRyZXNzXCJdLCBbdmFsdWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBoZXhaZXJvUGFkKGhleGxpZnkodmFsdWUpLCAzMik7XG4gICAgICAgIH07XG4gICAgICAgIHZhbHVlcy5mb3JFYWNoKCh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGxldCBwYXJhbSA9IGV2ZW50RnJhZ21lbnQuaW5wdXRzW2luZGV4XTtcbiAgICAgICAgICAgIGlmICghcGFyYW0uaW5kZXhlZCkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJjYW5ub3QgZmlsdGVyIG5vbi1pbmRleGVkIHBhcmFtZXRlcnM7IG11c3QgYmUgbnVsbFwiLCAoXCJjb250cmFjdC5cIiArIHBhcmFtLm5hbWUpLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdG9waWNzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJhbS5iYXNlVHlwZSA9PT0gXCJhcnJheVwiIHx8IHBhcmFtLmJhc2VUeXBlID09PSBcInR1cGxlXCIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiZmlsdGVyaW5nIHdpdGggdHVwbGVzIG9yIGFycmF5cyBub3Qgc3VwcG9ydGVkXCIsIChcImNvbnRyYWN0LlwiICsgcGFyYW0ubmFtZSksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdG9waWNzLnB1c2godmFsdWUubWFwKCh2YWx1ZSkgPT4gZW5jb2RlVG9waWMocGFyYW0sIHZhbHVlKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9waWNzLnB1c2goZW5jb2RlVG9waWMocGFyYW0sIHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUcmltIG9mZiB0cmFpbGluZyBudWxsc1xuICAgICAgICB3aGlsZSAodG9waWNzLmxlbmd0aCAmJiB0b3BpY3NbdG9waWNzLmxlbmd0aCAtIDFdID09PSBudWxsKSB7XG4gICAgICAgICAgICB0b3BpY3MucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvcGljcztcbiAgICB9XG4gICAgZW5jb2RlRXZlbnRMb2coZXZlbnRGcmFnbWVudCwgdmFsdWVzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGV2ZW50RnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBldmVudEZyYWdtZW50ID0gdGhpcy5nZXRFdmVudChldmVudEZyYWdtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b3BpY3MgPSBbXTtcbiAgICAgICAgY29uc3QgZGF0YVR5cGVzID0gW107XG4gICAgICAgIGNvbnN0IGRhdGFWYWx1ZXMgPSBbXTtcbiAgICAgICAgaWYgKCFldmVudEZyYWdtZW50LmFub255bW91cykge1xuICAgICAgICAgICAgdG9waWNzLnB1c2godGhpcy5nZXRFdmVudFRvcGljKGV2ZW50RnJhZ21lbnQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCAhPT0gZXZlbnRGcmFnbWVudC5pbnB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiZXZlbnQgYXJndW1lbnRzL3ZhbHVlcyBtaXNtYXRjaFwiLCBcInZhbHVlc1wiLCB2YWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50RnJhZ21lbnQuaW5wdXRzLmZvckVhY2goKHBhcmFtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKHBhcmFtLmluZGV4ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaChpZCh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJhbS50eXBlID09PSBcImJ5dGVzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9waWNzLnB1c2goa2VjY2FrMjU2KHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLmJhc2VUeXBlID09PSBcInR1cGxlXCIgfHwgcGFyYW0uYmFzZVR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBAVE9ET1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaCh0aGlzLl9hYmlDb2Rlci5lbmNvZGUoW3BhcmFtLnR5cGVdLCBbdmFsdWVdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YVR5cGVzLnB1c2gocGFyYW0pO1xuICAgICAgICAgICAgICAgIGRhdGFWYWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogdGhpcy5fYWJpQ29kZXIuZW5jb2RlKGRhdGFUeXBlcywgZGF0YVZhbHVlcyksXG4gICAgICAgICAgICB0b3BpY3M6IHRvcGljc1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBEZWNvZGUgYSBmaWx0ZXIgZm9yIHRoZSBldmVudCBhbmQgdGhlIHNlYXJjaCBjcml0ZXJpYVxuICAgIGRlY29kZUV2ZW50TG9nKGV2ZW50RnJhZ21lbnQsIGRhdGEsIHRvcGljcykge1xuICAgICAgICBpZiAodHlwZW9mIChldmVudEZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZXZlbnRGcmFnbWVudCA9IHRoaXMuZ2V0RXZlbnQoZXZlbnRGcmFnbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvcGljcyAhPSBudWxsICYmICFldmVudEZyYWdtZW50LmFub255bW91cykge1xuICAgICAgICAgICAgbGV0IHRvcGljSGFzaCA9IHRoaXMuZ2V0RXZlbnRUb3BpYyhldmVudEZyYWdtZW50KTtcbiAgICAgICAgICAgIGlmICghaXNIZXhTdHJpbmcodG9waWNzWzBdLCAzMikgfHwgdG9waWNzWzBdLnRvTG93ZXJDYXNlKCkgIT09IHRvcGljSGFzaCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZnJhZ21lbnQvdG9waWMgbWlzbWF0Y2hcIiwgTG9nZ2VyLmVycm9ycy5JTlZBTElEX0FSR1VNRU5ULCB7IGFyZ3VtZW50OiBcInRvcGljc1swXVwiLCBleHBlY3RlZDogdG9waWNIYXNoLCB2YWx1ZTogdG9waWNzWzBdIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9waWNzID0gdG9waWNzLnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpbmRleGVkID0gW107XG4gICAgICAgIGxldCBub25JbmRleGVkID0gW107XG4gICAgICAgIGxldCBkeW5hbWljID0gW107XG4gICAgICAgIGV2ZW50RnJhZ21lbnQuaW5wdXRzLmZvckVhY2goKHBhcmFtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKHBhcmFtLmluZGV4ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBwYXJhbS50eXBlID09PSBcImJ5dGVzXCIgfHwgcGFyYW0uYmFzZVR5cGUgPT09IFwidHVwbGVcIiB8fCBwYXJhbS5iYXNlVHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ZWQucHVzaChQYXJhbVR5cGUuZnJvbU9iamVjdCh7IHR5cGU6IFwiYnl0ZXMzMlwiLCBuYW1lOiBwYXJhbS5uYW1lIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgZHluYW1pYy5wdXNoKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhlZC5wdXNoKHBhcmFtKTtcbiAgICAgICAgICAgICAgICAgICAgZHluYW1pYy5wdXNoKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub25JbmRleGVkLnB1c2gocGFyYW0pO1xuICAgICAgICAgICAgICAgIGR5bmFtaWMucHVzaChmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgcmVzdWx0SW5kZXhlZCA9ICh0b3BpY3MgIT0gbnVsbCkgPyB0aGlzLl9hYmlDb2Rlci5kZWNvZGUoaW5kZXhlZCwgY29uY2F0KHRvcGljcykpIDogbnVsbDtcbiAgICAgICAgbGV0IHJlc3VsdE5vbkluZGV4ZWQgPSB0aGlzLl9hYmlDb2Rlci5kZWNvZGUobm9uSW5kZXhlZCwgZGF0YSwgdHJ1ZSk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IG5vbkluZGV4ZWRJbmRleCA9IDAsIGluZGV4ZWRJbmRleCA9IDA7XG4gICAgICAgIGV2ZW50RnJhZ21lbnQuaW5wdXRzLmZvckVhY2goKHBhcmFtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKHBhcmFtLmluZGV4ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0SW5kZXhlZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBuZXcgSW5kZXhlZCh7IF9pc0luZGV4ZWQ6IHRydWUsIGhhc2g6IG51bGwgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGR5bmFtaWNbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBuZXcgSW5kZXhlZCh7IF9pc0luZGV4ZWQ6IHRydWUsIGhhc2g6IHJlc3VsdEluZGV4ZWRbaW5kZXhlZEluZGV4KytdIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSByZXN1bHRJbmRleGVkW2luZGV4ZWRJbmRleCsrXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSByZXN1bHROb25JbmRleGVkW25vbkluZGV4ZWRJbmRleCsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgdGhlIGtleXdvcmQgYXJndW1lbnQgaWYgbmFtZWQgYW5kIHNhZmVcbiAgICAgICAgICAgIGlmIChwYXJhbS5uYW1lICYmIHJlc3VsdFtwYXJhbS5uYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSByZXN1bHRbaW5kZXhdO1xuICAgICAgICAgICAgICAgIC8vIE1ha2UgZXJyb3IgbmFtZWQgdmFsdWVzIHRocm93IG9uIGFjY2Vzc1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXN1bHQsIHBhcmFtLm5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IHsgdGhyb3cgd3JhcEFjY2Vzc0Vycm9yKGBwcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KHBhcmFtLm5hbWUpfWAsIHZhbHVlKTsgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtwYXJhbS5uYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIE1ha2UgYWxsIGVycm9yIGluZGV4ZWQgdmFsdWVzIHRocm93IG9uIGFjY2Vzc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSByZXN1bHRbaV07XG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXN1bHQsIGksIHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiB7IHRocm93IHdyYXBBY2Nlc3NFcnJvcihgaW5kZXggJHtpfWAsIHZhbHVlKTsgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPYmplY3QuZnJlZXplKHJlc3VsdCk7XG4gICAgfVxuICAgIC8vIEdpdmVuIGEgdHJhbnNhY3Rpb24sIGZpbmQgdGhlIG1hdGNoaW5nIGZ1bmN0aW9uIGZyYWdtZW50IChpZiBhbnkpIGFuZFxuICAgIC8vIGRldGVybWluZSBhbGwgaXRzIHByb3BlcnRpZXMgYW5kIGNhbGwgcGFyYW1ldGVyc1xuICAgIHBhcnNlVHJhbnNhY3Rpb24odHgpIHtcbiAgICAgICAgbGV0IGZyYWdtZW50ID0gdGhpcy5nZXRGdW5jdGlvbih0eC5kYXRhLnN1YnN0cmluZygwLCAxMCkudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIGlmICghZnJhZ21lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25EZXNjcmlwdGlvbih7XG4gICAgICAgICAgICBhcmdzOiB0aGlzLl9hYmlDb2Rlci5kZWNvZGUoZnJhZ21lbnQuaW5wdXRzLCBcIjB4XCIgKyB0eC5kYXRhLnN1YnN0cmluZygxMCkpLFxuICAgICAgICAgICAgZnVuY3Rpb25GcmFnbWVudDogZnJhZ21lbnQsXG4gICAgICAgICAgICBuYW1lOiBmcmFnbWVudC5uYW1lLFxuICAgICAgICAgICAgc2lnbmF0dXJlOiBmcmFnbWVudC5mb3JtYXQoKSxcbiAgICAgICAgICAgIHNpZ2hhc2g6IHRoaXMuZ2V0U2lnaGFzaChmcmFnbWVudCksXG4gICAgICAgICAgICB2YWx1ZTogQmlnTnVtYmVyLmZyb20odHgudmFsdWUgfHwgXCIwXCIpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gQFRPRE9cbiAgICAvL3BhcnNlQ2FsbFJlc3VsdChkYXRhOiBCeXRlc0xpa2UpOiA/P1xuICAgIC8vIEdpdmVuIGFuIGV2ZW50IGxvZywgZmluZCB0aGUgbWF0Y2hpbmcgZXZlbnQgZnJhZ21lbnQgKGlmIGFueSkgYW5kXG4gICAgLy8gZGV0ZXJtaW5lIGFsbCBpdHMgcHJvcGVydGllcyBhbmQgdmFsdWVzXG4gICAgcGFyc2VMb2cobG9nKSB7XG4gICAgICAgIGxldCBmcmFnbWVudCA9IHRoaXMuZ2V0RXZlbnQobG9nLnRvcGljc1swXSk7XG4gICAgICAgIGlmICghZnJhZ21lbnQgfHwgZnJhZ21lbnQuYW5vbnltb3VzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBAVE9ETzogSWYgYW5vbnltb3VzLCBhbmQgdGhlIG9ubHkgbWV0aG9kLCBhbmQgdGhlIGlucHV0IGNvdW50IG1hdGNoZXMsIHNob3VsZCB3ZSBwYXJzZT9cbiAgICAgICAgLy8gICAgICAgIFByb2JhYmx5IG5vdCwgYmVjYXVzZSBqdXN0IGJlY2F1c2UgaXQgaXMgdGhlIG9ubHkgZXZlbnQgaW4gdGhlIEFCSSBkb2VzXG4gICAgICAgIC8vICAgICAgICBub3QgbWVhbiB3ZSBoYXZlIHRoZSBmdWxsIEFCSTsgbWF5YmUganVzdCBhIGZyYWdtZW50P1xuICAgICAgICByZXR1cm4gbmV3IExvZ0Rlc2NyaXB0aW9uKHtcbiAgICAgICAgICAgIGV2ZW50RnJhZ21lbnQ6IGZyYWdtZW50LFxuICAgICAgICAgICAgbmFtZTogZnJhZ21lbnQubmFtZSxcbiAgICAgICAgICAgIHNpZ25hdHVyZTogZnJhZ21lbnQuZm9ybWF0KCksXG4gICAgICAgICAgICB0b3BpYzogdGhpcy5nZXRFdmVudFRvcGljKGZyYWdtZW50KSxcbiAgICAgICAgICAgIGFyZ3M6IHRoaXMuZGVjb2RlRXZlbnRMb2coZnJhZ21lbnQsIGxvZy5kYXRhLCBsb2cudG9waWNzKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGFyc2VFcnJvcihkYXRhKSB7XG4gICAgICAgIGNvbnN0IGhleERhdGEgPSBoZXhsaWZ5KGRhdGEpO1xuICAgICAgICBsZXQgZnJhZ21lbnQgPSB0aGlzLmdldEVycm9yKGhleERhdGEuc3Vic3RyaW5nKDAsIDEwKS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgaWYgKCFmcmFnbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvckRlc2NyaXB0aW9uKHtcbiAgICAgICAgICAgIGFyZ3M6IHRoaXMuX2FiaUNvZGVyLmRlY29kZShmcmFnbWVudC5pbnB1dHMsIFwiMHhcIiArIGhleERhdGEuc3Vic3RyaW5nKDEwKSksXG4gICAgICAgICAgICBlcnJvckZyYWdtZW50OiBmcmFnbWVudCxcbiAgICAgICAgICAgIG5hbWU6IGZyYWdtZW50Lm5hbWUsXG4gICAgICAgICAgICBzaWduYXR1cmU6IGZyYWdtZW50LmZvcm1hdCgpLFxuICAgICAgICAgICAgc2lnaGFzaDogdGhpcy5nZXRTaWdoYXNoKGZyYWdtZW50KSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qXG4gICAgc3RhdGljIGZyb20odmFsdWU6IEFycmF5PEZyYWdtZW50IHwgc3RyaW5nIHwgSnNvbkFiaT4gfCBzdHJpbmcgfCBJbnRlcmZhY2UpIHtcbiAgICAgICAgaWYgKEludGVyZmFjZS5pc0ludGVyZmFjZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRlcmZhY2UoSlNPTi5wYXJzZSh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSW50ZXJmYWNlKHZhbHVlKTtcbiAgICB9XG4gICAgKi9cbiAgICBzdGF0aWMgaXNJbnRlcmZhY2UodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9pc0ludGVyZmFjZSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJmYWNlLmpzLm1hcCIsImV4cG9ydCBjb25zdCB2ZXJzaW9uID0gXCJhZGRyZXNzLzUuNy4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IGFycmF5aWZ5LCBjb25jYXQsIGhleERhdGFMZW5ndGgsIGhleERhdGFTbGljZSwgaXNIZXhTdHJpbmcsIHN0cmlwWmVyb3MgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IEJpZ051bWJlciwgX2Jhc2UxNlRvMzYsIF9iYXNlMzZUbzE2IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2JpZ251bWJlclwiO1xuaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2tlY2NhazI1NlwiO1xuaW1wb3J0IHsgZW5jb2RlIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3JscFwiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuZnVuY3Rpb24gZ2V0Q2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpIHtcbiAgICBpZiAoIWlzSGV4U3RyaW5nKGFkZHJlc3MsIDIwKSkge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhZGRyZXNzXCIsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcbiAgICB9XG4gICAgYWRkcmVzcyA9IGFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCBjaGFycyA9IGFkZHJlc3Muc3Vic3RyaW5nKDIpLnNwbGl0KFwiXCIpO1xuICAgIGNvbnN0IGV4cGFuZGVkID0gbmV3IFVpbnQ4QXJyYXkoNDApO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDA7IGkrKykge1xuICAgICAgICBleHBhbmRlZFtpXSA9IGNoYXJzW2ldLmNoYXJDb2RlQXQoMCk7XG4gICAgfVxuICAgIGNvbnN0IGhhc2hlZCA9IGFycmF5aWZ5KGtlY2NhazI1NihleHBhbmRlZCkpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDA7IGkgKz0gMikge1xuICAgICAgICBpZiAoKGhhc2hlZFtpID4+IDFdID4+IDQpID49IDgpIHtcbiAgICAgICAgICAgIGNoYXJzW2ldID0gY2hhcnNbaV0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGhhc2hlZFtpID4+IDFdICYgMHgwZikgPj0gOCkge1xuICAgICAgICAgICAgY2hhcnNbaSArIDFdID0gY2hhcnNbaSArIDFdLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFwiMHhcIiArIGNoYXJzLmpvaW4oXCJcIik7XG59XG4vLyBTaGltcyBmb3IgZW52aXJvbm1lbnRzIHRoYXQgYXJlIG1pc3Npbmcgc29tZSByZXF1aXJlZCBjb25zdGFudHMgYW5kIGZ1bmN0aW9uc1xuY29uc3QgTUFYX1NBRkVfSU5URUdFUiA9IDB4MWZmZmZmZmZmZmZmZmY7XG5mdW5jdGlvbiBsb2cxMCh4KSB7XG4gICAgaWYgKE1hdGgubG9nMTApIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubG9nMTAoeCk7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLmxvZyh4KSAvIE1hdGguTE4xMDtcbn1cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSW50ZXJuYXRpb25hbF9CYW5rX0FjY291bnRfTnVtYmVyXG4vLyBDcmVhdGUgbG9va3VwIHRhYmxlXG5jb25zdCBpYmFuTG9va3VwID0ge307XG5mb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICBpYmFuTG9va3VwW1N0cmluZyhpKV0gPSBTdHJpbmcoaSk7XG59XG5mb3IgKGxldCBpID0gMDsgaSA8IDI2OyBpKyspIHtcbiAgICBpYmFuTG9va3VwW1N0cmluZy5mcm9tQ2hhckNvZGUoNjUgKyBpKV0gPSBTdHJpbmcoMTAgKyBpKTtcbn1cbi8vIEhvdyBtYW55IGRlY2ltYWwgZGlnaXRzIGNhbiB3ZSBwcm9jZXNzPyAoZm9yIDY0LWJpdCBmbG9hdCwgdGhpcyBpcyAxNSlcbmNvbnN0IHNhZmVEaWdpdHMgPSBNYXRoLmZsb29yKGxvZzEwKE1BWF9TQUZFX0lOVEVHRVIpKTtcbmZ1bmN0aW9uIGliYW5DaGVja3N1bShhZGRyZXNzKSB7XG4gICAgYWRkcmVzcyA9IGFkZHJlc3MudG9VcHBlckNhc2UoKTtcbiAgICBhZGRyZXNzID0gYWRkcmVzcy5zdWJzdHJpbmcoNCkgKyBhZGRyZXNzLnN1YnN0cmluZygwLCAyKSArIFwiMDBcIjtcbiAgICBsZXQgZXhwYW5kZWQgPSBhZGRyZXNzLnNwbGl0KFwiXCIpLm1hcCgoYykgPT4geyByZXR1cm4gaWJhbkxvb2t1cFtjXTsgfSkuam9pbihcIlwiKTtcbiAgICAvLyBKYXZhc2NyaXB0IGNhbiBoYW5kbGUgaW50ZWdlcnMgc2FmZWx5IHVwIHRvIDE1IChkZWNpbWFsKSBkaWdpdHNcbiAgICB3aGlsZSAoZXhwYW5kZWQubGVuZ3RoID49IHNhZmVEaWdpdHMpIHtcbiAgICAgICAgbGV0IGJsb2NrID0gZXhwYW5kZWQuc3Vic3RyaW5nKDAsIHNhZmVEaWdpdHMpO1xuICAgICAgICBleHBhbmRlZCA9IHBhcnNlSW50KGJsb2NrLCAxMCkgJSA5NyArIGV4cGFuZGVkLnN1YnN0cmluZyhibG9jay5sZW5ndGgpO1xuICAgIH1cbiAgICBsZXQgY2hlY2tzdW0gPSBTdHJpbmcoOTggLSAocGFyc2VJbnQoZXhwYW5kZWQsIDEwKSAlIDk3KSk7XG4gICAgd2hpbGUgKGNoZWNrc3VtLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgY2hlY2tzdW0gPSBcIjBcIiArIGNoZWNrc3VtO1xuICAgIH1cbiAgICByZXR1cm4gY2hlY2tzdW07XG59XG47XG5leHBvcnQgZnVuY3Rpb24gZ2V0QWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgaWYgKHR5cGVvZiAoYWRkcmVzcykgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYWRkcmVzc1wiLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG4gICAgfVxuICAgIGlmIChhZGRyZXNzLm1hdGNoKC9eKDB4KT9bMC05YS1mQS1GXXs0MH0kLykpIHtcbiAgICAgICAgLy8gTWlzc2luZyB0aGUgMHggcHJlZml4XG4gICAgICAgIGlmIChhZGRyZXNzLnN1YnN0cmluZygwLCAyKSAhPT0gXCIweFwiKSB7XG4gICAgICAgICAgICBhZGRyZXNzID0gXCIweFwiICsgYWRkcmVzcztcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSBnZXRDaGVja3N1bUFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgIC8vIEl0IGlzIGEgY2hlY2tzdW1tZWQgYWRkcmVzcyB3aXRoIGEgYmFkIGNoZWNrc3VtXG4gICAgICAgIGlmIChhZGRyZXNzLm1hdGNoKC8oW0EtRl0uKlthLWZdKXwoW2EtZl0uKltBLUZdKS8pICYmIHJlc3VsdCAhPT0gYWRkcmVzcykge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImJhZCBhZGRyZXNzIGNoZWNrc3VtXCIsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYXliZSBJQ0FQPyAod2Ugb25seSBzdXBwb3J0IGRpcmVjdCBtb2RlKVxuICAgIH1cbiAgICBlbHNlIGlmIChhZGRyZXNzLm1hdGNoKC9eWEVbMC05XXsyfVswLTlBLVphLXpdezMwLDMxfSQvKSkge1xuICAgICAgICAvLyBJdCBpcyBhbiBJQ0FQIGFkZHJlc3Mgd2l0aCBhIGJhZCBjaGVja3N1bVxuICAgICAgICBpZiAoYWRkcmVzcy5zdWJzdHJpbmcoMiwgNCkgIT09IGliYW5DaGVja3N1bShhZGRyZXNzKSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImJhZCBpY2FwIGNoZWNrc3VtXCIsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSBfYmFzZTM2VG8xNihhZGRyZXNzLnN1YnN0cmluZyg0KSk7XG4gICAgICAgIHdoaWxlIChyZXN1bHQubGVuZ3RoIDwgNDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFwiMFwiICsgcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IGdldENoZWNrc3VtQWRkcmVzcyhcIjB4XCIgKyByZXN1bHQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYWRkcmVzc1wiLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICB0cnkge1xuICAgICAgICBnZXRBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0SWNhcEFkZHJlc3MoYWRkcmVzcykge1xuICAgIGxldCBiYXNlMzYgPSBfYmFzZTE2VG8zNihnZXRBZGRyZXNzKGFkZHJlc3MpLnN1YnN0cmluZygyKSkudG9VcHBlckNhc2UoKTtcbiAgICB3aGlsZSAoYmFzZTM2Lmxlbmd0aCA8IDMwKSB7XG4gICAgICAgIGJhc2UzNiA9IFwiMFwiICsgYmFzZTM2O1xuICAgIH1cbiAgICByZXR1cm4gXCJYRVwiICsgaWJhbkNoZWNrc3VtKFwiWEUwMFwiICsgYmFzZTM2KSArIGJhc2UzNjtcbn1cbi8vIGh0dHA6Ly9ldGhlcmV1bS5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvNzYwL2hvdy1pcy10aGUtYWRkcmVzcy1vZi1hbi1ldGhlcmV1bS1jb250cmFjdC1jb21wdXRlZFxuZXhwb3J0IGZ1bmN0aW9uIGdldENvbnRyYWN0QWRkcmVzcyh0cmFuc2FjdGlvbikge1xuICAgIGxldCBmcm9tID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgICBmcm9tID0gZ2V0QWRkcmVzcyh0cmFuc2FjdGlvbi5mcm9tKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJtaXNzaW5nIGZyb20gYWRkcmVzc1wiLCBcInRyYW5zYWN0aW9uXCIsIHRyYW5zYWN0aW9uKTtcbiAgICB9XG4gICAgY29uc3Qgbm9uY2UgPSBzdHJpcFplcm9zKGFycmF5aWZ5KEJpZ051bWJlci5mcm9tKHRyYW5zYWN0aW9uLm5vbmNlKS50b0hleFN0cmluZygpKSk7XG4gICAgcmV0dXJuIGdldEFkZHJlc3MoaGV4RGF0YVNsaWNlKGtlY2NhazI1NihlbmNvZGUoW2Zyb20sIG5vbmNlXSkpLCAxMikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldENyZWF0ZTJBZGRyZXNzKGZyb20sIHNhbHQsIGluaXRDb2RlSGFzaCkge1xuICAgIGlmIChoZXhEYXRhTGVuZ3RoKHNhbHQpICE9PSAzMikge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwic2FsdCBtdXN0IGJlIDMyIGJ5dGVzXCIsIFwic2FsdFwiLCBzYWx0KTtcbiAgICB9XG4gICAgaWYgKGhleERhdGFMZW5ndGgoaW5pdENvZGVIYXNoKSAhPT0gMzIpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImluaXRDb2RlSGFzaCBtdXN0IGJlIDMyIGJ5dGVzXCIsIFwiaW5pdENvZGVIYXNoXCIsIGluaXRDb2RlSGFzaCk7XG4gICAgfVxuICAgIHJldHVybiBnZXRBZGRyZXNzKGhleERhdGFTbGljZShrZWNjYWsyNTYoY29uY2F0KFtcIjB4ZmZcIiwgZ2V0QWRkcmVzcyhmcm9tKSwgc2FsdCwgaW5pdENvZGVIYXNoXSkpLCAxMikpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcImJpZ251bWJlci81LjcuMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqICBCaWdOdW1iZXJcbiAqXG4gKiAgQSB3cmFwcGVyIGFyb3VuZCB0aGUgQk4uanMgb2JqZWN0LiBXZSB1c2UgdGhlIEJOLmpzIGxpYnJhcnlcbiAqICBiZWNhdXNlIGl0IGlzIHVzZWQgYnkgZWxsaXB0aWMsIHNvIGl0IGlzIHJlcXVpcmVkIHJlZ2FyZGxlc3MuXG4gKlxuICovXG5pbXBvcnQgX0JOIGZyb20gXCJibi5qc1wiO1xudmFyIEJOID0gX0JOLkJOO1xuaW1wb3J0IHsgaGV4bGlmeSwgaXNCeXRlcywgaXNIZXhTdHJpbmcgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmNvbnN0IF9jb25zdHJ1Y3Rvckd1YXJkID0ge307XG5jb25zdCBNQVhfU0FGRSA9IDB4MWZmZmZmZmZmZmZmZmY7XG5leHBvcnQgZnVuY3Rpb24gaXNCaWdOdW1iZXJpc2godmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICE9IG51bGwpICYmIChCaWdOdW1iZXIuaXNCaWdOdW1iZXIodmFsdWUpIHx8XG4gICAgICAgICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJudW1iZXJcIiAmJiAodmFsdWUgJSAxKSA9PT0gMCkgfHxcbiAgICAgICAgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiICYmICEhdmFsdWUubWF0Y2goL14tP1swLTldKyQvKSkgfHxcbiAgICAgICAgaXNIZXhTdHJpbmcodmFsdWUpIHx8XG4gICAgICAgICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJiaWdpbnRcIikgfHxcbiAgICAgICAgaXNCeXRlcyh2YWx1ZSkpO1xufVxuLy8gT25seSB3YXJuIGFib3V0IHBhc3NpbmcgMTAgaW50byByYWRpeCBvbmNlXG5sZXQgX3dhcm5lZFRvU3RyaW5nUmFkaXggPSBmYWxzZTtcbmV4cG9ydCBjbGFzcyBCaWdOdW1iZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbnN0cnVjdG9yR3VhcmQsIGhleCkge1xuICAgICAgICBpZiAoY29uc3RydWN0b3JHdWFyZCAhPT0gX2NvbnN0cnVjdG9yR3VhcmQpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IGNhbGwgY29uc3RydWN0b3IgZGlyZWN0bHk7IHVzZSBCaWdOdW1iZXIuZnJvbVwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJuZXcgKEJpZ051bWJlcilcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faGV4ID0gaGV4O1xuICAgICAgICB0aGlzLl9pc0JpZ051bWJlciA9IHRydWU7XG4gICAgICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gICAgfVxuICAgIGZyb21Ud29zKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLmZyb21Ud29zKHZhbHVlKSk7XG4gICAgfVxuICAgIHRvVHdvcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS50b1R3b3ModmFsdWUpKTtcbiAgICB9XG4gICAgYWJzKCkge1xuICAgICAgICBpZiAodGhpcy5faGV4WzBdID09PSBcIi1cIikge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKHRoaXMuX2hleC5zdWJzdHJpbmcoMSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhZGQob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykuYWRkKHRvQk4ob3RoZXIpKSk7XG4gICAgfVxuICAgIHN1YihvdGhlcikge1xuICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5zdWIodG9CTihvdGhlcikpKTtcbiAgICB9XG4gICAgZGl2KG90aGVyKSB7XG4gICAgICAgIGNvbnN0IG8gPSBCaWdOdW1iZXIuZnJvbShvdGhlcik7XG4gICAgICAgIGlmIChvLmlzWmVybygpKSB7XG4gICAgICAgICAgICB0aHJvd0ZhdWx0KFwiZGl2aXNpb24tYnktemVyb1wiLCBcImRpdlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5kaXYodG9CTihvdGhlcikpKTtcbiAgICB9XG4gICAgbXVsKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLm11bCh0b0JOKG90aGVyKSkpO1xuICAgIH1cbiAgICBtb2Qob3RoZXIpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0b0JOKG90aGVyKTtcbiAgICAgICAgaWYgKHZhbHVlLmlzTmVnKCkpIHtcbiAgICAgICAgICAgIHRocm93RmF1bHQoXCJkaXZpc2lvbi1ieS16ZXJvXCIsIFwibW9kXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLnVtb2QodmFsdWUpKTtcbiAgICB9XG4gICAgcG93KG90aGVyKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdG9CTihvdGhlcik7XG4gICAgICAgIGlmICh2YWx1ZS5pc05lZygpKSB7XG4gICAgICAgICAgICB0aHJvd0ZhdWx0KFwibmVnYXRpdmUtcG93ZXJcIiwgXCJwb3dcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykucG93KHZhbHVlKSk7XG4gICAgfVxuICAgIGFuZChvdGhlcikge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRvQk4ob3RoZXIpO1xuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkgfHwgdmFsdWUuaXNOZWcoKSkge1xuICAgICAgICAgICAgdGhyb3dGYXVsdChcInVuYm91bmQtYml0d2lzZS1yZXN1bHRcIiwgXCJhbmRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykuYW5kKHZhbHVlKSk7XG4gICAgfVxuICAgIG9yKG90aGVyKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdG9CTihvdGhlcik7XG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSB8fCB2YWx1ZS5pc05lZygpKSB7XG4gICAgICAgICAgICB0aHJvd0ZhdWx0KFwidW5ib3VuZC1iaXR3aXNlLXJlc3VsdFwiLCBcIm9yXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLm9yKHZhbHVlKSk7XG4gICAgfVxuICAgIHhvcihvdGhlcikge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRvQk4ob3RoZXIpO1xuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkgfHwgdmFsdWUuaXNOZWcoKSkge1xuICAgICAgICAgICAgdGhyb3dGYXVsdChcInVuYm91bmQtYml0d2lzZS1yZXN1bHRcIiwgXCJ4b3JcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykueG9yKHZhbHVlKSk7XG4gICAgfVxuICAgIG1hc2sodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpIHx8IHZhbHVlIDwgMCkge1xuICAgICAgICAgICAgdGhyb3dGYXVsdChcIm5lZ2F0aXZlLXdpZHRoXCIsIFwibWFza1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5tYXNrbih2YWx1ZSkpO1xuICAgIH1cbiAgICBzaGwodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpIHx8IHZhbHVlIDwgMCkge1xuICAgICAgICAgICAgdGhyb3dGYXVsdChcIm5lZ2F0aXZlLXdpZHRoXCIsIFwic2hsXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLnNobG4odmFsdWUpKTtcbiAgICB9XG4gICAgc2hyKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSB8fCB2YWx1ZSA8IDApIHtcbiAgICAgICAgICAgIHRocm93RmF1bHQoXCJuZWdhdGl2ZS13aWR0aFwiLCBcInNoclwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5zaHJuKHZhbHVlKSk7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0b0JOKHRoaXMpLmVxKHRvQk4ob3RoZXIpKTtcbiAgICB9XG4gICAgbHQob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRvQk4odGhpcykubHQodG9CTihvdGhlcikpO1xuICAgIH1cbiAgICBsdGUob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRvQk4odGhpcykubHRlKHRvQk4ob3RoZXIpKTtcbiAgICB9XG4gICAgZ3Qob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRvQk4odGhpcykuZ3QodG9CTihvdGhlcikpO1xuICAgIH1cbiAgICBndGUob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRvQk4odGhpcykuZ3RlKHRvQk4ob3RoZXIpKTtcbiAgICB9XG4gICAgaXNOZWdhdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9oZXhbMF0gPT09IFwiLVwiKTtcbiAgICB9XG4gICAgaXNaZXJvKCkge1xuICAgICAgICByZXR1cm4gdG9CTih0aGlzKS5pc1plcm8oKTtcbiAgICB9XG4gICAgdG9OdW1iZXIoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdG9CTih0aGlzKS50b051bWJlcigpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3dGYXVsdChcIm92ZXJmbG93XCIsIFwidG9OdW1iZXJcIiwgdGhpcy50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdG9CaWdJbnQoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gQmlnSW50KHRoaXMudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoXCJ0aGlzIHBsYXRmb3JtIGRvZXMgbm90IHN1cHBvcnQgQmlnSW50XCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICB2YWx1ZTogdGhpcy50b1N0cmluZygpXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgLy8gTG90cyBvZiBwZW9wbGUgZXhwZWN0IHRoaXMsIHdoaWNoIHdlIGRvIG5vdCBzdXBwb3J0LCBzbyBjaGVjayAoU2VlOiAjODg5KVxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHNbMF0gPT09IDEwKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfd2FybmVkVG9TdHJpbmdSYWRpeCkge1xuICAgICAgICAgICAgICAgICAgICBfd2FybmVkVG9TdHJpbmdSYWRpeCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiQmlnTnVtYmVyLnRvU3RyaW5nIGRvZXMgbm90IGFjY2VwdCBhbnkgcGFyYW1ldGVyczsgYmFzZS0xMCBpcyBhc3N1bWVkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFyZ3VtZW50c1swXSA9PT0gMTYpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIkJpZ051bWJlci50b1N0cmluZyBkb2VzIG5vdCBhY2NlcHQgYW55IHBhcmFtZXRlcnM7IHVzZSBiaWdOdW1iZXIudG9IZXhTdHJpbmcoKVwiLCBMb2dnZXIuZXJyb3JzLlVORVhQRUNURURfQVJHVU1FTlQsIHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiQmlnTnVtYmVyLnRvU3RyaW5nIGRvZXMgbm90IGFjY2VwdCBwYXJhbWV0ZXJzXCIsIExvZ2dlci5lcnJvcnMuVU5FWFBFQ1RFRF9BUkdVTUVOVCwge30pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b0JOKHRoaXMpLnRvU3RyaW5nKDEwKTtcbiAgICB9XG4gICAgdG9IZXhTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oZXg7XG4gICAgfVxuICAgIHRvSlNPTihrZXkpIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJCaWdOdW1iZXJcIiwgaGV4OiB0aGlzLnRvSGV4U3RyaW5nKCkgfTtcbiAgICB9XG4gICAgc3RhdGljIGZyb20odmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQmlnTnVtYmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUubWF0Y2goL14tPzB4WzAtOWEtZl0rJC9pKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKF9jb25zdHJ1Y3Rvckd1YXJkLCB0b0hleCh2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlLm1hdGNoKC9eLT9bMC05XSskLykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihfY29uc3RydWN0b3JHdWFyZCwgdG9IZXgobmV3IEJOKHZhbHVlKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIEJpZ051bWJlciBzdHJpbmdcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgJSAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dGYXVsdChcInVuZGVyZmxvd1wiLCBcIkJpZ051bWJlci5mcm9tXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSA+PSBNQVhfU0FGRSB8fCB2YWx1ZSA8PSAtTUFYX1NBRkUpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0ZhdWx0KFwib3ZlcmZsb3dcIiwgXCJCaWdOdW1iZXIuZnJvbVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20oU3RyaW5nKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYW55VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiAoYW55VmFsdWUpID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20oYW55VmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQnl0ZXMoYW55VmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20oaGV4bGlmeShhbnlWYWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbnlWYWx1ZSkge1xuICAgICAgICAgICAgLy8gSGV4YWJsZSBpbnRlcmZhY2UgKHRha2VzIHByaW9yaXR5KVxuICAgICAgICAgICAgaWYgKGFueVZhbHVlLnRvSGV4U3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGV4ID0gYW55VmFsdWUudG9IZXhTdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChoZXgpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbShoZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEZvciBub3csIGhhbmRsZSBsZWdhY3kgSlNPTi1pZmllZCB2YWx1ZXMgKGdvZXMgYXdheSBpbiB2NilcbiAgICAgICAgICAgICAgICBsZXQgaGV4ID0gYW55VmFsdWUuX2hleDtcbiAgICAgICAgICAgICAgICAvLyBOZXctZm9ybSBKU09OXG4gICAgICAgICAgICAgICAgaWYgKGhleCA9PSBudWxsICYmIGFueVZhbHVlLnR5cGUgPT09IFwiQmlnTnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaGV4ID0gYW55VmFsdWUuaGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChoZXgpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0hleFN0cmluZyhoZXgpIHx8IChoZXhbMF0gPT09IFwiLVwiICYmIGlzSGV4U3RyaW5nKGhleC5zdWJzdHJpbmcoMSkpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKGhleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIEJpZ051bWJlciB2YWx1ZVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICB9XG4gICAgc3RhdGljIGlzQmlnTnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5faXNCaWdOdW1iZXIpO1xuICAgIH1cbn1cbi8vIE5vcm1hbGl6ZSB0aGUgaGV4IHN0cmluZ1xuZnVuY3Rpb24gdG9IZXgodmFsdWUpIHtcbiAgICAvLyBGb3IgQk4sIGNhbGwgb24gdGhlIGhleCBzdHJpbmdcbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHRvSGV4KHZhbHVlLnRvU3RyaW5nKDE2KSk7XG4gICAgfVxuICAgIC8vIElmIG5lZ2F0aXZlLCBwcmVwZW5kIHRoZSBuZWdhdGl2ZSBzaWduIHRvIHRoZSBub3JtYWxpemVkIHBvc2l0aXZlIHZhbHVlXG4gICAgaWYgKHZhbHVlWzBdID09PSBcIi1cIikge1xuICAgICAgICAvLyBTdHJpcCBvZmYgdGhlIG5lZ2F0aXZlIHNpZ25cbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgIC8vIENhbm5vdCBoYXZlIG11bHRpcGxlIG5lZ2F0aXZlIHNpZ25zIChlLmcuIFwiLS0weDA0XCIpXG4gICAgICAgIGlmICh2YWx1ZVswXSA9PT0gXCItXCIpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGhleFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYWxsIHRvSGV4IG9uIHRoZSBwb3NpdGl2ZSBjb21wb25lbnRcbiAgICAgICAgdmFsdWUgPSB0b0hleCh2YWx1ZSk7XG4gICAgICAgIC8vIERvIG5vdCBhbGxvdyBcIi0weDAwXCJcbiAgICAgICAgaWYgKHZhbHVlID09PSBcIjB4MDBcIikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5lZ2F0ZSB0aGUgdmFsdWVcbiAgICAgICAgcmV0dXJuIFwiLVwiICsgdmFsdWU7XG4gICAgfVxuICAgIC8vIEFkZCBhIFwiMHhcIiBwcmVmaXggaWYgbWlzc2luZ1xuICAgIGlmICh2YWx1ZS5zdWJzdHJpbmcoMCwgMikgIT09IFwiMHhcIikge1xuICAgICAgICB2YWx1ZSA9IFwiMHhcIiArIHZhbHVlO1xuICAgIH1cbiAgICAvLyBOb3JtYWxpemUgemVyb1xuICAgIGlmICh2YWx1ZSA9PT0gXCIweFwiKSB7XG4gICAgICAgIHJldHVybiBcIjB4MDBcIjtcbiAgICB9XG4gICAgLy8gTWFrZSB0aGUgc3RyaW5nIGV2ZW4gbGVuZ3RoXG4gICAgaWYgKHZhbHVlLmxlbmd0aCAlIDIpIHtcbiAgICAgICAgdmFsdWUgPSBcIjB4MFwiICsgdmFsdWUuc3Vic3RyaW5nKDIpO1xuICAgIH1cbiAgICAvLyBUcmltIHRvIHNtYWxsZXN0IGV2ZW4tbGVuZ3RoIHN0cmluZ1xuICAgIHdoaWxlICh2YWx1ZS5sZW5ndGggPiA0ICYmIHZhbHVlLnN1YnN0cmluZygwLCA0KSA9PT0gXCIweDAwXCIpIHtcbiAgICAgICAgdmFsdWUgPSBcIjB4XCIgKyB2YWx1ZS5zdWJzdHJpbmcoNCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHRvQmlnTnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKHRvSGV4KHZhbHVlKSk7XG59XG5mdW5jdGlvbiB0b0JOKHZhbHVlKSB7XG4gICAgY29uc3QgaGV4ID0gQmlnTnVtYmVyLmZyb20odmFsdWUpLnRvSGV4U3RyaW5nKCk7XG4gICAgaWYgKGhleFswXSA9PT0gXCItXCIpIHtcbiAgICAgICAgcmV0dXJuIChuZXcgQk4oXCItXCIgKyBoZXguc3Vic3RyaW5nKDMpLCAxNikpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEJOKGhleC5zdWJzdHJpbmcoMiksIDE2KTtcbn1cbmZ1bmN0aW9uIHRocm93RmF1bHQoZmF1bHQsIG9wZXJhdGlvbiwgdmFsdWUpIHtcbiAgICBjb25zdCBwYXJhbXMgPSB7IGZhdWx0OiBmYXVsdCwgb3BlcmF0aW9uOiBvcGVyYXRpb24gfTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBwYXJhbXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKGZhdWx0LCBMb2dnZXIuZXJyb3JzLk5VTUVSSUNfRkFVTFQsIHBhcmFtcyk7XG59XG4vLyB2YWx1ZSBzaG91bGQgaGF2ZSBubyBwcmVmaXhcbmV4cG9ydCBmdW5jdGlvbiBfYmFzZTM2VG8xNih2YWx1ZSkge1xuICAgIHJldHVybiAobmV3IEJOKHZhbHVlLCAzNikpLnRvU3RyaW5nKDE2KTtcbn1cbi8vIHZhbHVlIHNob3VsZCBoYXZlIG5vIHByZWZpeFxuZXhwb3J0IGZ1bmN0aW9uIF9iYXNlMTZUbzM2KHZhbHVlKSB7XG4gICAgcmV0dXJuIChuZXcgQk4odmFsdWUsIDE2KSkudG9TdHJpbmcoMzYpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmlnbnVtYmVyLmpzLm1hcCIsImV4cG9ydCBjb25zdCB2ZXJzaW9uID0gXCJieXRlcy81LjcuMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5mdW5jdGlvbiBpc0hleGFibGUodmFsdWUpIHtcbiAgICByZXR1cm4gISEodmFsdWUudG9IZXhTdHJpbmcpO1xufVxuZnVuY3Rpb24gYWRkU2xpY2UoYXJyYXkpIHtcbiAgICBpZiAoYXJyYXkuc2xpY2UpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cbiAgICBhcnJheS5zbGljZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBhZGRTbGljZShuZXcgVWludDhBcnJheShBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoYXJyYXksIGFyZ3MpKSk7XG4gICAgfTtcbiAgICByZXR1cm4gYXJyYXk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNCeXRlc0xpa2UodmFsdWUpIHtcbiAgICByZXR1cm4gKChpc0hleFN0cmluZyh2YWx1ZSkgJiYgISh2YWx1ZS5sZW5ndGggJSAyKSkgfHwgaXNCeXRlcyh2YWx1ZSkpO1xufVxuZnVuY3Rpb24gaXNJbnRlZ2VyKHZhbHVlKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJudW1iZXJcIiAmJiB2YWx1ZSA9PSB2YWx1ZSAmJiAodmFsdWUgJSAxKSA9PT0gMCk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNCeXRlcyh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlLmNvbnN0cnVjdG9yID09PSBVaW50OEFycmF5KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWlzSW50ZWdlcih2YWx1ZS5sZW5ndGgpIHx8IHZhbHVlLmxlbmd0aCA8IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHYgPSB2YWx1ZVtpXTtcbiAgICAgICAgaWYgKCFpc0ludGVnZXIodikgfHwgdiA8IDAgfHwgdiA+PSAyNTYpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhcnJheWlmeSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBsb2dnZXIuY2hlY2tTYWZlVWludDUzKHZhbHVlLCBcImludmFsaWQgYXJyYXlpZnkgdmFsdWVcIik7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICB3aGlsZSAodmFsdWUpIHtcbiAgICAgICAgICAgIHJlc3VsdC51bnNoaWZ0KHZhbHVlICYgMHhmZik7XG4gICAgICAgICAgICB2YWx1ZSA9IHBhcnNlSW50KFN0cmluZyh2YWx1ZSAvIDI1NikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWRkU2xpY2UobmV3IFVpbnQ4QXJyYXkocmVzdWx0KSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmFsbG93TWlzc2luZ1ByZWZpeCAmJiB0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5zdWJzdHJpbmcoMCwgMikgIT09IFwiMHhcIikge1xuICAgICAgICB2YWx1ZSA9IFwiMHhcIiArIHZhbHVlO1xuICAgIH1cbiAgICBpZiAoaXNIZXhhYmxlKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSGV4U3RyaW5nKCk7XG4gICAgfVxuICAgIGlmIChpc0hleFN0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgbGV0IGhleCA9IHZhbHVlLnN1YnN0cmluZygyKTtcbiAgICAgICAgaWYgKGhleC5sZW5ndGggJSAyKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5oZXhQYWQgPT09IFwibGVmdFwiKSB7XG4gICAgICAgICAgICAgICAgaGV4ID0gXCIwXCIgKyBoZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLmhleFBhZCA9PT0gXCJyaWdodFwiKSB7XG4gICAgICAgICAgICAgICAgaGV4ICs9IFwiMFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImhleCBkYXRhIGlzIG9kZC1sZW5ndGhcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGV4Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXJzZUludChoZXguc3Vic3RyaW5nKGksIGkgKyAyKSwgMTYpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWRkU2xpY2UobmV3IFVpbnQ4QXJyYXkocmVzdWx0KSk7XG4gICAgfVxuICAgIGlmIChpc0J5dGVzKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gYWRkU2xpY2UobmV3IFVpbnQ4QXJyYXkodmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGFycmF5aWZ5IHZhbHVlXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdChpdGVtcykge1xuICAgIGNvbnN0IG9iamVjdHMgPSBpdGVtcy5tYXAoaXRlbSA9PiBhcnJheWlmeShpdGVtKSk7XG4gICAgY29uc3QgbGVuZ3RoID0gb2JqZWN0cy5yZWR1Y2UoKGFjY3VtLCBpdGVtKSA9PiAoYWNjdW0gKyBpdGVtLmxlbmd0aCksIDApO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgb2JqZWN0cy5yZWR1Y2UoKG9mZnNldCwgb2JqZWN0KSA9PiB7XG4gICAgICAgIHJlc3VsdC5zZXQob2JqZWN0LCBvZmZzZXQpO1xuICAgICAgICByZXR1cm4gb2Zmc2V0ICsgb2JqZWN0Lmxlbmd0aDtcbiAgICB9LCAwKTtcbiAgICByZXR1cm4gYWRkU2xpY2UocmVzdWx0KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzdHJpcFplcm9zKHZhbHVlKSB7XG4gICAgbGV0IHJlc3VsdCA9IGFycmF5aWZ5KHZhbHVlKTtcbiAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBGaW5kIHRoZSBmaXJzdCBub24temVybyBlbnRyeVxuICAgIGxldCBzdGFydCA9IDA7XG4gICAgd2hpbGUgKHN0YXJ0IDwgcmVzdWx0Lmxlbmd0aCAmJiByZXN1bHRbc3RhcnRdID09PSAwKSB7XG4gICAgICAgIHN0YXJ0Kys7XG4gICAgfVxuICAgIC8vIElmIHdlIHN0YXJ0ZWQgd2l0aCB6ZXJvcywgc3RyaXAgdGhlbVxuICAgIGlmIChzdGFydCkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2Uoc3RhcnQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHplcm9QYWQodmFsdWUsIGxlbmd0aCkge1xuICAgIHZhbHVlID0gYXJyYXlpZnkodmFsdWUpO1xuICAgIGlmICh2YWx1ZS5sZW5ndGggPiBsZW5ndGgpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInZhbHVlIG91dCBvZiByYW5nZVwiLCBcInZhbHVlXCIsIGFyZ3VtZW50c1swXSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgcmVzdWx0LnNldCh2YWx1ZSwgbGVuZ3RoIC0gdmFsdWUubGVuZ3RoKTtcbiAgICByZXR1cm4gYWRkU2xpY2UocmVzdWx0KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0hleFN0cmluZyh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpICE9PSBcInN0cmluZ1wiIHx8ICF2YWx1ZS5tYXRjaCgvXjB4WzAtOUEtRmEtZl0qJC8pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGxlbmd0aCAmJiB2YWx1ZS5sZW5ndGggIT09IDIgKyAyICogbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5jb25zdCBIZXhDaGFyYWN0ZXJzID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG5leHBvcnQgZnVuY3Rpb24gaGV4bGlmeSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBsb2dnZXIuY2hlY2tTYWZlVWludDUzKHZhbHVlLCBcImludmFsaWQgaGV4bGlmeSB2YWx1ZVwiKTtcbiAgICAgICAgbGV0IGhleCA9IFwiXCI7XG4gICAgICAgIHdoaWxlICh2YWx1ZSkge1xuICAgICAgICAgICAgaGV4ID0gSGV4Q2hhcmFjdGVyc1t2YWx1ZSAmIDB4Zl0gKyBoZXg7XG4gICAgICAgICAgICB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUgLyAxNik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhleC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoZXgubGVuZ3RoICUgMikge1xuICAgICAgICAgICAgICAgIGhleCA9IFwiMFwiICsgaGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFwiMHhcIiArIGhleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCIweDAwXCI7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCAlIDIpIHtcbiAgICAgICAgICAgIHJldHVybiAoXCIweDBcIiArIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCIweFwiICsgdmFsdWU7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmFsbG93TWlzc2luZ1ByZWZpeCAmJiB0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5zdWJzdHJpbmcoMCwgMikgIT09IFwiMHhcIikge1xuICAgICAgICB2YWx1ZSA9IFwiMHhcIiArIHZhbHVlO1xuICAgIH1cbiAgICBpZiAoaXNIZXhhYmxlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUudG9IZXhTdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKGlzSGV4U3RyaW5nKHZhbHVlKSkge1xuICAgICAgICBpZiAodmFsdWUubGVuZ3RoICUgMikge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGV4UGFkID09PSBcImxlZnRcIikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gXCIweDBcIiArIHZhbHVlLnN1YnN0cmluZygyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuaGV4UGFkID09PSBcInJpZ2h0XCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSBcIjBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJoZXggZGF0YSBpcyBvZGQtbGVuZ3RoXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICBpZiAoaXNCeXRlcyh2YWx1ZSkpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiMHhcIjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHYgPSB2YWx1ZVtpXTtcbiAgICAgICAgICAgIHJlc3VsdCArPSBIZXhDaGFyYWN0ZXJzWyh2ICYgMHhmMCkgPj4gNF0gKyBIZXhDaGFyYWN0ZXJzW3YgJiAweDBmXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgaGV4bGlmeSB2YWx1ZVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbn1cbi8qXG5mdW5jdGlvbiB1bm9kZGlmeSh2YWx1ZTogQnl0ZXNMaWtlIHwgSGV4YWJsZSB8IG51bWJlcik6IEJ5dGVzTGlrZSB8IEhleGFibGUgfCBudW1iZXIge1xuICAgIGlmICh0eXBlb2YodmFsdWUpID09PSBcInN0cmluZ1wiICYmIHZhbHVlLmxlbmd0aCAlIDIgJiYgdmFsdWUuc3Vic3RyaW5nKDAsIDIpID09PSBcIjB4XCIpIHtcbiAgICAgICAgcmV0dXJuIFwiMHgwXCIgKyB2YWx1ZS5zdWJzdHJpbmcoMik7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbiovXG5leHBvcnQgZnVuY3Rpb24gaGV4RGF0YUxlbmd0aChkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiAoZGF0YSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgZGF0YSA9IGhleGxpZnkoZGF0YSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFpc0hleFN0cmluZyhkYXRhKSB8fCAoZGF0YS5sZW5ndGggJSAyKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChkYXRhLmxlbmd0aCAtIDIpIC8gMjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoZXhEYXRhU2xpY2UoZGF0YSwgb2Zmc2V0LCBlbmRPZmZzZXQpIHtcbiAgICBpZiAodHlwZW9mIChkYXRhKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBkYXRhID0gaGV4bGlmeShkYXRhKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWlzSGV4U3RyaW5nKGRhdGEpIHx8IChkYXRhLmxlbmd0aCAlIDIpKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGhleERhdGFcIiwgXCJ2YWx1ZVwiLCBkYXRhKTtcbiAgICB9XG4gICAgb2Zmc2V0ID0gMiArIDIgKiBvZmZzZXQ7XG4gICAgaWYgKGVuZE9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBcIjB4XCIgKyBkYXRhLnN1YnN0cmluZyhvZmZzZXQsIDIgKyAyICogZW5kT2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIFwiMHhcIiArIGRhdGEuc3Vic3RyaW5nKG9mZnNldCk7XG59XG5leHBvcnQgZnVuY3Rpb24gaGV4Q29uY2F0KGl0ZW1zKSB7XG4gICAgbGV0IHJlc3VsdCA9IFwiMHhcIjtcbiAgICBpdGVtcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgIHJlc3VsdCArPSBoZXhsaWZ5KGl0ZW0pLnN1YnN0cmluZygyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhleFZhbHVlKHZhbHVlKSB7XG4gICAgY29uc3QgdHJpbW1lZCA9IGhleFN0cmlwWmVyb3MoaGV4bGlmeSh2YWx1ZSwgeyBoZXhQYWQ6IFwibGVmdFwiIH0pKTtcbiAgICBpZiAodHJpbW1lZCA9PT0gXCIweFwiKSB7XG4gICAgICAgIHJldHVybiBcIjB4MFwiO1xuICAgIH1cbiAgICByZXR1cm4gdHJpbW1lZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoZXhTdHJpcFplcm9zKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhbHVlID0gaGV4bGlmeSh2YWx1ZSk7XG4gICAgfVxuICAgIGlmICghaXNIZXhTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGhleCBzdHJpbmdcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgfVxuICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDIpO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIHdoaWxlIChvZmZzZXQgPCB2YWx1ZS5sZW5ndGggJiYgdmFsdWVbb2Zmc2V0XSA9PT0gXCIwXCIpIHtcbiAgICAgICAgb2Zmc2V0Kys7XG4gICAgfVxuICAgIHJldHVybiBcIjB4XCIgKyB2YWx1ZS5zdWJzdHJpbmcob2Zmc2V0KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoZXhaZXJvUGFkKHZhbHVlLCBsZW5ndGgpIHtcbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdmFsdWUgPSBoZXhsaWZ5KHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWlzSGV4U3RyaW5nKHZhbHVlKSkge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBoZXggc3RyaW5nXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIH1cbiAgICBpZiAodmFsdWUubGVuZ3RoID4gMiAqIGxlbmd0aCArIDIpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInZhbHVlIG91dCBvZiByYW5nZVwiLCBcInZhbHVlXCIsIGFyZ3VtZW50c1sxXSk7XG4gICAgfVxuICAgIHdoaWxlICh2YWx1ZS5sZW5ndGggPCAyICogbGVuZ3RoICsgMikge1xuICAgICAgICB2YWx1ZSA9IFwiMHgwXCIgKyB2YWx1ZS5zdWJzdHJpbmcoMik7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzcGxpdFNpZ25hdHVyZShzaWduYXR1cmUpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIHI6IFwiMHhcIixcbiAgICAgICAgczogXCIweFwiLFxuICAgICAgICBfdnM6IFwiMHhcIixcbiAgICAgICAgcmVjb3ZlcnlQYXJhbTogMCxcbiAgICAgICAgdjogMCxcbiAgICAgICAgeVBhcml0eUFuZFM6IFwiMHhcIixcbiAgICAgICAgY29tcGFjdDogXCIweFwiXG4gICAgfTtcbiAgICBpZiAoaXNCeXRlc0xpa2Uoc2lnbmF0dXJlKSkge1xuICAgICAgICBsZXQgYnl0ZXMgPSBhcnJheWlmeShzaWduYXR1cmUpO1xuICAgICAgICAvLyBHZXQgdGhlIHIsIHMgYW5kIHZcbiAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gNjQpIHtcbiAgICAgICAgICAgIC8vIEVJUC0yMDk4OyBwdWxsIHRoZSB2IGZyb20gdGhlIHRvcCBiaXQgb2YgcyBhbmQgY2xlYXIgaXRcbiAgICAgICAgICAgIHJlc3VsdC52ID0gMjcgKyAoYnl0ZXNbMzJdID4+IDcpO1xuICAgICAgICAgICAgYnl0ZXNbMzJdICY9IDB4N2Y7XG4gICAgICAgICAgICByZXN1bHQuciA9IGhleGxpZnkoYnl0ZXMuc2xpY2UoMCwgMzIpKTtcbiAgICAgICAgICAgIHJlc3VsdC5zID0gaGV4bGlmeShieXRlcy5zbGljZSgzMiwgNjQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChieXRlcy5sZW5ndGggPT09IDY1KSB7XG4gICAgICAgICAgICByZXN1bHQuciA9IGhleGxpZnkoYnl0ZXMuc2xpY2UoMCwgMzIpKTtcbiAgICAgICAgICAgIHJlc3VsdC5zID0gaGV4bGlmeShieXRlcy5zbGljZSgzMiwgNjQpKTtcbiAgICAgICAgICAgIHJlc3VsdC52ID0gYnl0ZXNbNjRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgc2lnbmF0dXJlIHN0cmluZ1wiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFsbG93IGEgcmVjaWQgdG8gYmUgdXNlZCBhcyB0aGUgdlxuICAgICAgICBpZiAocmVzdWx0LnYgPCAyNykge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC52ID09PSAwIHx8IHJlc3VsdC52ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnYgKz0gMjc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwic2lnbmF0dXJlIGludmFsaWQgdiBieXRlXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHV0ZSByZWNvdmVyeVBhcmFtIGZyb20gdlxuICAgICAgICByZXN1bHQucmVjb3ZlcnlQYXJhbSA9IDEgLSAocmVzdWx0LnYgJSAyKTtcbiAgICAgICAgLy8gQ29tcHV0ZSBfdnMgZnJvbSByZWNvdmVyeVBhcmFtIGFuZCBzXG4gICAgICAgIGlmIChyZXN1bHQucmVjb3ZlcnlQYXJhbSkge1xuICAgICAgICAgICAgYnl0ZXNbMzJdIHw9IDB4ODA7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0Ll92cyA9IGhleGxpZnkoYnl0ZXMuc2xpY2UoMzIsIDY0KSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQuciA9IHNpZ25hdHVyZS5yO1xuICAgICAgICByZXN1bHQucyA9IHNpZ25hdHVyZS5zO1xuICAgICAgICByZXN1bHQudiA9IHNpZ25hdHVyZS52O1xuICAgICAgICByZXN1bHQucmVjb3ZlcnlQYXJhbSA9IHNpZ25hdHVyZS5yZWNvdmVyeVBhcmFtO1xuICAgICAgICByZXN1bHQuX3ZzID0gc2lnbmF0dXJlLl92cztcbiAgICAgICAgLy8gSWYgdGhlIF92cyBpcyBhdmFpbGFibGUsIHVzZSBpdCB0byBwb3B1bGF0ZSBtaXNzaW5nIHMsIHYgYW5kIHJlY292ZXJ5UGFyYW1cbiAgICAgICAgLy8gYW5kIHZlcmlmeSBub24tbWlzc2luZyBzLCB2IGFuZCByZWNvdmVyeVBhcmFtXG4gICAgICAgIGlmIChyZXN1bHQuX3ZzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHZzID0gemVyb1BhZChhcnJheWlmeShyZXN1bHQuX3ZzKSwgMzIpO1xuICAgICAgICAgICAgcmVzdWx0Ll92cyA9IGhleGxpZnkodnMpO1xuICAgICAgICAgICAgLy8gU2V0IG9yIGNoZWNrIHRoZSByZWNpZFxuICAgICAgICAgICAgY29uc3QgcmVjb3ZlcnlQYXJhbSA9ICgodnNbMF0gPj0gMTI4KSA/IDEgOiAwKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQucmVjb3ZlcnlQYXJhbSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnJlY292ZXJ5UGFyYW0gPSByZWNvdmVyeVBhcmFtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0LnJlY292ZXJ5UGFyYW0gIT09IHJlY292ZXJ5UGFyYW0pIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwic2lnbmF0dXJlIHJlY292ZXJ5UGFyYW0gbWlzbWF0Y2ggX3ZzXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZXQgb3IgY2hlY2sgdGhlIHNcbiAgICAgICAgICAgIHZzWzBdICY9IDB4N2Y7XG4gICAgICAgICAgICBjb25zdCBzID0gaGV4bGlmeSh2cyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zID0gcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdC5zICE9PSBzKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSB2IG1pc21hdGNoIF92c1wiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFVzZSByZWNpZCBhbmQgdiB0byBwb3B1bGF0ZSBlYWNoIG90aGVyXG4gICAgICAgIGlmIChyZXN1bHQucmVjb3ZlcnlQYXJhbSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnYgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgbWlzc2luZyB2IGFuZCByZWNvdmVyeVBhcmFtXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZXN1bHQudiA9PT0gMCB8fCByZXN1bHQudiA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5yZWNvdmVyeVBhcmFtID0gcmVzdWx0LnY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucmVjb3ZlcnlQYXJhbSA9IDEgLSAocmVzdWx0LnYgJSAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQudiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnYgPSAyNyArIHJlc3VsdC5yZWNvdmVyeVBhcmFtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVjSWQgPSAocmVzdWx0LnYgPT09IDAgfHwgcmVzdWx0LnYgPT09IDEpID8gcmVzdWx0LnYgOiAoMSAtIChyZXN1bHQudiAlIDIpKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnJlY292ZXJ5UGFyYW0gIT09IHJlY0lkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgcmVjb3ZlcnlQYXJhbSBtaXNtYXRjaCB2XCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQuciA9PSBudWxsIHx8ICFpc0hleFN0cmluZyhyZXN1bHQucikpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgbWlzc2luZyBvciBpbnZhbGlkIHJcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5yID0gaGV4WmVyb1BhZChyZXN1bHQuciwgMzIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQucyA9PSBudWxsIHx8ICFpc0hleFN0cmluZyhyZXN1bHQucykpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgbWlzc2luZyBvciBpbnZhbGlkIHNcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5zID0gaGV4WmVyb1BhZChyZXN1bHQucywgMzIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZzID0gYXJyYXlpZnkocmVzdWx0LnMpO1xuICAgICAgICBpZiAodnNbMF0gPj0gMTI4KSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwic2lnbmF0dXJlIHMgb3V0IG9mIHJhbmdlXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5yZWNvdmVyeVBhcmFtKSB7XG4gICAgICAgICAgICB2c1swXSB8PSAweDgwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IF92cyA9IGhleGxpZnkodnMpO1xuICAgICAgICBpZiAocmVzdWx0Ll92cykge1xuICAgICAgICAgICAgaWYgKCFpc0hleFN0cmluZyhyZXN1bHQuX3ZzKSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgaW52YWxpZCBfdnNcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5fdnMgPSBoZXhaZXJvUGFkKHJlc3VsdC5fdnMsIDMyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgb3IgY2hlY2sgdGhlIF92c1xuICAgICAgICBpZiAocmVzdWx0Ll92cyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuX3ZzID0gX3ZzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlc3VsdC5fdnMgIT09IF92cykge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSBfdnMgbWlzbWF0Y2ggdiBhbmQgc1wiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC55UGFyaXR5QW5kUyA9IHJlc3VsdC5fdnM7XG4gICAgcmVzdWx0LmNvbXBhY3QgPSByZXN1bHQuciArIHJlc3VsdC55UGFyaXR5QW5kUy5zdWJzdHJpbmcoMik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBqb2luU2lnbmF0dXJlKHNpZ25hdHVyZSkge1xuICAgIHNpZ25hdHVyZSA9IHNwbGl0U2lnbmF0dXJlKHNpZ25hdHVyZSk7XG4gICAgcmV0dXJuIGhleGxpZnkoY29uY2F0KFtcbiAgICAgICAgc2lnbmF0dXJlLnIsXG4gICAgICAgIHNpZ25hdHVyZS5zLFxuICAgICAgICAoc2lnbmF0dXJlLnJlY292ZXJ5UGFyYW0gPyBcIjB4MWNcIiA6IFwiMHgxYlwiKVxuICAgIF0pKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9iaWdudW1iZXJcIjtcbmNvbnN0IE5lZ2F0aXZlT25lID0gKCAvKiNfX1BVUkVfXyovQmlnTnVtYmVyLmZyb20oLTEpKTtcbmNvbnN0IFplcm8gPSAoIC8qI19fUFVSRV9fKi9CaWdOdW1iZXIuZnJvbSgwKSk7XG5jb25zdCBPbmUgPSAoIC8qI19fUFVSRV9fKi9CaWdOdW1iZXIuZnJvbSgxKSk7XG5jb25zdCBUd28gPSAoIC8qI19fUFVSRV9fKi9CaWdOdW1iZXIuZnJvbSgyKSk7XG5jb25zdCBXZWlQZXJFdGhlciA9ICggLyojX19QVVJFX18qL0JpZ051bWJlci5mcm9tKFwiMTAwMDAwMDAwMDAwMDAwMDAwMFwiKSk7XG5jb25zdCBNYXhVaW50MjU2ID0gKCAvKiNfX1BVUkVfXyovQmlnTnVtYmVyLmZyb20oXCIweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZcIikpO1xuY29uc3QgTWluSW50MjU2ID0gKCAvKiNfX1BVUkVfXyovQmlnTnVtYmVyLmZyb20oXCItMHg4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIpKTtcbmNvbnN0IE1heEludDI1NiA9ICggLyojX19QVVJFX18qL0JpZ051bWJlci5mcm9tKFwiMHg3ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmXCIpKTtcbmV4cG9ydCB7IE5lZ2F0aXZlT25lLCBaZXJvLCBPbmUsIFR3bywgV2VpUGVyRXRoZXIsIE1heFVpbnQyNTYsIE1pbkludDI1NiwgTWF4SW50MjU2LCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmlnbnVtYmVycy5qcy5tYXAiLCJpbXBvcnQgeyBrZWNjYWsyNTYgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3Qva2VjY2FrMjU2XCI7XG5pbXBvcnQgeyB0b1V0ZjhCeXRlcyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9zdHJpbmdzXCI7XG5leHBvcnQgZnVuY3Rpb24gaWQodGV4dCkge1xuICAgIHJldHVybiBrZWNjYWsyNTYodG9VdGY4Qnl0ZXModGV4dCkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aWQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgc2hhMyBmcm9tIFwianMtc2hhM1wiO1xuaW1wb3J0IHsgYXJyYXlpZnkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmV4cG9ydCBmdW5jdGlvbiBrZWNjYWsyNTYoZGF0YSkge1xuICAgIHJldHVybiAnMHgnICsgc2hhMy5rZWNjYWtfMjU2KGFycmF5aWZ5KGRhdGEpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImV4cG9ydCBjb25zdCB2ZXJzaW9uID0gXCJsb2dnZXIvNS43LjBcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV92ZXJzaW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xubGV0IF9wZXJtYW5lbnRDZW5zb3JFcnJvcnMgPSBmYWxzZTtcbmxldCBfY2Vuc29yRXJyb3JzID0gZmFsc2U7XG5jb25zdCBMb2dMZXZlbHMgPSB7IGRlYnVnOiAxLCBcImRlZmF1bHRcIjogMiwgaW5mbzogMiwgd2FybmluZzogMywgZXJyb3I6IDQsIG9mZjogNSB9O1xubGV0IF9sb2dMZXZlbCA9IExvZ0xldmVsc1tcImRlZmF1bHRcIl07XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmxldCBfZ2xvYmFsTG9nZ2VyID0gbnVsbDtcbmZ1bmN0aW9uIF9jaGVja05vcm1hbGl6ZSgpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBtaXNzaW5nID0gW107XG4gICAgICAgIC8vIE1ha2Ugc3VyZSBhbGwgZm9ybXMgb2Ygbm9ybWFsaXphdGlvbiBhcmUgc3VwcG9ydGVkXG4gICAgICAgIFtcIk5GRFwiLCBcIk5GQ1wiLCBcIk5GS0RcIiwgXCJORktDXCJdLmZvckVhY2goKGZvcm0pID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKFwidGVzdFwiLm5vcm1hbGl6ZShmb3JtKSAhPT0gXCJ0ZXN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIG5vcm1hbGl6ZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgbWlzc2luZy5wdXNoKGZvcm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG1pc3NpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIFwiICsgbWlzc2luZy5qb2luKFwiLCBcIikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZTkpLm5vcm1hbGl6ZShcIk5GRFwiKSAhPT0gU3RyaW5nLmZyb21DaGFyQ29kZSgweDY1LCAweDAzMDEpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJicm9rZW4gaW1wbGVtZW50YXRpb25cIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBlcnJvci5tZXNzYWdlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmNvbnN0IF9ub3JtYWxpemVFcnJvciA9IF9jaGVja05vcm1hbGl6ZSgpO1xuZXhwb3J0IHZhciBMb2dMZXZlbDtcbihmdW5jdGlvbiAoTG9nTGV2ZWwpIHtcbiAgICBMb2dMZXZlbFtcIkRFQlVHXCJdID0gXCJERUJVR1wiO1xuICAgIExvZ0xldmVsW1wiSU5GT1wiXSA9IFwiSU5GT1wiO1xuICAgIExvZ0xldmVsW1wiV0FSTklOR1wiXSA9IFwiV0FSTklOR1wiO1xuICAgIExvZ0xldmVsW1wiRVJST1JcIl0gPSBcIkVSUk9SXCI7XG4gICAgTG9nTGV2ZWxbXCJPRkZcIl0gPSBcIk9GRlwiO1xufSkoTG9nTGV2ZWwgfHwgKExvZ0xldmVsID0ge30pKTtcbmV4cG9ydCB2YXIgRXJyb3JDb2RlO1xuKGZ1bmN0aW9uIChFcnJvckNvZGUpIHtcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gR2VuZXJpYyBFcnJvcnNcbiAgICAvLyBVbmtub3duIEVycm9yXG4gICAgRXJyb3JDb2RlW1wiVU5LTk9XTl9FUlJPUlwiXSA9IFwiVU5LTk9XTl9FUlJPUlwiO1xuICAgIC8vIE5vdCBJbXBsZW1lbnRlZFxuICAgIEVycm9yQ29kZVtcIk5PVF9JTVBMRU1FTlRFRFwiXSA9IFwiTk9UX0lNUExFTUVOVEVEXCI7XG4gICAgLy8gVW5zdXBwb3J0ZWQgT3BlcmF0aW9uXG4gICAgLy8gICAtIG9wZXJhdGlvblxuICAgIEVycm9yQ29kZVtcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiXSA9IFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCI7XG4gICAgLy8gTmV0d29yayBFcnJvciAoaS5lLiBFdGhlcmV1bSBOZXR3b3JrLCBzdWNoIGFzIGFuIGludmFsaWQgY2hhaW4gSUQpXG4gICAgLy8gICAtIGV2ZW50IChcIm5vTmV0d29ya1wiIGlzIG5vdCByZS10aHJvd24gaW4gcHJvdmlkZXIucmVhZHk7IG90aGVyd2lzZSB0aHJvd24pXG4gICAgRXJyb3JDb2RlW1wiTkVUV09SS19FUlJPUlwiXSA9IFwiTkVUV09SS19FUlJPUlwiO1xuICAgIC8vIFNvbWUgc29ydCBvZiBiYWQgcmVzcG9uc2UgZnJvbSB0aGUgc2VydmVyXG4gICAgRXJyb3JDb2RlW1wiU0VSVkVSX0VSUk9SXCJdID0gXCJTRVJWRVJfRVJST1JcIjtcbiAgICAvLyBUaW1lb3V0XG4gICAgRXJyb3JDb2RlW1wiVElNRU9VVFwiXSA9IFwiVElNRU9VVFwiO1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBPcGVyYXRpb25hbCAgRXJyb3JzXG4gICAgLy8gQnVmZmVyIE92ZXJydW5cbiAgICBFcnJvckNvZGVbXCJCVUZGRVJfT1ZFUlJVTlwiXSA9IFwiQlVGRkVSX09WRVJSVU5cIjtcbiAgICAvLyBOdW1lcmljIEZhdWx0XG4gICAgLy8gICAtIG9wZXJhdGlvbjogdGhlIG9wZXJhdGlvbiBiZWluZyBleGVjdXRlZFxuICAgIC8vICAgLSBmYXVsdDogdGhlIHJlYXNvbiB0aGlzIGZhdWx0ZWRcbiAgICBFcnJvckNvZGVbXCJOVU1FUklDX0ZBVUxUXCJdID0gXCJOVU1FUklDX0ZBVUxUXCI7XG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIEFyZ3VtZW50IEVycm9yc1xuICAgIC8vIE1pc3NpbmcgbmV3IG9wZXJhdG9yIHRvIGFuIG9iamVjdFxuICAgIC8vICAtIG5hbWU6IFRoZSBuYW1lIG9mIHRoZSBjbGFzc1xuICAgIEVycm9yQ29kZVtcIk1JU1NJTkdfTkVXXCJdID0gXCJNSVNTSU5HX05FV1wiO1xuICAgIC8vIEludmFsaWQgYXJndW1lbnQgKGUuZy4gdmFsdWUgaXMgaW5jb21wYXRpYmxlIHdpdGggdHlwZSkgdG8gYSBmdW5jdGlvbjpcbiAgICAvLyAgIC0gYXJndW1lbnQ6IFRoZSBhcmd1bWVudCBuYW1lIHRoYXQgd2FzIGludmFsaWRcbiAgICAvLyAgIC0gdmFsdWU6IFRoZSB2YWx1ZSBvZiB0aGUgYXJndW1lbnRcbiAgICBFcnJvckNvZGVbXCJJTlZBTElEX0FSR1VNRU5UXCJdID0gXCJJTlZBTElEX0FSR1VNRU5UXCI7XG4gICAgLy8gTWlzc2luZyBhcmd1bWVudCB0byBhIGZ1bmN0aW9uOlxuICAgIC8vICAgLSBjb3VudDogVGhlIG51bWJlciBvZiBhcmd1bWVudHMgcmVjZWl2ZWRcbiAgICAvLyAgIC0gZXhwZWN0ZWRDb3VudDogVGhlIG51bWJlciBvZiBhcmd1bWVudHMgZXhwZWN0ZWRcbiAgICBFcnJvckNvZGVbXCJNSVNTSU5HX0FSR1VNRU5UXCJdID0gXCJNSVNTSU5HX0FSR1VNRU5UXCI7XG4gICAgLy8gVG9vIG1hbnkgYXJndW1lbnRzXG4gICAgLy8gICAtIGNvdW50OiBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyByZWNlaXZlZFxuICAgIC8vICAgLSBleHBlY3RlZENvdW50OiBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyBleHBlY3RlZFxuICAgIEVycm9yQ29kZVtcIlVORVhQRUNURURfQVJHVU1FTlRcIl0gPSBcIlVORVhQRUNURURfQVJHVU1FTlRcIjtcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gQmxvY2tjaGFpbiBFcnJvcnNcbiAgICAvLyBDYWxsIGV4Y2VwdGlvblxuICAgIC8vICAtIHRyYW5zYWN0aW9uOiB0aGUgdHJhbnNhY3Rpb25cbiAgICAvLyAgLSBhZGRyZXNzPzogdGhlIGNvbnRyYWN0IGFkZHJlc3NcbiAgICAvLyAgLSBhcmdzPzogVGhlIGFyZ3VtZW50cyBwYXNzZWQgaW50byB0aGUgZnVuY3Rpb25cbiAgICAvLyAgLSBtZXRob2Q/OiBUaGUgU29saWRpdHkgbWV0aG9kIHNpZ25hdHVyZVxuICAgIC8vICAtIGVycm9yU2lnbmF0dXJlPzogVGhlIEVJUDg0OCBlcnJvciBzaWduYXR1cmVcbiAgICAvLyAgLSBlcnJvckFyZ3M/OiBUaGUgRUlQODQ4IGVycm9yIHBhcmFtZXRlcnNcbiAgICAvLyAgLSByZWFzb246IFRoZSByZWFzb24gKG9ubHkgZm9yIEVJUDg0OCBcIkVycm9yKHN0cmluZylcIilcbiAgICBFcnJvckNvZGVbXCJDQUxMX0VYQ0VQVElPTlwiXSA9IFwiQ0FMTF9FWENFUFRJT05cIjtcbiAgICAvLyBJbnN1ZmZpY2llbnQgZnVuZHMgKDwgdmFsdWUgKyBnYXNMaW1pdCAqIGdhc1ByaWNlKVxuICAgIC8vICAgLSB0cmFuc2FjdGlvbjogdGhlIHRyYW5zYWN0aW9uIGF0dGVtcHRlZFxuICAgIEVycm9yQ29kZVtcIklOU1VGRklDSUVOVF9GVU5EU1wiXSA9IFwiSU5TVUZGSUNJRU5UX0ZVTkRTXCI7XG4gICAgLy8gTm9uY2UgaGFzIGFscmVhZHkgYmVlbiB1c2VkXG4gICAgLy8gICAtIHRyYW5zYWN0aW9uOiB0aGUgdHJhbnNhY3Rpb24gYXR0ZW1wdGVkXG4gICAgRXJyb3JDb2RlW1wiTk9OQ0VfRVhQSVJFRFwiXSA9IFwiTk9OQ0VfRVhQSVJFRFwiO1xuICAgIC8vIFRoZSByZXBsYWNlbWVudCBmZWUgZm9yIHRoZSB0cmFuc2FjdGlvbiBpcyB0b28gbG93XG4gICAgLy8gICAtIHRyYW5zYWN0aW9uOiB0aGUgdHJhbnNhY3Rpb24gYXR0ZW1wdGVkXG4gICAgRXJyb3JDb2RlW1wiUkVQTEFDRU1FTlRfVU5ERVJQUklDRURcIl0gPSBcIlJFUExBQ0VNRU5UX1VOREVSUFJJQ0VEXCI7XG4gICAgLy8gVGhlIGdhcyBsaW1pdCBjb3VsZCBub3QgYmUgZXN0aW1hdGVkXG4gICAgLy8gICAtIHRyYW5zYWN0aW9uOiB0aGUgdHJhbnNhY3Rpb24gcGFzc2VkIHRvIGVzdGltYXRlR2FzXG4gICAgRXJyb3JDb2RlW1wiVU5QUkVESUNUQUJMRV9HQVNfTElNSVRcIl0gPSBcIlVOUFJFRElDVEFCTEVfR0FTX0xJTUlUXCI7XG4gICAgLy8gVGhlIHRyYW5zYWN0aW9uIHdhcyByZXBsYWNlZCBieSBvbmUgd2l0aCBhIGhpZ2hlciBnYXMgcHJpY2VcbiAgICAvLyAgIC0gcmVhc29uOiBcImNhbmNlbGxlZFwiLCBcInJlcGxhY2VkXCIgb3IgXCJyZXByaWNlZFwiXG4gICAgLy8gICAtIGNhbmNlbGxlZDogdHJ1ZSBpZiByZWFzb24gPT0gXCJjYW5jZWxsZWRcIiBvciByZWFzb24gPT0gXCJyZXBsYWNlZFwiKVxuICAgIC8vICAgLSBoYXNoOiBvcmlnaW5hbCB0cmFuc2FjdGlvbiBoYXNoXG4gICAgLy8gICAtIHJlcGxhY2VtZW50OiB0aGUgZnVsbCBUcmFuc2FjdGlvbnNSZXNwb25zZSBmb3IgdGhlIHJlcGxhY2VtZW50XG4gICAgLy8gICAtIHJlY2VpcHQ6IHRoZSByZWNlaXB0IG9mIHRoZSByZXBsYWNlbWVudFxuICAgIEVycm9yQ29kZVtcIlRSQU5TQUNUSU9OX1JFUExBQ0VEXCJdID0gXCJUUkFOU0FDVElPTl9SRVBMQUNFRFwiO1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBJbnRlcmFjdGlvbiBFcnJvcnNcbiAgICAvLyBUaGUgdXNlciByZWplY3RlZCB0aGUgYWN0aW9uLCBzdWNoIGFzIHNpZ25pbmcgYSBtZXNzYWdlIG9yIHNlbmRpbmdcbiAgICAvLyBhIHRyYW5zYWN0aW9uXG4gICAgRXJyb3JDb2RlW1wiQUNUSU9OX1JFSkVDVEVEXCJdID0gXCJBQ1RJT05fUkVKRUNURURcIjtcbn0pKEVycm9yQ29kZSB8fCAoRXJyb3JDb2RlID0ge30pKTtcbjtcbmNvbnN0IEhFWCA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuZXhwb3J0IGNsYXNzIExvZ2dlciB7XG4gICAgY29uc3RydWN0b3IodmVyc2lvbikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2ZXJzaW9uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdmVyc2lvbixcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2xvZyhsb2dMZXZlbCwgYXJncykge1xuICAgICAgICBjb25zdCBsZXZlbCA9IGxvZ0xldmVsLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChMb2dMZXZlbHNbbGV2ZWxdID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBsb2cgbGV2ZWwgbmFtZVwiLCBcImxvZ0xldmVsXCIsIGxvZ0xldmVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2xvZ0xldmVsID4gTG9nTGV2ZWxzW2xldmVsXSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xuICAgIH1cbiAgICBkZWJ1ZyguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuX2xvZyhMb2dnZXIubGV2ZWxzLkRFQlVHLCBhcmdzKTtcbiAgICB9XG4gICAgaW5mbyguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuX2xvZyhMb2dnZXIubGV2ZWxzLklORk8sIGFyZ3MpO1xuICAgIH1cbiAgICB3YXJuKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5fbG9nKExvZ2dlci5sZXZlbHMuV0FSTklORywgYXJncyk7XG4gICAgfVxuICAgIG1ha2VFcnJvcihtZXNzYWdlLCBjb2RlLCBwYXJhbXMpIHtcbiAgICAgICAgLy8gRXJyb3JzIGFyZSBiZWluZyBjZW5zb3JlZFxuICAgICAgICBpZiAoX2NlbnNvckVycm9ycykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFrZUVycm9yKFwiY2Vuc29yZWQgZXJyb3JcIiwgY29kZSwge30pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgY29kZSA9IExvZ2dlci5lcnJvcnMuVU5LTk9XTl9FUlJPUjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhcmFtcykge1xuICAgICAgICAgICAgcGFyYW1zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWVzc2FnZURldGFpbHMgPSBbXTtcbiAgICAgICAgT2JqZWN0LmtleXMocGFyYW1zKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGhleCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhleCArPSBIRVhbdmFsdWVbaV0gPj4gNF07XG4gICAgICAgICAgICAgICAgICAgICAgICBoZXggKz0gSEVYW3ZhbHVlW2ldICYgMHgwZl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZURldGFpbHMucHVzaChrZXkgKyBcIj1VaW50OEFycmF5KDB4XCIgKyBoZXggKyBcIilcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlRGV0YWlscy5wdXNoKGtleSArIFwiPVwiICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlRGV0YWlscy5wdXNoKGtleSArIFwiPVwiICsgSlNPTi5zdHJpbmdpZnkocGFyYW1zW2tleV0udG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbWVzc2FnZURldGFpbHMucHVzaChgY29kZT0ke2NvZGV9YCk7XG4gICAgICAgIG1lc3NhZ2VEZXRhaWxzLnB1c2goYHZlcnNpb249JHt0aGlzLnZlcnNpb259YCk7XG4gICAgICAgIGNvbnN0IHJlYXNvbiA9IG1lc3NhZ2U7XG4gICAgICAgIGxldCB1cmwgPSBcIlwiO1xuICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgRXJyb3JDb2RlLk5VTUVSSUNfRkFVTFQ6IHtcbiAgICAgICAgICAgICAgICB1cmwgPSBcIk5VTUVSSUNfRkFVTFRcIjtcbiAgICAgICAgICAgICAgICBjb25zdCBmYXVsdCA9IG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChmYXVsdCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwib3ZlcmZsb3dcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInVuZGVyZmxvd1wiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZGl2aXNpb24tYnktemVyb1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IFwiLVwiICsgZmF1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm5lZ2F0aXZlLXBvd2VyXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJuZWdhdGl2ZS13aWR0aFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IFwiLXVuc3VwcG9ydGVkXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInVuYm91bmQtYml0d2lzZS1yZXN1bHRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCArPSBcIi11bmJvdW5kLXJlc3VsdFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBFcnJvckNvZGUuQ0FMTF9FWENFUFRJT046XG4gICAgICAgICAgICBjYXNlIEVycm9yQ29kZS5JTlNVRkZJQ0lFTlRfRlVORFM6XG4gICAgICAgICAgICBjYXNlIEVycm9yQ29kZS5NSVNTSU5HX05FVzpcbiAgICAgICAgICAgIGNhc2UgRXJyb3JDb2RlLk5PTkNFX0VYUElSRUQ6XG4gICAgICAgICAgICBjYXNlIEVycm9yQ29kZS5SRVBMQUNFTUVOVF9VTkRFUlBSSUNFRDpcbiAgICAgICAgICAgIGNhc2UgRXJyb3JDb2RlLlRSQU5TQUNUSU9OX1JFUExBQ0VEOlxuICAgICAgICAgICAgY2FzZSBFcnJvckNvZGUuVU5QUkVESUNUQUJMRV9HQVNfTElNSVQ6XG4gICAgICAgICAgICAgICAgdXJsID0gY29kZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAodXJsKSB7XG4gICAgICAgICAgICBtZXNzYWdlICs9IFwiIFsgU2VlOiBodHRwczovXFwvbGlua3MuZXRoZXJzLm9yZy92NS1lcnJvcnMtXCIgKyB1cmwgKyBcIiBdXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2VEZXRhaWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAoXCIgKyBtZXNzYWdlRGV0YWlscy5qb2luKFwiLCBcIikgKyBcIilcIjtcbiAgICAgICAgfVxuICAgICAgICAvLyBAVE9ETzogQW55Pz9cbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIGVycm9yLnJlYXNvbiA9IHJlYXNvbjtcbiAgICAgICAgZXJyb3IuY29kZSA9IGNvZGU7XG4gICAgICAgIE9iamVjdC5rZXlzKHBhcmFtcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBlcnJvcltrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxuICAgIHRocm93RXJyb3IobWVzc2FnZSwgY29kZSwgcGFyYW1zKSB7XG4gICAgICAgIHRocm93IHRoaXMubWFrZUVycm9yKG1lc3NhZ2UsIGNvZGUsIHBhcmFtcyk7XG4gICAgfVxuICAgIHRocm93QXJndW1lbnRFcnJvcihtZXNzYWdlLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2UsIExvZ2dlci5lcnJvcnMuSU5WQUxJRF9BUkdVTUVOVCwge1xuICAgICAgICAgICAgYXJndW1lbnQ6IG5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzc2VydChjb25kaXRpb24sIG1lc3NhZ2UsIGNvZGUsIHBhcmFtcykge1xuICAgICAgICBpZiAoISFjb25kaXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZSwgY29kZSwgcGFyYW1zKTtcbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoY29uZGl0aW9uLCBtZXNzYWdlLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAoISFjb25kaXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRocm93QXJndW1lbnRFcnJvcihtZXNzYWdlLCBuYW1lLCB2YWx1ZSk7XG4gICAgfVxuICAgIGNoZWNrTm9ybWFsaXplKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZSA9IFwicGxhdGZvcm0gbWlzc2luZyBTdHJpbmcucHJvdG90eXBlLm5vcm1hbGl6ZVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfbm9ybWFsaXplRXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcInBsYXRmb3JtIG1pc3NpbmcgU3RyaW5nLnByb3RvdHlwZS5ub3JtYWxpemVcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiU3RyaW5nLnByb3RvdHlwZS5ub3JtYWxpemVcIiwgZm9ybTogX25vcm1hbGl6ZUVycm9yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVja1NhZmVVaW50NTModmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZSA9IFwidmFsdWUgbm90IHNhZmVcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID49IDB4MWZmZmZmZmZmZmZmZmYpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlLCBMb2dnZXIuZXJyb3JzLk5VTUVSSUNfRkFVTFQsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiY2hlY2tTYWZlSW50ZWdlclwiLFxuICAgICAgICAgICAgICAgIGZhdWx0OiBcIm91dC1vZi1zYWZlLXJhbmdlXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgJSAxKSB7XG4gICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZSwgTG9nZ2VyLmVycm9ycy5OVU1FUklDX0ZBVUxULCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImNoZWNrU2FmZUludGVnZXJcIixcbiAgICAgICAgICAgICAgICBmYXVsdDogXCJub24taW50ZWdlclwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tBcmd1bWVudENvdW50KGNvdW50LCBleHBlY3RlZENvdW50LCBtZXNzYWdlKSB7XG4gICAgICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gXCI6IFwiICsgbWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3VudCA8IGV4cGVjdGVkQ291bnQpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcIm1pc3NpbmcgYXJndW1lbnRcIiArIG1lc3NhZ2UsIExvZ2dlci5lcnJvcnMuTUlTU0lOR19BUkdVTUVOVCwge1xuICAgICAgICAgICAgICAgIGNvdW50OiBjb3VudCxcbiAgICAgICAgICAgICAgICBleHBlY3RlZENvdW50OiBleHBlY3RlZENvdW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY291bnQgPiBleHBlY3RlZENvdW50KSB7XG4gICAgICAgICAgICB0aGlzLnRocm93RXJyb3IoXCJ0b28gbWFueSBhcmd1bWVudHNcIiArIG1lc3NhZ2UsIExvZ2dlci5lcnJvcnMuVU5FWFBFQ1RFRF9BUkdVTUVOVCwge1xuICAgICAgICAgICAgICAgIGNvdW50OiBjb3VudCxcbiAgICAgICAgICAgICAgICBleHBlY3RlZENvdW50OiBleHBlY3RlZENvdW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVja05ldyh0YXJnZXQsIGtpbmQpIHtcbiAgICAgICAgaWYgKHRhcmdldCA9PT0gT2JqZWN0IHx8IHRhcmdldCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnRocm93RXJyb3IoXCJtaXNzaW5nIG5ld1wiLCBMb2dnZXIuZXJyb3JzLk1JU1NJTkdfTkVXLCB7IG5hbWU6IGtpbmQubmFtZSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVja0Fic3RyYWN0KHRhcmdldCwga2luZCkge1xuICAgICAgICBpZiAodGFyZ2V0ID09PSBraW5kKSB7XG4gICAgICAgICAgICB0aGlzLnRocm93RXJyb3IoXCJjYW5ub3QgaW5zdGFudGlhdGUgYWJzdHJhY3QgY2xhc3MgXCIgKyBKU09OLnN0cmluZ2lmeShraW5kLm5hbWUpICsgXCIgZGlyZWN0bHk7IHVzZSBhIHN1Yi1jbGFzc1wiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwgeyBuYW1lOiB0YXJnZXQubmFtZSwgb3BlcmF0aW9uOiBcIm5ld1wiIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRhcmdldCA9PT0gT2JqZWN0IHx8IHRhcmdldCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnRocm93RXJyb3IoXCJtaXNzaW5nIG5ld1wiLCBMb2dnZXIuZXJyb3JzLk1JU1NJTkdfTkVXLCB7IG5hbWU6IGtpbmQubmFtZSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZ2xvYmFsTG9nZ2VyKCkge1xuICAgICAgICBpZiAoIV9nbG9iYWxMb2dnZXIpIHtcbiAgICAgICAgICAgIF9nbG9iYWxMb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfZ2xvYmFsTG9nZ2VyO1xuICAgIH1cbiAgICBzdGF0aWMgc2V0Q2Vuc29yc2hpcChjZW5zb3JzaGlwLCBwZXJtYW5lbnQpIHtcbiAgICAgICAgaWYgKCFjZW5zb3JzaGlwICYmIHBlcm1hbmVudCkge1xuICAgICAgICAgICAgdGhpcy5nbG9iYWxMb2dnZXIoKS50aHJvd0Vycm9yKFwiY2Fubm90IHBlcm1hbmVudGx5IGRpc2FibGUgY2Vuc29yc2hpcFwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJzZXRDZW5zb3JzaGlwXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfcGVybWFuZW50Q2Vuc29yRXJyb3JzKSB7XG4gICAgICAgICAgICBpZiAoIWNlbnNvcnNoaXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmdsb2JhbExvZ2dlcigpLnRocm93RXJyb3IoXCJlcnJvciBjZW5zb3JzaGlwIHBlcm1hbmVudFwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJzZXRDZW5zb3JzaGlwXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIF9jZW5zb3JFcnJvcnMgPSAhIWNlbnNvcnNoaXA7XG4gICAgICAgIF9wZXJtYW5lbnRDZW5zb3JFcnJvcnMgPSAhIXBlcm1hbmVudDtcbiAgICB9XG4gICAgc3RhdGljIHNldExvZ0xldmVsKGxvZ0xldmVsKSB7XG4gICAgICAgIGNvbnN0IGxldmVsID0gTG9nTGV2ZWxzW2xvZ0xldmVsLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICBpZiAobGV2ZWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgTG9nZ2VyLmdsb2JhbExvZ2dlcigpLndhcm4oXCJpbnZhbGlkIGxvZyBsZXZlbCAtIFwiICsgbG9nTGV2ZWwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIF9sb2dMZXZlbCA9IGxldmVsO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbSh2ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuICAgIH1cbn1cbkxvZ2dlci5lcnJvcnMgPSBFcnJvckNvZGU7XG5Mb2dnZXIubGV2ZWxzID0gTG9nTGV2ZWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJleHBvcnQgY29uc3QgdmVyc2lvbiA9IFwicHJvcGVydGllcy81LjcuMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmV4cG9ydCBmdW5jdGlvbiBkZWZpbmVSZWFkT25seShvYmplY3QsIG5hbWUsIHZhbHVlKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICB9KTtcbn1cbi8vIENyYXdsIHVwIHRoZSBjb25zdHJ1Y3RvciBjaGFpbiB0byBmaW5kIGEgc3RhdGljIG1ldGhvZFxuZXhwb3J0IGZ1bmN0aW9uIGdldFN0YXRpYyhjdG9yLCBrZXkpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICAgICAgaWYgKGN0b3Jba2V5XSkge1xuICAgICAgICAgICAgcmV0dXJuIGN0b3Jba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWN0b3IucHJvdG90eXBlIHx8IHR5cGVvZiAoY3Rvci5wcm90b3R5cGUpICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjdG9yID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGN0b3IucHJvdG90eXBlKS5jb25zdHJ1Y3RvcjtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZVByb3BlcnRpZXMob2JqZWN0KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBPYmplY3Qua2V5cyhvYmplY3QpLm1hcCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbigodikgPT4gKHsga2V5OiBrZXksIHZhbHVlOiB2IH0pKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSB5aWVsZCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICAgIHJldHVybiByZXN1bHRzLnJlZHVjZSgoYWNjdW0sIHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgYWNjdW1bKHJlc3VsdC5rZXkpXSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgfSwge30pO1xuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrUHJvcGVydGllcyhvYmplY3QsIHByb3BlcnRpZXMpIHtcbiAgICBpZiAoIW9iamVjdCB8fCB0eXBlb2YgKG9iamVjdCkgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgb2JqZWN0XCIsIFwib2JqZWN0XCIsIG9iamVjdCk7XG4gICAgfVxuICAgIE9iamVjdC5rZXlzKG9iamVjdCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGlmICghcHJvcGVydGllc1trZXldKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBvYmplY3Qga2V5IC0gXCIgKyBrZXksIFwidHJhbnNhY3Rpb246XCIgKyBrZXksIG9iamVjdCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzaGFsbG93Q29weShvYmplY3QpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IG9wYXF1ZSA9IHsgYmlnaW50OiB0cnVlLCBib29sZWFuOiB0cnVlLCBcImZ1bmN0aW9uXCI6IHRydWUsIG51bWJlcjogdHJ1ZSwgc3RyaW5nOiB0cnVlIH07XG5mdW5jdGlvbiBfaXNGcm96ZW4ob2JqZWN0KSB7XG4gICAgLy8gT3BhcXVlIG9iamVjdHMgYXJlIG5vdCBtdXRhYmxlLCBzbyBzYWZlIHRvIGNvcHkgYnkgYXNzaWdubWVudFxuICAgIGlmIChvYmplY3QgPT09IHVuZGVmaW5lZCB8fCBvYmplY3QgPT09IG51bGwgfHwgb3BhcXVlW3R5cGVvZiAob2JqZWN0KV0pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkgfHwgdHlwZW9mIChvYmplY3QpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmICghT2JqZWN0LmlzRnJvemVuKG9iamVjdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXlzW2ldXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIElmIGFjY2Vzc2luZyBhIHZhbHVlIHRyaWdnZXJzIGFuIGVycm9yLCBpdCBpcyBhIGdldHRlclxuICAgICAgICAgICAgICAgIC8vIGRlc2lnbmVkIHRvIGRvIHNvIChlLmcuIFJlc3VsdCkgYW5kIGlzIHRoZXJlZm9yZSBcImZyb3plblwiXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIV9pc0Zyb3plbih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGBDYW5ub3QgZGVlcENvcHkgJHt0eXBlb2YgKG9iamVjdCl9YCwgXCJvYmplY3RcIiwgb2JqZWN0KTtcbn1cbi8vIFJldHVybnMgYSBuZXcgY29weSBvZiBvYmplY3QsIHN1Y2ggdGhhdCBubyBwcm9wZXJ0aWVzIG1heSBiZSByZXBsYWNlZC5cbi8vIE5ldyBwcm9wZXJ0aWVzIG1heSBiZSBhZGRlZCBvbmx5IHRvIG9iamVjdHMuXG5mdW5jdGlvbiBfZGVlcENvcHkob2JqZWN0KSB7XG4gICAgaWYgKF9pc0Zyb3plbihvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICAgIC8vIEFycmF5cyBhcmUgbXV0YWJsZSwgc28gd2UgbmVlZCB0byBjcmVhdGUgYSBjb3B5XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShvYmplY3QubWFwKChpdGVtKSA9PiBkZWVwQ29weShpdGVtKSkpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChvYmplY3QpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkocmVzdWx0LCBrZXksIGRlZXBDb3B5KHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYENhbm5vdCBkZWVwQ29weSAke3R5cGVvZiAob2JqZWN0KX1gLCBcIm9iamVjdFwiLCBvYmplY3QpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlZXBDb3B5KG9iamVjdCkge1xuICAgIHJldHVybiBfZGVlcENvcHkob2JqZWN0KTtcbn1cbmV4cG9ydCBjbGFzcyBEZXNjcmlwdGlvbiB7XG4gICAgY29uc3RydWN0b3IoaW5mbykge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBpbmZvKSB7XG4gICAgICAgICAgICB0aGlzW2tleV0gPSBkZWVwQ29weShpbmZvW2tleV0pO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcInJscC81LjcuMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vL1NlZTogaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3dpa2kvd2lraS9STFBcbmltcG9ydCB7IGFycmF5aWZ5LCBoZXhsaWZ5LCBpc0J5dGVzTGlrZSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuZnVuY3Rpb24gYXJyYXlpZnlJbnRlZ2VyKHZhbHVlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgd2hpbGUgKHZhbHVlKSB7XG4gICAgICAgIHJlc3VsdC51bnNoaWZ0KHZhbHVlICYgMHhmZik7XG4gICAgICAgIHZhbHVlID4+PSA4O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdW5hcnJheWlmeUludGVnZXIoZGF0YSwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICBsZXQgcmVzdWx0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCA9IChyZXN1bHQgKiAyNTYpICsgZGF0YVtvZmZzZXQgKyBpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIF9lbmNvZGUob2JqZWN0KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgICBsZXQgcGF5bG9hZCA9IFtdO1xuICAgICAgICBvYmplY3QuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIHBheWxvYWQgPSBwYXlsb2FkLmNvbmNhdChfZW5jb2RlKGNoaWxkKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocGF5bG9hZC5sZW5ndGggPD0gNTUpIHtcbiAgICAgICAgICAgIHBheWxvYWQudW5zaGlmdCgweGMwICsgcGF5bG9hZC5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuZ3RoID0gYXJyYXlpZnlJbnRlZ2VyKHBheWxvYWQubGVuZ3RoKTtcbiAgICAgICAgbGVuZ3RoLnVuc2hpZnQoMHhmNyArIGxlbmd0aC5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gbGVuZ3RoLmNvbmNhdChwYXlsb2FkKTtcbiAgICB9XG4gICAgaWYgKCFpc0J5dGVzTGlrZShvYmplY3QpKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJSTFAgb2JqZWN0IG11c3QgYmUgQnl0ZXNMaWtlXCIsIFwib2JqZWN0XCIsIG9iamVjdCk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcnJheWlmeShvYmplY3QpKTtcbiAgICBpZiAoZGF0YS5sZW5ndGggPT09IDEgJiYgZGF0YVswXSA8PSAweDdmKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhLmxlbmd0aCA8PSA1NSkge1xuICAgICAgICBkYXRhLnVuc2hpZnQoMHg4MCArIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5aWZ5SW50ZWdlcihkYXRhLmxlbmd0aCk7XG4gICAgbGVuZ3RoLnVuc2hpZnQoMHhiNyArIGxlbmd0aC5sZW5ndGgpO1xuICAgIHJldHVybiBsZW5ndGguY29uY2F0KGRhdGEpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZShvYmplY3QpIHtcbiAgICByZXR1cm4gaGV4bGlmeShfZW5jb2RlKG9iamVjdCkpO1xufVxuZnVuY3Rpb24gX2RlY29kZUNoaWxkcmVuKGRhdGEsIG9mZnNldCwgY2hpbGRPZmZzZXQsIGxlbmd0aCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIHdoaWxlIChjaGlsZE9mZnNldCA8IG9mZnNldCArIDEgKyBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgZGVjb2RlZCA9IF9kZWNvZGUoZGF0YSwgY2hpbGRPZmZzZXQpO1xuICAgICAgICByZXN1bHQucHVzaChkZWNvZGVkLnJlc3VsdCk7XG4gICAgICAgIGNoaWxkT2Zmc2V0ICs9IGRlY29kZWQuY29uc3VtZWQ7XG4gICAgICAgIGlmIChjaGlsZE9mZnNldCA+IG9mZnNldCArIDEgKyBsZW5ndGgpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2hpbGQgZGF0YSB0b28gc2hvcnRcIiwgTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge30pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGNvbnN1bWVkOiAoMSArIGxlbmd0aCksIHJlc3VsdDogcmVzdWx0IH07XG59XG4vLyByZXR1cm5zIHsgY29uc3VtZWQ6IG51bWJlciwgcmVzdWx0OiBPYmplY3QgfVxuZnVuY3Rpb24gX2RlY29kZShkYXRhLCBvZmZzZXQpIHtcbiAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJkYXRhIHRvbyBzaG9ydFwiLCBMb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLCB7fSk7XG4gICAgfVxuICAgIC8vIEFycmF5IHdpdGggZXh0cmEgbGVuZ3RoIHByZWZpeFxuICAgIGlmIChkYXRhW29mZnNldF0gPj0gMHhmOCkge1xuICAgICAgICBjb25zdCBsZW5ndGhMZW5ndGggPSBkYXRhW29mZnNldF0gLSAweGY3O1xuICAgICAgICBpZiAob2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCA+IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImRhdGEgc2hvcnQgc2VnbWVudCB0b28gc2hvcnRcIiwgTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge30pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHVuYXJyYXlpZnlJbnRlZ2VyKGRhdGEsIG9mZnNldCArIDEsIGxlbmd0aExlbmd0aCk7XG4gICAgICAgIGlmIChvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoID4gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZGF0YSBsb25nIHNlZ21lbnQgdG9vIHNob3J0XCIsIExvZ2dlci5lcnJvcnMuQlVGRkVSX09WRVJSVU4sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2RlY29kZUNoaWxkcmVuKGRhdGEsIG9mZnNldCwgb2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCwgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YVtvZmZzZXRdID49IDB4YzApIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZGF0YVtvZmZzZXRdIC0gMHhjMDtcbiAgICAgICAgaWYgKG9mZnNldCArIDEgKyBsZW5ndGggPiBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJkYXRhIGFycmF5IHRvbyBzaG9ydFwiLCBMb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9kZWNvZGVDaGlsZHJlbihkYXRhLCBvZmZzZXQsIG9mZnNldCArIDEsIGxlbmd0aCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGFbb2Zmc2V0XSA+PSAweGI4KSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aExlbmd0aCA9IGRhdGFbb2Zmc2V0XSAtIDB4Yjc7XG4gICAgICAgIGlmIChvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoID4gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZGF0YSBhcnJheSB0b28gc2hvcnRcIiwgTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge30pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHVuYXJyYXlpZnlJbnRlZ2VyKGRhdGEsIG9mZnNldCArIDEsIGxlbmd0aExlbmd0aCk7XG4gICAgICAgIGlmIChvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoID4gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZGF0YSBhcnJheSB0b28gc2hvcnRcIiwgTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge30pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGhleGxpZnkoZGF0YS5zbGljZShvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoLCBvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoKSk7XG4gICAgICAgIHJldHVybiB7IGNvbnN1bWVkOiAoMSArIGxlbmd0aExlbmd0aCArIGxlbmd0aCksIHJlc3VsdDogcmVzdWx0IH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGFbb2Zmc2V0XSA+PSAweDgwKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGRhdGFbb2Zmc2V0XSAtIDB4ODA7XG4gICAgICAgIGlmIChvZmZzZXQgKyAxICsgbGVuZ3RoID4gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZGF0YSB0b28gc2hvcnRcIiwgTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge30pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGhleGxpZnkoZGF0YS5zbGljZShvZmZzZXQgKyAxLCBvZmZzZXQgKyAxICsgbGVuZ3RoKSk7XG4gICAgICAgIHJldHVybiB7IGNvbnN1bWVkOiAoMSArIGxlbmd0aCksIHJlc3VsdDogcmVzdWx0IH07XG4gICAgfVxuICAgIHJldHVybiB7IGNvbnN1bWVkOiAxLCByZXN1bHQ6IGhleGxpZnkoZGF0YVtvZmZzZXRdKSB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZShkYXRhKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBhcnJheWlmeShkYXRhKTtcbiAgICBjb25zdCBkZWNvZGVkID0gX2RlY29kZShieXRlcywgMCk7XG4gICAgaWYgKGRlY29kZWQuY29uc3VtZWQgIT09IGJ5dGVzLmxlbmd0aCkge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBybHAgZGF0YVwiLCBcImRhdGFcIiwgZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBkZWNvZGVkLnJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImV4cG9ydCBjb25zdCB2ZXJzaW9uID0gXCJzdHJpbmdzLzUuNy4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IGFycmF5aWZ5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5leHBvcnQgdmFyIFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybTtcbihmdW5jdGlvbiAoVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtKSB7XG4gICAgVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtW1wiY3VycmVudFwiXSA9IFwiXCI7XG4gICAgVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtW1wiTkZDXCJdID0gXCJORkNcIjtcbiAgICBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm1bXCJORkRcIl0gPSBcIk5GRFwiO1xuICAgIFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybVtcIk5GS0NcIl0gPSBcIk5GS0NcIjtcbiAgICBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm1bXCJORktEXCJdID0gXCJORktEXCI7XG59KShVbmljb2RlTm9ybWFsaXphdGlvbkZvcm0gfHwgKFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybSA9IHt9KSk7XG47XG5leHBvcnQgdmFyIFV0ZjhFcnJvclJlYXNvbjtcbihmdW5jdGlvbiAoVXRmOEVycm9yUmVhc29uKSB7XG4gICAgLy8gQSBjb250aW51YXRpb24gYnl0ZSB3YXMgcHJlc2VudCB3aGVyZSB0aGVyZSB3YXMgbm90aGluZyB0byBjb250aW51ZVxuICAgIC8vIC0gb2Zmc2V0ID0gdGhlIGluZGV4IHRoZSBjb2RlcG9pbnQgYmVnYW4gaW5cbiAgICBVdGY4RXJyb3JSZWFzb25bXCJVTkVYUEVDVEVEX0NPTlRJTlVFXCJdID0gXCJ1bmV4cGVjdGVkIGNvbnRpbnVhdGlvbiBieXRlXCI7XG4gICAgLy8gQW4gaW52YWxpZCAobm9uLWNvbnRpbnVhdGlvbikgYnl0ZSB0byBzdGFydCBhIFVURi04IGNvZGVwb2ludCB3YXMgZm91bmRcbiAgICAvLyAtIG9mZnNldCA9IHRoZSBpbmRleCB0aGUgY29kZXBvaW50IGJlZ2FuIGluXG4gICAgVXRmOEVycm9yUmVhc29uW1wiQkFEX1BSRUZJWFwiXSA9IFwiYmFkIGNvZGVwb2ludCBwcmVmaXhcIjtcbiAgICAvLyBUaGUgc3RyaW5nIGlzIHRvbyBzaG9ydCB0byBwcm9jZXNzIHRoZSBleHBlY3RlZCBjb2RlcG9pbnRcbiAgICAvLyAtIG9mZnNldCA9IHRoZSBpbmRleCB0aGUgY29kZXBvaW50IGJlZ2FuIGluXG4gICAgVXRmOEVycm9yUmVhc29uW1wiT1ZFUlJVTlwiXSA9IFwic3RyaW5nIG92ZXJydW5cIjtcbiAgICAvLyBBIG1pc3NpbmcgY29udGludWF0aW9uIGJ5dGUgd2FzIGV4cGVjdGVkIGJ1dCBub3QgZm91bmRcbiAgICAvLyAtIG9mZnNldCA9IHRoZSBpbmRleCB0aGUgY29udGludWF0aW9uIGJ5dGUgd2FzIGV4cGVjdGVkIGF0XG4gICAgVXRmOEVycm9yUmVhc29uW1wiTUlTU0lOR19DT05USU5VRVwiXSA9IFwibWlzc2luZyBjb250aW51YXRpb24gYnl0ZVwiO1xuICAgIC8vIFRoZSBjb21wdXRlZCBjb2RlIHBvaW50IGlzIG91dHNpZGUgdGhlIHJhbmdlIGZvciBVVEYtOFxuICAgIC8vIC0gb2Zmc2V0ICAgICAgID0gc3RhcnQgb2YgdGhpcyBjb2RlcG9pbnRcbiAgICAvLyAtIGJhZENvZGVwb2ludCA9IHRoZSBjb21wdXRlZCBjb2RlcG9pbnQ7IG91dHNpZGUgdGhlIFVURi04IHJhbmdlXG4gICAgVXRmOEVycm9yUmVhc29uW1wiT1VUX09GX1JBTkdFXCJdID0gXCJvdXQgb2YgVVRGLTggcmFuZ2VcIjtcbiAgICAvLyBVVEYtOCBzdHJpbmdzIG1heSBub3QgY29udGFpbiBVVEYtMTYgc3Vycm9nYXRlIHBhaXJzXG4gICAgLy8gLSBvZmZzZXQgICAgICAgPSBzdGFydCBvZiB0aGlzIGNvZGVwb2ludFxuICAgIC8vIC0gYmFkQ29kZXBvaW50ID0gdGhlIGNvbXB1dGVkIGNvZGVwb2ludDsgaW5zaWRlIHRoZSBVVEYtMTYgc3Vycm9nYXRlIHJhbmdlXG4gICAgVXRmOEVycm9yUmVhc29uW1wiVVRGMTZfU1VSUk9HQVRFXCJdID0gXCJVVEYtMTYgc3Vycm9nYXRlXCI7XG4gICAgLy8gVGhlIHN0cmluZyBpcyBhbiBvdmVybG9uZyByZXByZXNlbnRhdGlvblxuICAgIC8vIC0gb2Zmc2V0ICAgICAgID0gc3RhcnQgb2YgdGhpcyBjb2RlcG9pbnRcbiAgICAvLyAtIGJhZENvZGVwb2ludCA9IHRoZSBjb21wdXRlZCBjb2RlcG9pbnQ7IGFscmVhZHkgYm91bmRzIGNoZWNrZWRcbiAgICBVdGY4RXJyb3JSZWFzb25bXCJPVkVSTE9OR1wiXSA9IFwib3ZlcmxvbmcgcmVwcmVzZW50YXRpb25cIjtcbn0pKFV0ZjhFcnJvclJlYXNvbiB8fCAoVXRmOEVycm9yUmVhc29uID0ge30pKTtcbjtcbmZ1bmN0aW9uIGVycm9yRnVuYyhyZWFzb24sIG9mZnNldCwgYnl0ZXMsIG91dHB1dCwgYmFkQ29kZXBvaW50KSB7XG4gICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYGludmFsaWQgY29kZXBvaW50IGF0IG9mZnNldCAke29mZnNldH07ICR7cmVhc29ufWAsIFwiYnl0ZXNcIiwgYnl0ZXMpO1xufVxuZnVuY3Rpb24gaWdub3JlRnVuYyhyZWFzb24sIG9mZnNldCwgYnl0ZXMsIG91dHB1dCwgYmFkQ29kZXBvaW50KSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gaW52YWxpZCBwcmVmaXggKGluY2x1ZGluZyBzdHJheSBjb250aW51YXRpb24pLCBza2lwIGFueSBhZGRpdGlvbmFsIGNvbnRpbnVhdGlvbiBieXRlc1xuICAgIGlmIChyZWFzb24gPT09IFV0ZjhFcnJvclJlYXNvbi5CQURfUFJFRklYIHx8IHJlYXNvbiA9PT0gVXRmOEVycm9yUmVhc29uLlVORVhQRUNURURfQ09OVElOVUUpIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBmb3IgKGxldCBvID0gb2Zmc2V0ICsgMTsgbyA8IGJ5dGVzLmxlbmd0aDsgbysrKSB7XG4gICAgICAgICAgICBpZiAoYnl0ZXNbb10gPj4gNiAhPT0gMHgwMikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICAvLyBUaGlzIGJ5dGUgcnVucyB1cyBwYXN0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc28ganVzdCBqdW1wIHRvIHRoZSBlbmRcbiAgICAvLyAoYnV0IHRoZSBmaXJzdCBieXRlIHdhcyByZWFkIGFscmVhZHkgcmVhZCBhbmQgdGhlcmVmb3JlIHNraXBwZWQpXG4gICAgaWYgKHJlYXNvbiA9PT0gVXRmOEVycm9yUmVhc29uLk9WRVJSVU4pIHtcbiAgICAgICAgcmV0dXJuIGJ5dGVzLmxlbmd0aCAtIG9mZnNldCAtIDE7XG4gICAgfVxuICAgIC8vIE5vdGhpbmcgdG8gc2tpcFxuICAgIHJldHVybiAwO1xufVxuZnVuY3Rpb24gcmVwbGFjZUZ1bmMocmVhc29uLCBvZmZzZXQsIGJ5dGVzLCBvdXRwdXQsIGJhZENvZGVwb2ludCkge1xuICAgIC8vIE92ZXJsb25nIHJlcHJlc2VudGF0aW9ucyBhcmUgb3RoZXJ3aXNlIFwidmFsaWRcIiBjb2RlIHBvaW50czsganVzdCBub24tZGVpc3Rpbmd0aXNoZWRcbiAgICBpZiAocmVhc29uID09PSBVdGY4RXJyb3JSZWFzb24uT1ZFUkxPTkcpIHtcbiAgICAgICAgb3V0cHV0LnB1c2goYmFkQ29kZXBvaW50KTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8vIFB1dCB0aGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVyIGludG8gdGhlIG91dHB1dFxuICAgIG91dHB1dC5wdXNoKDB4ZmZmZCk7XG4gICAgLy8gT3RoZXJ3aXNlLCBwcm9jZXNzIGFzIGlmIGlnbm9yaW5nIGVycm9yc1xuICAgIHJldHVybiBpZ25vcmVGdW5jKHJlYXNvbiwgb2Zmc2V0LCBieXRlcywgb3V0cHV0LCBiYWRDb2RlcG9pbnQpO1xufVxuLy8gQ29tbW9uIGVycm9yIGhhbmRpbmcgc3RyYXRlZ2llc1xuZXhwb3J0IGNvbnN0IFV0ZjhFcnJvckZ1bmNzID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgZXJyb3I6IGVycm9yRnVuYyxcbiAgICBpZ25vcmU6IGlnbm9yZUZ1bmMsXG4gICAgcmVwbGFjZTogcmVwbGFjZUZ1bmNcbn0pO1xuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMzM1NjQ5My9kZWNvZGUtdXRmLTgtd2l0aC1qYXZhc2NyaXB0IzEzNjkxNDk5XG5mdW5jdGlvbiBnZXRVdGY4Q29kZVBvaW50cyhieXRlcywgb25FcnJvcikge1xuICAgIGlmIChvbkVycm9yID09IG51bGwpIHtcbiAgICAgICAgb25FcnJvciA9IFV0ZjhFcnJvckZ1bmNzLmVycm9yO1xuICAgIH1cbiAgICBieXRlcyA9IGFycmF5aWZ5KGJ5dGVzKTtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgaSA9IDA7XG4gICAgLy8gSW52YWxpZCBieXRlcyBhcmUgaWdub3JlZFxuICAgIHdoaWxlIChpIDwgYnl0ZXMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGMgPSBieXRlc1tpKytdO1xuICAgICAgICAvLyAweHh4IHh4eHhcbiAgICAgICAgaWYgKGMgPj4gNyA9PT0gMCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYyk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNdWx0aWJ5dGU7IGhvdyBtYW55IGJ5dGVzIGxlZnQgZm9yIHRoaXMgY2hhcmFjdGVyP1xuICAgICAgICBsZXQgZXh0cmFMZW5ndGggPSBudWxsO1xuICAgICAgICBsZXQgb3ZlcmxvbmdNYXNrID0gbnVsbDtcbiAgICAgICAgLy8gMTEweCB4eHh4IDEweHggeHh4eFxuICAgICAgICBpZiAoKGMgJiAweGUwKSA9PT0gMHhjMCkge1xuICAgICAgICAgICAgZXh0cmFMZW5ndGggPSAxO1xuICAgICAgICAgICAgb3ZlcmxvbmdNYXNrID0gMHg3ZjtcbiAgICAgICAgICAgIC8vIDExMTAgeHh4eCAxMHh4IHh4eHggMTB4eCB4eHh4XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGMgJiAweGYwKSA9PT0gMHhlMCkge1xuICAgICAgICAgICAgZXh0cmFMZW5ndGggPSAyO1xuICAgICAgICAgICAgb3ZlcmxvbmdNYXNrID0gMHg3ZmY7XG4gICAgICAgICAgICAvLyAxMTExIDB4eHggMTB4eCB4eHh4IDEweHggeHh4eCAxMHh4IHh4eHhcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoYyAmIDB4ZjgpID09PSAweGYwKSB7XG4gICAgICAgICAgICBleHRyYUxlbmd0aCA9IDM7XG4gICAgICAgICAgICBvdmVybG9uZ01hc2sgPSAweGZmZmY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoKGMgJiAweGMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgICAgIGkgKz0gb25FcnJvcihVdGY4RXJyb3JSZWFzb24uVU5FWFBFQ1RFRF9DT05USU5VRSwgaSAtIDEsIGJ5dGVzLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaSArPSBvbkVycm9yKFV0ZjhFcnJvclJlYXNvbi5CQURfUFJFRklYLCBpIC0gMSwgYnl0ZXMsIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEbyB3ZSBoYXZlIGVub3VnaCBieXRlcyBpbiBvdXIgZGF0YT9cbiAgICAgICAgaWYgKGkgLSAxICsgZXh0cmFMZW5ndGggPj0gYnl0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpICs9IG9uRXJyb3IoVXRmOEVycm9yUmVhc29uLk9WRVJSVU4sIGkgLSAxLCBieXRlcywgcmVzdWx0KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgbGVuZ3RoIHByZWZpeCBmcm9tIHRoZSBjaGFyXG4gICAgICAgIGxldCByZXMgPSBjICYgKCgxIDw8ICg4IC0gZXh0cmFMZW5ndGggLSAxKSkgLSAxKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBleHRyYUxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBsZXQgbmV4dENoYXIgPSBieXRlc1tpXTtcbiAgICAgICAgICAgIC8vIEludmFsaWQgY29udGludWF0aW9uIGJ5dGVcbiAgICAgICAgICAgIGlmICgobmV4dENoYXIgJiAweGMwKSAhPSAweDgwKSB7XG4gICAgICAgICAgICAgICAgaSArPSBvbkVycm9yKFV0ZjhFcnJvclJlYXNvbi5NSVNTSU5HX0NPTlRJTlVFLCBpLCBieXRlcywgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICByZXMgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgcmVzID0gKHJlcyA8PCA2KSB8IChuZXh0Q2hhciAmIDB4M2YpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNlZSBhYm92ZSBsb29wIGZvciBpbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlXG4gICAgICAgIGlmIChyZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1heGltdW0gY29kZSBwb2ludFxuICAgICAgICBpZiAocmVzID4gMHgxMGZmZmYpIHtcbiAgICAgICAgICAgIGkgKz0gb25FcnJvcihVdGY4RXJyb3JSZWFzb24uT1VUX09GX1JBTkdFLCBpIC0gMSAtIGV4dHJhTGVuZ3RoLCBieXRlcywgcmVzdWx0LCByZXMpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzZXJ2ZWQgZm9yIFVURi0xNiBzdXJyb2dhdGUgaGFsdmVzXG4gICAgICAgIGlmIChyZXMgPj0gMHhkODAwICYmIHJlcyA8PSAweGRmZmYpIHtcbiAgICAgICAgICAgIGkgKz0gb25FcnJvcihVdGY4RXJyb3JSZWFzb24uVVRGMTZfU1VSUk9HQVRFLCBpIC0gMSAtIGV4dHJhTGVuZ3RoLCBieXRlcywgcmVzdWx0LCByZXMpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgZm9yIG92ZXJsb25nIHNlcXVlbmNlcyAobW9yZSBieXRlcyB0aGFuIG5lZWRlZClcbiAgICAgICAgaWYgKHJlcyA8PSBvdmVybG9uZ01hc2spIHtcbiAgICAgICAgICAgIGkgKz0gb25FcnJvcihVdGY4RXJyb3JSZWFzb24uT1ZFUkxPTkcsIGkgLSAxIC0gZXh0cmFMZW5ndGgsIGJ5dGVzLCByZXN1bHQsIHJlcyk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaChyZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xODcyOTQwNS9ob3ctdG8tY29udmVydC11dGY4LXN0cmluZy10by1ieXRlLWFycmF5XG5leHBvcnQgZnVuY3Rpb24gdG9VdGY4Qnl0ZXMoc3RyLCBmb3JtID0gVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtLmN1cnJlbnQpIHtcbiAgICBpZiAoZm9ybSAhPSBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm0uY3VycmVudCkge1xuICAgICAgICBsb2dnZXIuY2hlY2tOb3JtYWxpemUoKTtcbiAgICAgICAgc3RyID0gc3RyLm5vcm1hbGl6ZShmb3JtKTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjIDwgMHg4MDApIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChjID4+IDYpIHwgMHhjMCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoYyAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGMgJiAweGZjMDApID09IDB4ZDgwMCkge1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgY29uc3QgYzIgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGlmIChpID49IHN0ci5sZW5ndGggfHwgKGMyICYgMHhmYzAwKSAhPT0gMHhkYzAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB1dGYtOCBzdHJpbmdcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdXJyb2dhdGUgUGFpclxuICAgICAgICAgICAgY29uc3QgcGFpciA9IDB4MTAwMDAgKyAoKGMgJiAweDAzZmYpIDw8IDEwKSArIChjMiAmIDB4MDNmZik7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgocGFpciA+PiAxOCkgfCAweGYwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCgocGFpciA+PiAxMikgJiAweDNmKSB8IDB4ODApO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKChwYWlyID4+IDYpICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChwYWlyICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChjID4+IDEyKSB8IDB4ZTApO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKChjID4+IDYpICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChjICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlpZnkocmVzdWx0KTtcbn1cbjtcbmZ1bmN0aW9uIGVzY2FwZUNoYXIodmFsdWUpIHtcbiAgICBjb25zdCBoZXggPSAoXCIwMDAwXCIgKyB2YWx1ZS50b1N0cmluZygxNikpO1xuICAgIHJldHVybiBcIlxcXFx1XCIgKyBoZXguc3Vic3RyaW5nKGhleC5sZW5ndGggLSA0KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBfdG9Fc2NhcGVkVXRmOFN0cmluZyhieXRlcywgb25FcnJvcikge1xuICAgIHJldHVybiAnXCInICsgZ2V0VXRmOENvZGVQb2ludHMoYnl0ZXMsIG9uRXJyb3IpLm1hcCgoY29kZVBvaW50KSA9PiB7XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPCAyNTYpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoY29kZVBvaW50KSB7XG4gICAgICAgICAgICAgICAgY2FzZSA4OiByZXR1cm4gXCJcXFxcYlwiO1xuICAgICAgICAgICAgICAgIGNhc2UgOTogcmV0dXJuIFwiXFxcXHRcIjtcbiAgICAgICAgICAgICAgICBjYXNlIDEwOiByZXR1cm4gXCJcXFxcblwiO1xuICAgICAgICAgICAgICAgIGNhc2UgMTM6IHJldHVybiBcIlxcXFxyXCI7XG4gICAgICAgICAgICAgICAgY2FzZSAzNDogcmV0dXJuIFwiXFxcXFxcXCJcIjtcbiAgICAgICAgICAgICAgICBjYXNlIDkyOiByZXR1cm4gXCJcXFxcXFxcXFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA+PSAzMiAmJiBjb2RlUG9pbnQgPCAxMjcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPD0gMHhmZmZmKSB7XG4gICAgICAgICAgICByZXR1cm4gZXNjYXBlQ2hhcihjb2RlUG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwO1xuICAgICAgICByZXR1cm4gZXNjYXBlQ2hhcigoKGNvZGVQb2ludCA+PiAxMCkgJiAweDNmZikgKyAweGQ4MDApICsgZXNjYXBlQ2hhcigoY29kZVBvaW50ICYgMHgzZmYpICsgMHhkYzAwKTtcbiAgICB9KS5qb2luKFwiXCIpICsgJ1wiJztcbn1cbmV4cG9ydCBmdW5jdGlvbiBfdG9VdGY4U3RyaW5nKGNvZGVQb2ludHMpIHtcbiAgICByZXR1cm4gY29kZVBvaW50cy5tYXAoKGNvZGVQb2ludCkgPT4ge1xuICAgICAgICBpZiAoY29kZVBvaW50IDw9IDB4ZmZmZikge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50KTtcbiAgICAgICAgfVxuICAgICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMDtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoKCgoY29kZVBvaW50ID4+IDEwKSAmIDB4M2ZmKSArIDB4ZDgwMCksICgoY29kZVBvaW50ICYgMHgzZmYpICsgMHhkYzAwKSk7XG4gICAgfSkuam9pbihcIlwiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0b1V0ZjhTdHJpbmcoYnl0ZXMsIG9uRXJyb3IpIHtcbiAgICByZXR1cm4gX3RvVXRmOFN0cmluZyhnZXRVdGY4Q29kZVBvaW50cyhieXRlcywgb25FcnJvcikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRvVXRmOENvZGVQb2ludHMoc3RyLCBmb3JtID0gVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtLmN1cnJlbnQpIHtcbiAgICByZXR1cm4gZ2V0VXRmOENvZGVQb2ludHModG9VdGY4Qnl0ZXMoc3RyLCBmb3JtKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGY4LmpzLm1hcCIsImltcG9ydCB7IHBhcnNlLCBpY29uIH0gZnJvbSAnQGZvcnRhd2Vzb21lL2ZvbnRhd2Vzb21lLXN2Zy1jb3JlJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkMih0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gbnVsbCAhPSBhcmd1bWVudHNbaV0gPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICBpICUgMiA/IG93bktleXMoT2JqZWN0KHNvdXJjZSksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgIH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgfSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICB9LCBfdHlwZW9mKG9iaik7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG5cbiAgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpO1xuXG4gIHZhciBrZXksIGk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldO1xuICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTtcbn1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICByZXR1cm4gYXJyMjtcbn1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxuLy8gR2V0IENTUyBjbGFzcyBsaXN0IGZyb20gYSBwcm9wcyBvYmplY3RcbmZ1bmN0aW9uIGNsYXNzTGlzdChwcm9wcykge1xuICB2YXIgX2NsYXNzZXM7XG5cbiAgdmFyIGJlYXQgPSBwcm9wcy5iZWF0LFxuICAgICAgZmFkZSA9IHByb3BzLmZhZGUsXG4gICAgICBiZWF0RmFkZSA9IHByb3BzLmJlYXRGYWRlLFxuICAgICAgYm91bmNlID0gcHJvcHMuYm91bmNlLFxuICAgICAgc2hha2UgPSBwcm9wcy5zaGFrZSxcbiAgICAgIGZsYXNoID0gcHJvcHMuZmxhc2gsXG4gICAgICBzcGluID0gcHJvcHMuc3BpbixcbiAgICAgIHNwaW5QdWxzZSA9IHByb3BzLnNwaW5QdWxzZSxcbiAgICAgIHNwaW5SZXZlcnNlID0gcHJvcHMuc3BpblJldmVyc2UsXG4gICAgICBwdWxzZSA9IHByb3BzLnB1bHNlLFxuICAgICAgZml4ZWRXaWR0aCA9IHByb3BzLmZpeGVkV2lkdGgsXG4gICAgICBpbnZlcnNlID0gcHJvcHMuaW52ZXJzZSxcbiAgICAgIGJvcmRlciA9IHByb3BzLmJvcmRlcixcbiAgICAgIGxpc3RJdGVtID0gcHJvcHMubGlzdEl0ZW0sXG4gICAgICBmbGlwID0gcHJvcHMuZmxpcCxcbiAgICAgIHNpemUgPSBwcm9wcy5zaXplLFxuICAgICAgcm90YXRpb24gPSBwcm9wcy5yb3RhdGlvbixcbiAgICAgIHB1bGwgPSBwcm9wcy5wdWxsOyAvLyBtYXAgb2YgQ1NTIGNsYXNzIG5hbWVzIHRvIHByb3BlcnRpZXNcblxuICB2YXIgY2xhc3NlcyA9IChfY2xhc3NlcyA9IHtcbiAgICAnZmEtYmVhdCc6IGJlYXQsXG4gICAgJ2ZhLWZhZGUnOiBmYWRlLFxuICAgICdmYS1iZWF0LWZhZGUnOiBiZWF0RmFkZSxcbiAgICAnZmEtYm91bmNlJzogYm91bmNlLFxuICAgICdmYS1zaGFrZSc6IHNoYWtlLFxuICAgICdmYS1mbGFzaCc6IGZsYXNoLFxuICAgICdmYS1zcGluJzogc3BpbixcbiAgICAnZmEtc3Bpbi1yZXZlcnNlJzogc3BpblJldmVyc2UsXG4gICAgJ2ZhLXNwaW4tcHVsc2UnOiBzcGluUHVsc2UsXG4gICAgJ2ZhLXB1bHNlJzogcHVsc2UsXG4gICAgJ2ZhLWZ3JzogZml4ZWRXaWR0aCxcbiAgICAnZmEtaW52ZXJzZSc6IGludmVyc2UsXG4gICAgJ2ZhLWJvcmRlcic6IGJvcmRlcixcbiAgICAnZmEtbGknOiBsaXN0SXRlbSxcbiAgICAnZmEtZmxpcCc6IGZsaXAgPT09IHRydWUsXG4gICAgJ2ZhLWZsaXAtaG9yaXpvbnRhbCc6IGZsaXAgPT09ICdob3Jpem9udGFsJyB8fCBmbGlwID09PSAnYm90aCcsXG4gICAgJ2ZhLWZsaXAtdmVydGljYWwnOiBmbGlwID09PSAndmVydGljYWwnIHx8IGZsaXAgPT09ICdib3RoJ1xuICB9LCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzZXMsIFwiZmEtXCIuY29uY2F0KHNpemUpLCB0eXBlb2Ygc2l6ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgc2l6ZSAhPT0gbnVsbCksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NlcywgXCJmYS1yb3RhdGUtXCIuY29uY2F0KHJvdGF0aW9uKSwgdHlwZW9mIHJvdGF0aW9uICE9PSAndW5kZWZpbmVkJyAmJiByb3RhdGlvbiAhPT0gbnVsbCAmJiByb3RhdGlvbiAhPT0gMCksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NlcywgXCJmYS1wdWxsLVwiLmNvbmNhdChwdWxsKSwgdHlwZW9mIHB1bGwgIT09ICd1bmRlZmluZWQnICYmIHB1bGwgIT09IG51bGwpLCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzZXMsICdmYS1zd2FwLW9wYWNpdHknLCBwcm9wcy5zd2FwT3BhY2l0eSksIF9jbGFzc2VzKTsgLy8gbWFwIG92ZXIgYWxsIHRoZSBrZXlzIGluIHRoZSBjbGFzc2VzIG9iamVjdFxuICAvLyByZXR1cm4gYW4gYXJyYXkgb2YgdGhlIGtleXMgd2hlcmUgdGhlIHZhbHVlIGZvciB0aGUga2V5IGlzIG5vdCBudWxsXG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKGNsYXNzZXMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGNsYXNzZXNba2V5XSA/IGtleSA6IG51bGw7XG4gIH0pLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGtleTtcbiAgfSk7XG59XG5cbi8vIENhbWVsaXplIHRha2VuIGZyb20gaHVtcHNcbi8vIGh1bXBzIGlzIGNvcHlyaWdodCDCqSAyMDEyKyBEb20gQ2hyaXN0aWVcbi8vIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbi8vIFBlcmZvcm1hbnQgd2F5IHRvIGRldGVybWluZSBpZiBvYmplY3QgY29lcmNlcyB0byBhIG51bWJlclxuZnVuY3Rpb24gX2lzTnVtZXJpY2FsKG9iaikge1xuICBvYmogPSBvYmogLSAwOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG5cbiAgcmV0dXJuIG9iaiA9PT0gb2JqO1xufVxuXG5mdW5jdGlvbiBjYW1lbGl6ZShzdHJpbmcpIHtcbiAgaWYgKF9pc051bWVyaWNhbChzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZztcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcblxuXG4gIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKC9bXFwtX1xcc10rKC4pPy9nLCBmdW5jdGlvbiAobWF0Y2gsIGNocikge1xuICAgIHJldHVybiBjaHIgPyBjaHIudG9VcHBlckNhc2UoKSA6ICcnO1xuICB9KTsgLy8gRW5zdXJlIDFzdCBjaGFyIGlzIGFsd2F5cyBsb3dlcmNhc2VcblxuICByZXR1cm4gc3RyaW5nLnN1YnN0cigwLCAxKS50b0xvd2VyQ2FzZSgpICsgc3RyaW5nLnN1YnN0cigxKTtcbn1cblxudmFyIF9leGNsdWRlZCA9IFtcInN0eWxlXCJdO1xuXG5mdW5jdGlvbiBjYXBpdGFsaXplKHZhbCkge1xuICByZXR1cm4gdmFsLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdmFsLnNsaWNlKDEpO1xufVxuXG5mdW5jdGlvbiBzdHlsZVRvT2JqZWN0KHN0eWxlKSB7XG4gIHJldHVybiBzdHlsZS5zcGxpdCgnOycpLm1hcChmdW5jdGlvbiAocykge1xuICAgIHJldHVybiBzLnRyaW0oKTtcbiAgfSkuZmlsdGVyKGZ1bmN0aW9uIChzKSB7XG4gICAgcmV0dXJuIHM7XG4gIH0pLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwYWlyKSB7XG4gICAgdmFyIGkgPSBwYWlyLmluZGV4T2YoJzonKTtcbiAgICB2YXIgcHJvcCA9IGNhbWVsaXplKHBhaXIuc2xpY2UoMCwgaSkpO1xuICAgIHZhciB2YWx1ZSA9IHBhaXIuc2xpY2UoaSArIDEpLnRyaW0oKTtcbiAgICBwcm9wLnN0YXJ0c1dpdGgoJ3dlYmtpdCcpID8gYWNjW2NhcGl0YWxpemUocHJvcCldID0gdmFsdWUgOiBhY2NbcHJvcF0gPSB2YWx1ZTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnQoY3JlYXRlRWxlbWVudCwgZWxlbWVudCkge1xuICB2YXIgZXh0cmFQcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgdmFyIGNoaWxkcmVuID0gKGVsZW1lbnQuY2hpbGRyZW4gfHwgW10pLm1hcChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICByZXR1cm4gY29udmVydChjcmVhdGVFbGVtZW50LCBjaGlsZCk7XG4gIH0pO1xuICAvKiBlc2xpbnQtZGlzYWJsZSBkb3Qtbm90YXRpb24gKi9cblxuICB2YXIgbWl4aW5zID0gT2JqZWN0LmtleXMoZWxlbWVudC5hdHRyaWJ1dGVzIHx8IHt9KS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7XG4gICAgdmFyIHZhbCA9IGVsZW1lbnQuYXR0cmlidXRlc1trZXldO1xuXG4gICAgc3dpdGNoIChrZXkpIHtcbiAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgYWNjLmF0dHJzWydjbGFzc05hbWUnXSA9IHZhbDtcbiAgICAgICAgZGVsZXRlIGVsZW1lbnQuYXR0cmlidXRlc1snY2xhc3MnXTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3N0eWxlJzpcbiAgICAgICAgYWNjLmF0dHJzWydzdHlsZSddID0gc3R5bGVUb09iamVjdCh2YWwpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGtleS5pbmRleE9mKCdhcmlhLScpID09PSAwIHx8IGtleS5pbmRleE9mKCdkYXRhLScpID09PSAwKSB7XG4gICAgICAgICAgYWNjLmF0dHJzW2tleS50b0xvd2VyQ2FzZSgpXSA9IHZhbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhY2MuYXR0cnNbY2FtZWxpemUoa2V5KV0gPSB2YWw7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBhY2M7XG4gIH0sIHtcbiAgICBhdHRyczoge31cbiAgfSk7XG5cbiAgdmFyIF9leHRyYVByb3BzJHN0eWxlID0gZXh0cmFQcm9wcy5zdHlsZSxcbiAgICAgIGV4aXN0aW5nU3R5bGUgPSBfZXh0cmFQcm9wcyRzdHlsZSA9PT0gdm9pZCAwID8ge30gOiBfZXh0cmFQcm9wcyRzdHlsZSxcbiAgICAgIHJlbWFpbmluZyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhleHRyYVByb3BzLCBfZXhjbHVkZWQpO1xuXG4gIG1peGlucy5hdHRyc1snc3R5bGUnXSA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBtaXhpbnMuYXR0cnNbJ3N0eWxlJ10pLCBleGlzdGluZ1N0eWxlKTtcbiAgLyogZXNsaW50LWVuYWJsZSAqL1xuXG4gIHJldHVybiBjcmVhdGVFbGVtZW50LmFwcGx5KHZvaWQgMCwgW2VsZW1lbnQudGFnLCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgbWl4aW5zLmF0dHJzKSwgcmVtYWluaW5nKV0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShjaGlsZHJlbikpKTtcbn1cblxudmFyIFBST0RVQ1RJT04gPSBmYWxzZTtcblxudHJ5IHtcbiAgUFJPRFVDVElPTiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbic7XG59IGNhdGNoIChlKSB7fVxuXG5mdW5jdGlvbiBsb2cgKCkge1xuICBpZiAoIVBST0RVQ1RJT04gJiYgY29uc29sZSAmJiB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBfY29uc29sZTtcblxuICAgIChfY29uc29sZSA9IGNvbnNvbGUpLmVycm9yLmFwcGx5KF9jb25zb2xlLCBhcmd1bWVudHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUljb25BcmdzKGljb24pIHtcbiAgLy8gdGhpcyBoYXMgZXZlcnl0aGluZyB0aGF0IGl0IG5lZWRzIHRvIGJlIHJlbmRlcmVkIHdoaWNoIG1lYW5zIGl0IHdhcyBwcm9iYWJseSBpbXBvcnRlZFxuICAvLyBkaXJlY3RseSBmcm9tIGFuIGljb24gc3ZnIHBhY2thZ2VcbiAgaWYgKGljb24gJiYgX3R5cGVvZihpY29uKSA9PT0gJ29iamVjdCcgJiYgaWNvbi5wcmVmaXggJiYgaWNvbi5pY29uTmFtZSAmJiBpY29uLmljb24pIHtcbiAgICByZXR1cm4gaWNvbjtcbiAgfVxuXG4gIGlmIChwYXJzZS5pY29uKSB7XG4gICAgcmV0dXJuIHBhcnNlLmljb24oaWNvbik7XG4gIH0gLy8gaWYgdGhlIGljb24gaXMgbnVsbCwgdGhlcmUncyBub3RoaW5nIHRvIGRvXG5cblxuICBpZiAoaWNvbiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9IC8vIGlmIHRoZSBpY29uIGlzIGFuIG9iamVjdCBhbmQgaGFzIGEgcHJlZml4IGFuZCBhbiBpY29uIG5hbWUsIHJldHVybiBpdFxuXG5cbiAgaWYgKGljb24gJiYgX3R5cGVvZihpY29uKSA9PT0gJ29iamVjdCcgJiYgaWNvbi5wcmVmaXggJiYgaWNvbi5pY29uTmFtZSkge1xuICAgIHJldHVybiBpY29uO1xuICB9IC8vIGlmIGl0J3MgYW4gYXJyYXkgd2l0aCBsZW5ndGggb2YgdHdvXG5cblxuICBpZiAoQXJyYXkuaXNBcnJheShpY29uKSAmJiBpY29uLmxlbmd0aCA9PT0gMikge1xuICAgIC8vIHVzZSB0aGUgZmlyc3QgaXRlbSBhcyBwcmVmaXgsIHNlY29uZCBhcyBpY29uIG5hbWVcbiAgICByZXR1cm4ge1xuICAgICAgcHJlZml4OiBpY29uWzBdLFxuICAgICAgaWNvbk5hbWU6IGljb25bMV1cbiAgICB9O1xuICB9IC8vIGlmIGl0J3MgYSBzdHJpbmcsIHVzZSBpdCBhcyB0aGUgaWNvbiBuYW1lXG5cblxuICBpZiAodHlwZW9mIGljb24gPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByZWZpeDogJ2ZhcycsXG4gICAgICBpY29uTmFtZTogaWNvblxuICAgIH07XG4gIH1cbn1cblxuLy8gY3JlYXRlcyBhbiBvYmplY3Qgd2l0aCBhIGtleSBvZiBrZXlcbi8vIGFuZCBhIHZhbHVlIG9mIHZhbHVlXG4vLyBpZiBjZXJ0YWluIGNvbmRpdGlvbnMgYXJlIG1ldFxuZnVuY3Rpb24gb2JqZWN0V2l0aEtleShrZXksIHZhbHVlKSB7XG4gIC8vIGlmIHRoZSB2YWx1ZSBpcyBhIG5vbi1lbXB0eSBhcnJheVxuICAvLyBvciBpdCdzIG5vdCBhbiBhcnJheSBidXQgaXQgaXMgdHJ1dGh5XG4gIC8vIHRoZW4gY3JlYXRlIHRoZSBvYmplY3Qgd2l0aCB0aGUga2V5IGFuZCB0aGUgdmFsdWVcbiAgLy8gaWYgbm90LCByZXR1cm4gYW4gZW1wdHkgYXJyYXlcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA+IDAgfHwgIUFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlID8gX2RlZmluZVByb3BlcnR5KHt9LCBrZXksIHZhbHVlKSA6IHt9O1xufVxuXG52YXIgRm9udEF3ZXNvbWVJY29uID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gKHByb3BzLCByZWYpIHtcbiAgdmFyIGljb25BcmdzID0gcHJvcHMuaWNvbixcbiAgICAgIG1hc2tBcmdzID0gcHJvcHMubWFzayxcbiAgICAgIHN5bWJvbCA9IHByb3BzLnN5bWJvbCxcbiAgICAgIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIHRpdGxlID0gcHJvcHMudGl0bGUsXG4gICAgICB0aXRsZUlkID0gcHJvcHMudGl0bGVJZCxcbiAgICAgIG1hc2tJZCA9IHByb3BzLm1hc2tJZDtcbiAgdmFyIGljb25Mb29rdXAgPSBub3JtYWxpemVJY29uQXJncyhpY29uQXJncyk7XG4gIHZhciBjbGFzc2VzID0gb2JqZWN0V2l0aEtleSgnY2xhc3NlcycsIFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoY2xhc3NMaXN0KHByb3BzKSksIF90b0NvbnN1bWFibGVBcnJheShjbGFzc05hbWUuc3BsaXQoJyAnKSkpKTtcbiAgdmFyIHRyYW5zZm9ybSA9IG9iamVjdFdpdGhLZXkoJ3RyYW5zZm9ybScsIHR5cGVvZiBwcm9wcy50cmFuc2Zvcm0gPT09ICdzdHJpbmcnID8gcGFyc2UudHJhbnNmb3JtKHByb3BzLnRyYW5zZm9ybSkgOiBwcm9wcy50cmFuc2Zvcm0pO1xuICB2YXIgbWFzayA9IG9iamVjdFdpdGhLZXkoJ21hc2snLCBub3JtYWxpemVJY29uQXJncyhtYXNrQXJncykpO1xuICB2YXIgcmVuZGVyZWRJY29uID0gaWNvbihpY29uTG9va3VwLCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgY2xhc3NlcyksIHRyYW5zZm9ybSksIG1hc2spLCB7fSwge1xuICAgIHN5bWJvbDogc3ltYm9sLFxuICAgIHRpdGxlOiB0aXRsZSxcbiAgICB0aXRsZUlkOiB0aXRsZUlkLFxuICAgIG1hc2tJZDogbWFza0lkXG4gIH0pKTtcblxuICBpZiAoIXJlbmRlcmVkSWNvbikge1xuICAgIGxvZygnQ291bGQgbm90IGZpbmQgaWNvbicsIGljb25Mb29rdXApO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGFic3RyYWN0ID0gcmVuZGVyZWRJY29uLmFic3RyYWN0O1xuICB2YXIgZXh0cmFQcm9wcyA9IHtcbiAgICByZWY6IHJlZlxuICB9O1xuICBPYmplY3Qua2V5cyhwcm9wcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgIGlmICghRm9udEF3ZXNvbWVJY29uLmRlZmF1bHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBleHRyYVByb3BzW2tleV0gPSBwcm9wc1trZXldO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBjb252ZXJ0Q3VycnkoYWJzdHJhY3RbMF0sIGV4dHJhUHJvcHMpO1xufSk7XG5Gb250QXdlc29tZUljb24uZGlzcGxheU5hbWUgPSAnRm9udEF3ZXNvbWVJY29uJztcbkZvbnRBd2Vzb21lSWNvbi5wcm9wVHlwZXMgPSB7XG4gIGJlYXQ6IFByb3BUeXBlcy5ib29sLFxuICBib3JkZXI6IFByb3BUeXBlcy5ib29sLFxuICBiZWF0RmFkZTogUHJvcFR5cGVzLmJvb2wsXG4gIGJvdW5jZTogUHJvcFR5cGVzLmJvb2wsXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgZmFkZTogUHJvcFR5cGVzLmJvb2wsXG4gIGZsYXNoOiBQcm9wVHlwZXMuYm9vbCxcbiAgbWFzazogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm9iamVjdCwgUHJvcFR5cGVzLmFycmF5LCBQcm9wVHlwZXMuc3RyaW5nXSksXG4gIG1hc2tJZDogUHJvcFR5cGVzLnN0cmluZyxcbiAgZml4ZWRXaWR0aDogUHJvcFR5cGVzLmJvb2wsXG4gIGludmVyc2U6IFByb3BUeXBlcy5ib29sLFxuICBmbGlwOiBQcm9wVHlwZXMub25lT2YoW3RydWUsIGZhbHNlLCAnaG9yaXpvbnRhbCcsICd2ZXJ0aWNhbCcsICdib3RoJ10pLFxuICBpY29uOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMub2JqZWN0LCBQcm9wVHlwZXMuYXJyYXksIFByb3BUeXBlcy5zdHJpbmddKSxcbiAgbGlzdEl0ZW06IFByb3BUeXBlcy5ib29sLFxuICBwdWxsOiBQcm9wVHlwZXMub25lT2YoWydyaWdodCcsICdsZWZ0J10pLFxuICBwdWxzZTogUHJvcFR5cGVzLmJvb2wsXG4gIHJvdGF0aW9uOiBQcm9wVHlwZXMub25lT2YoWzAsIDkwLCAxODAsIDI3MF0pLFxuICBzaGFrZTogUHJvcFR5cGVzLmJvb2wsXG4gIHNpemU6IFByb3BUeXBlcy5vbmVPZihbJzJ4cycsICd4cycsICdzbScsICdsZycsICd4bCcsICcyeGwnLCAnMXgnLCAnMngnLCAnM3gnLCAnNHgnLCAnNXgnLCAnNngnLCAnN3gnLCAnOHgnLCAnOXgnLCAnMTB4J10pLFxuICBzcGluOiBQcm9wVHlwZXMuYm9vbCxcbiAgc3BpblB1bHNlOiBQcm9wVHlwZXMuYm9vbCxcbiAgc3BpblJldmVyc2U6IFByb3BUeXBlcy5ib29sLFxuICBzeW1ib2w6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5ib29sLCBQcm9wVHlwZXMuc3RyaW5nXSksXG4gIHRpdGxlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICB0aXRsZUlkOiBQcm9wVHlwZXMuc3RyaW5nLFxuICB0cmFuc2Zvcm06IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5vYmplY3RdKSxcbiAgc3dhcE9wYWNpdHk6IFByb3BUeXBlcy5ib29sXG59O1xuRm9udEF3ZXNvbWVJY29uLmRlZmF1bHRQcm9wcyA9IHtcbiAgYm9yZGVyOiBmYWxzZSxcbiAgY2xhc3NOYW1lOiAnJyxcbiAgbWFzazogbnVsbCxcbiAgbWFza0lkOiBudWxsLFxuICBmaXhlZFdpZHRoOiBmYWxzZSxcbiAgaW52ZXJzZTogZmFsc2UsXG4gIGZsaXA6IGZhbHNlLFxuICBpY29uOiBudWxsLFxuICBsaXN0SXRlbTogZmFsc2UsXG4gIHB1bGw6IG51bGwsXG4gIHB1bHNlOiBmYWxzZSxcbiAgcm90YXRpb246IG51bGwsXG4gIHNpemU6IG51bGwsXG4gIHNwaW46IGZhbHNlLFxuICBzcGluUHVsc2U6IGZhbHNlLFxuICBzcGluUmV2ZXJzZTogZmFsc2UsXG4gIGJlYXQ6IGZhbHNlLFxuICBmYWRlOiBmYWxzZSxcbiAgYmVhdEZhZGU6IGZhbHNlLFxuICBib3VuY2U6IGZhbHNlLFxuICBzaGFrZTogZmFsc2UsXG4gIHN5bWJvbDogZmFsc2UsXG4gIHRpdGxlOiAnJyxcbiAgdGl0bGVJZDogbnVsbCxcbiAgdHJhbnNmb3JtOiBudWxsLFxuICBzd2FwT3BhY2l0eTogZmFsc2Vcbn07XG52YXIgY29udmVydEN1cnJ5ID0gY29udmVydC5iaW5kKG51bGwsIFJlYWN0LmNyZWF0ZUVsZW1lbnQpO1xuXG5leHBvcnQgeyBGb250QXdlc29tZUljb24gfTtcbiIsIi8qIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICdMaWNlbnNlJyk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gJ0FTIElTJyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IGh0bWwgfSBmcm9tICdsaXQnO1xuZXhwb3J0IGRlZmF1bHQgaHRtbCBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0cHhcIiBoZWlnaHQ9XCIyNHB4XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIGZpbGw9XCIjMDAwMDAwXCI+XG4gICAgPCEtLSBOT1RFKGNkYXRhKTogVGhpcyBTVkcgZmlsdGVyIGlzIGEgc3RvcC1nYXAgdW50aWwgd2UgY2FuIGltcGxlbWVudFxuICAgICAgICAgc3VwcG9ydCBmb3IgZHluYW1pYyByZS1jb2xvcmluZyBvZiBVSSBjb21wb25lbnRzIC0tPlxuICAgIDxkZWZzPlxuICAgICAgPGZpbHRlciBpZD1cImRyb3Atc2hhZG93XCIgeD1cIi0xMDAlXCIgeT1cIi0xMDAlXCIgd2lkdGg9XCIzMDAlXCIgaGVpZ2h0PVwiMzAwJVwiPlxuICAgICAgICA8ZmVHYXVzc2lhbkJsdXIgaW49XCJTb3VyY2VBbHBoYVwiIHN0ZERldmlhdGlvbj1cIjFcIi8+XG4gICAgICAgIDxmZU9mZnNldCBkeD1cIjBcIiBkeT1cIjBcIiByZXN1bHQ9XCJvZmZzZXRibHVyXCIvPlxuICAgICAgICA8ZmVGbG9vZCBmbG9vZC1jb2xvcj1cIiMwMDAwMDBcIi8+XG4gICAgICAgIDxmZUNvbXBvc2l0ZSBpbjI9XCJvZmZzZXRibHVyXCIgb3BlcmF0b3I9XCJpblwiLz5cbiAgICAgICAgPGZlTWVyZ2U+XG4gICAgICAgICAgPGZlTWVyZ2VOb2RlLz5cbiAgICAgICAgICA8ZmVNZXJnZU5vZGUgaW49XCJTb3VyY2VHcmFwaGljXCIvPlxuICAgICAgICA8L2ZlTWVyZ2U+XG4gICAgICA8L2ZpbHRlcj5cbiAgICA8L2RlZnM+XG4gICAgPHBhdGggZmlsdGVyPVwidXJsKCNkcm9wLXNoYWRvdylcIiBkPVwiTTE5IDYuNDFMMTcuNTkgNSAxMiAxMC41OSA2LjQxIDUgNSA2LjQxIDEwLjU5IDEyIDUgMTcuNTkgNi40MSAxOSAxMiAxMy40MSAxNy41OSAxOSAxOSAxNy41OSAxMy40MSAxMnpcIi8+XG4gICAgPHBhdGggZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiLz5cbjwvc3ZnPmA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbG9zZS1tYXRlcmlhbC1zdmcuanMubWFwIiwiLyogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgJ0xpY2Vuc2UnKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAnQVMgSVMnIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgaHRtbCB9IGZyb20gJ2xpdCc7XG5leHBvcnQgZGVmYXVsdCBodG1sIGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiIHdpZHRoPVwiMjVcIiBoZWlnaHQ9XCIzNlwiPlxuICAgIDxkZWZzPlxuICAgICAgICA8cGF0aCBpZD1cIkFcIiBkPVwiTS4wMDEuMjMyaDI0Ljk5N1YzNkguMDAxelwiIC8+XG4gICAgPC9kZWZzPlxuICAgIDxnIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgtMTEgLTQpXCIgZmlsbD1cIm5vbmVcIiBmaWxsLXJ1bGU9XCJldmVub2RkXCI+XG4gICAgICAgIDxwYXRoIGZpbGwtb3BhY2l0eT1cIjBcIiBmaWxsPVwiI2ZmZlwiIGQ9XCJNMCAwaDQ0djQ0SDB6XCIgLz5cbiAgICAgICAgPGcgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDExIDMpXCI+XG4gICAgICAgICAgICA8cGF0aCBkPVwiTTguNzMzIDExLjE2NWMuMDQtMS4xMDguNzY2LTIuMDI3IDEuNzQzLTIuMzA3YTIuNTQgMi41NCAwIDAgMSAuNjI4LS4wODljLjE2IDAgLjMxNC4wMTcuNDYzLjA0NCAxLjA4OC4yIDEuOSAxLjA5MiAxLjkgMi4xNnY4Ljg4aDEuMjZjMi45NDMtMS4zOSA1LTQuNDUgNS04LjAyNWE5LjAxIDkuMDEgMCAwIDAtMS45LTUuNTZsLS40My0uNWMtLjc2NS0uODM4LTEuNjgzLTEuNTIyLTIuNzEyLTItMS4wNTctLjQ5LTIuMjI2LS43Ny0zLjQ2LS43N3MtMi40LjI3OC0zLjQ2Ljc3Yy0xLjAzLjQ3OC0xLjk0NyAxLjE2Mi0yLjcxIDJsLS40My41YTkuMDEgOS4wMSAwIDAgMC0xLjkgNS41NiA5LjA0IDkuMDQgMCAwIDAgLjA5NCAxLjMwNWMuMDMuMjEuMDg4LjQxLjEzLjYxN2wuMTM2LjYyNGMuMDgzLjI4Ni4xOTYuNTYuMzA1LjgzMmwuMTI0LjMzM2E4Ljc4IDguNzggMCAwIDAgLjUwOS45NTNsLjA2NS4xMjJhOC42OSA4LjY5IDAgMCAwIDMuNTIxIDMuMTkxbDEuMTEuNTM3di05LjE3OHpcIiBmaWxsLW9wYWNpdHk9XCIuNVwiIGZpbGw9XCIjZTRlNGU0XCIgLz5cbiAgICAgICAgICAgIDxwYXRoIGQ9XCJNMjIuOTQgMjYuMjE4bC0yLjc2IDcuNzRjLS4xNzIuNDg1LS42NzYuOC0xLjI1My44SDEyLjI0Yy0xLjYwNiAwLTMuMDkyLS42OC0zLjk4LTEuODItMS41OTItMi4wNDgtMy42NDctMy44MjItNi4xMS01LjI3LS4wOTUtLjA1NS0uMTUtLjEzNy0uMTUyLS4yMy0uMDA0LS4xLjA0Ni0uMTk2LjE5My0uMjk3LjU2LS4zOTMgMS4yMzQtLjYgMS45MjYtLjZhMy40MyAzLjQzIDAgMCAxIC42OTEuMDY5bDQuOTIyLjk5NFYxMC45NzJjMC0uNjYzLjYxNS0xLjIwMyAxLjM3LTEuMjAzczEuMzczLjU0IDEuMzczIDEuMjAzdjkuODgyaDIuOTUzYy4yNzMgMCAuNTMzLjA3My43NTcuMjFsNi4yNTcgMy44NzRjLjAyNy4wMTcuMDQ1LjA0Mi4wNy4wNi40MS4yOTYuNTg2Ljc3LjQyNiAxLjIyTTQuMSAxNi42MTRjLS4wMjQtLjA0LS4wNDItLjA4My0uMDY1LS4xMjJhOC42OSA4LjY5IDAgMCAxLS41MDktLjk1M2MtLjA0OC0uMTA3LS4wOC0uMjIzLS4xMjQtLjMzM2wtLjMwNS0uODMyYy0uMDU4LS4yMDItLjA5LS40MTYtLjEzNi0uNjI0bC0uMTMtLjYxN2E5LjAzIDkuMDMgMCAwIDEtLjA5NC0xLjMwNWMwLTIuMTA3LjcxNC00LjA0IDEuOS01LjU2bC40My0uNWMuNzY0LS44NCAxLjY4Mi0xLjUyMyAyLjcxLTIgMS4wNTgtLjQ5IDIuMjI2LS43NyAzLjQ2LS43N3MyLjQwMi4yOCAzLjQ2Ljc3YzEuMDMuNDc3IDEuOTQ3IDEuMTYgMi43MTIgMmwuNDI4LjVhOSA5IDAgMCAxIDEuOTAxIDUuNTU5YzAgMy41NzctMi4wNTYgNi42MzYtNSA4LjAyNmgtMS4yNnYtOC44ODJjMC0xLjA2Ny0uODIyLTEuOTYtMS45LTIuMTYtLjE1LS4wMjgtLjMwNC0uMDQ0LS40NjMtLjA0NC0uMjIgMC0uNDI3LjAzNy0uNjI4LjA5LS45NzcuMjgtMS43MDMgMS4xOTgtMS43NDMgMi4zMDZ2OS4xNzhsLTEuMTEtLjUzN0M2LjE4IDE5LjA5OCA0Ljk2IDE4IDQuMSAxNi42MTRNMjIuOTcgMjQuMDlsLTYuMjU2LTMuODc0Yy0uMTAyLS4wNjMtLjIxOC0uMDk4LS4zMy0uMTQ0IDIuNjgzLTEuOCA0LjM1NC00Ljg1NSA0LjM1NC04LjI0MyAwLS40ODYtLjAzNy0uOTY0LS4xMDQtMS40M2E5Ljk3IDkuOTcgMCAwIDAtMS41Ny00LjEyOGwtLjI5NS0uNDA4LS4wNjYtLjA5MmExMC4wNSAxMC4wNSAwIDAgMC0uOTQ5LTEuMDc4Yy0uMzQyLS4zMzQtLjcwOC0uNjQzLTEuMDk0LS45MjItMS4xNTUtLjgzNC0yLjQ5Mi0xLjQxMi0zLjk0LTEuNjVsLS43MzItLjA4OC0uNzQ4LS4wM2E5LjI5IDkuMjkgMCAwIDAtMS40ODIuMTE5Yy0xLjQ0Ny4yMzgtMi43ODYuODE2LTMuOTQgMS42NWE5LjMzIDkuMzMgMCAwIDAtLjgxMy42ODYgOS41OSA5LjU5IDAgMCAwLS44NDUuODc3bC0uMzg1LjQzNy0uMzYuNS0uMjg4LjQ2OC0uNDE4Ljc3OC0uMDQuMDljLS41OTMgMS4yOC0uOTMgMi43MS0uOTMgNC4yMjIgMCAzLjgzMiAyLjE4MiA3LjM0MiA1LjU2IDguOTM4bDEuNDM3LjY4djQuOTQ2TDUgMjUuNjRhNC40NCA0LjQ0IDAgMCAwLS44ODgtLjA4NmMtLjAxNyAwLS4wMzQuMDAzLS4wNS4wMDMtLjI1Mi4wMDQtLjUwMy4wMzMtLjc1LjA4YTUuMDggNS4wOCAwIDAgMC0uMjM3LjA1NmMtLjE5My4wNDYtLjM4Mi4xMDctLjU2OC4xOC0uMDc1LjAzLS4xNS4wNTctLjIyNS4xLS4yNS4xMTQtLjQ5NC4yNDQtLjcyMy40MDVhMS4zMSAxLjMxIDAgMCAwLS41NjYgMS4xMjIgMS4yOCAxLjI4IDAgMCAwIC42NDUgMS4wNTFDNCAyOS45MjUgNS45NiAzMS42MTQgNy40NzMgMzMuNTYzYTUuMDYgNS4wNiAwIDAgMCAuNDM0LjQ5MWMxLjA4NiAxLjA4MiAyLjY1NiAxLjcxMyA0LjMyNiAxLjcxNWg2LjY5N2MuNzQ4LS4wMDEgMS40My0uMzMzIDEuODU4LS44NzIuMTQyLS4xOC4yNTYtLjM4LjMzNi0uNjAybDIuNzU3LTcuNzRjLjA5NC0uMjYuMTMtLjUzLjExMi0uNzk0cy0uMDg4LS41Mi0uMjAzLS43NmEyLjE5IDIuMTkgMCAwIDAtLjgyMS0uOTFcIiBmaWxsLW9wYWNpdHk9XCIuNlwiIGZpbGw9XCIjMDAwXCIgLz5cbiAgICAgICAgICAgIDxwYXRoIGQ9XCJNMjIuNDQ0IDI0Ljk0bC02LjI1Ny0zLjg3NGExLjQ1IDEuNDUgMCAwIDAtLjc1Ny0uMjExaC0yLjk1M3YtOS44OGMwLS42NjMtLjYxNi0xLjIwMy0xLjM3My0xLjIwM3MtMS4zNy41NC0xLjM3IDEuMjAzdjE2LjY0M2wtNC45MjItLjk5NGEzLjQ0IDMuNDQgMCAwIDAtLjY5Mi0uMDY5IDMuMzUgMy4zNSAwIDAgMC0xLjkyNS41OThjLS4xNDcuMTAyLS4xOTguMTk4LS4xOTQuMjk4LjAwNC4wOTQuMDU4LjE3Ni4xNTMuMjMgMi40NjIgMS40NDggNC41MTcgMy4yMiA2LjExIDUuMjcuODg3IDEuMTQgMi4zNzMgMS44MiAzLjk4IDEuODJoNi42ODZjLjU3NyAwIDEuMDgtLjMyNiAxLjI1My0uOGwyLjc2LTcuNzRjLjE2LS40NDgtLjAxNy0uOTIzLS40MjYtMS4yMi0uMDI1LS4wMi0uMDQzLS4wNDMtLjA3LS4wNnpcIiBmaWxsPVwiI2ZmZlwiIC8+XG4gICAgICAgICAgICA8ZyB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMCAuNzY5KVwiPlxuICAgICAgICAgICAgICAgIDxtYXNrIGlkPVwiQlwiIGZpbGw9XCIjZmZmXCI+XG4gICAgICAgICAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj1cIiNBXCIgLz5cbiAgICAgICAgICAgICAgICA8L21hc2s+XG4gICAgICAgICAgICAgICAgPHBhdGggZD1cIk0yMy45OTMgMjQuOTkyYTEuOTYgMS45NiAwIDAgMS0uMTExLjc5NGwtMi43NTggNy43NGMtLjA4LjIyLS4xOTQuNDIzLS4zMzYuNjAyLS40MjcuNTQtMS4xMS44Ny0xLjg1Ny44NzJoLTYuNjk4Yy0xLjY3LS4wMDItMy4yNC0uNjMzLTQuMzI2LTEuNzE1LS4xNTQtLjE1NC0uMy0uMzE4LS40MzQtLjQ5QzUuOTYgMzAuODQ2IDQgMjkuMTU3IDEuNjQ2IDI3Ljc3M2MtLjM4NS0uMjI1LS42MjYtLjYxOC0uNjQ1LTEuMDVhMS4zMSAxLjMxIDAgMCAxIC41NjYtMS4xMjIgNC41NiA0LjU2IDAgMCAxIC43MjMtLjQwNWwuMjI1LS4xYTQuMyA0LjMgMCAwIDEgLjU2OC0uMThsLjIzNy0uMDU2Yy4yNDgtLjA0Ni41LS4wNzUuNzUtLjA4LjAxOCAwIC4wMzQtLjAwMy4wNS0uMDAzLjMwMy0uMDAxLjU5Ny4wMjcuODkuMDg2bDMuNzIyLjc1MlYyMC42OGwtMS40MzYtLjY4Yy0zLjM3Ny0xLjU5Ni01LjU2LTUuMTA2LTUuNTYtOC45MzggMC0xLjUxLjMzNi0yLjk0LjkzLTQuMjIyLjAxNS0uMDMuMDI1LS4wNi4wNC0uMDkuMTI3LS4yNjcuMjY4LS41MjUuNDE4LS43NzguMDkzLS4xNi4xODYtLjMxNi4yODgtLjQ2OC4wNjMtLjA5NS4xMzMtLjE4Ni4yLS4yNzdMMy43NzMgNWMuMTE4LS4xNTUuMjYtLjI5LjM4NS0uNDM3LjI2Ni0uMy41NDQtLjYwNC44NDUtLjg3N2E5LjMzIDkuMzMgMCAwIDEgLjgxMy0uNjg2QzYuOTcgMi4xNjcgOC4zMSAxLjU5IDkuNzU3IDEuMzVhOS4yNyA5LjI3IDAgMCAxIDEuNDgxLS4xMTkgOC44MiA4LjgyIDAgMCAxIC43NDguMDMxYy4yNDcuMDIuNDkuMDUuNzMzLjA4OCAxLjQ0OC4yMzggMi43ODYuODE2IDMuOTQgMS42NS4zODcuMjguNzUyLjU4OCAxLjA5NC45MjJhOS45NCA5Ljk0IDAgMCAxIC45NDkgMS4wNzhsLjA2Ni4wOTJjLjEwMi4xMzMuMjAzLjI2OC4yOTUuNDA4YTkuOTcgOS45NyAwIDAgMSAxLjU3MSA0LjEyOGMuMDY2LjQ2Ny4xMDMuOTQ1LjEwMyAxLjQzIDAgMy4zODgtMS42NyA2LjQ1My00LjM1MyA4LjI0My4xMS4wNDYuMjI3LjA4LjMzLjE0NGw2LjI1NiAzLjg3NGMuMzcuMjMuNjQ1LjU1LjgyLjkuMTE1LjI0LjE4NS40OTguMjAzLjc2bS42OTctMS4xOTVjLS4yNjUtLjU1LS42NzctMS4wMDctMS4xOTQtMS4zMjZsLTUuMzIzLTMuMjk3YzIuMjU1LTIuMDM3IDMuNTY0LTQuOTcgMy41NjQtOC4xMTQgMC0yLjE5LS42MzctNC4zMDQtMS44NC02LjExNC0uMTI2LS4xODgtLjI2LS4zNy0uNC0uNTUyLS42NDUtLjg0OC0xLjQwMi0xLjYtMi4yNTItMi4yMDRDMTUuNDcyLjkxIDEzLjM5My4yMzIgMTEuMjM4LjIzMkExMC4yMSAxMC4yMSAwIDAgMCA1LjIzIDIuMTljLS44NDguNjE0LTEuNjA2IDEuMzU2LTIuMjUzIDIuMjA1LS4xMzYuMTgtLjI3Mi4zNjMtLjM5OC41NUMxLjM3NCA2Ljc1Ni43MzcgOC44Ny43MzcgMTEuMDZjMCA0LjIxOCAyLjQwNyA4LjA4IDYuMTMzIDkuODQybC44NjMuNDF2My4wOTJsLTIuNTI1LS41MWMtLjM1Ni0uMDctLjcxNy0uMTA2LTEuMDc2LS4xMDZhNS40NSA1LjQ1IDAgMCAwLTMuMTQuOTk2Yy0uNjUzLjQ2LTEuMDIyIDEuMjAyLS45OSAxLjk4M2EyLjI4IDIuMjggMCAwIDAgMS4xMzggMS44NzJjMi4yNCAxLjMxOCA0LjEwNiAyLjkyMyA1LjU0MyA0Ljc3MiAxLjI2IDEuNjIgMy4zMzMgMi41OSA1LjU1IDIuNTkyaDYuNjk4YzEuNDItLjAwMSAyLjY4LS44NiAzLjEzNC0yLjEzOGwyLjc2LTcuNzRjLjI3Mi0uNzU3LjIyNC0xLjU4NC0uMTM0LTIuMzI1XCIgZmlsbC1vcGFjaXR5PVwiLjA1XCIgZmlsbD1cIiMwMDBcIiBtYXNrPVwidXJsKCNCKVwiIC8+XG4gICAgICAgICAgICA8L2c+XG4gICAgICAgIDwvZz5cbiAgICA8L2c+XG48L3N2Zz5gO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udHJvbHMtc3ZnLmpzLm1hcCIsIi8qIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICdMaWNlbnNlJyk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gJ0FTIElTJyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IGh0bWwgfSBmcm9tICdsaXQnO1xuZXhwb3J0IGRlZmF1bHQgaHRtbCBgXG48c3ZnIHZlcnNpb249XCIxLjFcIiBpZD1cInZpZXdfeDVGX2luX3g1Rl9BUl94NUZfaWNvblwiXG5cdCB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIgeD1cIjBweFwiIHk9XCIwcHhcIiB3aWR0aD1cIjI0cHhcIiBoZWlnaHQ9XCIyNHB4XCJcblx0IHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBlbmFibGUtYmFja2dyb3VuZD1cIm5ldyAwIDAgMjQgMjRcIiB4bWw6c3BhY2U9XCJwcmVzZXJ2ZVwiPlxuPHJlY3QgaWQ9XCJCb3VuZGluZ19Cb3hcIiB4PVwiMFwiIHk9XCIwXCIgZmlsbD1cIm5vbmVcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIi8+XG48ZyBpZD1cIkFydF9sYXllclwiPlxuXHQ8cGF0aCBkPVwiTTMsNGMwLTAuNTUsMC40NS0xLDEtMWgyVjFINEMyLjM1LDEsMSwyLjM1LDEsNHYyaDJWNHpcIi8+XG5cdDxwYXRoIGQ9XCJNMjAsM2MwLjU1LDAsMSwwLjQ1LDEsMXYyaDJWNGMwLTEuNjUtMS4zNS0zLTMtM2gtMnYySDIwelwiLz5cblx0PHBhdGggZD1cIk00LDIxYy0wLjU1LDAtMS0wLjQ1LTEtMXYtMkgxdjJjMCwxLjY1LDEuMzUsMywzLDNoMnYtMkg0elwiLz5cblx0PHBhdGggZD1cIk0yMCwyMWMwLjU1LDAsMS0wLjQ1LDEtMXYtMmgydjJjMCwxLjY1LTEuMzUsMy0zLDNoLTJ2LTJIMjB6XCIvPlxuXHQ8Zz5cblx0XHQ8cGF0aCBkPVwiTTE4LjI1LDcuNmwtNS41LTMuMThjLTAuNDYtMC4yNy0xLjA0LTAuMjctMS41LDBMNS43NSw3LjZDNS4yOSw3Ljg3LDUsOC4zNiw1LDguOXY2LjM1YzAsMC41NCwwLjI5LDEuMDMsMC43NSwxLjNcblx0XHRcdGw1LjUsMy4xOGMwLjQ2LDAuMjcsMS4wNCwwLjI3LDEuNSwwbDUuNS0zLjE4YzAuNDYtMC4yNywwLjc1LTAuNzYsMC43NS0xLjNWOC45QzE5LDguMzYsMTguNzEsNy44NywxOC4yNSw3LjZ6IE03LDE0Ljk2di00LjYyXG5cdFx0XHRsNCwyLjMydjQuNjFMNywxNC45NnogTTEyLDEwLjkzTDgsOC42MWw0LTIuMzFsNCwyLjMxTDEyLDEwLjkzeiBNMTMsMTcuMjd2LTQuNjFsNC0yLjMydjQuNjJMMTMsMTcuMjd6XCIvPlxuXHQ8L2c+XG48L2c+XG48L3N2Zz5gO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmlldy1pbi1hci1tYXRlcmlhbC1zdmcuanMubWFwIiwiLyogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgJ0xpY2Vuc2UnKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAnQVMgSVMnIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLy8gTk9URShjZGF0YSk6IFRoZSBIQVNfV0VCWFJfKiBjb25zdGFudHMgY2FuIGJlIGVuYWJsZWQgaW4gQ2hyb21lIGJ5IHR1cm5pbmcgb25cbi8vIHRoZSBhcHByb3ByaWF0ZSBmbGFncy4gSG93ZXZlciwganVzdCBiZWNhdXNlIHdlIGhhdmUgdGhlIEFQSSBkb2VzIG5vdFxuLy8gZ3VhcmFudGVlIHRoYXQgQVIgd2lsbCB3b3JrLlxuZXhwb3J0IGNvbnN0IEhBU19XRUJYUl9ERVZJQ0VfQVBJID0gbmF2aWdhdG9yLnhyICE9IG51bGwgJiZcbiAgICBzZWxmLlhSU2Vzc2lvbiAhPSBudWxsICYmIG5hdmlnYXRvci54ci5pc1Nlc3Npb25TdXBwb3J0ZWQgIT0gbnVsbDtcbmV4cG9ydCBjb25zdCBIQVNfV0VCWFJfSElUX1RFU1RfQVBJID0gSEFTX1dFQlhSX0RFVklDRV9BUEkgJiZcbiAgICBzZWxmLlhSU2Vzc2lvbi5wcm90b3R5cGUucmVxdWVzdEhpdFRlc3RTb3VyY2UgIT0gbnVsbDtcbmV4cG9ydCBjb25zdCBIQVNfUkVTSVpFX09CU0VSVkVSID0gc2VsZi5SZXNpemVPYnNlcnZlciAhPSBudWxsO1xuZXhwb3J0IGNvbnN0IEhBU19JTlRFUlNFQ1RJT05fT0JTRVJWRVIgPSBzZWxmLkludGVyc2VjdGlvbk9ic2VydmVyICE9IG51bGw7XG5leHBvcnQgY29uc3QgSVNfV0VCWFJfQVJfQ0FORElEQVRFID0gSEFTX1dFQlhSX0hJVF9URVNUX0FQSTtcbmV4cG9ydCBjb25zdCBJU19NT0JJTEUgPSAoKCkgPT4ge1xuICAgIGNvbnN0IHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQgfHwgbmF2aWdhdG9yLnZlbmRvciB8fCBzZWxmLm9wZXJhO1xuICAgIGxldCBjaGVjayA9IGZhbHNlO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIGlmICgvKGFuZHJvaWR8YmJcXGQrfG1lZWdvKS4rbW9iaWxlfGF2YW50Z298YmFkYVxcL3xibGFja2JlcnJ5fGJsYXplcnxjb21wYWx8ZWxhaW5lfGZlbm5lY3xoaXB0b3B8aWVtb2JpbGV8aXAoaG9uZXxvZCl8aXJpc3xraW5kbGV8bGdlIHxtYWVtb3xtaWRwfG1tcHxtb2JpbGUuK2ZpcmVmb3h8bmV0ZnJvbnR8b3BlcmEgbShvYnxpbilpfHBhbG0oIG9zKT98cGhvbmV8cChpeGl8cmUpXFwvfHBsdWNrZXJ8cG9ja2V0fHBzcHxzZXJpZXMoNHw2KTB8c3ltYmlhbnx0cmVvfHVwXFwuKGJyb3dzZXJ8bGluayl8dm9kYWZvbmV8d2FwfHdpbmRvd3MgY2V8eGRhfHhpaW5vL2lcbiAgICAgICAgLnRlc3QodXNlckFnZW50KSB8fFxuICAgICAgICAvMTIwN3w2MzEwfDY1OTB8M2dzb3w0dGhwfDUwWzEtNl1pfDc3MHN8ODAyc3xhIHdhfGFiYWN8YWMoZXJ8b298c1xcLSl8YWkoa298cm4pfGFsKGF2fGNhfGNvKXxhbW9pfGFuKGV4fG55fHl3KXxhcHR1fGFyKGNofGdvKXxhcyh0ZXx1cyl8YXR0d3xhdShkaXxcXC1tfHIgfHMgKXxhdmFufGJlKGNrfGxsfG5xKXxiaShsYnxyZCl8YmwoYWN8YXopfGJyKGV8dil3fGJ1bWJ8YndcXC0obnx1KXxjNTVcXC98Y2FwaXxjY3dhfGNkbVxcLXxjZWxsfGNodG18Y2xkY3xjbWRcXC18Y28obXB8bmQpfGNyYXd8ZGEoaXR8bGx8bmcpfGRidGV8ZGNcXC1zfGRldml8ZGljYXxkbW9ifGRvKGN8cClvfGRzKDEyfFxcLWQpfGVsKDQ5fGFpKXxlbShsMnx1bCl8ZXIoaWN8azApfGVzbDh8ZXooWzQtN10wfG9zfHdhfHplKXxmZXRjfGZseShcXC18Xyl8ZzEgdXxnNTYwfGdlbmV8Z2ZcXC01fGdcXC1tb3xnbyhcXC53fG9kKXxncihhZHx1bil8aGFpZXxoY2l0fGhkXFwtKG18cHx0KXxoZWlcXC18aGkocHR8dGEpfGhwKCBpfGlwKXxoc1xcLWN8aHQoYyhcXC18IHxffGF8Z3xwfHN8dCl8dHApfGh1KGF3fHRjKXxpXFwtKDIwfGdvfG1hKXxpMjMwfGlhYyggfFxcLXxcXC8pfGlicm98aWRlYXxpZzAxfGlrb218aW0xa3xpbm5vfGlwYXF8aXJpc3xqYSh0fHYpYXxqYnJvfGplbXV8amlnc3xrZGRpfGtlaml8a2d0KCB8XFwvKXxrbG9ufGtwdCB8a3djXFwtfGt5byhjfGspfGxlKG5vfHhpKXxsZyggZ3xcXC8oa3xsfHUpfDUwfDU0fFxcLVthLXddKXxsaWJ3fGx5bnh8bTFcXC13fG0zZ2F8bTUwXFwvfG1hKHRlfHVpfHhvKXxtYygwMXwyMXxjYSl8bVxcLWNyfG1lKHJjfHJpKXxtaShvOHxvYXx0cyl8bW1lZnxtbygwMXwwMnxiaXxkZXxkb3x0KFxcLXwgfG98dil8enopfG10KDUwfHAxfHYgKXxtd2JwfG15d2F8bjEwWzAtMl18bjIwWzItM118bjMwKDB8Mil8bjUwKDB8Mnw1KXxuNygwKDB8MSl8MTApfG5lKChjfG0pXFwtfG9ufHRmfHdmfHdnfHd0KXxub2soNnxpKXxuenBofG8yaW18b3AodGl8d3YpfG9yYW58b3dnMXxwODAwfHBhbihhfGR8dCl8cGR4Z3xwZygxM3xcXC0oWzEtOF18YykpfHBoaWx8cGlyZXxwbChheXx1Yyl8cG5cXC0yfHBvKGNrfHJ0fHNlKXxwcm94fHBzaW98cHRcXC1nfHFhXFwtYXxxYygwN3wxMnwyMXwzMnw2MHxcXC1bMi03XXxpXFwtKXxxdGVrfHIzODB8cjYwMHxyYWtzfHJpbTl8cm8odmV8em8pfHM1NVxcL3xzYShnZXxtYXxtbXxtc3xueXx2YSl8c2MoMDF8aFxcLXxvb3xwXFwtKXxzZGtcXC98c2UoYyhcXC18MHwxKXw0N3xtY3xuZHxyaSl8c2doXFwtfHNoYXJ8c2llKFxcLXxtKXxza1xcLTB8c2woNDV8aWQpfHNtKGFsfGFyfGIzfGl0fHQ1KXxzbyhmdHxueSl8c3AoMDF8aFxcLXx2XFwtfHYgKXxzeSgwMXxtYil8dDIoMTh8NTApfHQ2KDAwfDEwfDE4KXx0YShndHxsayl8dGNsXFwtfHRkZ1xcLXx0ZWwoaXxtKXx0aW1cXC18dFxcLW1vfHRvKHBsfHNoKXx0cyg3MHxtXFwtfG0zfG01KXx0eFxcLTl8dXAoXFwuYnxnMXxzaSl8dXRzdHx2NDAwfHY3NTB8dmVyaXx2aShyZ3x0ZSl8dmsoNDB8NVswLTNdfFxcLXYpfHZtNDB8dm9kYXx2dWxjfHZ4KDUyfDUzfDYwfDYxfDcwfDgwfDgxfDgzfDg1fDk4KXx3M2MoXFwtfCApfHdlYmN8d2hpdHx3aShnIHxuY3xudyl8d21sYnx3b251fHg3MDB8eWFzXFwtfHlvdXJ8emV0b3x6dGVcXC0vaVxuICAgICAgICAgICAgLnRlc3QodXNlckFnZW50LnN1YnN0cigwLCA0KSkpIHtcbiAgICAgICAgY2hlY2sgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gY2hlY2s7XG59KSgpO1xuZXhwb3J0IGNvbnN0IElTX0NIUk9NRU9TID0gL1xcYkNyT1NcXGIvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5leHBvcnQgY29uc3QgSVNfQU5EUk9JRCA9IC9hbmRyb2lkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbi8vIFByaW9yIHRvIGlPUyAxMywgZGV0ZWN0aW5nIGlPUyBTYWZhcmkgd2FzIHJlbGF0aXZlbHkgc3RyYWlnaHQtZm9yd2FyZC5cbi8vIEFzIG9mIGlPUyAxMywgU2FmYXJpIG9uIGlQYWQgKGluIGl0cyBkZWZhdWx0IGNvbmZpZ3VyYXRpb24pIHJlcG9ydHMgdGhlIHNhbWVcbi8vIHVzZXItYWdlbnQgc3RyaW5nIGFzIFNhZmFyaSBvbiBkZXNrdG9wIE1hY09TLiBTdHJpY3RseSBzcGVha2luZywgd2Ugb25seSBjYXJlXG4vLyBhYm91dCBpT1MgZm9yIHRoZSBwdXJwb3NlcyBpZiBzZWxlY3RpbmcgZm9yIGNhc2VzIHdoZXJlIFF1aWNrIExvb2sgaXMga25vd25cbi8vIHRvIGJlIHN1cHBvcnRlZC4gSG93ZXZlciwgZm9yIEFQSSBjb3JyZWN0bmVzcyBwdXJwb3Nlcywgd2UgbXVzdCByZWx5IG9uXG4vLyBrbm93biwgZGV0ZWN0YWJsZSBzaWduYWxzIHRvIGRpc3Rpbmd1aXNoIGlPUyBTYWZhcmkgZnJvbSBNYWNPUyBTYWZhcmkuIEF0IHRoZVxuLy8gdGltZSBvZiB0aGlzIHdyaXRpbmcsIHRoZXJlIGFyZSBubyBub24taU9TL2lQYWRPUyBBcHBsZSBkZXZpY2VzIHdpdGhcbi8vIG11bHRpLXRvdWNoIGRpc3BsYXlzLlxuLy8gQHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81Nzc2NTk1OC9ob3ctdG8tZGV0ZWN0LWlwYWQtYW5kLWlwYWQtb3MtdmVyc2lvbi1pbi1pb3MtMTMtYW5kLXVwXG4vLyBAc2VlIGh0dHBzOi8vZm9ydW1zLmRldmVsb3Blci5hcHBsZS5jb20vdGhyZWFkLzExOTE4NlxuLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL21vZGVsLXZpZXdlci9pc3N1ZXMvNzU4XG5leHBvcnQgY29uc3QgSVNfSU9TID0gKC9pUGFkfGlQaG9uZXxpUG9kLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICFzZWxmLk1TU3RyZWFtKSB8fFxuICAgIChuYXZpZ2F0b3IucGxhdGZvcm0gPT09ICdNYWNJbnRlbCcgJiYgbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMSk7XG4vLyBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vbXVsdGlkZXZpY2UvdXNlci1hZ2VudFxuZXhwb3J0IGNvbnN0IElTX1NBRkFSSSA9IC9TYWZhcmlcXC8vLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5leHBvcnQgY29uc3QgSVNfRklSRUZPWCA9IC9maXJlZm94L2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbmV4cG9ydCBjb25zdCBJU19PQ1VMVVMgPSAvT2N1bHVzQnJvd3Nlci8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbmV4cG9ydCBjb25zdCBJU19JT1NfQ0hST01FID0gSVNfSU9TICYmIC9DcmlPU1xcLy8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbmV4cG9ydCBjb25zdCBJU19JT1NfU0FGQVJJID0gSVNfSU9TICYmIElTX1NBRkFSSTtcbmV4cG9ydCBjb25zdCBJU19TQ0VORVZJRVdFUl9DQU5ESURBVEUgPSBJU19BTkRST0lEICYmICFJU19GSVJFRk9YICYmICFJU19PQ1VMVVM7XG5leHBvcnQgY29uc3QgSVNfV0tXRUJWSUVXID0gQm9vbGVhbih3aW5kb3cud2Via2l0ICYmIHdpbmRvdy53ZWJraXQubWVzc2FnZUhhbmRsZXJzKTtcbi8vIElmIHJ1bm5pbmcgaW4gaU9TIFNhZmFyaSBwcm9wZXIsIGFuZCBub3Qgd2l0aGluIGEgV0tXZWJWaWV3IGNvbXBvbmVudCBpbnN0YW5jZSwgY2hlY2sgZm9yIEFSUUwgZmVhdHVyZSBzdXBwb3J0LlxuLy8gT3RoZXJ3aXNlLCBpZiBydW5uaW5nIGluIGEgV0tXZWJWaWV3IGluc3RhbmNlLCBjaGVjayBmb3Iga25vd24gQVJRTCBjb21wYXRpYmxlIGlPUyBicm93c2VycywgaW5jbHVkaW5nOlxuLy8gQ2hyb21lIChDcmlPUyksIEVkZ2UgKEVkZ2lPUyksIEZpcmVmb3ggKEZ4aU9TKSwgR29vZ2xlIEFwcCAoR1NBKSwgRHVja0R1Y2tHbyAoRHVja0R1Y2tHbykuXG4vLyBBbGwgb3RoZXIgaU9TIGJyb3dzZXJzIC8gYXBwcyB3aWxsIGZhaWwgYnkgZGVmYXVsdC5cbmV4cG9ydCBjb25zdCBJU19BUl9RVUlDS0xPT0tfQ0FORElEQVRFID0gKCgpID0+IHtcbiAgICBpZiAoSVNfSU9TKSB7XG4gICAgICAgIGlmICghSVNfV0tXRUJWSUVXKSB7XG4gICAgICAgICAgICBjb25zdCB0ZW1wQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4odGVtcEFuY2hvci5yZWxMaXN0ICYmIHRlbXBBbmNob3IucmVsTGlzdC5zdXBwb3J0cyAmJiB0ZW1wQW5jaG9yLnJlbExpc3Quc3VwcG9ydHMoJ2FyJykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4oL0NyaU9TXFwvfEVkZ2lPU1xcL3xGeGlPU1xcL3xHU0FcXC98RHVja0R1Y2tHb1xcLy8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59KSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCIsIi8qIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICdMaWNlbnNlJyk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gJ0FTIElTJyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IFN0eWxlRXZhbHVhdG9yIH0gZnJvbSAnLi9zdHlsZXMvZXZhbHVhdG9ycyc7XG5pbXBvcnQgeyBwYXJzZUV4cHJlc3Npb25zIH0gZnJvbSAnLi9zdHlsZXMvcGFyc2Vycyc7XG5pbXBvcnQgeyBTdHlsZUVmZmVjdG9yIH0gZnJvbSAnLi9zdHlsZXMvc3R5bGUtZWZmZWN0b3InO1xuLyoqXG4gKiBUaGUgQHN0eWxlIGRlY29yYXRvciBpcyByZXNwb25zaWJsZSBmb3IgY29vcmRpbmF0aW5nIHRoZSBjb252ZXJzaW9uIG9mIGFcbiAqIENTUy1saWtlIHN0cmluZyBwcm9wZXJ0eSB2YWx1ZSBpbnRvIG51bWJlcnMgdGhhdCBjYW4gYmUgYXBwbGllZCB0b1xuICogbG93ZXItbGV2ZWwgY29uc3RydWN0cy4gSXQgYWxzbyBjYW4gb3B0aW9uYWxseSBtYW5hZ2UgdGhlIGxpZmVjeWNsZSBvZiBhXG4gKiBTdHlsZUVmZmVjdG9yIHdoaWNoIGFsbG93cyBhdXRvbWF0aWMgdXBkYXRlcyBmb3Igc3R5bGVzIHRoYXQgdXNlIGVudigpIG9yXG4gKiB2YXIoKSBmdW5jdGlvbnMuXG4gKlxuICogVGhlIGRlY29yYXRvciBpcyBjb25maWd1cmVkIHdpdGggSW50cmluc2ljcyBhbmQgdGhlIHByb3BlcnR5IGtleSBmb3IgYVxuICogbWV0aG9kIHRoYXQgaGFuZGxlcyB1cGRhdGVzLiBUaGUgbmFtZWQgdXBkYXRlIGhhbmRsZXIgaXMgaW52b2tlZCB3aXRoIHRoZVxuICogcmVzdWx0IG9mIHBhcnNpbmcgYW5kIGV2YWx1YXRpbmcgdGhlIHJhdyBwcm9wZXJ0eSBzdHJpbmcgdmFsdWUuIFRoZSBmb3JtYXQgb2ZcbiAqIHRoZSBldmFsdWF0ZWQgcmVzdWx0IGlzIGRlcml2ZWQgZnJvbSB0aGUgYmFzaXMgb2YgdGhlIGNvbmZpZ3VyZWQgSW50cmluc2ljcyxcbiAqIGFuZCBpcyBhbHdheXMgYW4gYXJyYXkgb2YgbnVtYmVycyBvZiBmaXhlZCBsZW5ndGguXG4gKlxuICogTk9URTogVGhpcyBkZWNvcmF0b3IgZGVwZW5kcyBvbiB0aGUgcHJvcGVydHkgdXBkYXRpbmcgbWVjaGFuaXNtIGRlZmluZWQgYnlcbiAqIFVwZGF0aW5nRWxlbWVudCBhcyBleHBvcnRlZCBieSB0aGUgbGl0LWVsZW1lbnQgbW9kdWxlLiBUaGF0IG1lYW5zIGl0ICptdXN0KlxuICogYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBAcHJvcGVydHkgZGVjb3JhdG9yLCBvciBlcXVpdmFsZW50XG4gKiBKYXZhU2NyaXB0LlxuICpcbiAqIFN1cHBvcnRlZCBjb25maWd1cmF0aW9ucyBhcmU6XG4gKlxuICogIC0gYGludHJpbnNpY3NgOiBBbiBJbnRyaW5zaWNzIHN0cnVjdCB0aGF0IGRlc2NyaWJlcyBob3cgdG8gaW50ZXJwcmV0IGFcbiAqIHNlcmlhbGl6ZWQgc3R5bGUgYXR0cmlidXRlLiBGb3IgbW9yZSBkZXRhaWwgb24gaW50cmluc2ljcyBzZWVcbiAqIC4vc3R5bGVzL2V2YWx1YXRvcnMudHNcbiAqICAtIGB1cGRhdGVIYW5kbGVyYDogQSBzdHJpbmcgb3IgU3ltYm9sIHRoYXQgaXMgdGhlIGtleSBvZiBhIG1ldGhvZCB0byBiZVxuICogaW52b2tlZCB3aXRoIHRoZSByZXN1bHQgb2YgcGFyc2luZyBhbmQgZXZhbHVhdGluZyBhIHNlcmlhbGl6ZWQgc3R5bGUgc3RyaW5nLlxuICogIC0gYG9ic2VydmVFZmZlY3RzYDogT3B0aW9uYWwsIGlmIHNldCB0byB0cnVlIHRoZW4gc3R5bGVzIHRoYXQgdXNlIGVudigpIHdpbGxcbiAqIGNhdXNlIHRoZWlyIHVwZGF0ZSBoYW5kbGVycyB0byBiZSBpbnZva2VkIGV2ZXJ5IHRpbWUgdGhlIGNvcnJlc3BvbmRpbmdcbiAqIGVudmlyb25tZW50IHZhcmlhYmxlIGNoYW5nZXMgKGV2ZW4gaWYgdGhlIHN0eWxlIGF0dHJpYnV0ZSBpdHNlbGYgcmVtYWluc1xuICogc3RhdGljKS5cbiAqL1xuZXhwb3J0IGNvbnN0IHN0eWxlID0gKGNvbmZpZykgPT4ge1xuICAgIGNvbnN0IG9ic2VydmVFZmZlY3RzID0gY29uZmlnLm9ic2VydmVFZmZlY3RzIHx8IGZhbHNlO1xuICAgIGNvbnN0IGdldEludHJpbnNpY3MgPSBjb25maWcuaW50cmluc2ljcyBpbnN0YW5jZW9mIEZ1bmN0aW9uID9cbiAgICAgICAgY29uZmlnLmludHJpbnNpY3MgOlxuICAgICAgICAoKCkgPT4gY29uZmlnLmludHJpbnNpY3MpO1xuICAgIHJldHVybiAocHJvdG8sIHByb3BlcnR5TmFtZSkgPT4ge1xuICAgICAgICBjb25zdCBvcmlnaW5hbFVwZGF0ZWQgPSBwcm90by51cGRhdGVkO1xuICAgICAgICBjb25zdCBvcmlnaW5hbENvbm5lY3RlZENhbGxiYWNrID0gcHJvdG8uY29ubmVjdGVkQ2FsbGJhY2s7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsRGlzY29ubmVjdGVkQ2FsbGJhY2sgPSBwcm90by5kaXNjb25uZWN0ZWRDYWxsYmFjaztcbiAgICAgICAgY29uc3QgJHN0eWxlRWZmZWN0b3IgPSBTeW1ib2woYCR7cHJvcGVydHlOYW1lfVN0eWxlRWZmZWN0b3JgKTtcbiAgICAgICAgY29uc3QgJHN0eWxlRXZhbHVhdG9yID0gU3ltYm9sKGAke3Byb3BlcnR5TmFtZX1TdHlsZUV2YWx1YXRvcmApO1xuICAgICAgICBjb25zdCAkdXBkYXRlRXZhbHVhdG9yID0gU3ltYm9sKGAke3Byb3BlcnR5TmFtZX1VcGRhdGVFdmFsdWF0b3JgKTtcbiAgICAgICAgY29uc3QgJGV2YWx1YXRlQW5kU3luYyA9IFN5bWJvbChgJHtwcm9wZXJ0eU5hbWV9RXZhbHVhdGVBbmRTeW5jYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHByb3RvLCB7XG4gICAgICAgICAgICBbJHN0eWxlRWZmZWN0b3JdOiB7IHZhbHVlOiBudWxsLCB3cml0YWJsZTogdHJ1ZSB9LFxuICAgICAgICAgICAgWyRzdHlsZUV2YWx1YXRvcl06IHsgdmFsdWU6IG51bGwsIHdyaXRhYmxlOiB0cnVlIH0sXG4gICAgICAgICAgICBbJHVwZGF0ZUV2YWx1YXRvcl06IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhc3QgPSBwYXJzZUV4cHJlc3Npb25zKHRoaXNbcHJvcGVydHlOYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbJHN0eWxlRXZhbHVhdG9yXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgU3R5bGVFdmFsdWF0b3IoYXN0LCBnZXRJbnRyaW5zaWNzKHRoaXMpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXNbJHN0eWxlRWZmZWN0b3JdID09IG51bGwgJiYgb2JzZXJ2ZUVmZmVjdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbJHN0eWxlRWZmZWN0b3JdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgU3R5bGVFZmZlY3RvcigoKSA9PiB0aGlzWyRldmFsdWF0ZUFuZFN5bmNdKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzWyRzdHlsZUVmZmVjdG9yXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzWyRzdHlsZUVmZmVjdG9yXS5vYnNlcnZlRWZmZWN0c0Zvcihhc3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFskZXZhbHVhdGVBbmRTeW5jXToge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzWyRzdHlsZUV2YWx1YXRvcl0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXNbJHN0eWxlRXZhbHVhdG9yXS5ldmFsdWF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9wdWxsLzMwNzY5XG4gICAgICAgICAgICAgICAgICAgIC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8xODYzXG4gICAgICAgICAgICAgICAgICAgIHRoaXNbY29uZmlnLnVwZGF0ZUhhbmRsZXJdKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZWQ6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKGNoYW5nZWRQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFsd2F5cyBpbnZva2UgdXBkYXRlcyB0byBzdHlsZXMgZmlyc3QuIFRoaXMgZ2l2ZXMgYSBjbGFzcyB0aGF0XG4gICAgICAgICAgICAgICAgICAgIC8vIHVzZXMgdGhpcyBkZWNvcmF0b3IgdGhlIG9wcG9ydHVuaXR5IHRvIG92ZXJyaWRlIHRoZSBlZmZlY3QsIG9yXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlc3BvbmQgdG8gaXQsIGluIGl0cyBvd24gaW1wbGVtZW50YXRpb24gb2YgYHVwZGF0ZWRgLlxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlZFByb3BlcnRpZXMuaGFzKHByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbJHVwZGF0ZUV2YWx1YXRvcl0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbJGV2YWx1YXRlQW5kU3luY10oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFVwZGF0ZWQuY2FsbCh0aGlzLCBjaGFuZ2VkUHJvcGVydGllcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbm5lY3RlZENhbGxiYWNrOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxDb25uZWN0ZWRDYWxsYmFjay5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RVcGRhdGUocHJvcGVydHlOYW1lLCB0aGlzW3Byb3BlcnR5TmFtZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkaXNjb25uZWN0ZWRDYWxsYmFjazoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRGlzY29ubmVjdGVkQ2FsbGJhY2suY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXNbJHN0eWxlRWZmZWN0b3JdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbJHN0eWxlRWZmZWN0b3JdLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbJHN0eWxlRWZmZWN0b3JdID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWNvcmF0b3JzLmpzLm1hcCIsIi8qIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICdMaWNlbnNlJyk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gJ0FTIElTJyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbmltcG9ydCB7IHByb3BlcnR5IH0gZnJvbSAnbGl0L2RlY29yYXRvcnMuanMnO1xuaW1wb3J0IHsgTG9vcE9uY2UsIExvb3BQaW5nUG9uZywgTG9vcFJlcGVhdCB9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7ICRnZXRNb2RlbElzVmlzaWJsZSwgJG5lZWRzUmVuZGVyLCAkb25Nb2RlbExvYWQsICRyZW5kZXJlciwgJHNjZW5lLCAkdGljayB9IGZyb20gJy4uL21vZGVsLXZpZXdlci1iYXNlLmpzJztcbmNvbnN0IE1JTExJU0VDT05EU19QRVJfU0VDT05EID0gMTAwMC4wO1xuY29uc3QgJGNoYW5nZUFuaW1hdGlvbiA9IFN5bWJvbCgnY2hhbmdlQW5pbWF0aW9uJyk7XG5jb25zdCAkcGF1c2VkID0gU3ltYm9sKCdwYXVzZWQnKTtcbmNvbnN0IERFRkFVTFRfUExBWV9PUFRJT05TID0ge1xuICAgIHJlcGV0aXRpb25zOiBJbmZpbml0eSxcbiAgICBwaW5ncG9uZzogZmFsc2Vcbn07XG5leHBvcnQgY29uc3QgQW5pbWF0aW9uTWl4aW4gPSAoTW9kZWxWaWV3ZXJFbGVtZW50KSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNsYXNzIEFuaW1hdGlvbk1vZGVsVmlld2VyRWxlbWVudCBleHRlbmRzIE1vZGVsVmlld2VyRWxlbWVudCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIHN1cGVyKGFyZ3MpO1xuICAgICAgICAgICAgdGhpcy5hdXRvcGxheSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25OYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25Dcm9zc2ZhZGVEdXJhdGlvbiA9IDMwMDtcbiAgICAgICAgICAgIHRoaXNbX2FdID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXNbJHNjZW5lXS5zdWJzY3JpYmVNaXhlckV2ZW50KCdsb29wJywgKGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb3VudCA9IGUuYWN0aW9uLl9sb29wQ291bnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnbG9vcCcsIHsgZGV0YWlsOiB7IGNvdW50IH0gfSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzWyRzY2VuZV0uc3Vic2NyaWJlTWl4ZXJFdmVudCgnZmluaXNoZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpc1skcGF1c2VkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnZmluaXNoZWQnKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhbiBhcnJheVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IGF2YWlsYWJsZUFuaW1hdGlvbnMoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5sb2FkZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1skc2NlbmVdLmFuaW1hdGlvbk5hbWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGdldCBkdXJhdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzWyRzY2VuZV0uZHVyYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHBhdXNlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzWyRwYXVzZWRdO1xuICAgICAgICB9XG4gICAgICAgIGdldCBjdXJyZW50VGltZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzWyRzY2VuZV0uYW5pbWF0aW9uVGltZTtcbiAgICAgICAgfVxuICAgICAgICBzZXQgY3VycmVudFRpbWUodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXNbJHNjZW5lXS5hbmltYXRpb25UaW1lID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzWyRuZWVkc1JlbmRlcl0oKTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgdGltZVNjYWxlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbJHNjZW5lXS5hbmltYXRpb25UaW1lU2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAgc2V0IHRpbWVTY2FsZSh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpc1skc2NlbmVdLmFuaW1hdGlvblRpbWVTY2FsZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHBhdXNlKCkge1xuICAgICAgICAgICAgaWYgKHRoaXNbJHBhdXNlZF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzWyRwYXVzZWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ3BhdXNlJykpO1xuICAgICAgICB9XG4gICAgICAgIHBsYXkob3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXZhaWxhYmxlQW5pbWF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpc1skcGF1c2VkXSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXNbJGNoYW5nZUFuaW1hdGlvbl0ob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgncGxheScpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBbKF9hID0gJHBhdXNlZCwgJG9uTW9kZWxMb2FkKV0oKSB7XG4gICAgICAgICAgICBzdXBlclskb25Nb2RlbExvYWRdKCk7XG4gICAgICAgICAgICB0aGlzWyRwYXVzZWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmFuaW1hdGlvbk5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXNbJGNoYW5nZUFuaW1hdGlvbl0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmF1dG9wbGF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wbGF5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgWyR0aWNrXShfdGltZSwgZGVsdGEpIHtcbiAgICAgICAgICAgIHN1cGVyWyR0aWNrXShfdGltZSwgZGVsdGEpO1xuICAgICAgICAgICAgaWYgKHRoaXNbJHBhdXNlZF0gfHxcbiAgICAgICAgICAgICAgICAoIXRoaXNbJGdldE1vZGVsSXNWaXNpYmxlXSgpICYmICF0aGlzWyRyZW5kZXJlcl0uaXNQcmVzZW50aW5nKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXNbJHNjZW5lXS51cGRhdGVBbmltYXRpb24oZGVsdGEgLyBNSUxMSVNFQ09ORFNfUEVSX1NFQ09ORCk7XG4gICAgICAgICAgICB0aGlzWyRuZWVkc1JlbmRlcl0oKTtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVkKGNoYW5nZWRQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBzdXBlci51cGRhdGVkKGNoYW5nZWRQcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VkUHJvcGVydGllcy5oYXMoJ2F1dG9wbGF5JykgJiYgdGhpcy5hdXRvcGxheSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGxheSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoYW5nZWRQcm9wZXJ0aWVzLmhhcygnYW5pbWF0aW9uTmFtZScpKSB7XG4gICAgICAgICAgICAgICAgdGhpc1skY2hhbmdlQW5pbWF0aW9uXSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFskY2hhbmdlQW5pbWF0aW9uXShvcHRpb25zID0gREVGQVVMVF9QTEFZX09QVElPTlMpIHtcbiAgICAgICAgICAgIHZhciBfYjtcbiAgICAgICAgICAgIGNvbnN0IHJlcGV0aXRpb25zID0gKF9iID0gb3B0aW9ucy5yZXBldGl0aW9ucykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogSW5maW5pdHk7XG4gICAgICAgICAgICBjb25zdCBtb2RlID0gb3B0aW9ucy5waW5ncG9uZyA/XG4gICAgICAgICAgICAgICAgTG9vcFBpbmdQb25nIDpcbiAgICAgICAgICAgICAgICAocmVwZXRpdGlvbnMgPT09IDEgPyBMb29wT25jZSA6IExvb3BSZXBlYXQpO1xuICAgICAgICAgICAgdGhpc1skc2NlbmVdLnBsYXlBbmltYXRpb24odGhpcy5hbmltYXRpb25OYW1lLCB0aGlzLmFuaW1hdGlvbkNyb3NzZmFkZUR1cmF0aW9uIC8gTUlMTElTRUNPTkRTX1BFUl9TRUNPTkQsIG1vZGUsIHJlcGV0aXRpb25zKTtcbiAgICAgICAgICAgIC8vIElmIHdlIGFyZSBjdXJyZW50bHkgcGF1c2VkLCB3ZSBuZWVkIHRvIGZvcmNlIGEgcmVuZGVyIHNvIHRoYXRcbiAgICAgICAgICAgIC8vIHRoZSBzY2VuZSB1cGRhdGVzIHRvIHRoZSBmaXJzdCBmcmFtZSBvZiB0aGUgbmV3IGFuaW1hdGlvblxuICAgICAgICAgICAgaWYgKHRoaXNbJHBhdXNlZF0pIHtcbiAgICAgICAgICAgICAgICB0aGlzWyRzY2VuZV0udXBkYXRlQW5pbWF0aW9uKDApO1xuICAgICAgICAgICAgICAgIHRoaXNbJG5lZWRzUmVuZGVyXSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBwcm9wZXJ0eSh7IHR5cGU6IEJvb2xlYW4gfSlcbiAgICBdLCBBbmltYXRpb25Nb2RlbFZpZXdlckVsZW1lbnQucHJvdG90eXBlLCBcImF1dG9wbGF5XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHByb3BlcnR5KHsgdHlwZTogU3RyaW5nLCBhdHRyaWJ1dGU6ICdhbmltYXRpb24tbmFtZScgfSlcbiAgICBdLCBBbmltYXRpb25Nb2RlbFZpZXdlckVsZW1lbnQucHJvdG90eXBlLCBcImFuaW1hdGlvbk5hbWVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgcHJvcGVydHkoeyB0eXBlOiBOdW1iZXIsIGF0dHJpYnV0ZTogJ2FuaW1hdGlvbi1jcm9zc2ZhZGUtZHVyYXRpb24nIH0pXG4gICAgXSwgQW5pbWF0aW9uTW9kZWxWaWV3ZXJFbGVtZW50LnByb3RvdHlwZSwgXCJhbmltYXRpb25Dcm9zc2ZhZGVEdXJhdGlvblwiLCB2b2lkIDApO1xuICAgIHJldHVybiBBbmltYXRpb25Nb2RlbFZpZXdlckVsZW1lbnQ7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YW5pbWF0aW9uLmpzLm1hcCIsIi8qIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICdMaWNlbnNlJyk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gJ0FTIElTJyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IE1hdHJpeDQsIFZlY3RvcjMgfSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyAkbmVlZHNSZW5kZXIsICRzY2VuZSwgJHRpY2ssIHRvVmVjdG9yMkQsIHRvVmVjdG9yM0QgfSBmcm9tICcuLi9tb2RlbC12aWV3ZXItYmFzZS5qcyc7XG5pbXBvcnQgeyBIb3RzcG90IH0gZnJvbSAnLi4vdGhyZWUtY29tcG9uZW50cy9Ib3RzcG90LmpzJztcbmNvbnN0ICRob3RzcG90TWFwID0gU3ltYm9sKCdob3RzcG90TWFwJyk7XG5jb25zdCAkbXV0YXRpb25DYWxsYmFjayA9IFN5bWJvbCgnbXV0YXRpb25DYWxsYmFjaycpO1xuY29uc3QgJG9ic2VydmVyID0gU3ltYm9sKCdvYnNlcnZlcicpO1xuY29uc3QgJGFkZEhvdHNwb3QgPSBTeW1ib2woJ2FkZEhvdHNwb3QnKTtcbmNvbnN0ICRyZW1vdmVIb3RzcG90ID0gU3ltYm9sKCdyZW1vdmVIb3RzcG90Jyk7XG5jb25zdCB3b3JsZFRvTW9kZWwgPSBuZXcgTWF0cml4NCgpO1xuLyoqXG4gKiBBbm5vdGF0aW9uTWl4aW4gaW1wbGVtZW50cyBhIGRlY2xhcmF0aXZlIEFQSSB0byBhZGQgaG90c3BvdHMgYW5kIGFubm90YXRpb25zLlxuICogQ2hpbGQgZWxlbWVudHMgb2YgdGhlIDxtb2RlbC12aWV3ZXI+IGVsZW1lbnQgdGhhdCBoYXZlIGEgc2xvdCBuYW1lIHRoYXRcbiAqIGJlZ2lucyB3aXRoIFwiaG90c3BvdFwiIGFuZCBkYXRhLXBvc2l0aW9uIGFuZCBkYXRhLW5vcm1hbCBhdHRyaWJ1dGVzIGluXG4gKiB0aGUgZm9ybWF0IG9mIHRoZSBjYW1lcmEtdGFyZ2V0IGF0dHJpYnV0ZSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBzY2VuZSBhbmRcbiAqIHRyYWNrIHRoZSBzcGVjaWZpZWQgbW9kZWwgY29vcmRpbmF0ZXMuXG4gKi9cbmV4cG9ydCBjb25zdCBBbm5vdGF0aW9uTWl4aW4gPSAoTW9kZWxWaWV3ZXJFbGVtZW50KSA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY2xhc3MgQW5ub3RhdGlvbk1vZGVsVmlld2VyRWxlbWVudCBleHRlbmRzIE1vZGVsVmlld2VyRWxlbWVudCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHRoaXNbX2FdID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgdGhpc1tfYl0gPSAobXV0YXRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgbXV0YXRpb25zLmZvckVhY2goKG11dGF0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IEJlIHdhcnkgdGhhdCBpbiBTaGFkeURPTSBjYXNlcywgdGhlIE11dGF0aW9uUmVjb3JkXG4gICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgaGFzIGFkZGVkTm9kZXMgYW5kIHJlbW92ZWROb2RlcyAoYW5kIG5vIG90aGVyIGRldGFpbHMpLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShtdXRhdGlvbiBpbnN0YW5jZW9mIE11dGF0aW9uUmVjb3JkKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRpb24udHlwZSA9PT0gJ2NoaWxkTGlzdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0aW9uLmFkZGVkTm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbJGFkZEhvdHNwb3RdKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbi5yZW1vdmVkTm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbJHJlbW92ZUhvdHNwb3RdKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzWyRuZWVkc1JlbmRlcl0oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXNbX2NdID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpc1skbXV0YXRpb25DYWxsYmFja10pO1xuICAgICAgICB9XG4gICAgICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICAgICAgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHRoaXNbJGFkZEhvdHNwb3RdKHRoaXMuY2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBTaGFkeURPTSB9ID0gc2VsZjtcbiAgICAgICAgICAgIGlmIChTaGFkeURPTSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpc1skb2JzZXJ2ZXJdLm9ic2VydmUodGhpcywgeyBjaGlsZExpc3Q6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzWyRvYnNlcnZlcl0gPVxuICAgICAgICAgICAgICAgICAgICBTaGFkeURPTS5vYnNlcnZlQ2hpbGRyZW4odGhpcywgdGhpc1skbXV0YXRpb25DYWxsYmFja10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICAgICAgc3VwZXIuZGlzY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICAgICAgICAgIGNvbnN0IHsgU2hhZHlET00gfSA9IHNlbGY7XG4gICAgICAgICAgICBpZiAoU2hhZHlET00gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXNbJG9ic2VydmVyXS5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBTaGFkeURPTS51bm9ic2VydmVDaGlsZHJlbih0aGlzWyRvYnNlcnZlcl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFsoX2EgPSAkaG90c3BvdE1hcCwgX2IgPSAkbXV0YXRpb25DYWxsYmFjaywgX2MgPSAkb2JzZXJ2ZXIsICR0aWNrKV0odGltZSwgZGVsdGEpIHtcbiAgICAgICAgICAgIHN1cGVyWyR0aWNrXSh0aW1lLCBkZWx0YSk7XG4gICAgICAgICAgICBjb25zdCBzY2VuZSA9IHRoaXNbJHNjZW5lXTtcbiAgICAgICAgICAgIGNvbnN0IHsgYW5ub3RhdGlvblJlbmRlcmVyIH0gPSBzY2VuZTtcbiAgICAgICAgICAgIGNvbnN0IGNhbWVyYSA9IHNjZW5lLmdldENhbWVyYSgpO1xuICAgICAgICAgICAgaWYgKHNjZW5lLnNob3VsZFJlbmRlcigpKSB7XG4gICAgICAgICAgICAgICAgc2NlbmUudXBkYXRlU3VyZmFjZUhvdHNwb3RzKCk7XG4gICAgICAgICAgICAgICAgc2NlbmUudXBkYXRlSG90c3BvdHNWaXNpYmlsaXR5KGNhbWVyYS5wb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgYW5ub3RhdGlvblJlbmRlcmVyLmRvbUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgICAgICAgICAgICAgIGFubm90YXRpb25SZW5kZXJlci5yZW5kZXIoc2NlbmUsIGNhbWVyYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNpbmNlIHRoZSBkYXRhLXBvc2l0aW9uIGFuZCBkYXRhLW5vcm1hbCBhdHRyaWJ1dGVzIGFyZSBub3Qgb2JzZXJ2ZWQsIHVzZVxuICAgICAgICAgKiB0aGlzIG1ldGhvZCB0byBtb3ZlIGEgaG90c3BvdC4gS2VlcCBpbiBtaW5kIHRoYXQgYWxsIGhvdHNwb3RzIHdpdGggdGhlXG4gICAgICAgICAqIHNhbWUgc2xvdCBuYW1lIHVzZSBhIHNpbmdsZSBsb2NhdGlvbiBhbmQgdGhlIGZpcnN0IGRlZmluaXRpb24gdGFrZXNcbiAgICAgICAgICogcHJlY2VkZW5jZSwgdW50aWwgdXBkYXRlZCB3aXRoIHRoaXMgbWV0aG9kLlxuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlSG90c3BvdChjb25maWcpIHtcbiAgICAgICAgICAgIGNvbnN0IGhvdHNwb3QgPSB0aGlzWyRob3RzcG90TWFwXS5nZXQoY29uZmlnLm5hbWUpO1xuICAgICAgICAgICAgaWYgKGhvdHNwb3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhvdHNwb3QudXBkYXRlUG9zaXRpb24oY29uZmlnLnBvc2l0aW9uKTtcbiAgICAgICAgICAgIGhvdHNwb3QudXBkYXRlTm9ybWFsKGNvbmZpZy5ub3JtYWwpO1xuICAgICAgICAgICAgaG90c3BvdC5zdXJmYWNlID0gY29uZmlnLnN1cmZhY2U7XG4gICAgICAgICAgICB0aGlzWyRuZWVkc1JlbmRlcl0oKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBpbi1zY2VuZSBkYXRhIGFib3V0IGEgcmVxdWVzdGVkIGhvdHNwb3QgaW5jbHVkaW5nXG4gICAgICAgICAqIGl0cyBwb3NpdGlvbiBpbiBzY3JlZW4gKGNhbnZhcykgc3BhY2UgYW5kIGl0cyBjdXJyZW50IHZpc2liaWxpdHkuXG4gICAgICAgICAqL1xuICAgICAgICBxdWVyeUhvdHNwb3QobmFtZSkge1xuICAgICAgICAgICAgY29uc3QgaG90c3BvdCA9IHRoaXNbJGhvdHNwb3RNYXBdLmdldChuYW1lKTtcbiAgICAgICAgICAgIGlmIChob3RzcG90ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gdG9WZWN0b3IzRChob3RzcG90LnBvc2l0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbCA9IHRvVmVjdG9yM0QoaG90c3BvdC5ub3JtYWwpO1xuICAgICAgICAgICAgY29uc3QgZmFjaW5nQ2FtZXJhID0gaG90c3BvdC5mYWNpbmdDYW1lcmE7XG4gICAgICAgICAgICBjb25zdCBzY2VuZSA9IHRoaXNbJHNjZW5lXTtcbiAgICAgICAgICAgIGNvbnN0IGNhbWVyYSA9IHNjZW5lLmdldENhbWVyYSgpO1xuICAgICAgICAgICAgY29uc3QgdmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgICAgICAgIHZlY3Rvci5zZXRGcm9tTWF0cml4UG9zaXRpb24oaG90c3BvdC5tYXRyaXhXb3JsZCk7XG4gICAgICAgICAgICB2ZWN0b3IucHJvamVjdChjYW1lcmEpO1xuICAgICAgICAgICAgY29uc3Qgd2lkdGhIYWxmID0gc2NlbmUud2lkdGggLyAyO1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0SGFsZiA9IHNjZW5lLmhlaWdodCAvIDI7XG4gICAgICAgICAgICB2ZWN0b3IueCA9ICh2ZWN0b3IueCAqIHdpZHRoSGFsZikgKyB3aWR0aEhhbGY7XG4gICAgICAgICAgICB2ZWN0b3IueSA9IC0odmVjdG9yLnkgKiBoZWlnaHRIYWxmKSArIGhlaWdodEhhbGY7XG4gICAgICAgICAgICBjb25zdCBjYW52YXNQb3NpdGlvbiA9IHRvVmVjdG9yM0QobmV3IFZlY3RvcjModmVjdG9yLngsIHZlY3Rvci55LCB2ZWN0b3IueikpO1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoY2FudmFzUG9zaXRpb24ueCkgfHxcbiAgICAgICAgICAgICAgICAhTnVtYmVyLmlzRmluaXRlKGNhbnZhc1Bvc2l0aW9uLnkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBwb3NpdGlvbiwgbm9ybWFsLCBjYW52YXNQb3NpdGlvbiwgZmFjaW5nQ2FtZXJhIH07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIG1vZGVsIHBvc2l0aW9uLCBub3JtYWwgYW5kIHRleHR1cmUgY29vcmRpbmF0ZVxuICAgICAgICAgKiBvZiB0aGUgcG9pbnQgb24gdGhlIG1lc2ggY29ycmVzcG9uZGluZyB0byB0aGUgaW5wdXQgcGl4ZWwgY29vcmRpbmF0ZXNcbiAgICAgICAgICogZ2l2ZW4gcmVsYXRpdmUgdG8gdGhlIG1vZGVsLXZpZXdlciBlbGVtZW50LiBUaGUgcG9zaXRpb24gYW5kIG5vcm1hbFxuICAgICAgICAgKiBhcmUgcmV0dXJuZWQgYXMgc3RyaW5ncyBpbiB0aGUgZm9ybWF0IHN1aXRhYmxlIGZvciBwdXR0aW5nIGluIGFcbiAgICAgICAgICogaG90c3BvdCdzIGRhdGEtcG9zaXRpb24gYW5kIGRhdGEtbm9ybWFsIGF0dHJpYnV0ZXMuIElmIHRoZSBtZXNoIGlzXG4gICAgICAgICAqIG5vdCBoaXQsIHRoZSByZXN1bHQgaXMgbnVsbC5cbiAgICAgICAgICovXG4gICAgICAgIHBvc2l0aW9uQW5kTm9ybWFsRnJvbVBvaW50KHBpeGVsWCwgcGl4ZWxZKSB7XG4gICAgICAgICAgICBjb25zdCBzY2VuZSA9IHRoaXNbJHNjZW5lXTtcbiAgICAgICAgICAgIGNvbnN0IG5kY1Bvc2l0aW9uID0gc2NlbmUuZ2V0TkRDKHBpeGVsWCwgcGl4ZWxZKTtcbiAgICAgICAgICAgIGNvbnN0IGhpdCA9IHNjZW5lLnBvc2l0aW9uQW5kTm9ybWFsRnJvbVBvaW50KG5kY1Bvc2l0aW9uKTtcbiAgICAgICAgICAgIGlmIChoaXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd29ybGRUb01vZGVsLmNvcHkoc2NlbmUudGFyZ2V0Lm1hdHJpeFdvcmxkKS5pbnZlcnQoKTtcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gdG9WZWN0b3IzRChoaXQucG9zaXRpb24uYXBwbHlNYXRyaXg0KHdvcmxkVG9Nb2RlbCkpO1xuICAgICAgICAgICAgY29uc3Qgbm9ybWFsID0gdG9WZWN0b3IzRChoaXQubm9ybWFsLnRyYW5zZm9ybURpcmVjdGlvbih3b3JsZFRvTW9kZWwpKTtcbiAgICAgICAgICAgIGxldCB1diA9IG51bGw7XG4gICAgICAgICAgICBpZiAoaGl0LnV2ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB1diA9IHRvVmVjdG9yMkQoaGl0LnV2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHBvc2l0aW9uOiBwb3NpdGlvbiwgbm9ybWFsOiBub3JtYWwsIHV2OiB1diB9O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgZHluYW1pYyBob3RzcG90IElEIHN0cmluZyBvZiB0aGUgcG9pbnQgb24gdGhlIG1lc2hcbiAgICAgICAgICogY29ycmVzcG9uZGluZyB0byB0aGUgaW5wdXQgcGl4ZWwgY29vcmRpbmF0ZXMgZ2l2ZW4gcmVsYXRpdmUgdG8gdGhlXG4gICAgICAgICAqIG1vZGVsLXZpZXdlciBlbGVtZW50LiBUaGUgSUQgc3RyaW5nIGNhbiBiZSB1c2VkIGluIHRoZSBkYXRhLXN1cmZhY2VcbiAgICAgICAgICogYXR0cmlidXRlIG9mIHRoZSBob3RzcG90IHRvIG1ha2UgaXQgZm9sbG93IHRoaXMgcG9pbnQgb24gdGhlIHN1cmZhY2UgZXZlblxuICAgICAgICAgKiBhcyB0aGUgbW9kZWwgYW5pbWF0ZXMuIElmIHRoZSBtZXNoIGlzIG5vdCBoaXQsIHRoZSByZXN1bHQgaXMgbnVsbC5cbiAgICAgICAgICovXG4gICAgICAgIHN1cmZhY2VGcm9tUG9pbnQocGl4ZWxYLCBwaXhlbFkpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjZW5lID0gdGhpc1skc2NlbmVdO1xuICAgICAgICAgICAgY29uc3QgbmRjUG9zaXRpb24gPSBzY2VuZS5nZXROREMocGl4ZWxYLCBwaXhlbFkpO1xuICAgICAgICAgICAgcmV0dXJuIHNjZW5lLnN1cmZhY2VGcm9tUG9pbnQobmRjUG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIFskYWRkSG90c3BvdF0obm9kZSkge1xuICAgICAgICAgICAgaWYgKCEobm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmXG4gICAgICAgICAgICAgICAgbm9kZS5zbG90LmluZGV4T2YoJ2hvdHNwb3QnKSA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgaG90c3BvdCA9IHRoaXNbJGhvdHNwb3RNYXBdLmdldChub2RlLnNsb3QpO1xuICAgICAgICAgICAgaWYgKGhvdHNwb3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGhvdHNwb3QuaW5jcmVtZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBob3RzcG90ID0gbmV3IEhvdHNwb3Qoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBub2RlLnNsb3QsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBub2RlLmRhdGFzZXQucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbDogbm9kZS5kYXRhc2V0Lm5vcm1hbCxcbiAgICAgICAgICAgICAgICAgICAgc3VyZmFjZTogbm9kZS5kYXRhc2V0LnN1cmZhY2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpc1skaG90c3BvdE1hcF0uc2V0KG5vZGUuc2xvdCwgaG90c3BvdCk7XG4gICAgICAgICAgICAgICAgdGhpc1skc2NlbmVdLmFkZEhvdHNwb3QoaG90c3BvdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzWyRzY2VuZV0ucXVldWVSZW5kZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBbJHJlbW92ZUhvdHNwb3RdKG5vZGUpIHtcbiAgICAgICAgICAgIGlmICghKG5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBob3RzcG90ID0gdGhpc1skaG90c3BvdE1hcF0uZ2V0KG5vZGUuc2xvdCk7XG4gICAgICAgICAgICBpZiAoIWhvdHNwb3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaG90c3BvdC5kZWNyZW1lbnQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXNbJHNjZW5lXS5yZW1vdmVIb3RzcG90KGhvdHNwb3QpO1xuICAgICAgICAgICAgICAgIHRoaXNbJGhvdHNwb3RNYXBdLmRlbGV0ZShub2RlLnNsb3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpc1skc2NlbmVdLnF1ZXVlUmVuZGVyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEFubm90YXRpb25Nb2RlbFZpZXdlckVsZW1lbnQ7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YW5ub3RhdGlvbi5qcy5tYXAiLCIvKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAnTGljZW5zZScpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICdBUyBJUycgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5pbXBvcnQgeyBwcm9wZXJ0eSB9IGZyb20gJ2xpdC9kZWNvcmF0b3JzLmpzJztcbmltcG9ydCB7IFVTRFpFeHBvcnRlciB9IGZyb20gJ3RocmVlL2V4YW1wbGVzL2pzbS9leHBvcnRlcnMvVVNEWkV4cG9ydGVyLmpzJztcbmltcG9ydCB7IElTX0FSX1FVSUNLTE9PS19DQU5ESURBVEUsIElTX1NDRU5FVklFV0VSX0NBTkRJREFURSwgSVNfV0VCWFJfQVJfQ0FORElEQVRFIH0gZnJvbSAnLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7ICRuZWVkc1JlbmRlciwgJHByb2dyZXNzVHJhY2tlciwgJHJlbmRlcmVyLCAkc2NlbmUsICRzaG91bGRBdHRlbXB0UHJlbG9hZCwgJHVwZGF0ZVNvdXJjZSB9IGZyb20gJy4uL21vZGVsLXZpZXdlci1iYXNlLmpzJztcbmltcG9ydCB7IGVudW1lcmF0aW9uRGVzZXJpYWxpemVyIH0gZnJvbSAnLi4vc3R5bGVzL2Rlc2VyaWFsaXplcnMuanMnO1xuaW1wb3J0IHsgQVJTdGF0dXMsIEFSVHJhY2tpbmcgfSBmcm9tICcuLi90aHJlZS1jb21wb25lbnRzL0FSUmVuZGVyZXIuanMnO1xuaW1wb3J0IHsgd2FpdEZvckV2ZW50IH0gZnJvbSAnLi4vdXRpbGl0aWVzLmpzJztcbmxldCBpc1dlYlhSQmxvY2tlZCA9IGZhbHNlO1xubGV0IGlzU2NlbmVWaWV3ZXJCbG9ja2VkID0gZmFsc2U7XG5jb25zdCBub0FyVmlld2VyU2lnaWwgPSAnI21vZGVsLXZpZXdlci1uby1hci1mYWxsYmFjayc7XG5jb25zdCBkZXNlcmlhbGl6ZUFSTW9kZXMgPSBlbnVtZXJhdGlvbkRlc2VyaWFsaXplcihbJ3F1aWNrLWxvb2snLCAnc2NlbmUtdmlld2VyJywgJ3dlYnhyJywgJ25vbmUnXSk7XG5jb25zdCBERUZBVUxUX0FSX01PREVTID0gJ3dlYnhyIHNjZW5lLXZpZXdlciBxdWljay1sb29rJztcbmNvbnN0IEFSTW9kZSA9IHtcbiAgICBRVUlDS19MT09LOiAncXVpY2stbG9vaycsXG4gICAgU0NFTkVfVklFV0VSOiAnc2NlbmUtdmlld2VyJyxcbiAgICBXRUJYUjogJ3dlYnhyJyxcbiAgICBOT05FOiAnbm9uZSdcbn07XG5jb25zdCAkYXJCdXR0b25Db250YWluZXIgPSBTeW1ib2woJ2FyQnV0dG9uQ29udGFpbmVyJyk7XG5jb25zdCAkZW50ZXJBUldpdGhXZWJYUiA9IFN5bWJvbCgnZW50ZXJBUldpdGhXZWJYUicpO1xuZXhwb3J0IGNvbnN0ICRvcGVuU2NlbmVWaWV3ZXIgPSBTeW1ib2woJ29wZW5TY2VuZVZpZXdlcicpO1xuZXhwb3J0IGNvbnN0ICRvcGVuSU9TQVJRdWlja0xvb2sgPSBTeW1ib2woJ29wZW5JT1NBUlF1aWNrTG9vaycpO1xuY29uc3QgJGNhbkFjdGl2YXRlQVIgPSBTeW1ib2woJ2NhbkFjdGl2YXRlQVInKTtcbmNvbnN0ICRhck1vZGUgPSBTeW1ib2woJ2FyTW9kZScpO1xuY29uc3QgJGFyTW9kZXMgPSBTeW1ib2woJ2FyTW9kZXMnKTtcbmNvbnN0ICRhckFuY2hvciA9IFN5bWJvbCgnYXJBbmNob3InKTtcbmNvbnN0ICRwcmVsb2FkID0gU3ltYm9sKCdwcmVsb2FkJyk7XG5jb25zdCAkb25BUkJ1dHRvbkNvbnRhaW5lckNsaWNrID0gU3ltYm9sKCdvbkFSQnV0dG9uQ29udGFpbmVyQ2xpY2snKTtcbmNvbnN0ICRvbkFSU3RhdHVzID0gU3ltYm9sKCdvbkFSU3RhdHVzJyk7XG5jb25zdCAkb25BUlRyYWNraW5nID0gU3ltYm9sKCdvbkFSVHJhY2tpbmcnKTtcbmNvbnN0ICRvbkFSVGFwID0gU3ltYm9sKCdvbkFSVGFwJyk7XG5jb25zdCAkc2VsZWN0QVJNb2RlID0gU3ltYm9sKCdzZWxlY3RBUk1vZGUnKTtcbmNvbnN0ICR0cmlnZ2VyTG9hZCA9IFN5bWJvbCgndHJpZ2dlckxvYWQnKTtcbmV4cG9ydCBjb25zdCBBUk1peGluID0gKE1vZGVsVmlld2VyRWxlbWVudCkgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qLCBfaztcbiAgICBjbGFzcyBBUk1vZGVsVmlld2VyRWxlbWVudCBleHRlbmRzIE1vZGVsVmlld2VyRWxlbWVudCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHRoaXMuYXIgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuYXJTY2FsZSA9ICdhdXRvJztcbiAgICAgICAgICAgIHRoaXMuYXJQbGFjZW1lbnQgPSAnZmxvb3InO1xuICAgICAgICAgICAgdGhpcy5hck1vZGVzID0gREVGQVVMVF9BUl9NT0RFUztcbiAgICAgICAgICAgIHRoaXMuaW9zU3JjID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMueHJFbnZpcm9ubWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpc1tfYV0gPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIFRPRE86IEFkZCB0aGlzIHRvIHRoZSBzaGFkb3cgcm9vdCBhcyBwYXJ0IG9mIHRoaXMgbWl4aW4nc1xuICAgICAgICAgICAgLy8gaW1wbGVtZW50YXRpb246XG4gICAgICAgICAgICB0aGlzW19iXSA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCcuYXItYnV0dG9uJyk7XG4gICAgICAgICAgICB0aGlzW19jXSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgICAgICAgIHRoaXNbX2RdID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgdGhpc1tfZV0gPSBBUk1vZGUuTk9ORTtcbiAgICAgICAgICAgIHRoaXNbX2ZdID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzW19nXSA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZUFSKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpc1tfaF0gPSAoeyBzdGF0dXMgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgPT09IEFSU3RhdHVzLk5PVF9QUkVTRU5USU5HIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbJHJlbmRlcmVyXS5hclJlbmRlcmVyLnByZXNlbnRlZFNjZW5lID09PSB0aGlzWyRzY2VuZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FyLXN0YXR1cycsIHN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2FyLXN0YXR1cycsIHsgZGV0YWlsOiB7IHN0YXR1cyB9IH0pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gQVJTdGF0dXMuTk9UX1BSRVNFTlRJTkcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKCdhci10cmFja2luZycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0YXR1cyA9PT0gQVJTdGF0dXMuU0VTU0lPTl9TVEFSVEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnYXItdHJhY2tpbmcnLCBBUlRyYWNraW5nLlRSQUNLSU5HKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzW19qXSA9ICh7IHN0YXR1cyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FyLXRyYWNraW5nJywgc3RhdHVzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdhci10cmFja2luZycsIHsgZGV0YWlsOiB7IHN0YXR1cyB9IH0pKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzW19rXSA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5kYXRhID09ICdfYXBwbGVfYXJfcXVpY2tsb29rX2J1dHRvbl90YXBwZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ3F1aWNrLWxvb2stYnV0dG9uLXRhcHBlZCcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGdldCBjYW5BY3RpdmF0ZUFSKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbJGFyTW9kZV0gIT09IEFSTW9kZS5OT05FO1xuICAgICAgICB9XG4gICAgICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICAgICAgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICAgICAgICAgIHRoaXNbJHJlbmRlcmVyXS5hclJlbmRlcmVyLmFkZEV2ZW50TGlzdGVuZXIoJ3N0YXR1cycsIHRoaXNbJG9uQVJTdGF0dXNdKTtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdhci1zdGF0dXMnLCBBUlN0YXR1cy5OT1RfUFJFU0VOVElORyk7XG4gICAgICAgICAgICB0aGlzWyRyZW5kZXJlcl0uYXJSZW5kZXJlci5hZGRFdmVudExpc3RlbmVyKCd0cmFja2luZycsIHRoaXNbJG9uQVJUcmFja2luZ10pO1xuICAgICAgICAgICAgdGhpc1skYXJBbmNob3JdLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzWyRvbkFSVGFwXSk7XG4gICAgICAgIH1cbiAgICAgICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICAgICBzdXBlci5kaXNjb25uZWN0ZWRDYWxsYmFjaygpO1xuICAgICAgICAgICAgdGhpc1skcmVuZGVyZXJdLmFyUmVuZGVyZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignc3RhdHVzJywgdGhpc1skb25BUlN0YXR1c10pO1xuICAgICAgICAgICAgdGhpc1skcmVuZGVyZXJdLmFyUmVuZGVyZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhY2tpbmcnLCB0aGlzWyRvbkFSVHJhY2tpbmddKTtcbiAgICAgICAgICAgIHRoaXNbJGFyQW5jaG9yXS5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpc1skb25BUlRhcF0pO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZShjaGFuZ2VkUHJvcGVydGllcykge1xuICAgICAgICAgICAgc3VwZXIudXBkYXRlKGNoYW5nZWRQcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VkUHJvcGVydGllcy5oYXMoJ2FyU2NhbGUnKSkge1xuICAgICAgICAgICAgICAgIHRoaXNbJHNjZW5lXS5jYW5TY2FsZSA9IHRoaXMuYXJTY2FsZSAhPT0gJ2ZpeGVkJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGFuZ2VkUHJvcGVydGllcy5oYXMoJ2FyUGxhY2VtZW50JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzWyRzY2VuZV0udXBkYXRlU2hhZG93KCk7XG4gICAgICAgICAgICAgICAgdGhpc1skbmVlZHNSZW5kZXJdKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hhbmdlZFByb3BlcnRpZXMuaGFzKCdhck1vZGVzJykpIHtcbiAgICAgICAgICAgICAgICB0aGlzWyRhck1vZGVzXSA9IGRlc2VyaWFsaXplQVJNb2Rlcyh0aGlzLmFyTW9kZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoYW5nZWRQcm9wZXJ0aWVzLmhhcygnYXInKSB8fCBjaGFuZ2VkUHJvcGVydGllcy5oYXMoJ2FyTW9kZXMnKSB8fFxuICAgICAgICAgICAgICAgIGNoYW5nZWRQcm9wZXJ0aWVzLmhhcygnc3JjJykgfHwgY2hhbmdlZFByb3BlcnRpZXMuaGFzKCdpb3NTcmMnKSkge1xuICAgICAgICAgICAgICAgIHRoaXNbJHNlbGVjdEFSTW9kZV0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQWN0aXZhdGVzIEFSLiBOb3RlIHRoYXQgZm9yIGFueSBtb2RlIHRoYXQgaXMgbm90IFdlYlhSLWJhc2VkLCB0aGlzXG4gICAgICAgICAqIG1ldGhvZCBtb3N0IGxpa2VseSBoYXMgdG8gYmUgY2FsbGVkIHN5bmNocm9ub3VzIGZyb20gYSB1c2VyXG4gICAgICAgICAqIGludGVyYWN0aW9uIGhhbmRsZXIuIE90aGVyd2lzZSwgYXR0ZW1wdHMgdG8gYWN0aXZhdGUgbW9kZXMgdGhhdFxuICAgICAgICAgKiByZXF1aXJlIHVzZXIgaW50ZXJhY3Rpb24gd2lsbCBtb3N0IGxpa2VseSBiZSBpZ25vcmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgYWN0aXZhdGVBUigpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpc1skYXJNb2RlXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgQVJNb2RlLlFVSUNLX0xPT0s6XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbJG9wZW5JT1NBUlF1aWNrTG9va10oKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBBUk1vZGUuV0VCWFI6XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXNbJGVudGVyQVJXaXRoV2ViWFJdKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQVJNb2RlLlNDRU5FX1ZJRVdFUjpcbiAgICAgICAgICAgICAgICAgICAgdGhpc1skb3BlblNjZW5lVmlld2VyXSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ05vIEFSIE1vZGUgY2FuIGJlIGFjdGl2YXRlZC4gVGhpcyBpcyBwcm9iYWJseSBkdWUgdG8gbWlzc2luZyBcXFxuY29uZmlndXJhdGlvbiBvciBkZXZpY2UgY2FwYWJpbGl0aWVzJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFzeW5jIFsoX2EgPSAkY2FuQWN0aXZhdGVBUiwgX2IgPSAkYXJCdXR0b25Db250YWluZXIsIF9jID0gJGFyQW5jaG9yLCBfZCA9ICRhck1vZGVzLCBfZSA9ICRhck1vZGUsIF9mID0gJHByZWxvYWQsIF9nID0gJG9uQVJCdXR0b25Db250YWluZXJDbGljaywgX2ggPSAkb25BUlN0YXR1cywgX2ogPSAkb25BUlRyYWNraW5nLCBfayA9ICRvbkFSVGFwLCAkc2VsZWN0QVJNb2RlKV0oKSB7XG4gICAgICAgICAgICBsZXQgYXJNb2RlID0gQVJNb2RlLk5PTkU7XG4gICAgICAgICAgICBpZiAodGhpcy5hcikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNyYyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdGhpc1skYXJNb2Rlc10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJ3dlYnhyJyAmJiBJU19XRUJYUl9BUl9DQU5ESURBVEUgJiYgIWlzV2ViWFJCbG9ja2VkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpc1skcmVuZGVyZXJdLmFyUmVuZGVyZXIuc3VwcG9ydHNQcmVzZW50YXRpb24oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyTW9kZSA9IEFSTW9kZS5XRUJYUjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJ3NjZW5lLXZpZXdlcicgJiYgSVNfU0NFTkVWSUVXRVJfQ0FORElEQVRFICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIWlzU2NlbmVWaWV3ZXJCbG9ja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJNb2RlID0gQVJNb2RlLlNDRU5FX1ZJRVdFUjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJ3F1aWNrLWxvb2snICYmIElTX0FSX1FVSUNLTE9PS19DQU5ESURBVEUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhck1vZGUgPSBBUk1vZGUuUVVJQ0tfTE9PSztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaGUgcHJlc2VuY2Ugb2YgaW9zLXNyYyBvdmVycmlkZXMgdGhlIGFic2VuY2Ugb2YgcXVpY2stbG9va1xuICAgICAgICAgICAgICAgIC8vIGFyLW1vZGUuXG4gICAgICAgICAgICAgICAgaWYgKGFyTW9kZSA9PT0gQVJNb2RlLk5PTkUgJiYgdGhpcy5pb3NTcmMgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICBJU19BUl9RVUlDS0xPT0tfQ0FORElEQVRFKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyTW9kZSA9IEFSTW9kZS5RVUlDS19MT09LO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhck1vZGUgIT09IEFSTW9kZS5OT05FKSB7XG4gICAgICAgICAgICAgICAgdGhpc1skYXJCdXR0b25Db250YWluZXJdLmNsYXNzTGlzdC5hZGQoJ2VuYWJsZWQnKTtcbiAgICAgICAgICAgICAgICB0aGlzWyRhckJ1dHRvbkNvbnRhaW5lcl0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzWyRvbkFSQnV0dG9uQ29udGFpbmVyQ2xpY2tdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXNbJGFyQnV0dG9uQ29udGFpbmVyXS5jbGFzc0xpc3QuY29udGFpbnMoJ2VuYWJsZWQnKSkge1xuICAgICAgICAgICAgICAgIHRoaXNbJGFyQnV0dG9uQ29udGFpbmVyXS5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXNbJG9uQVJCdXR0b25Db250YWluZXJDbGlja10pO1xuICAgICAgICAgICAgICAgIHRoaXNbJGFyQnV0dG9uQ29udGFpbmVyXS5jbGFzc0xpc3QucmVtb3ZlKCdlbmFibGVkJyk7XG4gICAgICAgICAgICAgICAgLy8gSWYgQVIgd2VudCBmcm9tIHdvcmtpbmcgdG8gbm90LCBub3RpZnkgdGhlIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gQVJTdGF0dXMuRkFJTEVEO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdhci1zdGF0dXMnLCBzdGF0dXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2FyLXN0YXR1cycsIHsgZGV0YWlsOiB7IHN0YXR1cyB9IH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXNbJGFyTW9kZV0gPSBhck1vZGU7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgWyRlbnRlckFSV2l0aFdlYlhSXSgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdBdHRlbXB0aW5nIHRvIHByZXNlbnQgaW4gQVIgd2l0aCBXZWJYUi4uLicpO1xuICAgICAgICAgICAgYXdhaXQgdGhpc1skdHJpZ2dlckxvYWRdKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXNbJGFyQnV0dG9uQ29udGFpbmVyXS5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXNbJG9uQVJCdXR0b25Db250YWluZXJDbGlja10pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgYXJSZW5kZXJlciB9ID0gdGhpc1skcmVuZGVyZXJdO1xuICAgICAgICAgICAgICAgIGFyUmVuZGVyZXIucGxhY2VPbldhbGwgPSB0aGlzLmFyUGxhY2VtZW50ID09PSAnd2FsbCc7XG4gICAgICAgICAgICAgICAgYXdhaXQgYXJSZW5kZXJlci5wcmVzZW50KHRoaXNbJHNjZW5lXSwgdGhpcy54ckVudmlyb25tZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignRXJyb3Igd2hpbGUgdHJ5aW5nIHRvIHByZXNlbnQgaW4gQVIgd2l0aCBXZWJYUicpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXNbJHJlbmRlcmVyXS5hclJlbmRlcmVyLnN0b3BQcmVzZW50aW5nKCk7XG4gICAgICAgICAgICAgICAgaXNXZWJYUkJsb2NrZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignRmFsbGluZyBiYWNrIHRvIG5leHQgYXItbW9kZScpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXNbJHNlbGVjdEFSTW9kZV0oKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2YXRlQVIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRoaXNbJHNlbGVjdEFSTW9kZV0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3luYyBbJHRyaWdnZXJMb2FkXSgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5sb2FkZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzWyRwcmVsb2FkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpc1skdXBkYXRlU291cmNlXSgpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHdhaXRGb3JFdmVudCh0aGlzLCAnbG9hZCcpO1xuICAgICAgICAgICAgICAgIHRoaXNbJHByZWxvYWRdID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgWyRzaG91bGRBdHRlbXB0UHJlbG9hZF0oKSB7XG4gICAgICAgICAgICByZXR1cm4gc3VwZXJbJHNob3VsZEF0dGVtcHRQcmVsb2FkXSgpIHx8IHRoaXNbJHByZWxvYWRdO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUYWtlcyBhIFVSTCBhbmQgYSB0aXRsZSBzdHJpbmcsIGFuZCBhdHRlbXB0cyB0byBsYXVuY2ggU2NlbmUgVmlld2VyIG9uXG4gICAgICAgICAqIHRoZSBjdXJyZW50IGRldmljZS5cbiAgICAgICAgICovXG4gICAgICAgIFskb3BlblNjZW5lVmlld2VyXSgpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gc2VsZi5sb2NhdGlvbi50b1N0cmluZygpO1xuICAgICAgICAgICAgY29uc3QgbG9jYXRpb25VcmwgPSBuZXcgVVJMKGxvY2F0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IG1vZGVsVXJsID0gbmV3IFVSTCh0aGlzLnNyYywgbG9jYXRpb24pO1xuICAgICAgICAgICAgaWYgKG1vZGVsVXJsLmhhc2gpXG4gICAgICAgICAgICAgICAgbW9kZWxVcmwuaGFzaCA9ICcnO1xuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhtb2RlbFVybC5zZWFyY2gpO1xuICAgICAgICAgICAgbG9jYXRpb25VcmwuaGFzaCA9IG5vQXJWaWV3ZXJTaWdpbDtcbiAgICAgICAgICAgIC8vIG1vZGVsVXJsIGNhbiBjb250YWluIHRpdGxlL2xpbmsvc291bmQgZXRjLlxuICAgICAgICAgICAgcGFyYW1zLnNldCgnbW9kZScsICdhcl9wcmVmZXJyZWQnKTtcbiAgICAgICAgICAgIGlmICghcGFyYW1zLmhhcygnZGlzYWJsZV9vY2NsdXNpb24nKSkge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5zZXQoJ2Rpc2FibGVfb2NjbHVzaW9uJywgJ3RydWUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmFyU2NhbGUgPT09ICdmaXhlZCcpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuc2V0KCdyZXNpemFibGUnLCAnZmFsc2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmFyUGxhY2VtZW50ID09PSAnd2FsbCcpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuc2V0KCdlbmFibGVfdmVydGljYWxfcGxhY2VtZW50JywgJ3RydWUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJhbXMuaGFzKCdzb3VuZCcpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc291bmRVcmwgPSBuZXcgVVJMKHBhcmFtcy5nZXQoJ3NvdW5kJyksIGxvY2F0aW9uKTtcbiAgICAgICAgICAgICAgICBwYXJhbXMuc2V0KCdzb3VuZCcsIHNvdW5kVXJsLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmFtcy5oYXMoJ2xpbmsnKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmtVcmwgPSBuZXcgVVJMKHBhcmFtcy5nZXQoJ2xpbmsnKSwgbG9jYXRpb24pO1xuICAgICAgICAgICAgICAgIHBhcmFtcy5zZXQoJ2xpbmsnLCBsaW5rVXJsLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaW50ZW50ID0gYGludGVudDovL2FydnIuZ29vZ2xlLmNvbS9zY2VuZS12aWV3ZXIvMS4wPyR7cGFyYW1zLnRvU3RyaW5nKCkgKyAnJmZpbGU9JyArXG4gICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KG1vZGVsVXJsXG4gICAgICAgICAgICAgICAgICAgIC50b1N0cmluZygpKX0jSW50ZW50O3NjaGVtZT1odHRwcztwYWNrYWdlPWNvbS5nb29nbGUuYXIuY29yZTthY3Rpb249YW5kcm9pZC5pbnRlbnQuYWN0aW9uLlZJRVc7Uy5icm93c2VyX2ZhbGxiYWNrX3VybD0ke2VuY29kZVVSSUNvbXBvbmVudChsb2NhdGlvblVybC50b1N0cmluZygpKX07ZW5kO2A7XG4gICAgICAgICAgICBjb25zdCB1bmRvSGFzaENoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5sb2NhdGlvbi5oYXNoID09PSBub0FyVmlld2VyU2lnaWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNTY2VuZVZpZXdlckJsb2NrZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbmV3IGhpc3Rvcnkgd2lsbCBiZSB0aGUgY3VycmVudCBVUkwgd2l0aCBhIG5ldyBoYXNoLlxuICAgICAgICAgICAgICAgICAgICAvLyBHbyBiYWNrIG9uZSBzdGVwIHNvIHRoYXQgd2UgcmVzZXQgdG8gdGhlIGV4cGVjdGVkIFVSTC5cbiAgICAgICAgICAgICAgICAgICAgLy8gTk9URShjZGF0YSk6IHRoaXMgc2hvdWxkIG5vdCBpbnZva2UgYW55IGJyb3dzZXItbGV2ZWwgbmF2aWdhdGlvblxuICAgICAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIGhhc2gtb25seSBjaGFuZ2VzIG1vZGlmeSB0aGUgVVJMIGluLXBsYWNlIHdpdGhvdXRcbiAgICAgICAgICAgICAgICAgICAgLy8gbmF2aWdhdGluZzpcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5oaXN0b3J5LmJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdFcnJvciB3aGlsZSB0cnlpbmcgdG8gcHJlc2VudCBpbiBBUiB3aXRoIFNjZW5lIFZpZXdlcicpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZhbGxpbmcgYmFjayB0byBuZXh0IGFyLW1vZGUnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1skc2VsZWN0QVJNb2RlXSgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBXb3VsZCBiZSBuaWNlIHRvIGFjdGl2YXRlQVIoKSBoZXJlLCBidXQgd2ViWFIgZmFpbHMgZHVlIHRvIG5vdFxuICAgICAgICAgICAgICAgICAgICAvLyBzZWVpbmcgYSB1c2VyIGFjdGl2YXRpb24uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcignaGFzaGNoYW5nZScsIHVuZG9IYXNoQ2hhbmdlLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgICAgICAgICB0aGlzWyRhckFuY2hvcl0uc2V0QXR0cmlidXRlKCdocmVmJywgaW50ZW50KTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdBdHRlbXB0aW5nIHRvIHByZXNlbnQgaW4gQVIgd2l0aCBTY2VuZSBWaWV3ZXIuLi4nKTtcbiAgICAgICAgICAgIHRoaXNbJGFyQW5jaG9yXS5jbGljaygpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUYWtlcyBhIFVSTCB0byBhIFVTRFogZmlsZSBhbmQgc2V0cyB0aGUgYXBwcm9wcmlhdGUgZmllbGRzIHNvIHRoYXRcbiAgICAgICAgICogU2FmYXJpIGlPUyBjYW4gaW50ZW50IHRvIHRoZWlyIEFSIFF1aWNrIExvb2suXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBbJG9wZW5JT1NBUlF1aWNrTG9va10oKSB7XG4gICAgICAgICAgICBjb25zdCBnZW5lcmF0ZVVzZHogPSAhdGhpcy5pb3NTcmM7XG4gICAgICAgICAgICB0aGlzWyRhckJ1dHRvbkNvbnRhaW5lcl0uY2xhc3NMaXN0LnJlbW92ZSgnZW5hYmxlZCcpO1xuICAgICAgICAgICAgY29uc3Qgb2JqZWN0VVJMID0gZ2VuZXJhdGVVc2R6ID8gYXdhaXQgdGhpcy5wcmVwYXJlVVNEWigpIDogdGhpcy5pb3NTcmM7XG4gICAgICAgICAgICBjb25zdCBtb2RlbFVybCA9IG5ldyBVUkwob2JqZWN0VVJMLCBzZWxmLmxvY2F0aW9uLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgaWYgKGdlbmVyYXRlVXNkeikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gc2VsZi5sb2NhdGlvbi50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uVXJsID0gbmV3IFVSTChsb2NhdGlvbik7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3JjVXJsID0gbmV3IFVSTCh0aGlzLnNyYywgbG9jYXRpb25VcmwpO1xuICAgICAgICAgICAgICAgIGlmIChzcmNVcmwuaGFzaCkge1xuICAgICAgICAgICAgICAgICAgICBtb2RlbFVybC5oYXNoID0gc3JjVXJsLmhhc2g7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuYXJTY2FsZSA9PT0gJ2ZpeGVkJykge1xuICAgICAgICAgICAgICAgIGlmIChtb2RlbFVybC5oYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsVXJsLmhhc2ggKz0gJyYnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtb2RlbFVybC5oYXNoICs9ICdhbGxvd3NDb250ZW50U2NhbGluZz0wJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFuY2hvciA9IHRoaXNbJGFyQW5jaG9yXTtcbiAgICAgICAgICAgIGFuY2hvci5zZXRBdHRyaWJ1dGUoJ3JlbCcsICdhcicpO1xuICAgICAgICAgICAgY29uc3QgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgICAgICAgICBhbmNob3IuYXBwZW5kQ2hpbGQoaW1nKTtcbiAgICAgICAgICAgIGFuY2hvci5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBtb2RlbFVybC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIGlmIChnZW5lcmF0ZVVzZHopIHtcbiAgICAgICAgICAgICAgICBhbmNob3Iuc2V0QXR0cmlidXRlKCdkb3dubG9hZCcsICdtb2RlbC51c2R6Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhdHRhY2ggYW5jaG9yIHRvIHNoYWRvdyBET00gdG8gZW5zdXJlIGlPUzE2IEFSUUwgYmFubmVyIGNsaWNrIG1lc3NhZ2UgZXZlbnQgcHJvcGFnYXRpb24gXG4gICAgICAgICAgICBhbmNob3Iuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIGlmICghYW5jaG9yLmlzQ29ubmVjdGVkKVxuICAgICAgICAgICAgICAgIHRoaXMuc2hhZG93Um9vdC5hcHBlbmRDaGlsZChhbmNob3IpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0F0dGVtcHRpbmcgdG8gcHJlc2VudCBpbiBBUiB3aXRoIFF1aWNrIExvb2suLi4nKTtcbiAgICAgICAgICAgIGFuY2hvci5jbGljaygpO1xuICAgICAgICAgICAgYW5jaG9yLnJlbW92ZUNoaWxkKGltZyk7XG4gICAgICAgICAgICBpZiAoZ2VuZXJhdGVVc2R6KSB7XG4gICAgICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChvYmplY3RVUkwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpc1skYXJCdXR0b25Db250YWluZXJdLmNsYXNzTGlzdC5hZGQoJ2VuYWJsZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBwcmVwYXJlVVNEWigpIHtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZVNvdXJjZVByb2dyZXNzID0gdGhpc1skcHJvZ3Jlc3NUcmFja2VyXS5iZWdpbkFjdGl2aXR5KCk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzWyR0cmlnZ2VyTG9hZF0oKTtcbiAgICAgICAgICAgIGNvbnN0IHsgbW9kZWwsIHNoYWRvdyB9ID0gdGhpc1skc2NlbmVdO1xuICAgICAgICAgICAgaWYgKG1vZGVsID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHNoYWRvdyBmcm9tIGV4cG9ydFxuICAgICAgICAgICAgaWYgKHNoYWRvdyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmlzaWJsZSA9IHNoYWRvdy52aXNpYmxlO1xuICAgICAgICAgICAgICAgIHNoYWRvdy52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cGRhdGVTb3VyY2VQcm9ncmVzcygwLjIpO1xuICAgICAgICAgICAgY29uc3QgZXhwb3J0ZXIgPSBuZXcgVVNEWkV4cG9ydGVyKCk7XG4gICAgICAgICAgICBjb25zdCBhcnJheWJ1ZmZlciA9IGF3YWl0IGV4cG9ydGVyLnBhcnNlKG1vZGVsKTtcbiAgICAgICAgICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbYXJyYXlidWZmZXJdLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ21vZGVsL3ZuZC51c2R6K3ppcCcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAgICAgICB1cGRhdGVTb3VyY2VQcm9ncmVzcygxKTtcbiAgICAgICAgICAgIGlmIChzaGFkb3cgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHNoYWRvdy52aXNpYmxlID0gdmlzaWJsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1cmw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHByb3BlcnR5KHsgdHlwZTogQm9vbGVhbiwgYXR0cmlidXRlOiAnYXInIH0pXG4gICAgXSwgQVJNb2RlbFZpZXdlckVsZW1lbnQucHJvdG90eXBlLCBcImFyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHByb3BlcnR5KHsgdHlwZTogU3RyaW5nLCBhdHRyaWJ1dGU6ICdhci1zY2FsZScgfSlcbiAgICBdLCBBUk1vZGVsVmlld2VyRWxlbWVudC5wcm90b3R5cGUsIFwiYXJTY2FsZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBwcm9wZXJ0eSh7IHR5cGU6IFN0cmluZywgYXR0cmlidXRlOiAnYXItcGxhY2VtZW50JyB9KVxuICAgIF0sIEFSTW9kZWxWaWV3ZXJFbGVtZW50LnByb3RvdHlwZSwgXCJhclBsYWNlbWVudFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBwcm9wZXJ0eSh7IHR5cGU6IFN0cmluZywgYXR0cmlidXRlOiAnYXItbW9kZXMnIH0pXG4gICAgXSwgQVJNb2RlbFZpZXdlckVsZW1lbnQucHJvdG90eXBlLCBcImFyTW9kZXNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgcHJvcGVydHkoeyB0eXBlOiBTdHJpbmcsIGF0dHJpYnV0ZTogJ2lvcy1zcmMnIH0pXG4gICAgXSwgQVJNb2RlbFZpZXdlckVsZW1lbnQucHJvdG90eXBlLCBcImlvc1NyY1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBwcm9wZXJ0eSh7IHR5cGU6IEJvb2xlYW4sIGF0dHJpYnV0ZTogJ3hyLWVudmlyb25tZW50JyB9KVxuICAgIF0sIEFSTW9kZWxWaWV3ZXJFbGVtZW50LnByb3RvdHlwZSwgXCJ4ckVudmlyb25tZW50XCIsIHZvaWQgMCk7XG4gICAgcmV0dXJuIEFSTW9kZWxWaWV3ZXJFbGVtZW50O1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFyLmpzLm1hcCIsIi8qIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICdMaWNlbnNlJyk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gJ0FTIElTJyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbmltcG9ydCB7IHByb3BlcnR5IH0gZnJvbSAnbGl0L2RlY29yYXRvcnMuanMnO1xuaW1wb3J0IHsgU3BoZXJpY2FsLCBWZWN0b3IzIH0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgc3R5bGUgfSBmcm9tICcuLi9kZWNvcmF0b3JzLmpzJztcbmltcG9ydCB7ICRhcmlhTGFiZWwsICRjb250YWluZXIsICRnZXRNb2RlbElzVmlzaWJsZSwgJGxvYWRlZFRpbWUsICRuZWVkc1JlbmRlciwgJG9uTW9kZWxMb2FkLCAkb25SZXNpemUsICRyZW5kZXJlciwgJHNjZW5lLCAkdGljaywgJHVwZGF0ZVN0YXR1cywgJHVzZXJJbnB1dEVsZW1lbnQsIHRvVmVjdG9yM0QgfSBmcm9tICcuLi9tb2RlbC12aWV3ZXItYmFzZS5qcyc7XG5pbXBvcnQgeyBkZWdyZWVzVG9SYWRpYW5zLCBub3JtYWxpemVVbml0IH0gZnJvbSAnLi4vc3R5bGVzL2NvbnZlcnNpb25zLmpzJztcbmltcG9ydCB7IFN0eWxlRXZhbHVhdG9yIH0gZnJvbSAnLi4vc3R5bGVzL2V2YWx1YXRvcnMuanMnO1xuaW1wb3J0IHsgbnVtYmVyTm9kZSwgcGFyc2VFeHByZXNzaW9ucyB9IGZyb20gJy4uL3N0eWxlcy9wYXJzZXJzLmpzJztcbmltcG9ydCB7IERFQ0FZX01JTExJU0VDT05EUyB9IGZyb20gJy4uL3RocmVlLWNvbXBvbmVudHMvRGFtcGVyLmpzJztcbmltcG9ydCB7IENoYW5nZVNvdXJjZSwgU21vb3RoQ29udHJvbHMgfSBmcm9tICcuLi90aHJlZS1jb21wb25lbnRzL1Ntb290aENvbnRyb2xzLmpzJztcbmltcG9ydCB7IHRpbWVsaW5lIH0gZnJvbSAnLi4vdXRpbGl0aWVzL2FuaW1hdGlvbi5qcyc7XG4vLyBOT1RFKGNkYXRhKTogVGhlIGZvbGxvd2luZyBcImFuaW1hdGlvblwiIHRpbWluZyBmdW5jdGlvbnMgYXJlIGRlbGliZXJhdGVseVxuLy8gYmVpbmcgdXNlZCBpbiBmYXZvciBvZiBDU1MgYW5pbWF0aW9ucy4gSW4gU2FmYXJpIDEyLjEgYW5kIDEzLCBDU1MgYW5pbWF0aW9uc1xuLy8gd291bGQgY2F1c2UgdGhlIGludGVyYWN0aW9uIHByb21wdCB0byBnbGl0Y2ggdW5leHBlY3RlZGx5XG4vLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvbW9kZWwtdmlld2VyL2lzc3Vlcy84MzlcbmNvbnN0IFBST01QVF9BTklNQVRJT05fVElNRSA9IDUwMDA7XG4vLyBGb3IgdGltaW5nIHB1cnBvc2VzLCBhIFwiZnJhbWVcIiBpcyBhIHRpbWluZyBhZ25vc3RpYyByZWxhdGl2ZSB1bml0IG9mIHRpbWVcbi8vIGFuZCBhIFwidmFsdWVcIiBpcyBhIHRhcmdldCB2YWx1ZSBmb3IgdGhlIEZyYW1lLlxuY29uc3Qgd2lnZ2xlID0gdGltZWxpbmUoe1xuICAgIGluaXRpYWxWYWx1ZTogMCxcbiAgICBrZXlmcmFtZXM6IFtcbiAgICAgICAgeyBmcmFtZXM6IDUsIHZhbHVlOiAtMSB9LFxuICAgICAgICB7IGZyYW1lczogMSwgdmFsdWU6IC0xIH0sXG4gICAgICAgIHsgZnJhbWVzOiA4LCB2YWx1ZTogMSB9LFxuICAgICAgICB7IGZyYW1lczogMSwgdmFsdWU6IDEgfSxcbiAgICAgICAgeyBmcmFtZXM6IDUsIHZhbHVlOiAwIH0sXG4gICAgICAgIHsgZnJhbWVzOiAxOCwgdmFsdWU6IDAgfVxuICAgIF1cbn0pO1xuY29uc3QgZmFkZSA9IHRpbWVsaW5lKHtcbiAgICBpbml0aWFsVmFsdWU6IDAsXG4gICAga2V5ZnJhbWVzOiBbXG4gICAgICAgIHsgZnJhbWVzOiAxLCB2YWx1ZTogMSB9LFxuICAgICAgICB7IGZyYW1lczogNSwgdmFsdWU6IDEgfSxcbiAgICAgICAgeyBmcmFtZXM6IDEsIHZhbHVlOiAwIH0sXG4gICAgICAgIHsgZnJhbWVzOiA2LCB2YWx1ZTogMCB9XG4gICAgXVxufSk7XG5leHBvcnQgY29uc3QgREVGQVVMVF9GT1ZfREVHID0gMzA7XG5leHBvcnQgY29uc3QgREVGQVVMVF9NSU5fRk9WX0RFRyA9IDEyO1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfQ0FNRVJBX09SQklUID0gJzBkZWcgNzVkZWcgMTA1JSc7XG5jb25zdCBERUZBVUxUX0NBTUVSQV9UQVJHRVQgPSAnYXV0byBhdXRvIGF1dG8nO1xuY29uc3QgREVGQVVMVF9GSUVMRF9PRl9WSUVXID0gJ2F1dG8nO1xuY29uc3QgTUlOSU1VTV9SQURJVVNfUkFUSU8gPSAyLjI7XG5jb25zdCBBWklNVVRIQUxfUVVBRFJBTlRfTEFCRUxTID0gWydmcm9udCcsICdyaWdodCcsICdiYWNrJywgJ2xlZnQnXTtcbmNvbnN0IFBPTEFSX1RSSUVOVF9MQUJFTFMgPSBbJ3VwcGVyLScsICcnLCAnbG93ZXItJ107XG5leHBvcnQgY29uc3QgREVGQVVMVF9JTlRFUkFDVElPTl9QUk9NUFRfVEhSRVNIT0xEID0gMzAwMDtcbmV4cG9ydCBjb25zdCBJTlRFUkFDVElPTl9QUk9NUFQgPSAnLiBVc2UgbW91c2UsIHRvdWNoIG9yIGFycm93IGtleXMgdG8gbW92ZS4nO1xuZXhwb3J0IGNvbnN0IEludGVyYWN0aW9uUHJvbXB0U3RyYXRlZ3kgPSB7XG4gICAgQVVUTzogJ2F1dG8nLFxuICAgIE5PTkU6ICdub25lJ1xufTtcbmV4cG9ydCBjb25zdCBJbnRlcmFjdGlvblByb21wdFN0eWxlID0ge1xuICAgIEJBU0lDOiAnYmFzaWMnLFxuICAgIFdJR0dMRTogJ3dpZ2dsZSdcbn07XG5leHBvcnQgY29uc3QgVG91Y2hBY3Rpb24gPSB7XG4gICAgUEFOX1k6ICdwYW4teScsXG4gICAgUEFOX1g6ICdwYW4teCcsXG4gICAgTk9ORTogJ25vbmUnXG59O1xuZXhwb3J0IGNvbnN0IGZpZWxkT2ZWaWV3SW50cmluc2ljcyA9ICgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICBiYXNpczogW2RlZ3JlZXNUb1JhZGlhbnMobnVtYmVyTm9kZShERUZBVUxUX0ZPVl9ERUcsICdkZWcnKSldLFxuICAgICAgICBrZXl3b3JkczogeyBhdXRvOiBbbnVsbF0gfVxuICAgIH07XG59O1xuY29uc3QgbWluRmllbGRPZlZpZXdJbnRyaW5zaWNzID0gKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIGJhc2lzOiBbZGVncmVlc1RvUmFkaWFucyhudW1iZXJOb2RlKERFRkFVTFRfTUlOX0ZPVl9ERUcsICdkZWcnKSldLFxuICAgICAgICBrZXl3b3JkczogeyBhdXRvOiBbbnVsbF0gfVxuICAgIH07XG59O1xuZXhwb3J0IGNvbnN0IGNhbWVyYU9yYml0SW50cmluc2ljcyA9ICgoKSA9PiB7XG4gICAgY29uc3QgZGVmYXVsdFRlcm1zID0gcGFyc2VFeHByZXNzaW9ucyhERUZBVUxUX0NBTUVSQV9PUkJJVClbMF1cbiAgICAgICAgLnRlcm1zO1xuICAgIGNvbnN0IHRoZXRhID0gbm9ybWFsaXplVW5pdChkZWZhdWx0VGVybXNbMF0pO1xuICAgIGNvbnN0IHBoaSA9IG5vcm1hbGl6ZVVuaXQoZGVmYXVsdFRlcm1zWzFdKTtcbiAgICByZXR1cm4gKGVsZW1lbnQpID0+IHtcbiAgICAgICAgY29uc3QgcmFkaXVzID0gZWxlbWVudFskc2NlbmVdLmlkZWFsQ2FtZXJhRGlzdGFuY2UoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJhc2lzOiBbdGhldGEsIHBoaSwgbnVtYmVyTm9kZShyYWRpdXMsICdtJyldLFxuICAgICAgICAgICAga2V5d29yZHM6IHsgYXV0bzogW251bGwsIG51bGwsIG51bWJlck5vZGUoMTA1LCAnJScpXSB9XG4gICAgICAgIH07XG4gICAgfTtcbn0pKCk7XG5jb25zdCBtaW5DYW1lcmFPcmJpdEludHJpbnNpY3MgPSAoZWxlbWVudCkgPT4ge1xuICAgIGNvbnN0IHJhZGl1cyA9IE1JTklNVU1fUkFESVVTX1JBVElPICogZWxlbWVudFskc2NlbmVdLmJvdW5kaW5nU3BoZXJlLnJhZGl1cztcbiAgICByZXR1cm4ge1xuICAgICAgICBiYXNpczogW1xuICAgICAgICAgICAgbnVtYmVyTm9kZSgtSW5maW5pdHksICdyYWQnKSxcbiAgICAgICAgICAgIG51bWJlck5vZGUoTWF0aC5QSSAvIDgsICdyYWQnKSxcbiAgICAgICAgICAgIG51bWJlck5vZGUocmFkaXVzLCAnbScpXG4gICAgICAgIF0sXG4gICAgICAgIGtleXdvcmRzOiB7IGF1dG86IFtudWxsLCBudWxsLCBudWxsXSB9XG4gICAgfTtcbn07XG5jb25zdCBtYXhDYW1lcmFPcmJpdEludHJpbnNpY3MgPSAoZWxlbWVudCkgPT4ge1xuICAgIGNvbnN0IG9yYml0SW50cmluc2ljcyA9IGNhbWVyYU9yYml0SW50cmluc2ljcyhlbGVtZW50KTtcbiAgICBjb25zdCBldmFsdWF0b3IgPSBuZXcgU3R5bGVFdmFsdWF0b3IoW10sIG9yYml0SW50cmluc2ljcyk7XG4gICAgY29uc3QgZGVmYXVsdFJhZGl1cyA9IGV2YWx1YXRvci5ldmFsdWF0ZSgpWzJdO1xuICAgIHJldHVybiB7XG4gICAgICAgIGJhc2lzOiBbXG4gICAgICAgICAgICBudW1iZXJOb2RlKEluZmluaXR5LCAncmFkJyksXG4gICAgICAgICAgICBudW1iZXJOb2RlKE1hdGguUEkgLSBNYXRoLlBJIC8gOCwgJ3JhZCcpLFxuICAgICAgICAgICAgbnVtYmVyTm9kZShkZWZhdWx0UmFkaXVzLCAnbScpXG4gICAgICAgIF0sXG4gICAgICAgIGtleXdvcmRzOiB7IGF1dG86IFtudWxsLCBudWxsLCBudWxsXSB9XG4gICAgfTtcbn07XG5leHBvcnQgY29uc3QgY2FtZXJhVGFyZ2V0SW50cmluc2ljcyA9IChlbGVtZW50KSA9PiB7XG4gICAgY29uc3QgY2VudGVyID0gZWxlbWVudFskc2NlbmVdLmJvdW5kaW5nQm94LmdldENlbnRlcihuZXcgVmVjdG9yMygpKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBiYXNpczogW1xuICAgICAgICAgICAgbnVtYmVyTm9kZShjZW50ZXIueCwgJ20nKSxcbiAgICAgICAgICAgIG51bWJlck5vZGUoY2VudGVyLnksICdtJyksXG4gICAgICAgICAgICBudW1iZXJOb2RlKGNlbnRlci56LCAnbScpXG4gICAgICAgIF0sXG4gICAgICAgIGtleXdvcmRzOiB7IGF1dG86IFtudWxsLCBudWxsLCBudWxsXSB9XG4gICAgfTtcbn07XG5jb25zdCBIQUxGX1BJID0gTWF0aC5QSSAvIDIuMDtcbmNvbnN0IFRISVJEX1BJID0gTWF0aC5QSSAvIDMuMDtcbmNvbnN0IFFVQVJURVJfUEkgPSBIQUxGX1BJIC8gMi4wO1xuY29uc3QgVEFVID0gMi4wICogTWF0aC5QSTtcbmV4cG9ydCBjb25zdCAkY29udHJvbHMgPSBTeW1ib2woJ2NvbnRyb2xzJyk7XG5leHBvcnQgY29uc3QgJHBhbkVsZW1lbnQgPSBTeW1ib2woJ3BhbkVsZW1lbnQnKTtcbmV4cG9ydCBjb25zdCAkcHJvbXB0RWxlbWVudCA9IFN5bWJvbCgncHJvbXB0RWxlbWVudCcpO1xuZXhwb3J0IGNvbnN0ICRwcm9tcHRBbmltYXRlZENvbnRhaW5lciA9IFN5bWJvbCgncHJvbXB0QW5pbWF0ZWRDb250YWluZXInKTtcbmV4cG9ydCBjb25zdCAkZmluZ2VyQW5pbWF0ZWRDb250YWluZXJzID0gU3ltYm9sKCdmaW5nZXJBbmltYXRlZENvbnRhaW5lcnMnKTtcbmNvbnN0ICRkZWZlckludGVyYWN0aW9uUHJvbXB0ID0gU3ltYm9sKCdkZWZlckludGVyYWN0aW9uUHJvbXB0Jyk7XG5jb25zdCAkdXBkYXRlQXJpYSA9IFN5bWJvbCgndXBkYXRlQXJpYScpO1xuY29uc3QgJHVwZGF0ZUNhbWVyYUZvclJhZGl1cyA9IFN5bWJvbCgndXBkYXRlQ2FtZXJhRm9yUmFkaXVzJyk7XG5jb25zdCAkY2FuY2VsUHJvbXB0cyA9IFN5bWJvbCgnY2FuY2VsUHJvbXB0cycpO1xuY29uc3QgJG9uQ2hhbmdlID0gU3ltYm9sKCdvbkNoYW5nZScpO1xuY29uc3QgJG9uUG9pbnRlckNoYW5nZSA9IFN5bWJvbCgnb25Qb2ludGVyQ2hhbmdlJyk7XG5jb25zdCAkd2FpdGluZ1RvUHJvbXB0VXNlciA9IFN5bWJvbCgnd2FpdGluZ1RvUHJvbXB0VXNlcicpO1xuY29uc3QgJHVzZXJIYXNJbnRlcmFjdGVkID0gU3ltYm9sKCd1c2VySGFzSW50ZXJhY3RlZCcpO1xuY29uc3QgJHByb21wdEVsZW1lbnRWaXNpYmxlVGltZSA9IFN5bWJvbCgncHJvbXB0RWxlbWVudFZpc2libGVUaW1lJyk7XG5jb25zdCAkbGFzdFByb21wdE9mZnNldCA9IFN5bWJvbCgnbGFzdFByb21wdE9mZnNldCcpO1xuY29uc3QgJGNhbmNlbGxhdGlvblNvdXJjZSA9IFN5bWJvbCgnY2FuY2VsbGF0aW9uU291cmNlJyk7XG5jb25zdCAkbGFzdFNwaGVyaWNhbCA9IFN5bWJvbCgnbGFzdFNwaGVyaWNhbCcpO1xuY29uc3QgJGp1bXBDYW1lcmEgPSBTeW1ib2woJ2p1bXBDYW1lcmEnKTtcbmNvbnN0ICRpbml0aWFsaXplZCA9IFN5bWJvbCgnaW5pdGlhbGl6ZWQnKTtcbmNvbnN0ICRtYWludGFpblRoZXRhUGhpID0gU3ltYm9sKCdtYWludGFpblRoZXRhUGhpJyk7XG5jb25zdCAkc3luY0NhbWVyYU9yYml0ID0gU3ltYm9sKCdzeW5jQ2FtZXJhT3JiaXQnKTtcbmNvbnN0ICRzeW5jRmllbGRPZlZpZXcgPSBTeW1ib2woJ3N5bmNGaWVsZE9mVmlldycpO1xuY29uc3QgJHN5bmNDYW1lcmFUYXJnZXQgPSBTeW1ib2woJ3N5bmNDYW1lcmFUYXJnZXQnKTtcbmNvbnN0ICRzeW5jTWluQ2FtZXJhT3JiaXQgPSBTeW1ib2woJ3N5bmNNaW5DYW1lcmFPcmJpdCcpO1xuY29uc3QgJHN5bmNNYXhDYW1lcmFPcmJpdCA9IFN5bWJvbCgnc3luY01heENhbWVyYU9yYml0Jyk7XG5jb25zdCAkc3luY01pbkZpZWxkT2ZWaWV3ID0gU3ltYm9sKCdzeW5jTWluRmllbGRPZlZpZXcnKTtcbmNvbnN0ICRzeW5jTWF4RmllbGRPZlZpZXcgPSBTeW1ib2woJ3N5bmNNYXhGaWVsZE9mVmlldycpO1xuZXhwb3J0IGNvbnN0IENvbnRyb2xzTWl4aW4gPSAoTW9kZWxWaWV3ZXJFbGVtZW50KSA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2osIF9rLCBfbCwgX20sIF9vLCBfcCwgX3EsIF9yLCBfcztcbiAgICBjbGFzcyBDb250cm9sc01vZGVsVmlld2VyRWxlbWVudCBleHRlbmRzIE1vZGVsVmlld2VyRWxlbWVudCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHRoaXMuY2FtZXJhQ29udHJvbHMgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuY2FtZXJhT3JiaXQgPSBERUZBVUxUX0NBTUVSQV9PUkJJVDtcbiAgICAgICAgICAgIHRoaXMuY2FtZXJhVGFyZ2V0ID0gREVGQVVMVF9DQU1FUkFfVEFSR0VUO1xuICAgICAgICAgICAgdGhpcy5maWVsZE9mVmlldyA9IERFRkFVTFRfRklFTERfT0ZfVklFVztcbiAgICAgICAgICAgIHRoaXMubWluQ2FtZXJhT3JiaXQgPSAnYXV0byc7XG4gICAgICAgICAgICB0aGlzLm1heENhbWVyYU9yYml0ID0gJ2F1dG8nO1xuICAgICAgICAgICAgdGhpcy5taW5GaWVsZE9mVmlldyA9ICdhdXRvJztcbiAgICAgICAgICAgIHRoaXMubWF4RmllbGRPZlZpZXcgPSAnYXV0byc7XG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uUHJvbXB0VGhyZXNob2xkID0gREVGQVVMVF9JTlRFUkFDVElPTl9QUk9NUFRfVEhSRVNIT0xEO1xuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvblByb21wdCA9IEludGVyYWN0aW9uUHJvbXB0U3RyYXRlZ3kuQVVUTztcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25Qcm9tcHRTdHlsZSA9IEludGVyYWN0aW9uUHJvbXB0U3R5bGUuV0lHR0xFO1xuICAgICAgICAgICAgdGhpcy5vcmJpdFNlbnNpdGl2aXR5ID0gMTtcbiAgICAgICAgICAgIHRoaXMudG91Y2hBY3Rpb24gPSBUb3VjaEFjdGlvbi5OT05FO1xuICAgICAgICAgICAgdGhpcy5kaXNhYmxlWm9vbSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5kaXNhYmxlUGFuID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmRpc2FibGVUYXAgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJwb2xhdGlvbkRlY2F5ID0gREVDQVlfTUlMTElTRUNPTkRTO1xuICAgICAgICAgICAgdGhpc1tfYV0gPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignLmludGVyYWN0aW9uLXByb21wdCcpO1xuICAgICAgICAgICAgdGhpc1tfYl0gPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignI3Byb21wdCcpO1xuICAgICAgICAgICAgdGhpc1tfY10gPSBbXG4gICAgICAgICAgICAgICAgdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJyNmaW5nZXIwJyksXG4gICAgICAgICAgICAgICAgdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJyNmaW5nZXIxJylcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICB0aGlzW19kXSA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCcucGFuLXRhcmdldCcpO1xuICAgICAgICAgICAgdGhpc1tfZV0gPSAwO1xuICAgICAgICAgICAgdGhpc1tfZl0gPSBJbmZpbml0eTtcbiAgICAgICAgICAgIHRoaXNbX2ddID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzW19oXSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpc1tfal0gPSBDaGFuZ2VTb3VyY2UuQVVUT01BVElDO1xuICAgICAgICAgICAgdGhpc1tfa10gPSBuZXcgU21vb3RoQ29udHJvbHModGhpc1skc2NlbmVdLmNhbWVyYSwgdGhpc1skdXNlcklucHV0RWxlbWVudF0sIHRoaXNbJHNjZW5lXSk7XG4gICAgICAgICAgICB0aGlzW19sXSA9IG5ldyBTcGhlcmljYWwoKTtcbiAgICAgICAgICAgIHRoaXNbX21dID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzW19vXSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpc1tfcF0gPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXNbX3FdID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IHRoaXNbJGNvbnRyb2xzXS5jaGFuZ2VTb3VyY2U7XG4gICAgICAgICAgICAgICAgdGhpc1skY2FuY2VsbGF0aW9uU291cmNlXSA9IHNvdXJjZTtcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlID09PSBDaGFuZ2VTb3VyY2UuVVNFUl9JTlRFUkFDVElPTikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzWyR1c2VySGFzSW50ZXJhY3RlZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzWyRkZWZlckludGVyYWN0aW9uUHJvbXB0XSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzW19yXSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzWyR1cGRhdGVBcmlhXSgpO1xuICAgICAgICAgICAgICAgIHRoaXNbJG5lZWRzUmVuZGVyXSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IHRoaXNbJGNvbnRyb2xzXS5jaGFuZ2VTb3VyY2U7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnY2FtZXJhLWNoYW5nZScsIHsgZGV0YWlsOiB7IHNvdXJjZSB9IH0pKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzW19zXSA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC50eXBlID09PSAncG9pbnRlci1jaGFuZ2Utc3RhcnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbJGNvbnRhaW5lcl0uY2xhc3NMaXN0LmFkZCgncG9pbnRlci10dW1ibGluZycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1skY29udGFpbmVyXS5jbGFzc0xpc3QucmVtb3ZlKCdwb2ludGVyLXR1bWJsaW5nJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgaW5wdXRTZW5zaXRpdml0eSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzWyRjb250cm9sc10uaW5wdXRTZW5zaXRpdml0eTtcbiAgICAgICAgfVxuICAgICAgICBzZXQgaW5wdXRTZW5zaXRpdml0eSh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpc1skY29udHJvbHNdLmlucHV0U2Vuc2l0aXZpdHkgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBnZXRDYW1lcmFPcmJpdCgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdGhldGEsIHBoaSwgcmFkaXVzIH0gPSB0aGlzWyRsYXN0U3BoZXJpY2FsXTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdGhldGEsXG4gICAgICAgICAgICAgICAgcGhpLFxuICAgICAgICAgICAgICAgIHJhZGl1cyxcbiAgICAgICAgICAgICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGAke3RoaXMudGhldGF9cmFkICR7dGhpcy5waGl9cmFkICR7dGhpcy5yYWRpdXN9bWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBnZXRDYW1lcmFUYXJnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9WZWN0b3IzRCh0aGlzWyRyZW5kZXJlcl0uaXNQcmVzZW50aW5nID8gdGhpc1skcmVuZGVyZXJdLmFyUmVuZGVyZXIudGFyZ2V0IDpcbiAgICAgICAgICAgICAgICB0aGlzWyRzY2VuZV0uZ2V0VGFyZ2V0KCkpO1xuICAgICAgICB9XG4gICAgICAgIGdldEZpZWxkT2ZWaWV3KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbJGNvbnRyb2xzXS5nZXRGaWVsZE9mVmlldygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByb3ZpZGVkIHNvIHVzZXIgY29kZSBkb2VzIG5vdCBoYXZlIHRvIHBhcnNlIHRoZXNlIGZyb20gYXR0cmlidXRlcy5cbiAgICAgICAgZ2V0TWluaW11bUZpZWxkT2ZWaWV3KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbJGNvbnRyb2xzXS5vcHRpb25zLm1pbmltdW1GaWVsZE9mVmlldztcbiAgICAgICAgfVxuICAgICAgICBnZXRNYXhpbXVtRmllbGRPZlZpZXcoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1skY29udHJvbHNdLm9wdGlvbnMubWF4aW11bUZpZWxkT2ZWaWV3O1xuICAgICAgICB9XG4gICAgICAgIGdldElkZWFsQXNwZWN0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbJHNjZW5lXS5pZGVhbEFzcGVjdDtcbiAgICAgICAgfVxuICAgICAgICBqdW1wQ2FtZXJhVG9Hb2FsKCkge1xuICAgICAgICAgICAgdGhpc1skanVtcENhbWVyYV0gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0VXBkYXRlKCRqdW1wQ2FtZXJhLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzZXRJbnRlcmFjdGlvblByb21wdCgpIHtcbiAgICAgICAgICAgIHRoaXNbJGxhc3RQcm9tcHRPZmZzZXRdID0gMDtcbiAgICAgICAgICAgIHRoaXNbJHByb21wdEVsZW1lbnRWaXNpYmxlVGltZV0gPSBJbmZpbml0eTtcbiAgICAgICAgICAgIHRoaXNbJHVzZXJIYXNJbnRlcmFjdGVkXSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpc1skd2FpdGluZ1RvUHJvbXB0VXNlcl0gPVxuICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25Qcm9tcHQgPT09IEludGVyYWN0aW9uUHJvbXB0U3RyYXRlZ3kuQVVUTyAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbWVyYUNvbnRyb2xzO1xuICAgICAgICB9XG4gICAgICAgIHpvb20oa2V5UHJlc3Nlcykge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgV2hlZWxFdmVudCgnd2hlZWwnLCB7IGRlbHRhWTogLTMwICoga2V5UHJlc3NlcyB9KTtcbiAgICAgICAgICAgIHRoaXNbJHVzZXJJbnB1dEVsZW1lbnRdLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICAgICAgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICAgICAgICAgIHRoaXNbJGNvbnRyb2xzXS5hZGRFdmVudExpc3RlbmVyKCd1c2VyLWludGVyYWN0aW9uJywgdGhpc1skY2FuY2VsUHJvbXB0c10pO1xuICAgICAgICAgICAgdGhpc1skY29udHJvbHNdLmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXItY2hhbmdlLXN0YXJ0JywgdGhpc1skb25Qb2ludGVyQ2hhbmdlXSk7XG4gICAgICAgICAgICB0aGlzWyRjb250cm9sc10uYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlci1jaGFuZ2UtZW5kJywgdGhpc1skb25Qb2ludGVyQ2hhbmdlXSk7XG4gICAgICAgIH1cbiAgICAgICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICAgICBzdXBlci5kaXNjb25uZWN0ZWRDYWxsYmFjaygpO1xuICAgICAgICAgICAgdGhpc1skY29udHJvbHNdLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VzZXItaW50ZXJhY3Rpb24nLCB0aGlzWyRjYW5jZWxQcm9tcHRzXSk7XG4gICAgICAgICAgICB0aGlzWyRjb250cm9sc10ucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlci1jaGFuZ2Utc3RhcnQnLCB0aGlzWyRvblBvaW50ZXJDaGFuZ2VdKTtcbiAgICAgICAgICAgIHRoaXNbJGNvbnRyb2xzXS5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVyLWNoYW5nZS1lbmQnLCB0aGlzWyRvblBvaW50ZXJDaGFuZ2VdKTtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVkKGNoYW5nZWRQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBzdXBlci51cGRhdGVkKGNoYW5nZWRQcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyb2xzID0gdGhpc1skY29udHJvbHNdO1xuICAgICAgICAgICAgY29uc3Qgc2NlbmUgPSB0aGlzWyRzY2VuZV07XG4gICAgICAgICAgICBpZiAoY2hhbmdlZFByb3BlcnRpZXMuaGFzKCdjYW1lcmFDb250cm9scycpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2FtZXJhQ29udHJvbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbHMuZW5hYmxlSW50ZXJhY3Rpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaW50ZXJhY3Rpb25Qcm9tcHQgPT09IEludGVyYWN0aW9uUHJvbXB0U3RyYXRlZ3kuQVVUTykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1skd2FpdGluZ1RvUHJvbXB0VXNlcl0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9scy5kaXNhYmxlSW50ZXJhY3Rpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1skZGVmZXJJbnRlcmFjdGlvblByb21wdF0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpc1skdXNlcklucHV0RWxlbWVudF0uc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgdGhpc1skYXJpYUxhYmVsXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hhbmdlZFByb3BlcnRpZXMuaGFzKCdkaXNhYmxlWm9vbScpKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbHMuZGlzYWJsZVpvb20gPSB0aGlzLmRpc2FibGVab29tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoYW5nZWRQcm9wZXJ0aWVzLmhhcygnZGlzYWJsZVBhbicpKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbHMuZW5hYmxlUGFuID0gIXRoaXMuZGlzYWJsZVBhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGFuZ2VkUHJvcGVydGllcy5oYXMoJ2Rpc2FibGVUYXAnKSkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xzLmVuYWJsZVRhcCA9ICF0aGlzLmRpc2FibGVUYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hhbmdlZFByb3BlcnRpZXMuaGFzKCdpbnRlcmFjdGlvblByb21wdCcpIHx8XG4gICAgICAgICAgICAgICAgY2hhbmdlZFByb3BlcnRpZXMuaGFzKCdjYW1lcmFDb250cm9scycpIHx8XG4gICAgICAgICAgICAgICAgY2hhbmdlZFByb3BlcnRpZXMuaGFzKCdzcmMnKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmludGVyYWN0aW9uUHJvbXB0ID09PSBJbnRlcmFjdGlvblByb21wdFN0cmF0ZWd5LkFVVE8gJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW1lcmFDb250cm9scyAmJiAhdGhpc1skdXNlckhhc0ludGVyYWN0ZWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbJHdhaXRpbmdUb1Byb21wdFVzZXJdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbJGRlZmVySW50ZXJhY3Rpb25Qcm9tcHRdKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoYW5nZWRQcm9wZXJ0aWVzLmhhcygnaW50ZXJhY3Rpb25Qcm9tcHRTdHlsZScpKSB7XG4gICAgICAgICAgICAgICAgdGhpc1skcHJvbXB0QW5pbWF0ZWRDb250YWluZXJdLnN0eWxlLm9wYWNpdHkgPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uUHJvbXB0U3R5bGUgPT0gSW50ZXJhY3Rpb25Qcm9tcHRTdHlsZS5CQVNJQyA/ICcxJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAnMCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hhbmdlZFByb3BlcnRpZXMuaGFzKCd0b3VjaEFjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG91Y2hBY3Rpb24gPSB0aGlzLnRvdWNoQWN0aW9uO1xuICAgICAgICAgICAgICAgIGNvbnRyb2xzLmFwcGx5T3B0aW9ucyh7IHRvdWNoQWN0aW9uIH0pO1xuICAgICAgICAgICAgICAgIGNvbnRyb2xzLnVwZGF0ZVRvdWNoQWN0aW9uU3R5bGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGFuZ2VkUHJvcGVydGllcy5oYXMoJ29yYml0U2Vuc2l0aXZpdHknKSkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xzLm9yYml0U2Vuc2l0aXZpdHkgPSB0aGlzLm9yYml0U2Vuc2l0aXZpdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hhbmdlZFByb3BlcnRpZXMuaGFzKCdpbnRlcnBvbGF0aW9uRGVjYXknKSkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xzLnNldERhbXBlckRlY2F5VGltZSh0aGlzLmludGVycG9sYXRpb25EZWNheSk7XG4gICAgICAgICAgICAgICAgc2NlbmUuc2V0VGFyZ2V0RGFtcGVyRGVjYXlUaW1lKHRoaXMuaW50ZXJwb2xhdGlvbkRlY2F5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzWyRqdW1wQ2FtZXJhXSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9scy5qdW1wVG9Hb2FsKCk7XG4gICAgICAgICAgICAgICAgICAgIHNjZW5lLmp1bXBUb0dvYWwoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1skb25DaGFuZ2VdKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbJGp1bXBDYW1lcmFdID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgdXBkYXRlRnJhbWluZygpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjZW5lID0gdGhpc1skc2NlbmVdO1xuICAgICAgICAgICAgY29uc3Qgb2xkRnJhbWVkRm9WID0gc2NlbmUuYWRqdXN0ZWRGb1Yoc2NlbmUuZnJhbWVkRm9WRGVnKTtcbiAgICAgICAgICAgIGF3YWl0IHNjZW5lLnVwZGF0ZUZyYW1pbmcoKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0ZyYW1lZEZvViA9IHNjZW5lLmFkanVzdGVkRm9WKHNjZW5lLmZyYW1lZEZvVkRlZyk7XG4gICAgICAgICAgICBjb25zdCB6b29tID0gdGhpc1skY29udHJvbHNdLmdldEZpZWxkT2ZWaWV3KCkgLyBvbGRGcmFtZWRGb1Y7XG4gICAgICAgICAgICB0aGlzWyRjb250cm9sc10uc2V0RmllbGRPZlZpZXcobmV3RnJhbWVkRm9WICogem9vbSk7XG4gICAgICAgICAgICB0aGlzWyRtYWludGFpblRoZXRhUGhpXSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RVcGRhdGUoJ21heEZpZWxkT2ZWaWV3Jyk7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RVcGRhdGUoJ2ZpZWxkT2ZWaWV3Jyk7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RVcGRhdGUoJ21pbkNhbWVyYU9yYml0Jyk7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RVcGRhdGUoJ21heENhbWVyYU9yYml0Jyk7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RVcGRhdGUoJ2NhbWVyYU9yYml0Jyk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnVwZGF0ZUNvbXBsZXRlO1xuICAgICAgICB9XG4gICAgICAgIGludGVyYWN0KGR1cmF0aW9uLCBmaW5nZXIwLCBmaW5nZXIxKSB7XG4gICAgICAgICAgICBjb25zdCBpbnB1dEVsZW1lbnQgPSB0aGlzWyR1c2VySW5wdXRFbGVtZW50XTtcbiAgICAgICAgICAgIGNvbnN0IGZpbmdlckVsZW1lbnRzID0gdGhpc1skZmluZ2VyQW5pbWF0ZWRDb250YWluZXJzXTtcbiAgICAgICAgICAgIGlmIChmaW5nZXJFbGVtZW50c1swXS5zdHlsZS5vcGFjaXR5ID09PSAnMScpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2ludGVyYWN0KCkgZmFpbGVkIGJlY2F1c2UgYW4gZXhpc3RpbmcgaW50ZXJhY3Rpb24gaXMgcnVubmluZy4nKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB4eSA9IG5ldyBBcnJheSgpO1xuICAgICAgICAgICAgeHkucHVzaCh7IHg6IHRpbWVsaW5lKGZpbmdlcjAueCksIHk6IHRpbWVsaW5lKGZpbmdlcjAueSkgfSk7XG4gICAgICAgICAgICBjb25zdCBwb3NpdGlvbnMgPSBbeyB4OiB4eVswXS54KDApLCB5OiB4eVswXS55KDApIH1dO1xuICAgICAgICAgICAgaWYgKGZpbmdlcjEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHh5LnB1c2goeyB4OiB0aW1lbGluZShmaW5nZXIxLngpLCB5OiB0aW1lbGluZShmaW5nZXIxLnkpIH0pO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKHsgeDogeHlbMV0ueCgwKSwgeTogeHlbMV0ueSgwKSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdGhpc1skc2NlbmVdO1xuICAgICAgICAgICAgY29uc3QgZGlzcGF0Y2hUb3VjaGVzID0gKHR5cGUpID0+IHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtpLCBwb3NpdGlvbl0gb2YgcG9zaXRpb25zLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHN0eWxlIH0gPSBmaW5nZXJFbGVtZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZVgoJHt3aWR0aCAqIHBvc2l0aW9uLnh9cHgpIHRyYW5zbGF0ZVkoJHtoZWlnaHQgKiBwb3NpdGlvbi55fXB4KWA7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAncG9pbnRlcmRvd24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZS5vcGFjaXR5ID0gJzEnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdwb2ludGVydXAnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZS5vcGFjaXR5ID0gJzAnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluaXQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVySWQ6IGkgLSA1Njc4LFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlclR5cGU6ICd0b3VjaCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IGlucHV0RWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudFg6IHdpZHRoICogcG9zaXRpb24ueCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudFk6IGhlaWdodCAqIHBvc2l0aW9uLnksXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHRLZXk6IHRydWUgLy8gZmxhZyB0aGF0IHRoaXMgaXMgbm90IGEgdXNlciBpbnRlcmFjdGlvblxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpbnB1dEVsZW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgUG9pbnRlckV2ZW50KHR5cGUsIGluaXQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgbW92ZVRvdWNoZXMgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gQ2FuY2VsIGludGVyYWN0aW9uIGlmIHNvbWV0aGluZyBlbHNlIG1vdmVzIHRoZSBjYW1lcmEgb3IgaW5wdXQgaXNcbiAgICAgICAgICAgICAgICAvLyByZW1vdmVkIGZyb20gdGhlIERPTS5cbiAgICAgICAgICAgICAgICBjb25zdCBjaGFuZ2VTb3VyY2UgPSB0aGlzWyRjYW5jZWxsYXRpb25Tb3VyY2VdO1xuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VTb3VyY2UgIT09IENoYW5nZVNvdXJjZS5BVVRPTUFUSUMgfHxcbiAgICAgICAgICAgICAgICAgICAgIWlucHV0RWxlbWVudC5pc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGZpbmdlckVsZW1lbnQgb2YgdGhpc1skZmluZ2VyQW5pbWF0ZWRDb250YWluZXJzXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmluZ2VyRWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gJzAnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoVG91Y2hlcygncG9pbnRlcmNhbmNlbCcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdpbnRlcmFjdC1zdG9wcGVkJywgeyBkZXRhaWw6IHsgc291cmNlOiBjaGFuZ2VTb3VyY2UgfSB9KSk7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCBvblZpc2liaWxpdHlDaGFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHRpbWUgPSBNYXRoLm1pbigxLCAocGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWUpIC8gZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2ksIHBvc2l0aW9uXSBvZiBwb3NpdGlvbnMuZW50cmllcygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uLnggPSB4eVtpXS54KHRpbWUpO1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbi55ID0geHlbaV0ueSh0aW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hUb3VjaGVzKCdwb2ludGVybW92ZScpO1xuICAgICAgICAgICAgICAgIGlmICh0aW1lIDwgMSkge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobW92ZVRvdWNoZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hUb3VjaGVzKCdwb2ludGVydXAnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnaW50ZXJhY3Qtc3RvcHBlZCcsIHsgZGV0YWlsOiB7IHNvdXJjZTogQ2hhbmdlU291cmNlLkFVVE9NQVRJQyB9IH0pKTtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIG9uVmlzaWJpbGl0eUNoYW5nZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IG9uVmlzaWJpbGl0eUNoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgZWxhcHNlZCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ2hpZGRlbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxhcHNlZCA9IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCkgLSBlbGFwc2VkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgb25WaXNpYmlsaXR5Q2hhbmdlKTtcbiAgICAgICAgICAgIGRpc3BhdGNoVG91Y2hlcygncG9pbnRlcmRvd24nKTtcbiAgICAgICAgICAgIHRoaXNbJGNhbmNlbGxhdGlvblNvdXJjZV0gPSBDaGFuZ2VTb3VyY2UuQVVUT01BVElDO1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKG1vdmVUb3VjaGVzKTtcbiAgICAgICAgfVxuICAgICAgICBbKF9hID0gJHByb21wdEVsZW1lbnQsIF9iID0gJHByb21wdEFuaW1hdGVkQ29udGFpbmVyLCBfYyA9ICRmaW5nZXJBbmltYXRlZENvbnRhaW5lcnMsIF9kID0gJHBhbkVsZW1lbnQsIF9lID0gJGxhc3RQcm9tcHRPZmZzZXQsIF9mID0gJHByb21wdEVsZW1lbnRWaXNpYmxlVGltZSwgX2cgPSAkdXNlckhhc0ludGVyYWN0ZWQsIF9oID0gJHdhaXRpbmdUb1Byb21wdFVzZXIsIF9qID0gJGNhbmNlbGxhdGlvblNvdXJjZSwgX2sgPSAkY29udHJvbHMsIF9sID0gJGxhc3RTcGhlcmljYWwsIF9tID0gJGp1bXBDYW1lcmEsIF9vID0gJGluaXRpYWxpemVkLCBfcCA9ICRtYWludGFpblRoZXRhUGhpLCAkc3luY0ZpZWxkT2ZWaWV3KV0oc3R5bGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyb2xzID0gdGhpc1skY29udHJvbHNdO1xuICAgICAgICAgICAgY29uc3Qgc2NlbmUgPSB0aGlzWyRzY2VuZV07XG4gICAgICAgICAgICBzY2VuZS5mcmFtZWRGb1ZEZWcgPSBzdHlsZVswXSAqIDE4MCAvIE1hdGguUEk7XG4gICAgICAgICAgICBjb250cm9scy5jaGFuZ2VTb3VyY2UgPSBDaGFuZ2VTb3VyY2UuTk9ORTtcbiAgICAgICAgICAgIGNvbnRyb2xzLnNldEZpZWxkT2ZWaWV3KHNjZW5lLmFkanVzdGVkRm9WKHNjZW5lLmZyYW1lZEZvVkRlZykpO1xuICAgICAgICAgICAgdGhpc1skY2FuY2VsUHJvbXB0c10oKTtcbiAgICAgICAgfVxuICAgICAgICBbJHN5bmNDYW1lcmFPcmJpdF0oc3R5bGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyb2xzID0gdGhpc1skY29udHJvbHNdO1xuICAgICAgICAgICAgaWYgKHRoaXNbJG1haW50YWluVGhldGFQaGldKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB0aGV0YSwgcGhpIH0gPSB0aGlzLmdldENhbWVyYU9yYml0KCk7XG4gICAgICAgICAgICAgICAgc3R5bGVbMF0gPSB0aGV0YTtcbiAgICAgICAgICAgICAgICBzdHlsZVsxXSA9IHBoaTtcbiAgICAgICAgICAgICAgICB0aGlzWyRtYWludGFpblRoZXRhUGhpXSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udHJvbHMuY2hhbmdlU291cmNlID0gQ2hhbmdlU291cmNlLk5PTkU7XG4gICAgICAgICAgICBjb250cm9scy5zZXRPcmJpdChzdHlsZVswXSwgc3R5bGVbMV0sIHN0eWxlWzJdKTtcbiAgICAgICAgICAgIHRoaXNbJGNhbmNlbFByb21wdHNdKCk7XG4gICAgICAgIH1cbiAgICAgICAgWyRzeW5jTWluQ2FtZXJhT3JiaXRdKHN0eWxlKSB7XG4gICAgICAgICAgICB0aGlzWyRjb250cm9sc10uYXBwbHlPcHRpb25zKHtcbiAgICAgICAgICAgICAgICBtaW5pbXVtQXppbXV0aGFsQW5nbGU6IHN0eWxlWzBdLFxuICAgICAgICAgICAgICAgIG1pbmltdW1Qb2xhckFuZ2xlOiBzdHlsZVsxXSxcbiAgICAgICAgICAgICAgICBtaW5pbXVtUmFkaXVzOiBzdHlsZVsyXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmp1bXBDYW1lcmFUb0dvYWwoKTtcbiAgICAgICAgfVxuICAgICAgICBbJHN5bmNNYXhDYW1lcmFPcmJpdF0oc3R5bGUpIHtcbiAgICAgICAgICAgIHRoaXNbJGNvbnRyb2xzXS5hcHBseU9wdGlvbnMoe1xuICAgICAgICAgICAgICAgIG1heGltdW1BemltdXRoYWxBbmdsZTogc3R5bGVbMF0sXG4gICAgICAgICAgICAgICAgbWF4aW11bVBvbGFyQW5nbGU6IHN0eWxlWzFdLFxuICAgICAgICAgICAgICAgIG1heGltdW1SYWRpdXM6IHN0eWxlWzJdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXNbJHVwZGF0ZUNhbWVyYUZvclJhZGl1c10oc3R5bGVbMl0pO1xuICAgICAgICAgICAgdGhpcy5qdW1wQ2FtZXJhVG9Hb2FsKCk7XG4gICAgICAgIH1cbiAgICAgICAgWyRzeW5jTWluRmllbGRPZlZpZXddKHN0eWxlKSB7XG4gICAgICAgICAgICB0aGlzWyRjb250cm9sc10uYXBwbHlPcHRpb25zKHsgbWluaW11bUZpZWxkT2ZWaWV3OiBzdHlsZVswXSAqIDE4MCAvIE1hdGguUEkgfSk7XG4gICAgICAgICAgICB0aGlzLmp1bXBDYW1lcmFUb0dvYWwoKTtcbiAgICAgICAgfVxuICAgICAgICBbJHN5bmNNYXhGaWVsZE9mVmlld10oc3R5bGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvdiA9IHRoaXNbJHNjZW5lXS5hZGp1c3RlZEZvVihzdHlsZVswXSAqIDE4MCAvIE1hdGguUEkpO1xuICAgICAgICAgICAgdGhpc1skY29udHJvbHNdLmFwcGx5T3B0aW9ucyh7IG1heGltdW1GaWVsZE9mVmlldzogZm92IH0pO1xuICAgICAgICAgICAgdGhpcy5qdW1wQ2FtZXJhVG9Hb2FsKCk7XG4gICAgICAgIH1cbiAgICAgICAgWyRzeW5jQ2FtZXJhVGFyZ2V0XShzdHlsZSkge1xuICAgICAgICAgICAgY29uc3QgW3gsIHksIHpdID0gc3R5bGU7XG4gICAgICAgICAgICBpZiAoIXRoaXNbJHJlbmRlcmVyXS5hclJlbmRlcmVyLmlzUHJlc2VudGluZykge1xuICAgICAgICAgICAgICAgIHRoaXNbJHNjZW5lXS5zZXRUYXJnZXQoeCwgeSwgeik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzWyRjb250cm9sc10uY2hhbmdlU291cmNlID0gQ2hhbmdlU291cmNlLk5PTkU7XG4gICAgICAgICAgICB0aGlzWyRyZW5kZXJlcl0uYXJSZW5kZXJlci51cGRhdGVUYXJnZXQoKTtcbiAgICAgICAgICAgIHRoaXNbJGNhbmNlbFByb21wdHNdKCk7XG4gICAgICAgIH1cbiAgICAgICAgWyR0aWNrXSh0aW1lLCBkZWx0YSkge1xuICAgICAgICAgICAgc3VwZXJbJHRpY2tdKHRpbWUsIGRlbHRhKTtcbiAgICAgICAgICAgIGlmICh0aGlzWyRyZW5kZXJlcl0uaXNQcmVzZW50aW5nIHx8ICF0aGlzWyRnZXRNb2RlbElzVmlzaWJsZV0oKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvbnRyb2xzID0gdGhpc1skY29udHJvbHNdO1xuICAgICAgICAgICAgY29uc3Qgc2NlbmUgPSB0aGlzWyRzY2VuZV07XG4gICAgICAgICAgICBjb25zdCBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgIGlmICh0aGlzWyR3YWl0aW5nVG9Qcm9tcHRVc2VyXSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxvYWRlZCAmJlxuICAgICAgICAgICAgICAgICAgICBub3cgPiB0aGlzWyRsb2FkZWRUaW1lXSArIHRoaXMuaW50ZXJhY3Rpb25Qcm9tcHRUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1skd2FpdGluZ1RvUHJvbXB0VXNlcl0gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1skcHJvbXB0RWxlbWVudFZpc2libGVUaW1lXSA9IG5vdztcbiAgICAgICAgICAgICAgICAgICAgdGhpc1skcHJvbXB0RWxlbWVudF0uY2xhc3NMaXN0LmFkZCgndmlzaWJsZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0Zpbml0ZSh0aGlzWyRwcm9tcHRFbGVtZW50VmlzaWJsZVRpbWVdKSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25Qcm9tcHRTdHlsZSA9PT0gSW50ZXJhY3Rpb25Qcm9tcHRTdHlsZS5XSUdHTEUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhbmltYXRpb25UaW1lID0gKChub3cgLSB0aGlzWyRwcm9tcHRFbGVtZW50VmlzaWJsZVRpbWVdKSAvIFBST01QVF9BTklNQVRJT05fVElNRSkgJVxuICAgICAgICAgICAgICAgICAgICAxO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHdpZ2dsZShhbmltYXRpb25UaW1lKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvcGFjaXR5ID0gZmFkZShhbmltYXRpb25UaW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzWyRwcm9tcHRBbmltYXRlZENvbnRhaW5lcl0uc3R5bGUub3BhY2l0eSA9IGAke29wYWNpdHl9YDtcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0ICE9PSB0aGlzWyRsYXN0UHJvbXB0T2Zmc2V0XSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB4T2Zmc2V0ID0gb2Zmc2V0ICogc2NlbmUud2lkdGggKiAwLjA1O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWx0YVRoZXRhID0gKG9mZnNldCAtIHRoaXNbJGxhc3RQcm9tcHRPZmZzZXRdKSAqIE1hdGguUEkgLyAxNjtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1skcHJvbXB0QW5pbWF0ZWRDb250YWluZXJdLnN0eWxlLnRyYW5zZm9ybSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBgdHJhbnNsYXRlWCgke3hPZmZzZXR9cHgpYDtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbHMuY2hhbmdlU291cmNlID0gQ2hhbmdlU291cmNlLkFVVE9NQVRJQztcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbHMuYWRqdXN0T3JiaXQoZGVsdGFUaGV0YSwgMCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbJGxhc3RQcm9tcHRPZmZzZXRdID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNhbWVyYU1vdmVkID0gY29udHJvbHMudXBkYXRlKHRpbWUsIGRlbHRhKTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldE1vdmVkID0gc2NlbmUudXBkYXRlVGFyZ2V0KGRlbHRhKTtcbiAgICAgICAgICAgIGlmIChjYW1lcmFNb3ZlZCB8fCB0YXJnZXRNb3ZlZCkge1xuICAgICAgICAgICAgICAgIHRoaXNbJG9uQ2hhbmdlXSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFskZGVmZXJJbnRlcmFjdGlvblByb21wdF0oKSB7XG4gICAgICAgICAgICAvLyBFZmZlY3RpdmVseSBjYW5jZWwgdGhlIHRpbWVyIHdhaXRpbmcgZm9yIHVzZXIgaW50ZXJhY3Rpb246XG4gICAgICAgICAgICB0aGlzWyR3YWl0aW5nVG9Qcm9tcHRVc2VyXSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpc1skcHJvbXB0RWxlbWVudF0uY2xhc3NMaXN0LnJlbW92ZSgndmlzaWJsZScpO1xuICAgICAgICAgICAgdGhpc1skcHJvbXB0RWxlbWVudFZpc2libGVUaW1lXSA9IEluZmluaXR5O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGVzIHRoZSBjYW1lcmEncyBuZWFyIGFuZCBmYXIgcGxhbmVzIHRvIGVuY2xvc2UgdGhlIHNjZW5lIHdoZW5cbiAgICAgICAgICogb3JiaXRpbmcgYXQgdGhlIHN1cHBsaWVkIHJhZGl1cy5cbiAgICAgICAgICovXG4gICAgICAgIFskdXBkYXRlQ2FtZXJhRm9yUmFkaXVzXShyYWRpdXMpIHtcbiAgICAgICAgICAgIGNvbnN0IG1heGltdW1SYWRpdXMgPSBNYXRoLm1heCh0aGlzWyRzY2VuZV0uYm91bmRpbmdTcGhlcmUucmFkaXVzLCByYWRpdXMpO1xuICAgICAgICAgICAgY29uc3QgbmVhciA9IDA7XG4gICAgICAgICAgICBjb25zdCBmYXIgPSAyICogbWF4aW11bVJhZGl1cztcbiAgICAgICAgICAgIHRoaXNbJGNvbnRyb2xzXS51cGRhdGVOZWFyRmFyKG5lYXIsIGZhcik7XG4gICAgICAgIH1cbiAgICAgICAgWyR1cGRhdGVBcmlhXSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdGhldGEsIHBoaSB9ID0gdGhpc1skY29udHJvbHNdLmdldENhbWVyYVNwaGVyaWNhbCh0aGlzWyRsYXN0U3BoZXJpY2FsXSk7XG4gICAgICAgICAgICBjb25zdCBhemltdXRoYWxRdWFkcmFudCA9ICg0ICsgTWF0aC5mbG9vcigoKHRoZXRhICUgVEFVKSArIFFVQVJURVJfUEkpIC8gSEFMRl9QSSkpICUgNDtcbiAgICAgICAgICAgIGNvbnN0IHBvbGFyVHJpZW50ID0gTWF0aC5mbG9vcihwaGkgLyBUSElSRF9QSSk7XG4gICAgICAgICAgICBjb25zdCBhemltdXRoYWxRdWFkcmFudExhYmVsID0gQVpJTVVUSEFMX1FVQURSQU5UX0xBQkVMU1themltdXRoYWxRdWFkcmFudF07XG4gICAgICAgICAgICBjb25zdCBwb2xhclRyaWVudExhYmVsID0gUE9MQVJfVFJJRU5UX0xBQkVMU1twb2xhclRyaWVudF07XG4gICAgICAgICAgICB0aGlzWyR1cGRhdGVTdGF0dXNdKGBWaWV3IGZyb20gc3RhZ2UgJHtwb2xhclRyaWVudExhYmVsfSR7YXppbXV0aGFsUXVhZHJhbnRMYWJlbH1gKTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgWyRhcmlhTGFiZWxdKCkge1xuICAgICAgICAgICAgcmV0dXJuIHN1cGVyWyRhcmlhTGFiZWxdLnJlcGxhY2UoL1xcLiQvLCAnJykgK1xuICAgICAgICAgICAgICAgICh0aGlzLmNhbWVyYUNvbnRyb2xzID8gSU5URVJBQ1RJT05fUFJPTVBUIDogJycpO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIFskb25SZXNpemVdKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBjb250cm9scyA9IHRoaXNbJGNvbnRyb2xzXTtcbiAgICAgICAgICAgIGNvbnN0IHNjZW5lID0gdGhpc1skc2NlbmVdO1xuICAgICAgICAgICAgY29uc3Qgb2xkRnJhbWVkRm9WID0gc2NlbmUuYWRqdXN0ZWRGb1Yoc2NlbmUuZnJhbWVkRm9WRGVnKTtcbiAgICAgICAgICAgIC8vIFRoZSBzdXBlciBvZiAkb25SZXNpemUgbWF5IHVwZGF0ZSB0aGUgc2NlbmUncyBhZGp1c3RlZEZvViwgc28gd2VcbiAgICAgICAgICAgIC8vIGNvbXBhcmUgdGhlIGJlZm9yZSBhbmQgYWZ0ZXIgdG8gY2FsY3VsYXRlIHRoZSBwcm9wZXIgem9vbS5cbiAgICAgICAgICAgIHN1cGVyWyRvblJlc2l6ZV0oZXZlbnQpO1xuICAgICAgICAgICAgY29uc3QgZm92UmF0aW8gPSBzY2VuZS5hZGp1c3RlZEZvVihzY2VuZS5mcmFtZWRGb1ZEZWcpIC8gb2xkRnJhbWVkRm9WO1xuICAgICAgICAgICAgY29uc3QgZm92ID0gY29udHJvbHMuZ2V0RmllbGRPZlZpZXcoKSAqIChpc0Zpbml0ZShmb3ZSYXRpbykgPyBmb3ZSYXRpbyA6IDEpO1xuICAgICAgICAgICAgY29udHJvbHMudXBkYXRlQXNwZWN0KHRoaXNbJHNjZW5lXS5hc3BlY3QpO1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0VXBkYXRlKCdtYXhGaWVsZE9mVmlldycsIHRoaXMubWF4RmllbGRPZlZpZXcpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy51cGRhdGVDb21wbGV0ZTtcbiAgICAgICAgICAgIHRoaXNbJGNvbnRyb2xzXS5zZXRGaWVsZE9mVmlldyhmb3YpO1xuICAgICAgICAgICAgdGhpcy5qdW1wQ2FtZXJhVG9Hb2FsKCk7XG4gICAgICAgIH1cbiAgICAgICAgWyRvbk1vZGVsTG9hZF0oKSB7XG4gICAgICAgICAgICBzdXBlclskb25Nb2RlbExvYWRdKCk7XG4gICAgICAgICAgICBpZiAodGhpc1skaW5pdGlhbGl6ZWRdKSB7XG4gICAgICAgICAgICAgICAgdGhpc1skbWFpbnRhaW5UaGV0YVBoaV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpc1skaW5pdGlhbGl6ZWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVxdWVzdFVwZGF0ZSgnbWF4RmllbGRPZlZpZXcnLCB0aGlzLm1heEZpZWxkT2ZWaWV3KTtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdFVwZGF0ZSgnZmllbGRPZlZpZXcnLCB0aGlzLmZpZWxkT2ZWaWV3KTtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdFVwZGF0ZSgnbWluQ2FtZXJhT3JiaXQnLCB0aGlzLm1pbkNhbWVyYU9yYml0KTtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdFVwZGF0ZSgnbWF4Q2FtZXJhT3JiaXQnLCB0aGlzLm1heENhbWVyYU9yYml0KTtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdFVwZGF0ZSgnY2FtZXJhT3JiaXQnLCB0aGlzLmNhbWVyYU9yYml0KTtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdFVwZGF0ZSgnY2FtZXJhVGFyZ2V0JywgdGhpcy5jYW1lcmFUYXJnZXQpO1xuICAgICAgICAgICAgdGhpcy5qdW1wQ2FtZXJhVG9Hb2FsKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3EgPSAkY2FuY2VsUHJvbXB0cywgX3IgPSAkb25DaGFuZ2UsIF9zID0gJG9uUG9pbnRlckNoYW5nZTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgcHJvcGVydHkoeyB0eXBlOiBCb29sZWFuLCBhdHRyaWJ1dGU6ICdjYW1lcmEtY29udHJvbHMnIH0pXG4gICAgXSwgQ29udHJvbHNNb2RlbFZpZXdlckVsZW1lbnQucHJvdG90eXBlLCBcImNhbWVyYUNvbnRyb2xzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHN0eWxlKHtcbiAgICAgICAgICAgIGludHJpbnNpY3M6IGNhbWVyYU9yYml0SW50cmluc2ljcyxcbiAgICAgICAgICAgIG9ic2VydmVFZmZlY3RzOiB0cnVlLFxuICAgICAgICAgICAgdXBkYXRlSGFuZGxlcjogJHN5bmNDYW1lcmFPcmJpdFxuICAgICAgICB9KSxcbiAgICAgICAgcHJvcGVydHkoeyB0eXBlOiBTdHJpbmcsIGF0dHJpYnV0ZTogJ2NhbWVyYS1vcmJpdCcsIGhhc0NoYW5nZWQ6ICgpID0+IHRydWUgfSlcbiAgICBdLCBDb250cm9sc01vZGVsVmlld2VyRWxlbWVudC5wcm90b3R5cGUsIFwiY2FtZXJhT3JiaXRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgc3R5bGUoe1xuICAgICAgICAgICAgaW50cmluc2ljczogY2FtZXJhVGFyZ2V0SW50cmluc2ljcyxcbiAgICAgICAgICAgIG9ic2VydmVFZmZlY3RzOiB0cnVlLFxuICAgICAgICAgICAgdXBkYXRlSGFuZGxlcjogJHN5bmNDYW1lcmFUYXJnZXRcbiAgICAgICAgfSksXG4gICAgICAgIHByb3BlcnR5KHsgdHlwZTogU3RyaW5nLCBhdHRyaWJ1dGU6ICdjYW1lcmEtdGFyZ2V0JywgaGFzQ2hhbmdlZDogKCkgPT4gdHJ1ZSB9KVxuICAgIF0sIENvbnRyb2xzTW9kZWxWaWV3ZXJFbGVtZW50LnByb3RvdHlwZSwgXCJjYW1lcmFUYXJnZXRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgc3R5bGUoe1xuICAgICAgICAgICAgaW50cmluc2ljczogZmllbGRPZlZpZXdJbnRyaW5zaWNzLFxuICAgICAgICAgICAgb2JzZXJ2ZUVmZmVjdHM6IHRydWUsXG4gICAgICAgICAgICB1cGRhdGVIYW5kbGVyOiAkc3luY0ZpZWxkT2ZWaWV3XG4gICAgICAgIH0pLFxuICAgICAgICBwcm9wZXJ0eSh7IHR5cGU6IFN0cmluZywgYXR0cmlidXRlOiAnZmllbGQtb2YtdmlldycsIGhhc0NoYW5nZWQ6ICgpID0+IHRydWUgfSlcbiAgICBdLCBDb250cm9sc01vZGVsVmlld2VyRWxlbWVudC5wcm90b3R5cGUsIFwiZmllbGRPZlZpZXdcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgc3R5bGUoe1xuICAgICAgICAgICAgaW50cmluc2ljczogbWluQ2FtZXJhT3JiaXRJbnRyaW5zaWNzLFxuICAgICAgICAgICAgdXBkYXRlSGFuZGxlcjogJHN5bmNNaW5DYW1lcmFPcmJpdFxuICAgICAgICB9KSxcbiAgICAgICAgcHJvcGVydHkoeyB0eXBlOiBTdHJpbmcsIGF0dHJpYnV0ZTogJ21pbi1jYW1lcmEtb3JiaXQnLCBoYXNDaGFuZ2VkOiAoKSA9PiB0cnVlIH0pXG4gICAgXSwgQ29udHJvbHNNb2RlbFZpZXdlckVsZW1lbnQucHJvdG90eXBlLCBcIm1pbkNhbWVyYU9yYml0XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHN0eWxlKHtcbiAgICAgICAgICAgIGludHJpbnNpY3M6IG1heENhbWVyYU9yYml0SW50cmluc2ljcyxcbiAgICAgICAgICAgIHVwZGF0ZUhhbmRsZXI6ICRzeW5jTWF4Q2FtZXJhT3JiaXRcbiAgICAgICAgfSksXG4gICAgICAgIHByb3BlcnR5KHsgdHlwZTogU3RyaW5nLCBhdHRyaWJ1dGU6ICdtYXgtY2FtZXJhLW9yYml0JywgaGFzQ2hhbmdlZDogKCkgPT4gdHJ1ZSB9KVxuICAgIF0sIENvbnRyb2xzTW9kZWxWaWV3ZXJFbGVtZW50LnByb3RvdHlwZSwgXCJtYXhDYW1lcmFPcmJpdFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBzdHlsZSh7XG4gICAgICAgICAgICBpbnRyaW5zaWNzOiBtaW5GaWVsZE9mVmlld0ludHJpbnNpY3MsXG4gICAgICAgICAgICB1cGRhdGVIYW5kbGVyOiAkc3luY01pbkZpZWxkT2ZWaWV3XG4gICAgICAgIH0pLFxuICAgICAgICBwcm9wZXJ0eSh7IHR5cGU6IFN0cmluZywgYXR0cmlidXRlOiAnbWluLWZpZWxkLW9mLXZpZXcnLCBoYXNDaGFuZ2VkOiAoKSA9PiB0cnVlIH0pXG4gICAgXSwgQ29udHJvbHNNb2RlbFZpZXdlckVsZW1lbnQucHJvdG90eXBlLCBcIm1pbkZpZWxkT2ZWaWV3XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHN0eWxlKHsgaW50cmluc2ljczogZmllbGRPZlZpZXdJbnRyaW5zaWNzLCB1cGRhdGVIYW5kbGVyOiAkc3luY01heEZpZWxkT2ZWaWV3IH0pLFxuICAgICAgICBwcm9wZXJ0eSh7IHR5cGU6IFN0cmluZywgYXR0cmlidXRlOiAnbWF4LWZpZWxkLW9mLXZpZXcnLCBoYXNDaGFuZ2VkOiAoKSA9PiB0cnVlIH0pXG4gICAgXSwgQ29udHJvbHNNb2RlbFZpZXdlckVsZW1lbnQucHJvdG90eXBlLCBcIm1heEZpZWxkT2ZWaWV3XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHByb3BlcnR5KHsgdHlwZTogTnVtYmVyLCBhdHRyaWJ1dGU6ICdpbnRlcmFjdGlvbi1wcm9tcHQtdGhyZXNob2xkJyB9KVxuICAgIF0sIENvbnRyb2xzTW9kZWxWaWV3ZXJFbGVtZW50LnByb3RvdHlwZSwgXCJpbnRlcmFjdGlvblByb21wdFRocmVzaG9sZFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBwcm9wZXJ0eSh7IHR5cGU6IFN0cmluZywgYXR0cmlidXRlOiAnaW50ZXJhY3Rpb24tcHJvbXB0JyB9KVxuICAgIF0sIENvbnRyb2xzTW9kZWxWaWV3ZXJFbGVtZW50LnByb3RvdHlwZSwgXCJpbnRlcmFjdGlvblByb21wdFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBwcm9wZXJ0eSh7IHR5cGU6IFN0cmluZywgYXR0cmlidXRlOiAnaW50ZXJhY3Rpb24tcHJvbXB0LXN0eWxlJyB9KVxuICAgIF0sIENvbnRyb2xzTW9kZWxWaWV3ZXJFbGVtZW50LnByb3RvdHlwZSwgXCJpbnRlcmFjdGlvblByb21wdFN0eWxlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHByb3BlcnR5KHsgdHlwZTogTnVtYmVyLCBhdHRyaWJ1dGU6ICdvcmJpdC1zZW5zaXRpdml0eScgfSlcbiAgICBdLCBDb250cm9sc01vZGVsVmlld2VyRWxlbWVudC5wcm90b3R5cGUsIFwib3JiaXRTZW5zaXRpdml0eVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBwcm9wZXJ0eSh7IHR5cGU6IFN0cmluZywgYXR0cmlidXRlOiAndG91Y2gtYWN0aW9uJyB9KVxuICAgIF0sIENvbnRyb2xzTW9kZWxWaWV3ZXJFbGVtZW50LnByb3RvdHlwZSwgXCJ0b3VjaEFjdGlvblwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBwcm9wZXJ0eSh7IHR5cGU6IEJvb2xlYW4sIGF0dHJpYnV0ZTogJ2Rpc2FibGUtem9vbScgfSlcbiAgICBdLCBDb250cm9sc01vZGVsVmlld2VyRWxlbWVudC5wcm90b3R5cGUsIFwiZGlzYWJsZVpvb21cIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgcHJvcGVydHkoeyB0eXBlOiBCb29sZWFuLCBhdHRyaWJ1dGU6ICdkaXNhYmxlLXBhbicgfSlcbiAgICBdLCBDb250cm9sc01vZGVsVmlld2VyRWxlbWVudC5wcm90b3R5cGUsIFwiZGlzYWJsZVBhblwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBwcm9wZXJ0eSh7IHR5cGU6IEJvb2xlYW4sIGF0dHJpYnV0ZTogJ2Rpc2FibGUtdGFwJyB9KVxuICAgIF0sIENvbnRyb2xzTW9kZWxWaWV3ZXJFbGVtZW50LnByb3RvdHlwZSwgXCJkaXNhYmxlVGFwXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHByb3BlcnR5KHsgdHlwZTogTnVtYmVyLCBhdHRyaWJ1dGU6ICdpbnRlcnBvbGF0aW9uLWRlY2F5JyB9KVxuICAgIF0sIENvbnRyb2xzTW9kZWxWaWV3ZXJFbGVtZW50LnByb3RvdHlwZSwgXCJpbnRlcnBvbGF0aW9uRGVjYXlcIiwgdm9pZCAwKTtcbiAgICByZXR1cm4gQ29udHJvbHNNb2RlbFZpZXdlckVsZW1lbnQ7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udHJvbHMuanMubWFwIiwiLyogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgJ0xpY2Vuc2UnKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAnQVMgSVMnIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuaW1wb3J0IHsgcHJvcGVydHkgfSBmcm9tICdsaXQvZGVjb3JhdG9ycy5qcyc7XG5pbXBvcnQgeyAkbmVlZHNSZW5kZXIsICRwcm9ncmVzc1RyYWNrZXIsICRyZW5kZXJlciwgJHNjZW5lLCAkc2hvdWxkQXR0ZW1wdFByZWxvYWQgfSBmcm9tICcuLi9tb2RlbC12aWV3ZXItYmFzZS5qcyc7XG5pbXBvcnQgeyBjbGFtcCwgZGVzZXJpYWxpemVVcmwgfSBmcm9tICcuLi91dGlsaXRpZXMuanMnO1xuZXhwb3J0IGNvbnN0IEJBU0VfT1BBQ0lUWSA9IDAuNTtcbmNvbnN0IERFRkFVTFRfU0hBRE9XX0lOVEVOU0lUWSA9IDAuMDtcbmNvbnN0IERFRkFVTFRfU0hBRE9XX1NPRlRORVNTID0gMS4wO1xuY29uc3QgREVGQVVMVF9FWFBPU1VSRSA9IDEuMDtcbmV4cG9ydCBjb25zdCAkY3VycmVudEVudmlyb25tZW50TWFwID0gU3ltYm9sKCdjdXJyZW50RW52aXJvbm1lbnRNYXAnKTtcbmV4cG9ydCBjb25zdCAkY3VycmVudEJhY2tncm91bmQgPSBTeW1ib2woJ2N1cnJlbnRCYWNrZ3JvdW5kJyk7XG5leHBvcnQgY29uc3QgJHVwZGF0ZUVudmlyb25tZW50ID0gU3ltYm9sKCd1cGRhdGVFbnZpcm9ubWVudCcpO1xuY29uc3QgJGNhbmNlbEVudmlyb25tZW50VXBkYXRlID0gU3ltYm9sKCdjYW5jZWxFbnZpcm9ubWVudFVwZGF0ZScpO1xuZXhwb3J0IGNvbnN0IEVudmlyb25tZW50TWl4aW4gPSAoTW9kZWxWaWV3ZXJFbGVtZW50KSA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY2xhc3MgRW52aXJvbm1lbnRNb2RlbFZpZXdlckVsZW1lbnQgZXh0ZW5kcyBNb2RlbFZpZXdlckVsZW1lbnQge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgICAgICB0aGlzLmVudmlyb25tZW50SW1hZ2UgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5za3lib3hJbWFnZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnNoYWRvd0ludGVuc2l0eSA9IERFRkFVTFRfU0hBRE9XX0lOVEVOU0lUWTtcbiAgICAgICAgICAgIHRoaXMuc2hhZG93U29mdG5lc3MgPSBERUZBVUxUX1NIQURPV19TT0ZUTkVTUztcbiAgICAgICAgICAgIHRoaXMuZXhwb3N1cmUgPSBERUZBVUxUX0VYUE9TVVJFO1xuICAgICAgICAgICAgdGhpc1tfYV0gPSBudWxsO1xuICAgICAgICAgICAgdGhpc1tfYl0gPSBudWxsO1xuICAgICAgICAgICAgdGhpc1tfY10gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZWQoY2hhbmdlZFByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHN1cGVyLnVwZGF0ZWQoY2hhbmdlZFByb3BlcnRpZXMpO1xuICAgICAgICAgICAgaWYgKGNoYW5nZWRQcm9wZXJ0aWVzLmhhcygnc2hhZG93SW50ZW5zaXR5JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzWyRzY2VuZV0uc2V0U2hhZG93SW50ZW5zaXR5KHRoaXMuc2hhZG93SW50ZW5zaXR5ICogQkFTRV9PUEFDSVRZKTtcbiAgICAgICAgICAgICAgICB0aGlzWyRuZWVkc1JlbmRlcl0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGFuZ2VkUHJvcGVydGllcy5oYXMoJ3NoYWRvd1NvZnRuZXNzJykpIHtcbiAgICAgICAgICAgICAgICB0aGlzWyRzY2VuZV0uc2V0U2hhZG93U29mdG5lc3ModGhpcy5zaGFkb3dTb2Z0bmVzcyk7XG4gICAgICAgICAgICAgICAgdGhpc1skbmVlZHNSZW5kZXJdKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hhbmdlZFByb3BlcnRpZXMuaGFzKCdleHBvc3VyZScpKSB7XG4gICAgICAgICAgICAgICAgdGhpc1skc2NlbmVdLmV4cG9zdXJlID0gdGhpcy5leHBvc3VyZTtcbiAgICAgICAgICAgICAgICB0aGlzWyRuZWVkc1JlbmRlcl0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoY2hhbmdlZFByb3BlcnRpZXMuaGFzKCdlbnZpcm9ubWVudEltYWdlJykgfHxcbiAgICAgICAgICAgICAgICBjaGFuZ2VkUHJvcGVydGllcy5oYXMoJ3NreWJveEltYWdlJykpICYmXG4gICAgICAgICAgICAgICAgdGhpc1skc2hvdWxkQXR0ZW1wdFByZWxvYWRdKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzWyR1cGRhdGVFbnZpcm9ubWVudF0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBoYXNCYWtlZFNoYWRvdygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzWyRzY2VuZV0uYmFrZWRTaGFkb3dzLnNpemUgPiAwO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIFsoX2EgPSAkY3VycmVudEVudmlyb25tZW50TWFwLCBfYiA9ICRjdXJyZW50QmFja2dyb3VuZCwgX2MgPSAkY2FuY2VsRW52aXJvbm1lbnRVcGRhdGUsICR1cGRhdGVFbnZpcm9ubWVudCldKCkge1xuICAgICAgICAgICAgY29uc3QgeyBza3lib3hJbWFnZSwgZW52aXJvbm1lbnRJbWFnZSB9ID0gdGhpcztcbiAgICAgICAgICAgIGlmICh0aGlzWyRjYW5jZWxFbnZpcm9ubWVudFVwZGF0ZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXNbJGNhbmNlbEVudmlyb25tZW50VXBkYXRlXSgpO1xuICAgICAgICAgICAgICAgIHRoaXNbJGNhbmNlbEVudmlyb25tZW50VXBkYXRlXSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHRleHR1cmVVdGlscyB9ID0gdGhpc1skcmVuZGVyZXJdO1xuICAgICAgICAgICAgaWYgKHRleHR1cmVVdGlscyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdXBkYXRlRW52UHJvZ3Jlc3MgPSB0aGlzWyRwcm9ncmVzc1RyYWNrZXJdLmJlZ2luQWN0aXZpdHkoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlbnZpcm9ubWVudE1hcCwgc2t5Ym94IH0gPSBhd2FpdCB0ZXh0dXJlVXRpbHMuZ2VuZXJhdGVFbnZpcm9ubWVudE1hcEFuZFNreWJveChkZXNlcmlhbGl6ZVVybChza3lib3hJbWFnZSksIGVudmlyb25tZW50SW1hZ2UsIChwcm9ncmVzcykgPT4gdXBkYXRlRW52UHJvZ3Jlc3MoY2xhbXAocHJvZ3Jlc3MsIDAsIDEpKSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXNbJGN1cnJlbnRFbnZpcm9ubWVudE1hcF0gIT09IGVudmlyb25tZW50TWFwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbJGN1cnJlbnRFbnZpcm9ubWVudE1hcF0gPSBlbnZpcm9ubWVudE1hcDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnZW52aXJvbm1lbnQtY2hhbmdlJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2t5Ym94ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiB1c2luZyB0aGUgc2FtZSBlbnZpcm9ubWVudCBhbmQgc2t5Ym94LCB1c2UgdGhlIGVudmlyb25tZW50IGFzXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0IGdpdmVzIEhEUiBmaWx0ZXJpbmcuXG4gICAgICAgICAgICAgICAgICAgIHRoaXNbJGN1cnJlbnRCYWNrZ3JvdW5kXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBza3lib3gubmFtZSA9PT0gZW52aXJvbm1lbnRNYXAubmFtZSA/IGVudmlyb25tZW50TWFwIDogc2t5Ym94O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1skY3VycmVudEJhY2tncm91bmRdID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpc1skc2NlbmVdLnNldEVudmlyb25tZW50QW5kU2t5Ym94KHRoaXNbJGN1cnJlbnRFbnZpcm9ubWVudE1hcF0sIHRoaXNbJGN1cnJlbnRCYWNrZ3JvdW5kXSk7XG4gICAgICAgICAgICAgICAgdGhpc1skc2NlbmVdLmRpc3BhdGNoRXZlbnQoeyB0eXBlOiAnZW52bWFwLXVwZGF0ZScgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3JPclByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JPclByb21pc2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzWyRzY2VuZV0uc2V0RW52aXJvbm1lbnRBbmRTa3lib3gobnVsbCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yT3JQcm9taXNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZUVudlByb2dyZXNzKDEuMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHByb3BlcnR5KHsgdHlwZTogU3RyaW5nLCBhdHRyaWJ1dGU6ICdlbnZpcm9ubWVudC1pbWFnZScgfSlcbiAgICBdLCBFbnZpcm9ubWVudE1vZGVsVmlld2VyRWxlbWVudC5wcm90b3R5cGUsIFwiZW52aXJvbm1lbnRJbWFnZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBwcm9wZXJ0eSh7IHR5cGU6IFN0cmluZywgYXR0cmlidXRlOiAnc2t5Ym94LWltYWdlJyB9KVxuICAgIF0sIEVudmlyb25tZW50TW9kZWxWaWV3ZXJFbGVtZW50LnByb3RvdHlwZSwgXCJza3lib3hJbWFnZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBwcm9wZXJ0eSh7IHR5cGU6IE51bWJlciwgYXR0cmlidXRlOiAnc2hhZG93LWludGVuc2l0eScgfSlcbiAgICBdLCBFbnZpcm9ubWVudE1vZGVsVmlld2VyRWxlbWVudC5wcm90b3R5cGUsIFwic2hhZG93SW50ZW5zaXR5XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHByb3BlcnR5KHsgdHlwZTogTnVtYmVyLCBhdHRyaWJ1dGU6ICdzaGFkb3ctc29mdG5lc3MnIH0pXG4gICAgXSwgRW52aXJvbm1lbnRNb2RlbFZpZXdlckVsZW1lbnQucHJvdG90eXBlLCBcInNoYWRvd1NvZnRuZXNzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHByb3BlcnR5KHtcbiAgICAgICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgfSlcbiAgICBdLCBFbnZpcm9ubWVudE1vZGVsVmlld2VyRWxlbWVudC5wcm90b3R5cGUsIFwiZXhwb3N1cmVcIiwgdm9pZCAwKTtcbiAgICByZXR1cm4gRW52aXJvbm1lbnRNb2RlbFZpZXdlckVsZW1lbnQ7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW52aXJvbm1lbnQuanMubWFwIiwiLyogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgJ0xpY2Vuc2UnKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAnQVMgSVMnIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuaW1wb3J0IHsgcHJvcGVydHkgfSBmcm9tICdsaXQvZGVjb3JhdG9ycy5qcyc7XG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgJGFsdERlZmF1bHRlZCwgJGFubm91bmNlTW9kZWxWaXNpYmlsaXR5LCAkZ2V0TW9kZWxJc1Zpc2libGUsICRpc0VsZW1lbnRJblZpZXdwb3J0LCAkcHJvZ3Jlc3NUcmFja2VyLCAkc2NlbmUsICRzaG91bGRBdHRlbXB0UHJlbG9hZCwgJHVwZGF0ZVNvdXJjZSwgJHVzZXJJbnB1dEVsZW1lbnQsIHRvVmVjdG9yM0QgfSBmcm9tICcuLi9tb2RlbC12aWV3ZXItYmFzZS5qcyc7XG5pbXBvcnQgeyAkbG9hZGVyLCBDYWNoaW5nR0xURkxvYWRlciB9IGZyb20gJy4uL3RocmVlLWNvbXBvbmVudHMvQ2FjaGluZ0dMVEZMb2FkZXIuanMnO1xuaW1wb3J0IHsgUmVuZGVyZXIgfSBmcm9tICcuLi90aHJlZS1jb21wb25lbnRzL1JlbmRlcmVyLmpzJztcbmltcG9ydCB7IHRocm90dGxlIH0gZnJvbSAnLi4vdXRpbGl0aWVzLmpzJztcbmV4cG9ydCBjb25zdCBQUk9HUkVTU19CQVJfVVBEQVRFX1RIUkVTSE9MRCA9IDEwMDtcbmNvbnN0IERFRkFVTFRfRFJBQ09fREVDT0RFUl9MT0NBVElPTiA9ICdodHRwczovL3d3dy5nc3RhdGljLmNvbS9kcmFjby92ZXJzaW9uZWQvZGVjb2RlcnMvMS41LjYvJztcbmNvbnN0IERFRkFVTFRfS1RYMl9UUkFOU0NPREVSX0xPQ0FUSU9OID0gJ2h0dHBzOi8vd3d3LmdzdGF0aWMuY29tL2Jhc2lzLXVuaXZlcnNhbC92ZXJzaW9uZWQvMjAyMS0wNC0xNS1iYTFjM2U0Lyc7XG5jb25zdCBERUZBVUxUX0xPVFRJRV9MT0FERVJfTE9DQVRJT04gPSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS90aHJlZUAwLjE0OS4wL2V4YW1wbGVzL2pzbS9sb2FkZXJzL0xvdHRpZUxvYWRlci5qcyc7XG5jb25zdCBSZXZlYWxTdHJhdGVneSA9IHtcbiAgICBBVVRPOiAnYXV0bycsXG4gICAgTUFOVUFMOiAnbWFudWFsJ1xufTtcbmNvbnN0IExvYWRpbmdTdHJhdGVneSA9IHtcbiAgICBBVVRPOiAnYXV0bycsXG4gICAgTEFaWTogJ2xhenknLFxuICAgIEVBR0VSOiAnZWFnZXInXG59O1xuZXhwb3J0IGNvbnN0ICRkZWZhdWx0UHJvZ3Jlc3NCYXJFbGVtZW50ID0gU3ltYm9sKCdkZWZhdWx0UHJvZ3Jlc3NCYXJFbGVtZW50Jyk7XG5leHBvcnQgY29uc3QgJHBvc3RlckNvbnRhaW5lckVsZW1lbnQgPSBTeW1ib2woJ3Bvc3RlckNvbnRhaW5lckVsZW1lbnQnKTtcbmV4cG9ydCBjb25zdCAkZGVmYXVsdFBvc3RlckVsZW1lbnQgPSBTeW1ib2woJ2RlZmF1bHRQb3N0ZXJFbGVtZW50Jyk7XG5jb25zdCAkc2hvdWxkRGlzbWlzc1Bvc3RlciA9IFN5bWJvbCgnc2hvdWxkRGlzbWlzc1Bvc3RlcicpO1xuY29uc3QgJGhpZGVQb3N0ZXIgPSBTeW1ib2woJ2hpZGVQb3N0ZXInKTtcbmNvbnN0ICRtb2RlbElzUmV2ZWFsZWQgPSBTeW1ib2woJ21vZGVsSXNSZXZlYWxlZCcpO1xuY29uc3QgJHVwZGF0ZVByb2dyZXNzQmFyID0gU3ltYm9sKCd1cGRhdGVQcm9ncmVzc0JhcicpO1xuY29uc3QgJGFyaWFMYWJlbENhbGxUb0FjdGlvbiA9IFN5bWJvbCgnYXJpYUxhYmVsQ2FsbFRvQWN0aW9uJyk7XG5jb25zdCAkb25Qcm9ncmVzcyA9IFN5bWJvbCgnb25Qcm9ncmVzcycpO1xuLyoqXG4gKiBMb2FkaW5nTWl4aW4gaW1wbGVtZW50cyBmZWF0dXJlcyByZWxhdGVkIHRvIGxhenkgbG9hZGluZywgYXMgd2VsbCBhc1xuICogcHJlc2VudGF0aW9uIGRldGFpbHMgcmVsYXRlZCB0byB0aGUgcHJlLWxvYWQgLyBwcmUtcmVuZGVyIHByZXNlbnRhdGlvbiBvZiBhXG4gKiA8bW9kZWwtdmlld2VyPlxuICpcbiAqIFRoaXMgbWl4aW4gaW1wbGVtZW50cyBzdXBwb3J0IGZvciBtb2RlbHMgd2l0aCBEUkFDTy1jb21wcmVzc2VkIG1lc2hlcy5cbiAqIFRoZSBEUkFDTyBkZWNvZGVyIHdpbGwgYmUgbG9hZGVkIG9uLWRlbWFuZCBpZiBhIGdsVEYgdGhhdCB1c2VzIHRoZSBEUkFDTyBtZXNoXG4gKiBjb21wcmVzc2lvbiBleHRlbnNpb24gaXMgZW5jb3VudGVyZWQuXG4gKlxuICogQnkgZGVmYXVsdCwgdGhlIERSQUNPIGRlY29kZXIgd2lsbCBiZSBsb2FkZWQgZnJvbSBhIEdvb2dsZSBDRE4uIEl0IGlzXG4gKiBwb3NzaWJsZSB0byBjdXN0b21pemUgd2hlcmUgdGhlIGRlY29kZXIgaXMgbG9hZGVkIGZyb20gYnkgZGVmaW5pbmcgYSBnbG9iYWxcbiAqIGNvbmZpZ3VyYXRpb24gb3B0aW9uIGZvciBgPG1vZGVsLXZpZXdlcj5gIGxpa2Ugc286XG4gKlxuICogYGBgaHRtbFxuICogPHNjcmlwdD5cbiAqIHNlbGYuTW9kZWxWaWV3ZXJFbGVtZW50ID0gc2VsZi5Nb2RlbFZpZXdlckVsZW1lbnQgfHwge307XG4gKiBzZWxmLk1vZGVsVmlld2VyRWxlbWVudC5kcmFjb0RlY29kZXJMb2NhdGlvbiA9XG4gKiAgICAgJ2h0dHA6Ly9leGFtcGxlLmNvbS9sb2NhdGlvbi9vZi9kcmFjby9kZWNvZGVyL2ZpbGVzLyc7XG4gKiA8L3NjcmlwdD5cbiAqIGBgYFxuICpcbiAqIE5vdGUgdGhhdCB0aGUgYWJvdmUgY29uZmlndXJhdGlvbiBzdHJhdGVneSBtdXN0IGJlIHBlcmZvcm1lZCAqYmVmb3JlKiB0aGVcbiAqIGZpcnN0IGA8bW9kZWwtdmlld2VyPmAgZWxlbWVudCBpcyBjcmVhdGVkIGluIHRoZSBicm93c2VyLiBUaGUgY29uZmlndXJhdGlvblxuICogY2FuIGJlIGRvbmUgYW55d2hlcmUsIGJ1dCB0aGUgZWFzaWVzdCB3YXkgdG8gZW5zdXJlIGl0IGlzIGRvbmUgYXQgdGhlIHJpZ2h0XG4gKiB0aW1lIGlzIHRvIGRvIGl0IGluIHRoZSBgPGhlYWQ+YCBvZiB0aGUgSFRNTCBkb2N1bWVudC4gVGhpcyBpcyB0aGVcbiAqIHJlY29tbWVuZGVkIHdheSB0byBzZXQgdGhlIGxvY2F0aW9uIGJlY2F1c2UgaXQgaXMgbW9zdCBjb21wYXRpYmxlIHdpdGhcbiAqIHNjZW5hcmlvcyB3aGVyZSB0aGUgYDxtb2RlbC12aWV3ZXI+YCBsaWJyYXJ5IGlzIGxhemlseSBsb2FkZWQuXG4gKlxuICogSWYgeW91IGFic29sdXRlbHkgaGF2ZSB0byBzZXQgdGhlIERSQUNPIGRlY29kZXIgbG9jYXRpb24gKmFmdGVyKiB0aGUgZmlyc3RcbiAqIGA8bW9kZWwtdmlld2VyPmAgZWxlbWVudCBpcyBjcmVhdGVkLCB5b3UgY2FuIGRvIGl0IHRoaXMgd2F5OlxuICpcbiAqIGBgYGh0bWxcbiAqIDxzY3JpcHQ+XG4gKiBjb25zdCBNb2RlbFZpZXdlckVsZW1lbnQgPSBjdXN0b21FbGVtZW50cy5nZXQoJ21vZGVsLXZpZXdlcicpO1xuICogTW9kZWxWaWV3ZXJFbGVtZW50LmRyYWNvRGVjb2RlckxvY2F0aW9uID1cbiAqICAgICAnaHR0cDovL2V4YW1wbGUuY29tL2xvY2F0aW9uL29mL2RyYWNvL2RlY29kZXIvZmlsZXMvJztcbiAqIDwvc2NyaXB0PlxuICogYGBgXG4gKlxuICogTm90ZSB0aGF0IHRoZSBhYm92ZSBjb25maWd1cmF0aW9uIGFwcHJvYWNoIHdpbGwgbm90IHdvcmsgdW50aWwgKmFmdGVyKlxuICogYDxtb2RlbC12aWV3ZXI+YCBpcyBkZWZpbmVkIGluIHRoZSBicm93c2VyLiBBbHNvIG5vdGUgdGhhdCB0aGlzIGNvbmZpZ3VyYXRpb25cbiAqICptdXN0KiBiZSBzZXQgKmJlZm9yZSogdGhlIGZpcnN0IERSQUNPIG1vZGVsIGlzIGZ1bGx5IGxvYWRlZC5cbiAqXG4gKiBJdCBpcyByZWNvbW1lbmRlZCB0aGF0IHVzZXJzIHdobyBpbnRlbmQgdG8gdGFrZSBhZHZhbnRhZ2Ugb2YgRFJBQ08gbWVzaFxuICogY29tcHJlc3Npb24gY29uc2lkZXIgd2hldGhlciBvciBub3QgaXQgaXMgYWNjZXB0YWJsZSBmb3IgdGhlaXIgdXNlIGNhc2UgdG9cbiAqIGhhdmUgY29kZSBzaWRlLWxvYWRlZCBmcm9tIGEgR29vZ2xlIENETi4gSWYgaXQgaXMgbm90IGFjY2VwdGFibGUsIHRoZW4gdGhlXG4gKiBsb2NhdGlvbiBtdXN0IGJlIGN1c3RvbWl6ZWQgYmVmb3JlIGxvYWRpbmcgYW55IERSQUNPIG1vZGVscyBpbiBvcmRlciB0byBjYXVzZVxuICogdGhlIGRlY29kZXIgdG8gYmUgbG9hZGVkIGZyb20gYW4gYWx0ZXJuYXRpdmUsIGFjY2VwdGFibGUgbG9jYXRpb24uXG4gKi9cbmV4cG9ydCBjb25zdCBMb2FkaW5nTWl4aW4gPSAoTW9kZWxWaWV3ZXJFbGVtZW50KSA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcbiAgICBjbGFzcyBMb2FkaW5nTW9kZWxWaWV3ZXJFbGVtZW50IGV4dGVuZHMgTW9kZWxWaWV3ZXJFbGVtZW50IHtcbiAgICAgICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEEgVVJMIHBvaW50aW5nIHRvIHRoZSBpbWFnZSB0byB1c2UgYXMgYSBwb3N0ZXIgaW4gc2NlbmFyaW9zIHdoZXJlIHRoZVxuICAgICAgICAgICAgICogPG1vZGVsLXZpZXdlcj4gaXMgbm90IHJlYWR5IHRvIHJldmVhbCBhIHJlbmRlcmVkIG1vZGVsIHRvIHRoZSB2aWV3ZXIuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMucG9zdGVyID0gbnVsbDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQW4gZW51bWVyYWJsZSBhdHRyaWJ1dGUgZGVzY3JpYmluZyB1bmRlciB3aGF0IGNvbmRpdGlvbnMgdGhlXG4gICAgICAgICAgICAgKiA8bW9kZWwtdmlld2VyPiBzaG91bGQgcmV2ZWFsIGEgbW9kZWwgdG8gdGhlIHZpZXdlci5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBcImF1dG9cIi4gVGhlIG9ubHkgc3VwcG9ydGVkIGFsdGVybmF0aXZlIHZhbHVlcyBpc1xuICAgICAgICAgICAgICogXCJtYW51YWxcIi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5yZXZlYWwgPSBSZXZlYWxTdHJhdGVneS5BVVRPO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBbiBlbnVtZXJhYmxlIGF0dHJpYnV0ZSBkZXNjcmliaW5nIHVuZGVyIHdoYXQgY29uZGl0aW9ucyB0aGVcbiAgICAgICAgICAgICAqIDxtb2RlbC12aWV3ZXI+IHNob3VsZCBwcmVsb2FkIGEgbW9kZWwuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgXCJhdXRvXCIuIFRoZSBvbmx5IHN1cHBvcnRlZCBhbHRlcm5hdGl2ZSB2YWx1ZXMgYXJlXG4gICAgICAgICAgICAgKiBcImxhenlcIiBhbmQgXCJlYWdlclwiLiBBdXRvIGlzIGVxdWl2YWxlbnQgdG8gbGF6eSwgd2hpY2ggbG9hZHMgdGhlIG1vZGVsXG4gICAgICAgICAgICAgKiB3aGVuIGl0IGlzIG5lYXIgdGhlIHZpZXdwb3J0IGZvciByZXZlYWwgPSBcImF1dG9cIiwgYW5kIHdoZW4gaW50ZXJhY3RlZFxuICAgICAgICAgICAgICogd2l0aCBmb3IgcmV2ZWFsID0gXCJpbnRlcmFjdGlvblwiLiBFYWdlciBsb2FkcyB0aGUgbW9kZWwgaW1tZWRpYXRlbHkuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMubG9hZGluZyA9IExvYWRpbmdTdHJhdGVneS5BVVRPO1xuICAgICAgICAgICAgdGhpc1tfYV0gPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXNbX2JdID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBUT0RPOiBBZGQgdGhpcyB0byB0aGUgc2hhZG93IHJvb3QgYXMgcGFydCBvZiB0aGlzIG1peGluJ3NcbiAgICAgICAgICAgIC8vIGltcGxlbWVudGF0aW9uOlxuICAgICAgICAgICAgdGhpc1tfY10gPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignLnNsb3QucG9zdGVyJyk7XG4gICAgICAgICAgICB0aGlzW19kXSA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCcjZGVmYXVsdC1wb3N0ZXInKTtcbiAgICAgICAgICAgIHRoaXNbX2VdID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJyNkZWZhdWx0LXByb2dyZXNzLWJhciA+IC5iYXInKTtcbiAgICAgICAgICAgIHRoaXNbX2ZdID0gdGhpc1skZGVmYXVsdFBvc3RlckVsZW1lbnRdLmdldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcpO1xuICAgICAgICAgICAgdGhpc1tfZ10gPSB0aHJvdHRsZSgocHJvZ3Jlc3MpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnROb2RlID0gdGhpc1skZGVmYXVsdFByb2dyZXNzQmFyRWxlbWVudF0ucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzWyRkZWZhdWx0UHJvZ3Jlc3NCYXJFbGVtZW50XS5zdHlsZS50cmFuc2Zvcm0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgYHNjYWxlWCgke3Byb2dyZXNzfSlgO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvZ3Jlc3MgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5PVEUoY2RhdGEpOiBXZSByZW1vdmUgYW5kIHJlLWFwcGVuZCB0aGUgcHJvZ3Jlc3MgYmFyIGluIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbmRpdGlvbiBzbyB0aGF0IHRoZSBwcm9ncmVzcyBiYXIgZG9lcyBub3QgYXBwZWFyIHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0cmFuc2l0aW9uIGJhY2t3YXJkcyBmcm9tIHRoZSByaWdodCB3aGVuIHdlIHJlc2V0IHRvIDAgKG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgPDEpIHByb2dyZXNzIGFmdGVyIGhhdmluZyBhbHJlYWR5IHJlYWNoZWQgMSBwcm9ncmVzc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJldmlvdXNseS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpc1skZGVmYXVsdFByb2dyZXNzQmFyRWxlbWVudF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh0aGlzWyRkZWZhdWx0UHJvZ3Jlc3NCYXJFbGVtZW50XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gTk9URShjZGF0YSk6IElFMTEgZG9lcyBub3QgcHJvcGVybHkgcmVzcGVjdCB0aGUgc2Vjb25kIHBhcmFtZXRlclxuICAgICAgICAgICAgICAgICAgICAvLyBvZiBjbGFzc0xpc3QudG9nZ2xlLCB3aGljaCB0aGlzIGltcGxlbWVudGF0aW9uIG9yaWdpbmFsbHkgdXNlZC5cbiAgICAgICAgICAgICAgICAgICAgLy8gQHNlZSBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL2VuLXVzL21pY3Jvc29mdC1lZGdlL3BsYXRmb3JtL2lzc3Vlcy8xMTg2NTg2NS9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2dyZXNzID09PSAxLjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbJGRlZmF1bHRQcm9ncmVzc0JhckVsZW1lbnRdLmNsYXNzTGlzdC5hZGQoJ2hpZGUnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbJGRlZmF1bHRQcm9ncmVzc0JhckVsZW1lbnRdLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGUnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgUFJPR1JFU1NfQkFSX1VQREFURV9USFJFU0hPTEQpO1xuICAgICAgICAgICAgdGhpc1tfaF0gPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9ncmVzcyA9IGV2ZW50LmRldGFpbC50b3RhbFByb2dyZXNzO1xuICAgICAgICAgICAgICAgIGlmIChwcm9ncmVzcyA9PT0gMS4wKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbJHVwZGF0ZVByb2dyZXNzQmFyXS5mbHVzaCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5sb2FkZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzWyRzaG91bGREaXNtaXNzUG9zdGVyXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmV2ZWFsID09PSBSZXZlYWxTdHJhdGVneS5BVVRPKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1skaGlkZVBvc3Rlcl0oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzWyR1cGRhdGVQcm9ncmVzc0Jhcl0ocHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ3Byb2dyZXNzJywgeyBkZXRhaWw6IHsgdG90YWxQcm9ncmVzczogcHJvZ3Jlc3MgfSB9KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgTW9kZWxWaWV3ZXJFbGVtZW50ID0gc2VsZi5Nb2RlbFZpZXdlckVsZW1lbnQgfHwge307XG4gICAgICAgICAgICBjb25zdCBkcmFjb0RlY29kZXJMb2NhdGlvbiA9IE1vZGVsVmlld2VyRWxlbWVudC5kcmFjb0RlY29kZXJMb2NhdGlvbiB8fFxuICAgICAgICAgICAgICAgIERFRkFVTFRfRFJBQ09fREVDT0RFUl9MT0NBVElPTjtcbiAgICAgICAgICAgIENhY2hpbmdHTFRGTG9hZGVyLnNldERSQUNPRGVjb2RlckxvY2F0aW9uKGRyYWNvRGVjb2RlckxvY2F0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IGt0eDJUcmFuc2NvZGVyTG9jYXRpb24gPSBNb2RlbFZpZXdlckVsZW1lbnQua3R4MlRyYW5zY29kZXJMb2NhdGlvbiB8fFxuICAgICAgICAgICAgICAgIERFRkFVTFRfS1RYMl9UUkFOU0NPREVSX0xPQ0FUSU9OO1xuICAgICAgICAgICAgQ2FjaGluZ0dMVEZMb2FkZXIuc2V0S1RYMlRyYW5zY29kZXJMb2NhdGlvbihrdHgyVHJhbnNjb2RlckxvY2F0aW9uKTtcbiAgICAgICAgICAgIGlmIChNb2RlbFZpZXdlckVsZW1lbnQubWVzaG9wdERlY29kZXJMb2NhdGlvbikge1xuICAgICAgICAgICAgICAgIENhY2hpbmdHTFRGTG9hZGVyLnNldE1lc2hvcHREZWNvZGVyTG9jYXRpb24oTW9kZWxWaWV3ZXJFbGVtZW50Lm1lc2hvcHREZWNvZGVyTG9jYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG90dGllTG9hZGVyTG9jYXRpb24gPSBNb2RlbFZpZXdlckVsZW1lbnQubG90dGllTG9hZGVyTG9jYXRpb24gfHxcbiAgICAgICAgICAgICAgICBERUZBVUxUX0xPVFRJRV9MT0FERVJfTE9DQVRJT047XG4gICAgICAgICAgICBSZW5kZXJlci5zaW5nbGV0b24udGV4dHVyZVV0aWxzLmxvdHRpZUxvYWRlclVybCA9IGxvdHRpZUxvYWRlckxvY2F0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBzZXQgZHJhY29EZWNvZGVyTG9jYXRpb24odmFsdWUpIHtcbiAgICAgICAgICAgIENhY2hpbmdHTFRGTG9hZGVyLnNldERSQUNPRGVjb2RlckxvY2F0aW9uKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZ2V0IGRyYWNvRGVjb2RlckxvY2F0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIENhY2hpbmdHTFRGTG9hZGVyLmdldERSQUNPRGVjb2RlckxvY2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIHNldCBrdHgyVHJhbnNjb2RlckxvY2F0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBDYWNoaW5nR0xURkxvYWRlci5zZXRLVFgyVHJhbnNjb2RlckxvY2F0aW9uKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZ2V0IGt0eDJUcmFuc2NvZGVyTG9jYXRpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gQ2FjaGluZ0dMVEZMb2FkZXIuZ2V0S1RYMlRyYW5zY29kZXJMb2NhdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBzZXQgbWVzaG9wdERlY29kZXJMb2NhdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgQ2FjaGluZ0dMVEZMb2FkZXIuc2V0TWVzaG9wdERlY29kZXJMb2NhdGlvbih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGdldCBtZXNob3B0RGVjb2RlckxvY2F0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIENhY2hpbmdHTFRGTG9hZGVyLmdldE1lc2hvcHREZWNvZGVyTG9jYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgc2V0IGxvdHRpZUxvYWRlckxvY2F0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBSZW5kZXJlci5zaW5nbGV0b24udGV4dHVyZVV0aWxzLmxvdHRpZUxvYWRlclVybCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBnZXQgbG90dGllTG9hZGVyTG9jYXRpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gUmVuZGVyZXIuc2luZ2xldG9uLnRleHR1cmVVdGlscy5sb3R0aWVMb2FkZXJVcmw7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBwYXNzZWQgZWFjaCByZXNvdXJjZSBVUkwgYmVmb3JlIGFcbiAgICAgICAgICogcmVxdWVzdCBpcyBzZW50LiBUaGUgY2FsbGJhY2sgbWF5IHJldHVybiB0aGUgb3JpZ2luYWwgVVJMLCBvciBhIG5ldyBVUkxcbiAgICAgICAgICogdG8gb3ZlcnJpZGUgbG9hZGluZyBiZWhhdmlvci4gVGhpcyBiZWhhdmlvciBjYW4gYmUgdXNlZCB0byBsb2FkIGFzc2V0c1xuICAgICAgICAgKiBmcm9tIC5aSVAgZmlsZXMsIGRyYWctYW5kLWRyb3AgQVBJcywgYW5kIERhdGEgVVJJcy5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBtYXBVUkxzKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBSZW5kZXJlci5zaW5nbGV0b24ubG9hZGVyWyRsb2FkZXJdLm1hbmFnZXIuc2V0VVJMTW9kaWZpZXIoY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNtaXNzZXMgdGhlIHBvc3RlciwgY2F1c2luZyB0aGUgbW9kZWwgdG8gbG9hZCBhbmQgcmVuZGVyIGlmXG4gICAgICAgICAqIG5lY2Vzc2FyeS4gVGhpcyBpcyBjdXJyZW50bHkgZWZmZWN0aXZlbHkgdGhlIHNhbWUgYXMgaW50ZXJhY3Rpbmcgd2l0aFxuICAgICAgICAgKiB0aGUgcG9zdGVyIHZpYSB1c2VyIGlucHV0LlxuICAgICAgICAgKi9cbiAgICAgICAgZGlzbWlzc1Bvc3RlcigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxvYWRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXNbJGhpZGVQb3N0ZXJdKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzWyRzaG91bGREaXNtaXNzUG9zdGVyXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpc1skdXBkYXRlU291cmNlXSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwbGF5cyB0aGUgcG9zdGVyLCBoaWRpbmcgdGhlIDNEIG1vZGVsLiBJZiB0aGlzIGlzIGNhbGxlZCBhZnRlciB0aGUgM0RcbiAgICAgICAgICogbW9kZWwgaGFzIGJlZW4gcmV2ZWFsZWQsIHRoZW4gaXQgbXVzdCBiZSBkaXNtaXNzZWQgYnkgYSBjYWxsIHRvXG4gICAgICAgICAqIGRpc21pc3NQb3N0ZXIoKS5cbiAgICAgICAgICovXG4gICAgICAgIHNob3dQb3N0ZXIoKSB7XG4gICAgICAgICAgICBjb25zdCBwb3N0ZXJDb250YWluZXJFbGVtZW50ID0gdGhpc1skcG9zdGVyQ29udGFpbmVyRWxlbWVudF07XG4gICAgICAgICAgICBpZiAocG9zdGVyQ29udGFpbmVyRWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ3Nob3cnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvc3RlckNvbnRhaW5lckVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnc2hvdycpO1xuICAgICAgICAgICAgdGhpc1skdXNlcklucHV0RWxlbWVudF0uY2xhc3NMaXN0LnJlbW92ZSgnc2hvdycpO1xuICAgICAgICAgICAgY29uc3QgZGVmYXVsdFBvc3RlckVsZW1lbnQgPSB0aGlzWyRkZWZhdWx0UG9zdGVyRWxlbWVudF07XG4gICAgICAgICAgICBkZWZhdWx0UG9zdGVyRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgICAgICAgICBkZWZhdWx0UG9zdGVyRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJyk7XG4gICAgICAgICAgICBjb25zdCBvbGRWaXNpYmlsaXR5ID0gdGhpcy5tb2RlbElzVmlzaWJsZTtcbiAgICAgICAgICAgIHRoaXNbJG1vZGVsSXNSZXZlYWxlZF0gPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXNbJGFubm91bmNlTW9kZWxWaXNpYmlsaXR5XShvbGRWaXNpYmlsaXR5KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgbW9kZWwncyBib3VuZGluZyBib3ggZGltZW5zaW9ucyBpbiBtZXRlcnMsIGluZGVwZW5kZW50IG9mXG4gICAgICAgICAqIHR1cm50YWJsZSByb3RhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIGdldERpbWVuc2lvbnMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9WZWN0b3IzRCh0aGlzWyRzY2VuZV0uc2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0Qm91bmRpbmdCb3hDZW50ZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9WZWN0b3IzRCh0aGlzWyRzY2VuZV0uYm91bmRpbmdCb3guZ2V0Q2VudGVyKG5ldyBWZWN0b3IzKCkpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgICAgIHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMubG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaG93UG9zdGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzWyRwcm9ncmVzc1RyYWNrZXJdLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgdGhpc1skb25Qcm9ncmVzc10pO1xuICAgICAgICB9XG4gICAgICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICAgICAgc3VwZXIuZGlzY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICAgICAgICAgIHRoaXNbJHByb2dyZXNzVHJhY2tlcl0ucmVtb3ZlRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCB0aGlzWyRvblByb2dyZXNzXSk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgdXBkYXRlZChjaGFuZ2VkUHJvcGVydGllcykge1xuICAgICAgICAgICAgc3VwZXIudXBkYXRlZChjaGFuZ2VkUHJvcGVydGllcyk7XG4gICAgICAgICAgICBpZiAoY2hhbmdlZFByb3BlcnRpZXMuaGFzKCdwb3N0ZXInKSAmJiB0aGlzLnBvc3RlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpc1skZGVmYXVsdFBvc3RlckVsZW1lbnRdLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9XG4gICAgICAgICAgICAgICAgICAgIGB1cmwoJHt0aGlzLnBvc3Rlcn0pYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGFuZ2VkUHJvcGVydGllcy5oYXMoJ2FsdCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpc1skZGVmYXVsdFBvc3RlckVsZW1lbnRdLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIHRoaXNbJGFsdERlZmF1bHRlZF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoYW5nZWRQcm9wZXJ0aWVzLmhhcygncmV2ZWFsJykgfHwgY2hhbmdlZFByb3BlcnRpZXMuaGFzKCdsb2FkaW5nJykpIHtcbiAgICAgICAgICAgICAgICB0aGlzWyR1cGRhdGVTb3VyY2VdKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgWyhfYSA9ICRtb2RlbElzUmV2ZWFsZWQsIF9iID0gJHNob3VsZERpc21pc3NQb3N0ZXIsIF9jID0gJHBvc3RlckNvbnRhaW5lckVsZW1lbnQsIF9kID0gJGRlZmF1bHRQb3N0ZXJFbGVtZW50LCBfZSA9ICRkZWZhdWx0UHJvZ3Jlc3NCYXJFbGVtZW50LCBfZiA9ICRhcmlhTGFiZWxDYWxsVG9BY3Rpb24sIF9nID0gJHVwZGF0ZVByb2dyZXNzQmFyLCBfaCA9ICRvblByb2dyZXNzLCAkc2hvdWxkQXR0ZW1wdFByZWxvYWQpXSgpIHtcbiAgICAgICAgICAgIHJldHVybiAhIXRoaXMuc3JjICYmXG4gICAgICAgICAgICAgICAgKHRoaXNbJHNob3VsZERpc21pc3NQb3N0ZXJdIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9hZGluZyA9PT0gTG9hZGluZ1N0cmF0ZWd5LkVBR0VSIHx8XG4gICAgICAgICAgICAgICAgICAgICh0aGlzLnJldmVhbCA9PT0gUmV2ZWFsU3RyYXRlZ3kuQVVUTyAmJiB0aGlzWyRpc0VsZW1lbnRJblZpZXdwb3J0XSkpO1xuICAgICAgICB9XG4gICAgICAgIFskaGlkZVBvc3Rlcl0oKSB7XG4gICAgICAgICAgICB0aGlzWyRzaG91bGREaXNtaXNzUG9zdGVyXSA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgcG9zdGVyQ29udGFpbmVyRWxlbWVudCA9IHRoaXNbJHBvc3RlckNvbnRhaW5lckVsZW1lbnRdO1xuICAgICAgICAgICAgaWYgKCFwb3N0ZXJDb250YWluZXJFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnc2hvdycpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zdGVyQ29udGFpbmVyRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdzaG93Jyk7XG4gICAgICAgICAgICB0aGlzWyR1c2VySW5wdXRFbGVtZW50XS5jbGFzc0xpc3QuYWRkKCdzaG93Jyk7XG4gICAgICAgICAgICBjb25zdCBvbGRWaXNpYmlsaXR5ID0gdGhpcy5tb2RlbElzVmlzaWJsZTtcbiAgICAgICAgICAgIHRoaXNbJG1vZGVsSXNSZXZlYWxlZF0gPSB0cnVlO1xuICAgICAgICAgICAgdGhpc1skYW5ub3VuY2VNb2RlbFZpc2liaWxpdHldKG9sZFZpc2liaWxpdHkpO1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IHRoaXMuZ2V0Um9vdE5vZGUoKTtcbiAgICAgICAgICAgIC8vIElmIHRoZSA8bW9kZWwtdmlld2VyPiBpcyBzdGlsbCBmb2N1c2VkLCBmb3J3YXJkIHRoZSBmb2N1cyB0b1xuICAgICAgICAgICAgLy8gdGhlIGNhbnZhcyB0aGF0IGhhcyBqdXN0IGJlZW4gcmV2ZWFsZWRcbiAgICAgICAgICAgIGlmIChyb290ICYmIHJvb3QuYWN0aXZlRWxlbWVudCA9PT0gdGhpcykge1xuICAgICAgICAgICAgICAgIHRoaXNbJHVzZXJJbnB1dEVsZW1lbnRdLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgcG9zdGVyIGlzIG5vIGxvbmdlciBmb2N1c2FibGUgb3IgdmlzaWJsZSB0b1xuICAgICAgICAgICAgLy8gc2NyZWVuIHJlYWRlcnNcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRQb3N0ZXJFbGVtZW50ID0gdGhpc1skZGVmYXVsdFBvc3RlckVsZW1lbnRdO1xuICAgICAgICAgICAgZGVmYXVsdFBvc3RlckVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG4gICAgICAgICAgICBkZWZhdWx0UG9zdGVyRWxlbWVudC50YWJJbmRleCA9IC0xO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgncG9zdGVyLWRpc21pc3NlZCcpKTtcbiAgICAgICAgfVxuICAgICAgICBbJGdldE1vZGVsSXNWaXNpYmxlXSgpIHtcbiAgICAgICAgICAgIHJldHVybiBzdXBlclskZ2V0TW9kZWxJc1Zpc2libGVdKCkgJiYgdGhpc1skbW9kZWxJc1JldmVhbGVkXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgcHJvcGVydHkoeyB0eXBlOiBTdHJpbmcgfSlcbiAgICBdLCBMb2FkaW5nTW9kZWxWaWV3ZXJFbGVtZW50LnByb3RvdHlwZSwgXCJwb3N0ZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgcHJvcGVydHkoeyB0eXBlOiBTdHJpbmcgfSlcbiAgICBdLCBMb2FkaW5nTW9kZWxWaWV3ZXJFbGVtZW50LnByb3RvdHlwZSwgXCJyZXZlYWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgcHJvcGVydHkoeyB0eXBlOiBTdHJpbmcgfSlcbiAgICBdLCBMb2FkaW5nTW9kZWxWaWV3ZXJFbGVtZW50LnByb3RvdHlwZSwgXCJsb2FkaW5nXCIsIHZvaWQgMCk7XG4gICAgcmV0dXJuIExvYWRpbmdNb2RlbFZpZXdlckVsZW1lbnQ7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZGluZy5qcy5tYXAiLCIvKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAnTGljZW5zZScpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICdBUyBJUycgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5pbXBvcnQgeyBwcm9wZXJ0eSB9IGZyb20gJ2xpdC9kZWNvcmF0b3JzLmpzJztcbmltcG9ydCB7IENhbnZhc1RleHR1cmUsIFJlcGVhdFdyYXBwaW5nLCBzUkdCRW5jb2RpbmcsIFZpZGVvVGV4dHVyZSB9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7IEdMVEZFeHBvcnRlciB9IGZyb20gJ3RocmVlL2V4YW1wbGVzL2pzbS9leHBvcnRlcnMvR0xURkV4cG9ydGVyLmpzJztcbmltcG9ydCB7ICRuZWVkc1JlbmRlciwgJG9uTW9kZWxMb2FkLCAkcHJvZ3Jlc3NUcmFja2VyLCAkcmVuZGVyZXIsICRzY2VuZSB9IGZyb20gJy4uL21vZGVsLXZpZXdlci1iYXNlLmpzJztcbmltcG9ydCBHTFRGRXhwb3J0ZXJNYXRlcmlhbHNWYXJpYW50c0V4dGVuc2lvbiBmcm9tICcuLi90aHJlZS1jb21wb25lbnRzL2dsdGYtaW5zdGFuY2UvVmFyaWFudE1hdGVyaWFsRXhwb3J0ZXJQbHVnaW4nO1xuaW1wb3J0IHsgJGF2YWlsYWJsZVZhcmlhbnRzLCAkbWF0ZXJpYWxGcm9tUG9pbnQsICRwcmVwYXJlVmFyaWFudHNGb3JFeHBvcnQsICRzd2l0Y2hWYXJpYW50LCBNb2RlbCB9IGZyb20gJy4vc2NlbmUtZ3JhcGgvbW9kZWwuanMnO1xuaW1wb3J0IHsgVGV4dHVyZSBhcyBNb2RlbFZpZXdlclRleHR1cmUgfSBmcm9tICcuL3NjZW5lLWdyYXBoL3RleHR1cmUnO1xuZXhwb3J0IGNvbnN0ICRjdXJyZW50R0xURiA9IFN5bWJvbCgnY3VycmVudEdMVEYnKTtcbmV4cG9ydCBjb25zdCAkb3JpZ2luYWxHbHRmSnNvbiA9IFN5bWJvbCgnb3JpZ2luYWxHbHRmSnNvbicpO1xuZXhwb3J0IGNvbnN0ICRtb2RlbCA9IFN5bWJvbCgnbW9kZWwnKTtcbmNvbnN0ICRnZXRPblVwZGF0ZU1ldGhvZCA9IFN5bWJvbCgnZ2V0T25VcGRhdGVNZXRob2QnKTtcbmNvbnN0ICRidWlsZFRleHR1cmUgPSBTeW1ib2woJ2J1aWxkVGV4dHVyZScpO1xuLyoqXG4gKiBTY2VuZUdyYXBoTWl4aW4gbWFuYWdlcyBleHBvc2VzIGEgbW9kZWwgQVBJIGluIG9yZGVyIHRvIHN1cHBvcnQgb3BlcmF0aW9ucyBvblxuICogdGhlIDxtb2RlbC12aWV3ZXI+IHNjZW5lIGdyYXBoLlxuICovXG5leHBvcnQgY29uc3QgU2NlbmVHcmFwaE1peGluID0gKE1vZGVsVmlld2VyRWxlbWVudCkgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGNsYXNzIFNjZW5lR3JhcGhNb2RlbFZpZXdlckVsZW1lbnQgZXh0ZW5kcyBNb2RlbFZpZXdlckVsZW1lbnQge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgICAgICB0aGlzW19hXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXNbX2JdID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXNbX2NdID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMudmFyaWFudE5hbWUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5vcmllbnRhdGlvbiA9ICcwIDAgMCc7XG4gICAgICAgICAgICB0aGlzLnNjYWxlID0gJzEgMSAxJztcbiAgICAgICAgfVxuICAgICAgICAvLyBTY2VuZS1ncmFwaCBBUEk6XG4gICAgICAgIC8qKiBAZXhwb3J0ICovXG4gICAgICAgIGdldCBtb2RlbCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzWyRtb2RlbF07XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IGF2YWlsYWJsZVZhcmlhbnRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwgPyB0aGlzLm1vZGVsWyRhdmFpbGFibGVWYXJpYW50c10oKSA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgZGVlcCBjb3B5IG9mIHRoZSBnbHRmIEpTT04gYXMgbG9hZGVkLiBJdCB3aWxsIG5vdCByZWZsZWN0XG4gICAgICAgICAqIGNoYW5nZXMgdG8gdGhlIHNjZW5lLWdyYXBoLCBub3Igd2lsbCBlZGl0aW5nIGl0IGhhdmUgYW55IGVmZmVjdC5cbiAgICAgICAgICovXG4gICAgICAgIGdldCBvcmlnaW5hbEdsdGZKc29uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbJG9yaWdpbmFsR2x0Zkpzb25dO1xuICAgICAgICB9XG4gICAgICAgIFsoX2EgPSAkbW9kZWwsIF9iID0gJGN1cnJlbnRHTFRGLCBfYyA9ICRvcmlnaW5hbEdsdGZKc29uLCAkZ2V0T25VcGRhdGVNZXRob2QpXSgpIHtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpc1skbmVlZHNSZW5kZXJdKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIFskYnVpbGRUZXh0dXJlXSh0ZXh0dXJlKSB7XG4gICAgICAgICAgICAvLyBBcHBsaWVzIGdsVEYgZGVmYXVsdCBzZXR0aW5ncy5cbiAgICAgICAgICAgIHRleHR1cmUuZW5jb2RpbmcgPSBzUkdCRW5jb2Rpbmc7XG4gICAgICAgICAgICB0ZXh0dXJlLndyYXBTID0gUmVwZWF0V3JhcHBpbmc7XG4gICAgICAgICAgICB0ZXh0dXJlLndyYXBUID0gUmVwZWF0V3JhcHBpbmc7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1vZGVsVmlld2VyVGV4dHVyZSh0aGlzWyRnZXRPblVwZGF0ZU1ldGhvZF0oKSwgdGV4dHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgY3JlYXRlVGV4dHVyZSh1cmksIHR5cGUgPSAnaW1hZ2UvcG5nJykge1xuICAgICAgICAgICAgY29uc3QgeyB0ZXh0dXJlVXRpbHMgfSA9IHRoaXNbJHJlbmRlcmVyXTtcbiAgICAgICAgICAgIGNvbnN0IHRleHR1cmUgPSBhd2FpdCB0ZXh0dXJlVXRpbHMubG9hZEltYWdlKHVyaSk7XG4gICAgICAgICAgICB0ZXh0dXJlLnVzZXJEYXRhLm1pbWVUeXBlID0gdHlwZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzWyRidWlsZFRleHR1cmVdKHRleHR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGNyZWF0ZUxvdHRpZVRleHR1cmUodXJpLCBxdWFsaXR5ID0gMSkge1xuICAgICAgICAgICAgY29uc3QgeyB0ZXh0dXJlVXRpbHMgfSA9IHRoaXNbJHJlbmRlcmVyXTtcbiAgICAgICAgICAgIGNvbnN0IHRleHR1cmUgPSBhd2FpdCB0ZXh0dXJlVXRpbHMubG9hZExvdHRpZSh1cmksIHF1YWxpdHkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbJGJ1aWxkVGV4dHVyZV0odGV4dHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgY3JlYXRlVmlkZW9UZXh0dXJlKHVyaSkge1xuICAgICAgICAgICAgY29uc3QgdmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICAgICAgICAgICAgdmlkZW8uc3JjID0gdXJpO1xuICAgICAgICAgICAgdmlkZW8ubXV0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdmlkZW8ucGxheXNJbmxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgdmlkZW8ubG9vcCA9IHRydWU7XG4gICAgICAgICAgICB2aWRlby5wbGF5KCk7XG4gICAgICAgICAgICBjb25zdCB0ZXh0dXJlID0gbmV3IFZpZGVvVGV4dHVyZSh2aWRlbyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1skYnVpbGRUZXh0dXJlXSh0ZXh0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBjcmVhdGVDYW52YXNUZXh0dXJlKCkge1xuICAgICAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICBjb25zdCB0ZXh0dXJlID0gbmV3IENhbnZhc1RleHR1cmUoY2FudmFzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzWyRidWlsZFRleHR1cmVdKHRleHR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIHVwZGF0ZWQoY2hhbmdlZFByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHN1cGVyLnVwZGF0ZWQoY2hhbmdlZFByb3BlcnRpZXMpO1xuICAgICAgICAgICAgaWYgKGNoYW5nZWRQcm9wZXJ0aWVzLmhhcygndmFyaWFudE5hbWUnKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZVZhcmlhbnRQcm9ncmVzcyA9IHRoaXNbJHByb2dyZXNzVHJhY2tlcl0uYmVnaW5BY3Rpdml0eSgpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZVZhcmlhbnRQcm9ncmVzcygwLjEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vZGVsID0gdGhpc1skbW9kZWxdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdmFyaWFudE5hbWUgfSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgaWYgKG1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgbW9kZWxbJHN3aXRjaFZhcmlhbnRdKHZhcmlhbnROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1skbmVlZHNSZW5kZXJdKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ3ZhcmlhbnQtYXBwbGllZCcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdXBkYXRlVmFyaWFudFByb2dyZXNzKDEuMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hhbmdlZFByb3BlcnRpZXMuaGFzKCdvcmllbnRhdGlvbicpIHx8XG4gICAgICAgICAgICAgICAgY2hhbmdlZFByb3BlcnRpZXMuaGFzKCdzY2FsZScpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmxvYWRlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHNjZW5lID0gdGhpc1skc2NlbmVdO1xuICAgICAgICAgICAgICAgIHNjZW5lLmFwcGx5VHJhbnNmb3JtKCk7XG4gICAgICAgICAgICAgICAgc2NlbmUudXBkYXRlQm91bmRpbmdCb3goKTtcbiAgICAgICAgICAgICAgICBzY2VuZS51cGRhdGVTaGFkb3coKTtcbiAgICAgICAgICAgICAgICB0aGlzWyRyZW5kZXJlcl0uYXJSZW5kZXJlci5vblVwZGF0ZVNjZW5lKCk7XG4gICAgICAgICAgICAgICAgdGhpc1skbmVlZHNSZW5kZXJdKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgWyRvbk1vZGVsTG9hZF0oKSB7XG4gICAgICAgICAgICBzdXBlclskb25Nb2RlbExvYWRdKCk7XG4gICAgICAgICAgICBjb25zdCB7IGN1cnJlbnRHTFRGIH0gPSB0aGlzWyRzY2VuZV07XG4gICAgICAgICAgICBpZiAoY3VycmVudEdMVEYgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgY29ycmVsYXRlZFNjZW5lR3JhcGggfSA9IGN1cnJlbnRHTFRGO1xuICAgICAgICAgICAgICAgIGlmIChjb3JyZWxhdGVkU2NlbmVHcmFwaCAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRHTFRGICE9PSB0aGlzWyRjdXJyZW50R0xURl0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1skbW9kZWxdID1cbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBNb2RlbChjb3JyZWxhdGVkU2NlbmVHcmFwaCwgdGhpc1skZ2V0T25VcGRhdGVNZXRob2RdKCkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzWyRvcmlnaW5hbEdsdGZKc29uXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGNvcnJlbGF0ZWRTY2VuZUdyYXBoLmdsdGYpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gS0hSX21hdGVyaWFsc192YXJpYW50cyBleHRlbnNpb24gc3BlYzpcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvZXh0ZW5zaW9ucy8yLjAvS2hyb25vcy9LSFJfbWF0ZXJpYWxzX3ZhcmlhbnRzXG4gICAgICAgICAgICAgICAgaWYgKCd2YXJpYW50cycgaW4gY3VycmVudEdMVEYudXNlckRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0VXBkYXRlKCd2YXJpYW50TmFtZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXNbJGN1cnJlbnRHTFRGXSA9IGN1cnJlbnRHTFRGO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBAZXhwb3J0ICovXG4gICAgICAgIGFzeW5jIGV4cG9ydFNjZW5lKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjZW5lID0gdGhpc1skc2NlbmVdO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBEZWZhdWx0c1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGJpbmFyeTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgb25seVZpc2libGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG1heFRleHR1cmVTaXplOiBJbmZpbml0eSxcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVkZUN1c3RvbUV4dGVuc2lvbnM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBmb3JjZUluZGljZXM6IGZhbHNlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKG9wdHMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIC8vIE5vdCBjb25maWd1cmFibGVcbiAgICAgICAgICAgICAgICBvcHRzLmFuaW1hdGlvbnMgPSBzY2VuZS5hbmltYXRpb25zO1xuICAgICAgICAgICAgICAgIG9wdHMudHJ1bmNhdGVEcmF3UmFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNoYWRvdyA9IHNjZW5lLnNoYWRvdztcbiAgICAgICAgICAgICAgICBsZXQgdmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBzaGFkb3cgZnJvbSBleHBvcnRcbiAgICAgICAgICAgICAgICBpZiAoc2hhZG93ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJsZSA9IHNoYWRvdy52aXNpYmxlO1xuICAgICAgICAgICAgICAgICAgICBzaGFkb3cudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzWyRtb2RlbF1bJHByZXBhcmVWYXJpYW50c0ZvckV4cG9ydF0oKTtcbiAgICAgICAgICAgICAgICBjb25zdCBleHBvcnRlciA9IG5ldyBHTFRGRXhwb3J0ZXIoKVxuICAgICAgICAgICAgICAgICAgICAucmVnaXN0ZXIoKHdyaXRlcikgPT4gbmV3IEdMVEZFeHBvcnRlck1hdGVyaWFsc1ZhcmlhbnRzRXh0ZW5zaW9uKHdyaXRlcikpO1xuICAgICAgICAgICAgICAgIGV4cG9ydGVyLnBhcnNlKHNjZW5lLm1vZGVsLCAoZ2x0ZikgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShuZXcgQmxvYihbb3B0cy5iaW5hcnkgPyBnbHRmIDogSlNPTi5zdHJpbmdpZnkoZ2x0ZildLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBvcHRzLmJpbmFyeSA/ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0sICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdCgnZ2xURiBleHBvcnQgZmFpbGVkJyk7XG4gICAgICAgICAgICAgICAgfSwgb3B0cyk7XG4gICAgICAgICAgICAgICAgaWYgKHNoYWRvdyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNoYWRvdy52aXNpYmxlID0gdmlzaWJsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBtYXRlcmlhbEZyb21Qb2ludChwaXhlbFgsIHBpeGVsWSkge1xuICAgICAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzWyRtb2RlbF07XG4gICAgICAgICAgICBpZiAobW9kZWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2NlbmUgPSB0aGlzWyRzY2VuZV07XG4gICAgICAgICAgICBjb25zdCBuZGNDb29yZHMgPSBzY2VuZS5nZXROREMocGl4ZWxYLCBwaXhlbFkpO1xuICAgICAgICAgICAgY29uc3QgaGl0ID0gc2NlbmUuaGl0RnJvbVBvaW50KG5kY0Nvb3Jkcyk7XG4gICAgICAgICAgICBpZiAoaGl0ID09IG51bGwgfHwgaGl0LmZhY2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1vZGVsWyRtYXRlcmlhbEZyb21Qb2ludF0oaGl0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgcHJvcGVydHkoeyB0eXBlOiBTdHJpbmcsIGF0dHJpYnV0ZTogJ3ZhcmlhbnQtbmFtZScgfSlcbiAgICBdLCBTY2VuZUdyYXBoTW9kZWxWaWV3ZXJFbGVtZW50LnByb3RvdHlwZSwgXCJ2YXJpYW50TmFtZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBwcm9wZXJ0eSh7IHR5cGU6IFN0cmluZywgYXR0cmlidXRlOiAnb3JpZW50YXRpb24nIH0pXG4gICAgXSwgU2NlbmVHcmFwaE1vZGVsVmlld2VyRWxlbWVudC5wcm90b3R5cGUsIFwib3JpZW50YXRpb25cIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgcHJvcGVydHkoeyB0eXBlOiBTdHJpbmcsIGF0dHJpYnV0ZTogJ3NjYWxlJyB9KVxuICAgIF0sIFNjZW5lR3JhcGhNb2RlbFZpZXdlckVsZW1lbnQucHJvdG90eXBlLCBcInNjYWxlXCIsIHZvaWQgMCk7XG4gICAgcmV0dXJuIFNjZW5lR3JhcGhNb2RlbFZpZXdlckVsZW1lbnQ7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2NlbmUtZ3JhcGguanMubWFwIiwiLyogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgJ0xpY2Vuc2UnKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAnQVMgSVMnIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgTWVzaCwgTWVzaEJhc2ljTWF0ZXJpYWwsIE9ydGhvZ3JhcGhpY0NhbWVyYSwgUGxhbmVHZW9tZXRyeSwgU2NlbmUsIFdlYkdMUmVuZGVyVGFyZ2V0IH0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgYmxvYkNhbnZhcyB9IGZyb20gJy4uLy4uL21vZGVsLXZpZXdlci1iYXNlLmpzJztcbmltcG9ydCB7IFJlbmRlcmVyIH0gZnJvbSAnLi4vLi4vdGhyZWUtY29tcG9uZW50cy9SZW5kZXJlci5qcyc7XG5pbXBvcnQgeyAkY29ycmVsYXRlZE9iamVjdHMsICRvblVwZGF0ZSwgJHNvdXJjZU9iamVjdCwgVGhyZWVET01FbGVtZW50IH0gZnJvbSAnLi90aHJlZS1kb20tZWxlbWVudC5qcyc7XG5jb25zdCBxdWFkTWF0ZXJpYWwgPSBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoKTtcbmNvbnN0IHF1YWQgPSBuZXcgUGxhbmVHZW9tZXRyeSgyLCAyKTtcbmxldCBhZGhvY051bSA9IDA7XG5leHBvcnQgY29uc3QgJHRocmVlVGV4dHVyZSA9IFN5bWJvbCgndGhyZWVUZXh0dXJlJyk7XG5leHBvcnQgY29uc3QgJGFwcGx5VGV4dHVyZSA9IFN5bWJvbCgnYXBwbHlUZXh0dXJlJyk7XG4vKipcbiAqIEltYWdlIGZhY2FkZSBpbXBsZW1lbnRhdGlvbiBmb3IgVGhyZWUuanMgdGV4dHVyZXNcbiAqL1xuZXhwb3J0IGNsYXNzIEltYWdlIGV4dGVuZHMgVGhyZWVET01FbGVtZW50IHtcbiAgICBnZXQgWyR0aHJlZVRleHR1cmVdKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KHRoaXNbJGNvcnJlbGF0ZWRPYmplY3RzXSAhPSBudWxsICYmIHRoaXNbJGNvcnJlbGF0ZWRPYmplY3RzXS5zaXplID4gMCwgJ0ltYWdlIGNvcnJlbGF0ZWQgb2JqZWN0IGlzIHVuZGVmaW5lZCcpO1xuICAgICAgICByZXR1cm4gKF9hID0gdGhpc1skY29ycmVsYXRlZE9iamVjdHNdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudmFsdWVzKCkubmV4dCgpLnZhbHVlO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihvblVwZGF0ZSwgdGV4dHVyZSwgZ2x0ZkltYWdlKSB7XG4gICAgICAgIGdsdGZJbWFnZSA9IGdsdGZJbWFnZSAhPT0gbnVsbCAmJiBnbHRmSW1hZ2UgIT09IHZvaWQgMCA/IGdsdGZJbWFnZSA6IHtcbiAgICAgICAgICAgIG5hbWU6ICh0ZXh0dXJlICYmIHRleHR1cmUuaW1hZ2UgJiYgdGV4dHVyZS5pbWFnZS5zcmMpID9cbiAgICAgICAgICAgICAgICB0ZXh0dXJlLmltYWdlLnNyYy5zcGxpdCgnLycpLnBvcCgpIDpcbiAgICAgICAgICAgICAgICAnYWRob2NfaW1hZ2UnLFxuICAgICAgICAgICAgdXJpOiAodGV4dHVyZSAmJiB0ZXh0dXJlLmltYWdlICYmIHRleHR1cmUuaW1hZ2Uuc3JjKSA/XG4gICAgICAgICAgICAgICAgdGV4dHVyZS5pbWFnZS5zcmMgOlxuICAgICAgICAgICAgICAgICdhZGhvY19pbWFnZScgKyBhZGhvY051bSsrXG4gICAgICAgIH07XG4gICAgICAgIHN1cGVyKG9uVXBkYXRlLCBnbHRmSW1hZ2UsIG5ldyBTZXQodGV4dHVyZSA/IFt0ZXh0dXJlXSA6IFtdKSk7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpc1skc291cmNlT2JqZWN0XS5uYW1lIHx8ICcnO1xuICAgIH1cbiAgICBnZXQgdXJpKCkge1xuICAgICAgICByZXR1cm4gdGhpc1skc291cmNlT2JqZWN0XS51cmk7XG4gICAgfVxuICAgIGdldCBidWZmZXJWaWV3KCkge1xuICAgICAgICByZXR1cm4gdGhpc1skc291cmNlT2JqZWN0XS5idWZmZXJWaWV3O1xuICAgIH1cbiAgICBnZXQgZWxlbWVudCgpIHtcbiAgICAgICAgY29uc3QgdGV4dHVyZSA9IHRoaXNbJHRocmVlVGV4dHVyZV07XG4gICAgICAgIGlmICh0ZXh0dXJlICYmICh0ZXh0dXJlLmlzQ2FudmFzVGV4dHVyZSB8fCB0ZXh0dXJlLmlzVmlkZW9UZXh0dXJlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRleHR1cmUuaW1hZ2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBnZXQgYW5pbWF0aW9uKCkge1xuICAgICAgICBjb25zdCB0ZXh0dXJlID0gdGhpc1skdGhyZWVUZXh0dXJlXTtcbiAgICAgICAgaWYgKHRleHR1cmUgJiYgdGV4dHVyZS5pc0NhbnZhc1RleHR1cmUgJiYgdGV4dHVyZS5hbmltYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0dXJlLmFuaW1hdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51cmkgIT0gbnVsbCA/ICdleHRlcm5hbCcgOiAnZW1iZWRkZWQnO1xuICAgIH1cbiAgICBzZXQgbmFtZShuYW1lKSB7XG4gICAgICAgIHRoaXNbJHNvdXJjZU9iamVjdF0ubmFtZSA9IG5hbWU7XG4gICAgfVxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgY29uc3QgdGV4dHVyZSA9IHRoaXNbJHRocmVlVGV4dHVyZV07XG4gICAgICAgIC8vIEFwcGxpZXMgdG8gbm9uLUxvdHRpZSBjYW52YXMgdGV4dHVyZXMgb25seVxuICAgICAgICBpZiAodGV4dHVyZSAmJiB0ZXh0dXJlLmlzQ2FudmFzVGV4dHVyZSAmJiAhdGV4dHVyZS5hbmltYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXNbJHRocmVlVGV4dHVyZV0ubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpc1skb25VcGRhdGVdKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlVGh1bWJuYWlsKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgY29uc3Qgc2NlbmUgPSBuZXcgU2NlbmUoKTtcbiAgICAgICAgcXVhZE1hdGVyaWFsLm1hcCA9IHRoaXNbJHRocmVlVGV4dHVyZV07XG4gICAgICAgIGNvbnN0IG1lc2ggPSBuZXcgTWVzaChxdWFkLCBxdWFkTWF0ZXJpYWwpO1xuICAgICAgICBzY2VuZS5hZGQobWVzaCk7XG4gICAgICAgIGNvbnN0IGNhbWVyYSA9IG5ldyBPcnRob2dyYXBoaWNDYW1lcmEoLTEsIDEsIDEsIC0xLCAwLCAxKTtcbiAgICAgICAgY29uc3QgeyB0aHJlZVJlbmRlcmVyIH0gPSBSZW5kZXJlci5zaW5nbGV0b247XG4gICAgICAgIGNvbnN0IHJlbmRlclRhcmdldCA9IG5ldyBXZWJHTFJlbmRlclRhcmdldCh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhyZWVSZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQocmVuZGVyVGFyZ2V0KTtcbiAgICAgICAgdGhyZWVSZW5kZXJlci5yZW5kZXIoc2NlbmUsIGNhbWVyYSk7XG4gICAgICAgIHRocmVlUmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KG51bGwpO1xuICAgICAgICBjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgICAgICB0aHJlZVJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHMocmVuZGVyVGFyZ2V0LCAwLCAwLCB3aWR0aCwgaGVpZ2h0LCBidWZmZXIpO1xuICAgICAgICBibG9iQ2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIGJsb2JDYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBjb25zdCBibG9iQ29udGV4dCA9IGJsb2JDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgY29uc3QgaW1hZ2VEYXRhID0gYmxvYkNvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBpbWFnZURhdGEuZGF0YS5zZXQoYnVmZmVyKTtcbiAgICAgICAgYmxvYkNvbnRleHQucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBibG9iQ2FudmFzLnRvQmxvYihibG9iID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWJsb2IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdCgnRmFpbGVkIHRvIGNhcHR1cmUgdGh1bWJuYWlsLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYikpO1xuICAgICAgICAgICAgfSwgJ2ltYWdlL3BuZycpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbWFnZS5qcy5tYXAiLCIvKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAnTGljZW5zZScpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICdBUyBJUycgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgX2E7XG5pbXBvcnQgeyBDb2xvciwgRG91YmxlU2lkZSwgRnJvbnRTaWRlIH0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgUEJSTWV0YWxsaWNSb3VnaG5lc3MgfSBmcm9tICcuL3Bici1tZXRhbGxpYy1yb3VnaG5lc3MuanMnO1xuaW1wb3J0IHsgVGV4dHVyZUluZm8sIFRleHR1cmVVc2FnZSB9IGZyb20gJy4vdGV4dHVyZS1pbmZvLmpzJztcbmltcG9ydCB7ICRjb3JyZWxhdGVkT2JqZWN0cywgJG9uVXBkYXRlLCAkc291cmNlT2JqZWN0LCBUaHJlZURPTUVsZW1lbnQgfSBmcm9tICcuL3RocmVlLWRvbS1lbGVtZW50LmpzJztcbmNvbnN0ICRwYnJNZXRhbGxpY1JvdWdobmVzcyA9IFN5bWJvbCgncGJyTWV0YWxsaWNSb3VnaG5lc3MnKTtcbmNvbnN0ICRub3JtYWxUZXh0dXJlID0gU3ltYm9sKCdub3JtYWxUZXh0dXJlJyk7XG5jb25zdCAkb2NjbHVzaW9uVGV4dHVyZSA9IFN5bWJvbCgnb2NjbHVzaW9uVGV4dHVyZScpO1xuY29uc3QgJGVtaXNzaXZlVGV4dHVyZSA9IFN5bWJvbCgnZW1pc3NpdmVUZXh0dXJlJyk7XG5jb25zdCAkYmFja2luZ1RocmVlTWF0ZXJpYWwgPSBTeW1ib2woJ2JhY2tpbmdUaHJlZU1hdGVyaWFsJyk7XG5jb25zdCAkYXBwbHlBbHBoYUN1dG9mZiA9IFN5bWJvbCgnYXBwbHlBbHBoYUN1dG9mZicpO1xuZXhwb3J0IGNvbnN0ICRsYXp5TG9hZEdMVEZJbmZvID0gU3ltYm9sKCdsYXp5TG9hZEdMVEZJbmZvJyk7XG5jb25zdCAkaW5pdGlhbGl6ZSA9IFN5bWJvbCgnaW5pdGlhbGl6ZScpO1xuZXhwb3J0IGNvbnN0ICRnZXRMb2FkZWRNYXRlcmlhbCA9IFN5bWJvbCgnZ2V0TG9hZGVkTWF0ZXJpYWwnKTtcbmV4cG9ydCBjb25zdCAkZW5zdXJlTWF0ZXJpYWxJc0xvYWRlZCA9IFN5bWJvbCgnZW5zdXJlTWF0ZXJpYWxJc0xvYWRlZCcpO1xuZXhwb3J0IGNvbnN0ICRnbHRmSW5kZXggPSBTeW1ib2woJ2dsdGZJbmRleCcpO1xuZXhwb3J0IGNvbnN0ICRzZXRBY3RpdmUgPSBTeW1ib2woJ3NldEFjdGl2ZScpO1xuZXhwb3J0IGNvbnN0ICR2YXJpYW50SW5kaWNlcyA9IFN5bWJvbCgndmFyaWFudEluZGljZXMnKTtcbmNvbnN0ICRpc0FjdGl2ZSA9IFN5bWJvbCgnaXNBY3RpdmUnKTtcbmV4cG9ydCBjb25zdCAkdmFyaWFudFNldCA9IFN5bWJvbCgndmFyaWFudFNldCcpO1xuY29uc3QgJG1vZGVsVmFyaWFudHMgPSBTeW1ib2woJ21vZGVsVmFyaWFudHMnKTtcbi8qKlxuICogTWF0ZXJpYWwgZmFjYWRlIGltcGxlbWVudGF0aW9uIGZvciBUaHJlZS5qcyBtYXRlcmlhbHNcbiAqL1xuZXhwb3J0IGNsYXNzIE1hdGVyaWFsIGV4dGVuZHMgVGhyZWVET01FbGVtZW50IHtcbiAgICBjb25zdHJ1Y3RvcihvblVwZGF0ZSwgZ2x0ZiwgZ2x0Zk1hdGVyaWFsLCBnbHRmSW5kZXgsIGlzQWN0aXZlLCBtb2RlbFZhcmlhbnRzLCBjb3JyZWxhdGVkTWF0ZXJpYWxzLCBsYXp5TG9hZEluZm8gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3VwZXIob25VcGRhdGUsIGdsdGZNYXRlcmlhbCwgY29ycmVsYXRlZE1hdGVyaWFscyk7XG4gICAgICAgIHRoaXNbX2FdID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzWyRnbHRmSW5kZXhdID0gZ2x0ZkluZGV4O1xuICAgICAgICB0aGlzWyRpc0FjdGl2ZV0gPSBpc0FjdGl2ZTtcbiAgICAgICAgdGhpc1skbW9kZWxWYXJpYW50c10gPSBtb2RlbFZhcmlhbnRzO1xuICAgICAgICBpZiAobGF6eUxvYWRJbmZvID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXNbJGluaXRpYWxpemVdKGdsdGYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpc1skbGF6eUxvYWRHTFRGSW5mb10gPSBsYXp5TG9hZEluZm87XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IFsoX2EgPSAkdmFyaWFudFNldCwgJGJhY2tpbmdUaHJlZU1hdGVyaWFsKV0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzWyRjb3JyZWxhdGVkT2JqZWN0c11cbiAgICAgICAgICAgIC52YWx1ZXMoKVxuICAgICAgICAgICAgLm5leHQoKVxuICAgICAgICAgICAgLnZhbHVlO1xuICAgIH1cbiAgICBbJGluaXRpYWxpemVdKGdsdGYpIHtcbiAgICAgICAgY29uc3Qgb25VcGRhdGUgPSB0aGlzWyRvblVwZGF0ZV07XG4gICAgICAgIGNvbnN0IGdsdGZNYXRlcmlhbCA9IHRoaXNbJHNvdXJjZU9iamVjdF07XG4gICAgICAgIGNvbnN0IGNvcnJlbGF0ZWRNYXRlcmlhbHMgPSB0aGlzWyRjb3JyZWxhdGVkT2JqZWN0c107XG4gICAgICAgIGlmIChnbHRmTWF0ZXJpYWwuZXh0ZW5zaW9ucyAmJlxuICAgICAgICAgICAgZ2x0Zk1hdGVyaWFsLmV4dGVuc2lvbnNbJ0tIUl9tYXRlcmlhbHNfcGJyU3BlY3VsYXJHbG9zc2luZXNzJ10pIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgTWF0ZXJpYWwgJHtnbHRmTWF0ZXJpYWwubmFtZX0gdXNlcyBhIGRlcHJlY2F0ZWQgZXh0ZW5zaW9uXG4gICAgICAgICAgXCJLSFJfbWF0ZXJpYWxzX3BiclNwZWN1bGFyR2xvc3NpbmVzc1wiLCBwbGVhc2UgdXNlXG4gICAgICAgICAgXCJwYnJNZXRhbGxpY1JvdWdobmVzc1wiIGluc3RlYWQuIFNwZWN1bGFyIEdsb3NzaW5lc3MgbWF0ZXJpYWxzIGFyZVxuICAgICAgICAgIG5vIGxvbmdlciBzdXBwb3J0ZWQ7IHRvIGNvbnZlcnQgdG8gbWV0YWwtcm91Z2gsIHNlZSBcbiAgICAgICAgICBodHRwczovL3d3dy5kb25tY2N1cmR5LmNvbS8yMDIyLzExLzI4L2NvbnZlcnRpbmctZ2x0Zi1wYnItbWF0ZXJpYWxzLWZyb20tc3BlY2dsb3NzLXRvLW1ldGFscm91Z2gvLmApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnbHRmTWF0ZXJpYWwucGJyTWV0YWxsaWNSb3VnaG5lc3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgZ2x0Zk1hdGVyaWFsLnBick1ldGFsbGljUm91Z2huZXNzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1skcGJyTWV0YWxsaWNSb3VnaG5lc3NdID0gbmV3IFBCUk1ldGFsbGljUm91Z2huZXNzKG9uVXBkYXRlLCBnbHRmLCBnbHRmTWF0ZXJpYWwucGJyTWV0YWxsaWNSb3VnaG5lc3MsIGNvcnJlbGF0ZWRNYXRlcmlhbHMpO1xuICAgICAgICBpZiAoZ2x0Zk1hdGVyaWFsLmVtaXNzaXZlRmFjdG9yID09IG51bGwpIHtcbiAgICAgICAgICAgIGdsdGZNYXRlcmlhbC5lbWlzc2l2ZUZhY3RvciA9IFswLCAwLCAwXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2x0Zk1hdGVyaWFsLmRvdWJsZVNpZGVkID09IG51bGwpIHtcbiAgICAgICAgICAgIGdsdGZNYXRlcmlhbC5kb3VibGVTaWRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnbHRmTWF0ZXJpYWwuYWxwaGFNb2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIGdsdGZNYXRlcmlhbC5hbHBoYU1vZGUgPSAnT1BBUVVFJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2x0Zk1hdGVyaWFsLmFscGhhQ3V0b2ZmID09IG51bGwpIHtcbiAgICAgICAgICAgIGdsdGZNYXRlcmlhbC5hbHBoYUN1dG9mZiA9IDAuNTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IG5vcm1hbFRleHR1cmU6IGdsdGZOb3JtYWxUZXh0dXJlLCBvY2NsdXNpb25UZXh0dXJlOiBnbHRmT2NjbHVzaW9uVGV4dHVyZSwgZW1pc3NpdmVUZXh0dXJlOiBnbHRmRW1pc3NpdmVUZXh0dXJlIH0gPSBnbHRmTWF0ZXJpYWw7XG4gICAgICAgIGNvbnN0IHsgbm9ybWFsTWFwLCBhb01hcCwgZW1pc3NpdmVNYXAgfSA9IGNvcnJlbGF0ZWRNYXRlcmlhbHMudmFsdWVzKCkubmV4dCgpLnZhbHVlO1xuICAgICAgICB0aGlzWyRub3JtYWxUZXh0dXJlXSA9IG5ldyBUZXh0dXJlSW5mbyhvblVwZGF0ZSwgVGV4dHVyZVVzYWdlLk5vcm1hbCwgbm9ybWFsTWFwLCBjb3JyZWxhdGVkTWF0ZXJpYWxzLCBnbHRmLCBnbHRmTm9ybWFsVGV4dHVyZSA/IGdsdGZOb3JtYWxUZXh0dXJlIDogbnVsbCk7XG4gICAgICAgIHRoaXNbJG9jY2x1c2lvblRleHR1cmVdID0gbmV3IFRleHR1cmVJbmZvKG9uVXBkYXRlLCBUZXh0dXJlVXNhZ2UuT2NjbHVzaW9uLCBhb01hcCwgY29ycmVsYXRlZE1hdGVyaWFscywgZ2x0ZiwgZ2x0Zk9jY2x1c2lvblRleHR1cmUgPyBnbHRmT2NjbHVzaW9uVGV4dHVyZSA6IG51bGwpO1xuICAgICAgICB0aGlzWyRlbWlzc2l2ZVRleHR1cmVdID0gbmV3IFRleHR1cmVJbmZvKG9uVXBkYXRlLCBUZXh0dXJlVXNhZ2UuRW1pc3NpdmUsIGVtaXNzaXZlTWFwLCBjb3JyZWxhdGVkTWF0ZXJpYWxzLCBnbHRmLCBnbHRmRW1pc3NpdmVUZXh0dXJlID8gZ2x0ZkVtaXNzaXZlVGV4dHVyZSA6IG51bGwpO1xuICAgIH1cbiAgICBhc3luYyBbJGdldExvYWRlZE1hdGVyaWFsXSgpIHtcbiAgICAgICAgaWYgKHRoaXNbJGxhenlMb2FkR0xURkluZm9dICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc2V0LCBtYXRlcmlhbCB9ID0gYXdhaXQgdGhpc1skbGF6eUxvYWRHTFRGSW5mb10uZG9MYXp5TG9hZCgpO1xuICAgICAgICAgICAgLy8gRmlsbHMgaW4gdGhlIG1pc3NpbmcgZGF0YS5cbiAgICAgICAgICAgIHRoaXNbJGNvcnJlbGF0ZWRPYmplY3RzXSA9IHNldDtcbiAgICAgICAgICAgIHRoaXNbJGluaXRpYWxpemVdKHRoaXNbJGxhenlMb2FkR0xURkluZm9dLmdsdGYpO1xuICAgICAgICAgICAgLy8gUmVsZWFzZXMgbGF6eSBsb2FkIGluZm8uXG4gICAgICAgICAgICB0aGlzWyRsYXp5TG9hZEdMVEZJbmZvXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIC8vIFJlZGVmaW5lcyB0aGUgbWV0aG9kIGFzIGEgbm9vcCBtZXRob2QuXG4gICAgICAgICAgICB0aGlzLmVuc3VyZUxvYWRlZCA9IGFzeW5jICgpID0+IHsgfTtcbiAgICAgICAgICAgIHJldHVybiBtYXRlcmlhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1skY29ycmVsYXRlZE9iamVjdHNdLnZhbHVlcygpLm5leHQoKS52YWx1ZTtcbiAgICB9XG4gICAgWyRlbnN1cmVNYXRlcmlhbElzTG9hZGVkXSgpIHtcbiAgICAgICAgaWYgKHRoaXNbJGxhenlMb2FkR0xURkluZm9dID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1hdGVyaWFsIFwiJHt0aGlzLm5hbWV9XCIgaGFzIG5vdCBiZWVuIGxvYWRlZCwgY2FsbCAnYXdhaXRcbiAgICBteU1hdGVyaWFsLmVuc3VyZUxvYWRlZCgpJyBiZWZvcmUgdXNpbmcgYW4gdW5sb2FkZWQgbWF0ZXJpYWwuYCk7XG4gICAgfVxuICAgIGFzeW5jIGVuc3VyZUxvYWRlZCgpIHtcbiAgICAgICAgYXdhaXQgdGhpc1skZ2V0TG9hZGVkTWF0ZXJpYWxdKCk7XG4gICAgfVxuICAgIGdldCBpc0xvYWRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbJGxhenlMb2FkR0xURkluZm9dID09IG51bGw7XG4gICAgfVxuICAgIGdldCBpc0FjdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbJGlzQWN0aXZlXTtcbiAgICB9XG4gICAgWyRzZXRBY3RpdmVdKGlzQWN0aXZlKSB7XG4gICAgICAgIHRoaXNbJGlzQWN0aXZlXSA9IGlzQWN0aXZlO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbJHNvdXJjZU9iamVjdF0ubmFtZTtcbiAgICB9XG4gICAgc2V0IG5hbWUobmFtZSkge1xuICAgICAgICBjb25zdCBzb3VyY2VNYXRlcmlhbCA9IHRoaXNbJHNvdXJjZU9iamVjdF07XG4gICAgICAgIGlmIChzb3VyY2VNYXRlcmlhbCAhPSBudWxsKSB7XG4gICAgICAgICAgICBzb3VyY2VNYXRlcmlhbC5uYW1lID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpc1skY29ycmVsYXRlZE9iamVjdHNdICE9IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdGhyZWVNYXRlcmlhbCBvZiB0aGlzWyRjb3JyZWxhdGVkT2JqZWN0c10pIHtcbiAgICAgICAgICAgICAgICB0aHJlZU1hdGVyaWFsLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBwYnJNZXRhbGxpY1JvdWdobmVzcygpIHtcbiAgICAgICAgdGhpc1skZW5zdXJlTWF0ZXJpYWxJc0xvYWRlZF0oKTtcbiAgICAgICAgcmV0dXJuIHRoaXNbJHBick1ldGFsbGljUm91Z2huZXNzXTtcbiAgICB9XG4gICAgZ2V0IG5vcm1hbFRleHR1cmUoKSB7XG4gICAgICAgIHRoaXNbJGVuc3VyZU1hdGVyaWFsSXNMb2FkZWRdKCk7XG4gICAgICAgIHJldHVybiB0aGlzWyRub3JtYWxUZXh0dXJlXTtcbiAgICB9XG4gICAgZ2V0IG9jY2x1c2lvblRleHR1cmUoKSB7XG4gICAgICAgIHRoaXNbJGVuc3VyZU1hdGVyaWFsSXNMb2FkZWRdKCk7XG4gICAgICAgIHJldHVybiB0aGlzWyRvY2NsdXNpb25UZXh0dXJlXTtcbiAgICB9XG4gICAgZ2V0IGVtaXNzaXZlVGV4dHVyZSgpIHtcbiAgICAgICAgdGhpc1skZW5zdXJlTWF0ZXJpYWxJc0xvYWRlZF0oKTtcbiAgICAgICAgcmV0dXJuIHRoaXNbJGVtaXNzaXZlVGV4dHVyZV07XG4gICAgfVxuICAgIGdldCBlbWlzc2l2ZUZhY3RvcigpIHtcbiAgICAgICAgdGhpc1skZW5zdXJlTWF0ZXJpYWxJc0xvYWRlZF0oKTtcbiAgICAgICAgcmV0dXJuIHRoaXNbJHNvdXJjZU9iamVjdF0uZW1pc3NpdmVGYWN0b3I7XG4gICAgfVxuICAgIGdldCBpbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbJGdsdGZJbmRleF07XG4gICAgfVxuICAgIFskdmFyaWFudEluZGljZXNdKCkge1xuICAgICAgICByZXR1cm4gdGhpc1skdmFyaWFudFNldF07XG4gICAgfVxuICAgIGhhc1ZhcmlhbnQobmFtZSkge1xuICAgICAgICBjb25zdCB2YXJpYW50RGF0YSA9IHRoaXNbJG1vZGVsVmFyaWFudHNdLmdldChuYW1lKTtcbiAgICAgICAgcmV0dXJuIHZhcmlhbnREYXRhICE9IG51bGwgJiYgdGhpc1skdmFyaWFudFNldF0uaGFzKHZhcmlhbnREYXRhLmluZGV4KTtcbiAgICB9XG4gICAgc2V0RW1pc3NpdmVGYWN0b3IocmdiKSB7XG4gICAgICAgIHRoaXNbJGVuc3VyZU1hdGVyaWFsSXNMb2FkZWRdKCk7XG4gICAgICAgIGNvbnN0IGNvbG9yID0gbmV3IENvbG9yKCk7XG4gICAgICAgIGlmIChyZ2IgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgY29sb3IuZnJvbUFycmF5KHJnYik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb2xvci5zZXQocmdiKS5jb252ZXJ0U1JHQlRvTGluZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBtYXRlcmlhbCBvZiB0aGlzWyRjb3JyZWxhdGVkT2JqZWN0c10pIHtcbiAgICAgICAgICAgIG1hdGVyaWFsLmVtaXNzaXZlLnNldChjb2xvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1skc291cmNlT2JqZWN0XS5lbWlzc2l2ZUZhY3RvciA9XG4gICAgICAgICAgICBjb2xvci50b0FycmF5KCk7XG4gICAgICAgIHRoaXNbJG9uVXBkYXRlXSgpO1xuICAgIH1cbiAgICBbJGFwcGx5QWxwaGFDdXRvZmZdKCkge1xuICAgICAgICB0aGlzWyRlbnN1cmVNYXRlcmlhbElzTG9hZGVkXSgpO1xuICAgICAgICBjb25zdCBnbHRmTWF0ZXJpYWwgPSB0aGlzWyRzb3VyY2VPYmplY3RdO1xuICAgICAgICBmb3IgKGNvbnN0IG1hdGVyaWFsIG9mIHRoaXNbJGNvcnJlbGF0ZWRPYmplY3RzXSkge1xuICAgICAgICAgICAgaWYgKHRoaXNbJHNvdXJjZU9iamVjdF0uYWxwaGFNb2RlID09PSAnTUFTSycpIHtcbiAgICAgICAgICAgICAgICBtYXRlcmlhbC5hbHBoYVRlc3QgPSBnbHRmTWF0ZXJpYWwuYWxwaGFDdXRvZmY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXRlcmlhbC5hbHBoYVRlc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0QWxwaGFDdXRvZmYoY3V0b2ZmKSB7XG4gICAgICAgIHRoaXNbJGVuc3VyZU1hdGVyaWFsSXNMb2FkZWRdKCk7XG4gICAgICAgIHRoaXNbJHNvdXJjZU9iamVjdF0uYWxwaGFDdXRvZmYgPSBjdXRvZmY7XG4gICAgICAgIHRoaXNbJGFwcGx5QWxwaGFDdXRvZmZdKCk7XG4gICAgICAgIHRoaXNbJG9uVXBkYXRlXSgpO1xuICAgIH1cbiAgICBnZXRBbHBoYUN1dG9mZigpIHtcbiAgICAgICAgdGhpc1skZW5zdXJlTWF0ZXJpYWxJc0xvYWRlZF0oKTtcbiAgICAgICAgcmV0dXJuIHRoaXNbJHNvdXJjZU9iamVjdF0uYWxwaGFDdXRvZmY7XG4gICAgfVxuICAgIHNldERvdWJsZVNpZGVkKGRvdWJsZVNpZGVkKSB7XG4gICAgICAgIHRoaXNbJGVuc3VyZU1hdGVyaWFsSXNMb2FkZWRdKCk7XG4gICAgICAgIGZvciAoY29uc3QgbWF0ZXJpYWwgb2YgdGhpc1skY29ycmVsYXRlZE9iamVjdHNdKSB7XG4gICAgICAgICAgICAvLyBXaGVuIGRvdWJsZS1zaWRlZCBpcyBkaXNhYmxlZCBnbHRmIHNwZWMgZGljdGF0ZXMgdGhhdCBCYWNrLUZhY2UgY3VsbGluZ1xuICAgICAgICAgICAgLy8gbXVzdCBiZSBkaXNhYmxlZCwgaW4gdGhyZWUuanMgcGFybGFuY2UgdGhhdCB3b3VsZCBtZWFuIEZyb250U2lkZVxuICAgICAgICAgICAgLy8gcmVuZGVyaW5nIG9ubHkuXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAjZG91YmxlLXNpZGVkXG4gICAgICAgICAgICBtYXRlcmlhbC5zaWRlID0gZG91YmxlU2lkZWQgPyBEb3VibGVTaWRlIDogRnJvbnRTaWRlO1xuICAgICAgICAgICAgbWF0ZXJpYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbJHNvdXJjZU9iamVjdF0uZG91YmxlU2lkZWQgPSBkb3VibGVTaWRlZDtcbiAgICAgICAgdGhpc1skb25VcGRhdGVdKCk7XG4gICAgfVxuICAgIGdldERvdWJsZVNpZGVkKCkge1xuICAgICAgICB0aGlzWyRlbnN1cmVNYXRlcmlhbElzTG9hZGVkXSgpO1xuICAgICAgICByZXR1cm4gdGhpc1skc291cmNlT2JqZWN0XS5kb3VibGVTaWRlZDtcbiAgICB9XG4gICAgc2V0QWxwaGFNb2RlKGFscGhhTW9kZSkge1xuICAgICAgICB0aGlzWyRlbnN1cmVNYXRlcmlhbElzTG9hZGVkXSgpO1xuICAgICAgICBjb25zdCBlbmFibGVUcmFuc3BhcmVuY3kgPSAobWF0ZXJpYWwsIGVuYWJsZWQpID0+IHtcbiAgICAgICAgICAgIG1hdGVyaWFsLnRyYW5zcGFyZW50ID0gZW5hYmxlZDtcbiAgICAgICAgICAgIG1hdGVyaWFsLmRlcHRoV3JpdGUgPSAhZW5hYmxlZDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpc1skc291cmNlT2JqZWN0XS5hbHBoYU1vZGUgPSBhbHBoYU1vZGU7XG4gICAgICAgIGZvciAoY29uc3QgbWF0ZXJpYWwgb2YgdGhpc1skY29ycmVsYXRlZE9iamVjdHNdKSB7XG4gICAgICAgICAgICBlbmFibGVUcmFuc3BhcmVuY3kobWF0ZXJpYWwsIGFscGhhTW9kZSA9PT0gJ0JMRU5EJyk7XG4gICAgICAgICAgICB0aGlzWyRhcHBseUFscGhhQ3V0b2ZmXSgpO1xuICAgICAgICAgICAgbWF0ZXJpYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbJG9uVXBkYXRlXSgpO1xuICAgIH1cbiAgICBnZXRBbHBoYU1vZGUoKSB7XG4gICAgICAgIHRoaXNbJGVuc3VyZU1hdGVyaWFsSXNMb2FkZWRdKCk7XG4gICAgICAgIHJldHVybiB0aGlzWyRzb3VyY2VPYmplY3RdLmFscGhhTW9kZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXRlcmlhbC5qcy5tYXAiLCIvKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAnTGljZW5zZScpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICdBUyBJUycgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbmltcG9ydCB7IE1lc2ggfSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyAkc2V0QWN0aXZlLCAkdmFyaWFudFNldCwgTWF0ZXJpYWwgfSBmcm9tICcuL21hdGVyaWFsLmpzJztcbmltcG9ydCB7IE5vZGUsIFByaW1pdGl2ZU5vZGUgfSBmcm9tICcuL25vZGVzL3ByaW1pdGl2ZS1ub2RlLmpzJztcbmltcG9ydCB7ICRjb3JyZWxhdGVkT2JqZWN0cywgJHNvdXJjZU9iamVjdCB9IGZyb20gJy4vdGhyZWUtZG9tLWVsZW1lbnQuanMnO1xuZXhwb3J0IGNvbnN0ICRtYXRlcmlhbHMgPSBTeW1ib2woJ21hdGVyaWFscycpO1xuY29uc3QgJGhpZXJhcmNoeSA9IFN5bWJvbCgnaGllcmFyY2h5Jyk7XG5jb25zdCAkcm9vdHMgPSBTeW1ib2woJ3Jvb3RzJyk7XG5leHBvcnQgY29uc3QgJHByaW1pdGl2ZXNMaXN0ID0gU3ltYm9sKCdwcmltaXRpdmVzJyk7XG5leHBvcnQgY29uc3QgJGxvYWRWYXJpYW50ID0gU3ltYm9sKCdsb2FkVmFyaWFudCcpO1xuZXhwb3J0IGNvbnN0ICRjb3JyZWxhdGVkU2NlbmVHcmFwaCA9IFN5bWJvbCgnY29ycmVsYXRlZFNjZW5lR3JhcGgnKTtcbmV4cG9ydCBjb25zdCAkcHJlcGFyZVZhcmlhbnRzRm9yRXhwb3J0ID0gU3ltYm9sKCdwcmVwYXJlVmFyaWFudHNGb3JFeHBvcnQnKTtcbmV4cG9ydCBjb25zdCAkc3dpdGNoVmFyaWFudCA9IFN5bWJvbCgnc3dpdGNoVmFyaWFudCcpO1xuZXhwb3J0IGNvbnN0ICRtYXRlcmlhbEZyb21Qb2ludCA9IFN5bWJvbCgnbWF0ZXJpYWxGcm9tUG9pbnQnKTtcbmV4cG9ydCBjb25zdCAkbm9kZUZyb21Qb2ludCA9IFN5bWJvbCgnbm9kZUZyb21Qb2ludCcpO1xuZXhwb3J0IGNvbnN0ICRub2RlRnJvbUluZGV4ID0gU3ltYm9sKCdub2RlRnJvbUluZGV4Jyk7XG5leHBvcnQgY29uc3QgJHZhcmlhbnREYXRhID0gU3ltYm9sKCd2YXJpYW50RGF0YScpO1xuZXhwb3J0IGNvbnN0ICRhdmFpbGFibGVWYXJpYW50cyA9IFN5bWJvbCgnYXZhaWxhYmxlVmFyaWFudHMnKTtcbmNvbnN0ICRtb2RlbE9uVXBkYXRlID0gU3ltYm9sKCdtb2RlbE9uVXBkYXRlJyk7XG5jb25zdCAkY2xvbmVNYXRlcmlhbCA9IFN5bWJvbCgnY2xvbmVNYXRlcmlhbCcpO1xuLy8gSG9sZHMgb250byB0ZW1wb3Jhcnkgc2NlbmUgY29udGV4dCBpbmZvcm1hdGlvbiBuZWVkZWQgdG8gcGVyZm9ybSBsYXp5IGxvYWRpbmdcbi8vIG9mIGEgcmVzb3VyY2UuXG5leHBvcnQgY2xhc3MgTGF6eUxvYWRlciB7XG4gICAgY29uc3RydWN0b3IoZ2x0ZiwgZ2x0ZkVsZW1lbnRNYXAsIG1hcEtleSwgZG9MYXp5TG9hZCkge1xuICAgICAgICB0aGlzLmdsdGYgPSBnbHRmO1xuICAgICAgICB0aGlzLmdsdGZFbGVtZW50TWFwID0gZ2x0ZkVsZW1lbnRNYXA7XG4gICAgICAgIHRoaXMubWFwS2V5ID0gbWFwS2V5O1xuICAgICAgICB0aGlzLmRvTGF6eUxvYWQgPSBkb0xhenlMb2FkO1xuICAgIH1cbn1cbi8qKlxuICogQSBNb2RlbCBmYWNhZGVzIHRoZSB0b3AtbGV2ZWwgR0xURiBvYmplY3QgcmV0dXJuZWQgYnkgVGhyZWUuanMnIEdMVEZMb2FkZXIuXG4gKiBDdXJyZW50bHksIHRoZSBtb2RlbCBvbmx5IGJvdGhlcnMgaXRzZWxmIHdpdGggdGhlIG1hdGVyaWFscyBpbiB0aGUgVGhyZWUuanNcbiAqIHNjZW5lIGdyYXBoLlxuICovXG5leHBvcnQgY2xhc3MgTW9kZWwge1xuICAgIGNvbnN0cnVjdG9yKGNvcnJlbGF0ZWRTY2VuZUdyYXBoLCBvblVwZGF0ZSA9ICgpID0+IHsgfSkge1xuICAgICAgICB0aGlzW19hXSA9IG5ldyBBcnJheSgpO1xuICAgICAgICB0aGlzW19iXSA9IG5ldyBBcnJheSgpO1xuICAgICAgICB0aGlzW19jXSA9IG5ldyBBcnJheSgpO1xuICAgICAgICB0aGlzW19kXSA9IG5ldyBBcnJheSgpO1xuICAgICAgICB0aGlzW19lXSA9ICgpID0+IHsgfTtcbiAgICAgICAgdGhpc1tfZl0gPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXNbJG1vZGVsT25VcGRhdGVdID0gb25VcGRhdGU7XG4gICAgICAgIHRoaXNbJGNvcnJlbGF0ZWRTY2VuZUdyYXBoXSA9IGNvcnJlbGF0ZWRTY2VuZUdyYXBoO1xuICAgICAgICBjb25zdCB7IGdsdGYsIHRocmVlR0xURiwgZ2x0ZkVsZW1lbnRNYXAgfSA9IGNvcnJlbGF0ZWRTY2VuZUdyYXBoO1xuICAgICAgICBmb3IgKGNvbnN0IFtpLCBtYXRlcmlhbF0gb2YgZ2x0Zi5tYXRlcmlhbHMuZW50cmllcygpKSB7XG4gICAgICAgICAgICBjb25zdCBjb3JyZWxhdGVkTWF0ZXJpYWwgPSBnbHRmRWxlbWVudE1hcC5nZXQobWF0ZXJpYWwpO1xuICAgICAgICAgICAgaWYgKGNvcnJlbGF0ZWRNYXRlcmlhbCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpc1skbWF0ZXJpYWxzXS5wdXNoKG5ldyBNYXRlcmlhbChvblVwZGF0ZSwgZ2x0ZiwgbWF0ZXJpYWwsIGksIHRydWUsIHRoaXNbJHZhcmlhbnREYXRhXSwgY29ycmVsYXRlZE1hdGVyaWFsKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50QXJyYXkgPSBnbHRmWydtYXRlcmlhbHMnXSB8fCBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBnbHRmTWF0ZXJpYWxEZWYgPSBlbGVtZW50QXJyYXlbaV07XG4gICAgICAgICAgICAgICAgLy8gTG9hZHMgdGhlIHRocmVlLmpzIG1hdGVyaWFsLlxuICAgICAgICAgICAgICAgIGNvbnN0IGNhcHR1cmVkTWF0SW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGVyaWFsTG9hZENhbGxiYWNrID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0aHJlZU1hdGVyaWFsID0gYXdhaXQgdGhyZWVHTFRGLnBhcnNlci5nZXREZXBlbmRlbmN5KCdtYXRlcmlhbCcsIGNhcHR1cmVkTWF0SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGRzIGNvcnJlbGF0aW9uLCBtYXBzIHRoZSB2YXJpYW50IGdsdGYtZGVmIHRvIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyB0aHJlZSBtYXRlcmlhbCBzZXQgY29udGFpbmluZyB0aGUgdmFyaWFudCBtYXRlcmlhbC5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGhyZWVNYXRlcmlhbFNldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgZ2x0ZkVsZW1lbnRNYXAuc2V0KGdsdGZNYXRlcmlhbERlZiwgdGhyZWVNYXRlcmlhbFNldCk7XG4gICAgICAgICAgICAgICAgICAgIHRocmVlTWF0ZXJpYWxTZXQuYWRkKHRocmVlTWF0ZXJpYWwpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBzZXQ6IHRocmVlTWF0ZXJpYWxTZXQsIG1hdGVyaWFsOiB0aHJlZU1hdGVyaWFsIH07XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBDb25maWd1cmVzIHRoZSBtYXRlcmlhbCBmb3IgbGF6eSBsb2FkaW5nLlxuICAgICAgICAgICAgICAgIHRoaXNbJG1hdGVyaWFsc10ucHVzaChuZXcgTWF0ZXJpYWwob25VcGRhdGUsIGdsdGYsIGdsdGZNYXRlcmlhbERlZiwgaSwgZmFsc2UsIHRoaXNbJHZhcmlhbnREYXRhXSwgY29ycmVsYXRlZE1hdGVyaWFsLCBuZXcgTGF6eUxvYWRlcihnbHRmLCBnbHRmRWxlbWVudE1hcCwgZ2x0Zk1hdGVyaWFsRGVmLCBtYXRlcmlhbExvYWRDYWxsYmFjaykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGVzIGEgaGllcmFyY2h5IG9mIE5vZGVzLiBBbGxvd3Mgbm90IGp1c3QgZm9yIHN3aXRjaGluZyB3aGljaFxuICAgICAgICAvLyBtYXRlcmlhbCBpcyBhcHBsaWVkIHRvIGEgbWVzaCBidXQgYWxzbyBleHBvc2VzIGEgd2F5IHRvIHByb3ZpZGUgQVBJXG4gICAgICAgIC8vIGZvciBzd2l0Y2hpbmcgbWF0ZXJpYWxzIGFuZCBnZW5lcmFsIGFzc2lnbm1lbnQvbW9kaWZpY2F0aW9uLlxuICAgICAgICAvLyBQcmVwYXJlcyBmb3Igc2NlbmUgaXRlcmF0aW9uLlxuICAgICAgICBjb25zdCBwYXJlbnRNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IG5vZGVTdGFjayA9IG5ldyBBcnJheSgpO1xuICAgICAgICBmb3IgKGNvbnN0IG9iamVjdCBvZiB0aHJlZUdMVEYuc2NlbmUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIG5vZGVTdGFjay5wdXNoKG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2Fsa3MgdGhlIGhpZXJhcmNoeSBhbmQgY3JlYXRlcyBhIG5vZGUgdHJlZS5cbiAgICAgICAgd2hpbGUgKG5vZGVTdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBvYmplY3QgPSBub2RlU3RhY2sucG9wKCk7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IG51bGw7XG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgTWVzaCkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBuZXcgUHJpbWl0aXZlTm9kZShvYmplY3QsIHRoaXMubWF0ZXJpYWxzLCB0aGlzWyR2YXJpYW50RGF0YV0sIGNvcnJlbGF0ZWRTY2VuZUdyYXBoKTtcbiAgICAgICAgICAgICAgICB0aGlzWyRwcmltaXRpdmVzTGlzdF0ucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBuZXcgTm9kZShvYmplY3QubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBwYXJlbnRNYXAuZ2V0KG9iamVjdCk7XG4gICAgICAgICAgICBpZiAocGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXNbJHJvb3RzXS5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpc1skaGllcmFyY2h5XS5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBvYmplY3QuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBub2RlU3RhY2sucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgcGFyZW50TWFwLnNldChvYmplY3QsIG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hdGVyaWFscyBhcmUgbGlzdGVkIGluIHRoZSBvcmRlciBvZiB0aGUgR0xURiBtYXRlcmlhbHMgYXJyYXksIHBsdXMgYVxuICAgICAqIGRlZmF1bHQgbWF0ZXJpYWwgYXQgdGhlIGVuZCBpZiBvbmUgaXMgdXNlZC5cbiAgICAgKlxuICAgICAqIFRPRE8oIzEwMDMpOiBIb3cgZG8gd2UgaGFuZGxlIG5vbi1hY3RpdmUgc2NlbmVzP1xuICAgICAqL1xuICAgIGdldCBtYXRlcmlhbHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzWyRtYXRlcmlhbHNdO1xuICAgIH1cbiAgICBbKF9hID0gJG1hdGVyaWFscywgX2IgPSAkaGllcmFyY2h5LCBfYyA9ICRyb290cywgX2QgPSAkcHJpbWl0aXZlc0xpc3QsIF9lID0gJG1vZGVsT25VcGRhdGUsIF9mID0gJHZhcmlhbnREYXRhLCAkYXZhaWxhYmxlVmFyaWFudHMpXSgpIHtcbiAgICAgICAgY29uc3QgdmFyaWFudHMgPSBBcnJheS5mcm9tKHRoaXNbJHZhcmlhbnREYXRhXS52YWx1ZXMoKSk7XG4gICAgICAgIHZhcmlhbnRzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhLmluZGV4IC0gYi5pbmRleDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YXJpYW50cy5tYXAoKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhLm5hbWU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRNYXRlcmlhbEJ5TmFtZShuYW1lKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSB0aGlzWyRtYXRlcmlhbHNdLmZpbHRlcihtYXRlcmlhbCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbWF0ZXJpYWwubmFtZSA9PT0gbmFtZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChtYXRjaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVzWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBbJG5vZGVGcm9tSW5kZXhdKG1lc2gsIHByaW1pdGl2ZSkge1xuICAgICAgICBjb25zdCBmb3VuZCA9IHRoaXNbJGhpZXJhcmNoeV0uZmluZCgobm9kZSkgPT4ge1xuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBQcmltaXRpdmVOb2RlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBtZXNoZXMsIHByaW1pdGl2ZXMgfSA9IG5vZGUubWVzaC51c2VyRGF0YS5hc3NvY2lhdGlvbnM7XG4gICAgICAgICAgICAgICAgaWYgKG1lc2hlcyA9PSBtZXNoICYmIHByaW1pdGl2ZXMgPT0gcHJpbWl0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmb3VuZCA9PSBudWxsID8gbnVsbCA6IGZvdW5kO1xuICAgIH1cbiAgICBbJG5vZGVGcm9tUG9pbnRdKGhpdCkge1xuICAgICAgICByZXR1cm4gdGhpc1skaGllcmFyY2h5XS5maW5kKChub2RlKSA9PiB7XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIFByaW1pdGl2ZU5vZGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmltaXRpdmUgPSBub2RlO1xuICAgICAgICAgICAgICAgIGlmIChwcmltaXRpdmUubWVzaCA9PT0gaGl0Lm9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcnNlY3RzIGEgcmF5IHdpdGggdGhlIE1vZGVsIGFuZCByZXR1cm5zIHRoZSBmaXJzdCBtYXRlcmlhbCB3aG9zZVxuICAgICAqIG9iamVjdCB3YXMgaW50ZXJzZWN0ZWQuXG4gICAgICovXG4gICAgWyRtYXRlcmlhbEZyb21Qb2ludF0oaGl0KSB7XG4gICAgICAgIHJldHVybiB0aGlzWyRub2RlRnJvbVBvaW50XShoaXQpLmdldEFjdGl2ZU1hdGVyaWFsKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN3aXRjaGVzIG1vZGVsIHZhcmlhbnQgdG8gdGhlIHZhcmlhbnQgbmFtZSBwcm92aWRlZCwgb3Igc3dpdGNoZXMgdG9cbiAgICAgKiBkZWZhdWx0L2luaXRpYWwgbWF0ZXJpYWxzIGlmICdudWxsJyBpcyBwcm92aWRlZC5cbiAgICAgKi9cbiAgICBhc3luYyBbJHN3aXRjaFZhcmlhbnRdKHZhcmlhbnROYW1lKSB7XG4gICAgICAgIGZvciAoY29uc3QgcHJpbWl0aXZlIG9mIHRoaXNbJHByaW1pdGl2ZXNMaXN0XSkge1xuICAgICAgICAgICAgYXdhaXQgcHJpbWl0aXZlLmVuYWJsZVZhcmlhbnQodmFyaWFudE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgbWF0ZXJpYWwgb2YgdGhpcy5tYXRlcmlhbHMpIHtcbiAgICAgICAgICAgIG1hdGVyaWFsWyRzZXRBY3RpdmVdKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYXJrcyB0aGUgbWF0ZXJpYWxzIHRoYXQgYXJlIG5vdyBpbiB1c2UgYWZ0ZXIgdGhlIHZhcmlhbnQgc3dpdGNoLlxuICAgICAgICBmb3IgKGNvbnN0IHByaW1pdGl2ZSBvZiB0aGlzWyRwcmltaXRpdmVzTGlzdF0pIHtcbiAgICAgICAgICAgIHRoaXMubWF0ZXJpYWxzW3ByaW1pdGl2ZS5nZXRBY3RpdmVNYXRlcmlhbCgpLmluZGV4XVskc2V0QWN0aXZlXSh0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBbJHByZXBhcmVWYXJpYW50c0ZvckV4cG9ydF0oKSB7XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gbmV3IEFycmF5KCk7XG4gICAgICAgIGZvciAoY29uc3QgcHJpbWl0aXZlIG9mIHRoaXNbJHByaW1pdGl2ZXNMaXN0XSkge1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChwcmltaXRpdmUuaW5zdGFudGlhdGVWYXJpYW50cygpKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgfVxuICAgIFskY2xvbmVNYXRlcmlhbF0oaW5kZXgsIG5ld01hdGVyaWFsTmFtZSkge1xuICAgICAgICBjb25zdCBtYXRlcmlhbCA9IHRoaXMubWF0ZXJpYWxzW2luZGV4XTtcbiAgICAgICAgaWYgKCFtYXRlcmlhbC5pc0xvYWRlZCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgQ2xvbmluZyBhbiB1bmxvYWRlZCBtYXRlcmlhbCxcbiAgICAgICAgICAgY2FsbCAnbWF0ZXJpYWwuZW5zdXJlTG9hZGVkKCkgYmVmb3JlIGNsb25pbmcgdGhlIG1hdGVyaWFsLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRocmVlTWF0ZXJpYWxTZXQgPSBtYXRlcmlhbFskY29ycmVsYXRlZE9iamVjdHNdO1xuICAgICAgICAvLyBjbG9uZXMgdGhlIGdsdGYgbWF0ZXJpYWwgZGF0YSBhbmQgdXBkYXRlcyB0aGUgbWF0ZXJpYWwgbmFtZS5cbiAgICAgICAgY29uc3QgZ2x0ZlNvdXJjZU1hdGVyaWFsID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShtYXRlcmlhbFskc291cmNlT2JqZWN0XSkpO1xuICAgICAgICBnbHRmU291cmNlTWF0ZXJpYWwubmFtZSA9IG5ld01hdGVyaWFsTmFtZTtcbiAgICAgICAgLy8gQWRkcyB0aGUgc291cmNlIG1hdGVyaWFsIGNsb25lIHRvIHRoZSBnbHRmIGRlZi5cbiAgICAgICAgY29uc3QgZ2x0ZiA9IHRoaXNbJGNvcnJlbGF0ZWRTY2VuZUdyYXBoXS5nbHRmO1xuICAgICAgICBnbHRmLm1hdGVyaWFscy5wdXNoKGdsdGZTb3VyY2VNYXRlcmlhbCk7XG4gICAgICAgIGNvbnN0IGNsb25lZFNldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgZm9yIChjb25zdCBbaSwgdGhyZWVNYXRlcmlhbF0gb2YgdGhyZWVNYXRlcmlhbFNldC5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNsb25lID0gdGhyZWVNYXRlcmlhbC5jbG9uZSgpO1xuICAgICAgICAgICAgY2xvbmUubmFtZSA9XG4gICAgICAgICAgICAgICAgbmV3TWF0ZXJpYWxOYW1lICsgKHRocmVlTWF0ZXJpYWxTZXQuc2l6ZSA+IDEgPyAnX2luc3QnICsgaSA6ICcnKTtcbiAgICAgICAgICAgIGNsb25lZFNldC5hZGQoY2xvbmUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsb25lZE1hdGVyaWFsID0gbmV3IE1hdGVyaWFsKHRoaXNbJG1vZGVsT25VcGRhdGVdLCB0aGlzWyRjb3JyZWxhdGVkU2NlbmVHcmFwaF0uZ2x0ZiwgZ2x0ZlNvdXJjZU1hdGVyaWFsLCB0aGlzWyRtYXRlcmlhbHNdLmxlbmd0aCwgZmFsc2UsIC8vIENsb25lZCBhcyBpbmFjdGl2ZS5cbiAgICAgICAgdGhpc1skdmFyaWFudERhdGFdLCBjbG9uZWRTZXQpO1xuICAgICAgICB0aGlzWyRtYXRlcmlhbHNdLnB1c2goY2xvbmVkTWF0ZXJpYWwpO1xuICAgICAgICByZXR1cm4gY2xvbmVkTWF0ZXJpYWw7XG4gICAgfVxuICAgIGNyZWF0ZU1hdGVyaWFsSW5zdGFuY2VGb3JWYXJpYW50KG9yaWdpbmFsTWF0ZXJpYWxJbmRleCwgbmV3TWF0ZXJpYWxOYW1lLCB2YXJpYW50TmFtZSwgYWN0aXZhdGVWYXJpYW50ID0gdHJ1ZSkge1xuICAgICAgICBsZXQgdmFyaWFudE1hdGVyaWFsSW5zdGFuY2UgPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IHByaW1pdGl2ZSBvZiB0aGlzWyRwcmltaXRpdmVzTGlzdF0pIHtcbiAgICAgICAgICAgIGNvbnN0IHZhcmlhbnREYXRhID0gdGhpc1skdmFyaWFudERhdGFdLmdldCh2YXJpYW50TmFtZSk7XG4gICAgICAgICAgICAvLyBTa2lwcyB0aGUgcHJpbWl0aXZlIGlmIHRoZSB2YXJpYW50IGFscmVhZHkgZXhpc3RzLlxuICAgICAgICAgICAgaWYgKHZhcmlhbnREYXRhICE9IG51bGwgJiYgcHJpbWl0aXZlLnZhcmlhbnRJbmZvLmhhcyh2YXJpYW50RGF0YS5pbmRleCkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNraXBzIHRoZSBwcmltaXRpdmUgaWYgdGhlIHNvdXJjZS9vcmlnaW5hbCBtYXRlcmlhbCBkb2VzIG5vdCBleGlzdC5cbiAgICAgICAgICAgIGlmIChwcmltaXRpdmUuZ2V0TWF0ZXJpYWwob3JpZ2luYWxNYXRlcmlhbEluZGV4KSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzVmFyaWFudCh2YXJpYW50TmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZVZhcmlhbnQodmFyaWFudE5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhcmlhbnRNYXRlcmlhbEluc3RhbmNlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXJpYW50TWF0ZXJpYWxJbnN0YW5jZSA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbJGNsb25lTWF0ZXJpYWxdKG9yaWdpbmFsTWF0ZXJpYWxJbmRleCwgbmV3TWF0ZXJpYWxOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByaW1pdGl2ZS5hZGRWYXJpYW50KHZhcmlhbnRNYXRlcmlhbEluc3RhbmNlLCB2YXJpYW50TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGl2YXRlVmFyaWFudCAmJiB2YXJpYW50TWF0ZXJpYWxJbnN0YW5jZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXJpYW50TWF0ZXJpYWxJbnN0YW5jZVskc2V0QWN0aXZlXSh0cnVlKTtcbiAgICAgICAgICAgIHRoaXMubWF0ZXJpYWxzW29yaWdpbmFsTWF0ZXJpYWxJbmRleF1bJHNldEFjdGl2ZV0oZmFsc2UpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwcmltaXRpdmUgb2YgdGhpc1skcHJpbWl0aXZlc0xpc3RdKSB7XG4gICAgICAgICAgICAgICAgcHJpbWl0aXZlLmVuYWJsZVZhcmlhbnQodmFyaWFudE5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YXJpYW50TWF0ZXJpYWxJbnN0YW5jZTtcbiAgICB9XG4gICAgY3JlYXRlVmFyaWFudCh2YXJpYW50TmFtZSkge1xuICAgICAgICBpZiAoIXRoaXNbJHZhcmlhbnREYXRhXS5oYXModmFyaWFudE5hbWUpKSB7XG4gICAgICAgICAgICAvLyBBZGRzIHRoZSBuYW1lIGlmIGl0J3Mgbm90IGFscmVhZHkgaW4gdGhlIGxpc3QuXG4gICAgICAgICAgICB0aGlzWyR2YXJpYW50RGF0YV0uc2V0KHZhcmlhbnROYW1lLCB7IG5hbWU6IHZhcmlhbnROYW1lLCBpbmRleDogdGhpc1skdmFyaWFudERhdGFdLnNpemUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFZhcmlhbnQgJyR7dmFyaWFudE5hbWV9JycgYWxyZWFkeSBleGlzdHNgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYXNWYXJpYW50KHZhcmlhbnROYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzWyR2YXJpYW50RGF0YV0uaGFzKHZhcmlhbnROYW1lKTtcbiAgICB9XG4gICAgc2V0TWF0ZXJpYWxUb1ZhcmlhbnQobWF0ZXJpYWxJbmRleCwgdGFyZ2V0VmFyaWFudE5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXNbJGF2YWlsYWJsZVZhcmlhbnRzXSgpLmZpbmQobmFtZSA9PiBuYW1lID09PSB0YXJnZXRWYXJpYW50TmFtZSkgPT1cbiAgICAgICAgICAgIG51bGwpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgQ2FuJ3QgYWRkIG1hdGVyaWFsIHRvICcke3RhcmdldFZhcmlhbnROYW1lfScsIHRoZSB2YXJpYW50IGRvZXMgbm90IGV4aXN0LidgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0ZXJpYWxJbmRleCA8IDAgfHwgbWF0ZXJpYWxJbmRleCA+PSB0aGlzLm1hdGVyaWFscy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYHNldE1hdGVyaWFsVG9WYXJpYW50KCk6IG1hdGVyaWFsSW5kZXggaXMgb3V0IG9mIGJvdW5kcy5gKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHByaW1pdGl2ZSBvZiB0aGlzWyRwcmltaXRpdmVzTGlzdF0pIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGVyaWFsID0gcHJpbWl0aXZlLmdldE1hdGVyaWFsKG1hdGVyaWFsSW5kZXgpO1xuICAgICAgICAgICAgLy8gRW5zdXJlcyB0aGUgbWF0ZXJpYWwgZXhpc3RzIG9uIHRoZSBwcmltaXRpdmUgYmVmb3JlIHNldHRpbmcgaXQgdG8gYVxuICAgICAgICAgICAgLy8gdmFyaWFudC5cbiAgICAgICAgICAgIGlmIChtYXRlcmlhbCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcHJpbWl0aXZlLmFkZFZhcmlhbnQobWF0ZXJpYWwsIHRhcmdldFZhcmlhbnROYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVWYXJpYW50TmFtZShjdXJyZW50TmFtZSwgbmV3TmFtZSkge1xuICAgICAgICBjb25zdCB2YXJpYW50RGF0YSA9IHRoaXNbJHZhcmlhbnREYXRhXS5nZXQoY3VycmVudE5hbWUpO1xuICAgICAgICBpZiAodmFyaWFudERhdGEgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhcmlhbnREYXRhLm5hbWUgPSBuZXdOYW1lO1xuICAgICAgICB0aGlzWyR2YXJpYW50RGF0YV0uc2V0KG5ld05hbWUsIHZhcmlhbnREYXRhKTtcbiAgICAgICAgdGhpc1skdmFyaWFudERhdGFdLmRlbGV0ZShjdXJyZW50TmFtZSk7XG4gICAgfVxuICAgIGRlbGV0ZVZhcmlhbnQodmFyaWFudE5hbWUpIHtcbiAgICAgICAgY29uc3QgdmFyaWFudCA9IHRoaXNbJHZhcmlhbnREYXRhXS5nZXQodmFyaWFudE5hbWUpO1xuICAgICAgICBpZiAodmFyaWFudCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBtYXRlcmlhbCBvZiB0aGlzLm1hdGVyaWFscykge1xuICAgICAgICAgICAgaWYgKG1hdGVyaWFsLmhhc1ZhcmlhbnQodmFyaWFudE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgbWF0ZXJpYWxbJHZhcmlhbnRTZXRdLmRlbGV0ZSh2YXJpYW50LmluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHByaW1pdGl2ZSBvZiB0aGlzWyRwcmltaXRpdmVzTGlzdF0pIHtcbiAgICAgICAgICAgIHByaW1pdGl2ZS5kZWxldGVWYXJpYW50KHZhcmlhbnQuaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbJHZhcmlhbnREYXRhXS5kZWxldGUodmFyaWFudE5hbWUpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZGVsLmpzLm1hcCIsImltcG9ydCB7ICRnZXRMb2FkZWRNYXRlcmlhbCwgJHZhcmlhbnRJbmRpY2VzIH0gZnJvbSAnLi4vbWF0ZXJpYWwuanMnO1xuaW1wb3J0IHsgJGNvcnJlbGF0ZWRPYmplY3RzIH0gZnJvbSAnLi4vdGhyZWUtZG9tLWVsZW1lbnQuanMnO1xuLy8gRGVmaW5lcyB0aGUgYmFzZSBsZXZlbCBub2RlIG1ldGhvZHMgYW5kIGRhdGEuXG5leHBvcnQgY2xhc3MgTm9kZSB7XG4gICAgY29uc3RydWN0b3IobmFtZSkge1xuICAgICAgICB0aGlzLm5hbWUgPSAnJztcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IG5ldyBBcnJheSgpO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIH1cbn1cbi8vIFJlcHJlc2VudHMgYSBwcmltaXRpdmUgaW4gYSBnbFRGIG1lc2guXG5leHBvcnQgY2xhc3MgUHJpbWl0aXZlTm9kZSBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKG1lc2gsIG12TWF0ZXJpYWxzLCBtb2RlbFZhcmlhbnRzLCBjb3JyZWxhdGVkU2NlbmVHcmFwaCkge1xuICAgICAgICBzdXBlcihtZXNoLm5hbWUpO1xuICAgICAgICAvLyBNYXBzIGdsVEYgbWF0ZXJpYWwgaW5kZXggbnVtYmVyIHRvIGEgbWF0ZXJpYWwgdGhhdCB0aGlzIHByaW1pdGl2ZSBzdXBwb3J0cy5cbiAgICAgICAgdGhpcy5tYXRlcmlhbHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIE1hcHMgdmFyaWFudCBpbmRleCB0byBtYXRlcmlhbC5cbiAgICAgICAgdGhpcy52YXJpYW50VG9NYXRlcmlhbE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5pbml0aWFsTWF0ZXJpYWxJZHggPSAwO1xuICAgICAgICB0aGlzLmFjdGl2ZU1hdGVyaWFsSWR4ID0gMDtcbiAgICAgICAgdGhpcy5tZXNoID0gbWVzaDtcbiAgICAgICAgY29uc3QgeyBnbHRmLCB0aHJlZUdMVEYsIHRocmVlT2JqZWN0TWFwIH0gPSBjb3JyZWxhdGVkU2NlbmVHcmFwaDtcbiAgICAgICAgdGhpcy5tb2RlbFZhcmlhbnRzID0gbW9kZWxWYXJpYW50cztcbiAgICAgICAgdGhpcy5tZXNoLnVzZXJEYXRhLnZhcmlhbnREYXRhID0gbW9kZWxWYXJpYW50cztcbiAgICAgICAgLy8gQ2FwdHVyZXMgdGhlIHByaW1pdGl2ZSdzIGluaXRpYWwgbWF0ZXJpYWwuXG4gICAgICAgIGNvbnN0IG1hdGVyaWFsTWFwcGluZ3MgPSB0aHJlZU9iamVjdE1hcC5nZXQobWVzaC5tYXRlcmlhbCk7XG4gICAgICAgIGlmIChtYXRlcmlhbE1hcHBpbmdzLm1hdGVyaWFscyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxNYXRlcmlhbElkeCA9IHRoaXMuYWN0aXZlTWF0ZXJpYWxJZHggPVxuICAgICAgICAgICAgICAgIG1hdGVyaWFsTWFwcGluZ3MubWF0ZXJpYWxzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgUHJpbWl0aXZlICgke21lc2gubmFtZX0pIG1pc3NpbmcgaW5pdGlhbCBtYXRlcmlhbCByZWZlcmVuY2UuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0cyB0aGUgbWVzaCBpbmRleCBmcm9tIHRoZSBub2RlLlxuICAgICAgICBjb25zdCBhc3NvY2lhdGlvbnMgPSBtZXNoLnVzZXJEYXRhLmFzc29jaWF0aW9ucyB8fFxuICAgICAgICAgICAge307XG4gICAgICAgIGlmIChhc3NvY2lhdGlvbnMubWVzaGVzID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ01lc2ggaXMgbWlzc2luZyBwcmltaXRpdmUgaW5kZXggYXNzb2NpYXRpb24nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgZ2x0ZiBtZXNoIGFycmF5IHRvIHNhbXBsZSBmcm9tLlxuICAgICAgICBjb25zdCBtZXNoRWxlbWVudEFycmF5ID0gZ2x0ZlsnbWVzaGVzJ10gfHwgW107XG4gICAgICAgIC8vIExpc3Qgb2YgcHJpbWl0aXZlcyB1bmRlciB0aGUgbWVzaC5cbiAgICAgICAgY29uc3QgZ2x0ZlByaW1pdGl2ZXMgPSAobWVzaEVsZW1lbnRBcnJheVthc3NvY2lhdGlvbnMubWVzaGVzXS5wcmltaXRpdmVzIHx8IFtdKTtcbiAgICAgICAgY29uc3QgZ2x0ZlByaW1pdGl2ZSA9IGdsdGZQcmltaXRpdmVzW2Fzc29jaWF0aW9ucy5wcmltaXRpdmVzXTtcbiAgICAgICAgaWYgKGdsdGZQcmltaXRpdmUgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignTWVzaCBwcmltaXRpdmUgZGVmaW5pdGlvbiBpcyBtaXNzaW5nLicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1hcHMgdGhlIGdsdGZQcmltaXRpdmUgZGVmYXVsdCB0byBhIG1hdGVyaWFsLlxuICAgICAgICBpZiAoZ2x0ZlByaW1pdGl2ZS5tYXRlcmlhbCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLm1hdGVyaWFscy5zZXQoZ2x0ZlByaW1pdGl2ZS5tYXRlcmlhbCwgbXZNYXRlcmlhbHNbZ2x0ZlByaW1pdGl2ZS5tYXRlcmlhbF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZGVmYXVsdElkeCA9IG12TWF0ZXJpYWxzLmZpbmRJbmRleCgobWF0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdC5uYW1lID09PSAnRGVmYXVsdCc7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChkZWZhdWx0SWR4ID49IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGVyaWFscy5zZXQoZGVmYXVsdElkeCwgbXZNYXRlcmlhbHNbZGVmYXVsdElkeF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdnbHRmUHJpbWl0aXZlIGhhcyBubyBtYXRlcmlhbCEnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2x0ZlByaW1pdGl2ZS5leHRlbnNpb25zICYmXG4gICAgICAgICAgICBnbHRmUHJpbWl0aXZlLmV4dGVuc2lvbnNbJ0tIUl9tYXRlcmlhbHNfdmFyaWFudHMnXSkge1xuICAgICAgICAgICAgY29uc3QgdmFyaWFudHNFeHRlbnNpb24gPSBnbHRmUHJpbWl0aXZlLmV4dGVuc2lvbnNbJ0tIUl9tYXRlcmlhbHNfdmFyaWFudHMnXTtcbiAgICAgICAgICAgIGNvbnN0IGV4dGVuc2lvbnMgPSB0aHJlZUdMVEYucGFyc2VyLmpzb24uZXh0ZW5zaW9ucztcbiAgICAgICAgICAgIGNvbnN0IHZhcmlhbnROYW1lcyA9IGV4dGVuc2lvbnNbJ0tIUl9tYXRlcmlhbHNfdmFyaWFudHMnXS52YXJpYW50cztcbiAgICAgICAgICAgIC8vIFByb3ZpZGVzIGRlZmluaXRpb24gbm93IHRoYXQgd2Uga25vdyB0aGVyZSBhcmUgdmFyaWFudHMgdG9cbiAgICAgICAgICAgIC8vIHN1cHBvcnQuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG1hcHBpbmcgb2YgdmFyaWFudHNFeHRlbnNpb24ubWFwcGluZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtdk1hdGVyaWFsID0gbXZNYXRlcmlhbHNbbWFwcGluZy5tYXRlcmlhbF07XG4gICAgICAgICAgICAgICAgLy8gTWFwcyB2YXJpYW50IGluZGljZXMgdG8gTWF0ZXJpYWxzLlxuICAgICAgICAgICAgICAgIHRoaXMubWF0ZXJpYWxzLnNldChtYXBwaW5nLm1hdGVyaWFsLCBtdk1hdGVyaWFsKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHZhcmlhbnQgb2YgbWFwcGluZy52YXJpYW50cykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IG5hbWUgfSA9IHZhcmlhbnROYW1lc1t2YXJpYW50XTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YXJpYW50VG9NYXRlcmlhbE1hcC5zZXQodmFyaWFudCwgbXZNYXRlcmlhbCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFByb3ZpZGVzIHZhcmlhbnQgaW5mbyBmb3IgbWF0ZXJpYWwgc2VsZiBsb29rdXAuXG4gICAgICAgICAgICAgICAgICAgIG12TWF0ZXJpYWxbJHZhcmlhbnRJbmRpY2VzXSgpLmFkZCh2YXJpYW50KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlcyB0aGUgbW9kZWxzIHZhcmlhbnQgZGF0YS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtb2RlbFZhcmlhbnRzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWxWYXJpYW50cy5zZXQobmFtZSwgeyBuYW1lLCBpbmRleDogdmFyaWFudCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBzZXRBY3RpdmVNYXRlcmlhbChtYXRlcmlhbCkge1xuICAgICAgICBjb25zdCBtdk1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbHMuZ2V0KG1hdGVyaWFsKTtcbiAgICAgICAgaWYgKG12TWF0ZXJpYWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5tZXNoLm1hdGVyaWFsID0gYXdhaXQgbXZNYXRlcmlhbFskZ2V0TG9hZGVkTWF0ZXJpYWxdKCk7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZU1hdGVyaWFsSWR4ID0gbWF0ZXJpYWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubWVzaC5tYXRlcmlhbDtcbiAgICB9XG4gICAgZ2V0QWN0aXZlTWF0ZXJpYWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hdGVyaWFscy5nZXQodGhpcy5hY3RpdmVNYXRlcmlhbElkeCk7XG4gICAgfVxuICAgIGdldE1hdGVyaWFsKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hdGVyaWFscy5nZXQoaW5kZXgpO1xuICAgIH1cbiAgICBhc3luYyBlbmFibGVWYXJpYW50KG5hbWUpIHtcbiAgICAgICAgaWYgKG5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0QWN0aXZlTWF0ZXJpYWwodGhpcy5pbml0aWFsTWF0ZXJpYWxJZHgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZhcmlhbnRUb01hdGVyaWFsTWFwICE9IG51bGwgJiYgdGhpcy5tb2RlbFZhcmlhbnRzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgY29uc3QgbW9kZWxWYXJpYW50cyA9IHRoaXMubW9kZWxWYXJpYW50cy5nZXQobmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmFibGVWYXJpYW50SGVscGVyKG1vZGVsVmFyaWFudHMuaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhc3luYyBlbmFibGVWYXJpYW50SGVscGVyKGluZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLnZhcmlhbnRUb01hdGVyaWFsTWFwICE9IG51bGwgJiYgaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgbWF0ZXJpYWwgPSB0aGlzLnZhcmlhbnRUb01hdGVyaWFsTWFwLmdldChpbmRleCk7XG4gICAgICAgICAgICBpZiAobWF0ZXJpYWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNldEFjdGl2ZU1hdGVyaWFsKG1hdGVyaWFsLmluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXN5bmMgaW5zdGFudGlhdGVWYXJpYW50cygpIHtcbiAgICAgICAgaWYgKHRoaXMudmFyaWFudFRvTWF0ZXJpYWxNYXAgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgaW5kZXggb2YgdGhpcy52YXJpYW50VG9NYXRlcmlhbE1hcC5rZXlzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhcmlhbnRNYXRlcmlhbCA9IHRoaXMubWVzaC51c2VyRGF0YS52YXJpYW50TWF0ZXJpYWxzLmdldChpbmRleCk7XG4gICAgICAgICAgICBpZiAodmFyaWFudE1hdGVyaWFsLm1hdGVyaWFsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRocmVlTWF0ZXJpYWwgPSBhd2FpdCB0aGlzLmVuYWJsZVZhcmlhbnRIZWxwZXIoaW5kZXgpO1xuICAgICAgICAgICAgaWYgKHRocmVlTWF0ZXJpYWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhcmlhbnRNYXRlcmlhbC5tYXRlcmlhbCA9IHRocmVlTWF0ZXJpYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHZhcmlhbnRJbmZvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YXJpYW50VG9NYXRlcmlhbE1hcDtcbiAgICB9XG4gICAgYWRkVmFyaWFudChtYXRlcmlhbFZhcmlhbnQsIHZhcmlhbnROYW1lKSB7XG4gICAgICAgIGlmICghdGhpcy5lbnN1cmVWYXJpYW50SXNVbnVzZWQodmFyaWFudE5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkcyB0aGUgdmFyaWFudCB0byB0aGUgbW9kZWwgdmFyaWFudHMgaWYgbmVlZGVkLlxuICAgICAgICBpZiAoIXRoaXMubW9kZWxWYXJpYW50cy5oYXModmFyaWFudE5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGVsVmFyaWFudHMuc2V0KHZhcmlhbnROYW1lLCB7IG5hbWU6IHZhcmlhbnROYW1lLCBpbmRleDogdGhpcy5tb2RlbFZhcmlhbnRzLnNpemUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW9kZWxWYXJpYW50RGF0YSA9IHRoaXMubW9kZWxWYXJpYW50cy5nZXQodmFyaWFudE5hbWUpO1xuICAgICAgICBjb25zdCB2YXJpYW50SW5kZXggPSBtb2RlbFZhcmlhbnREYXRhLmluZGV4O1xuICAgICAgICAvLyBVcGRhdGVzIG1hdGVyaWFscyBtYXBwZWQgdG8gdGhlIHZhcmlhbnQuXG4gICAgICAgIG1hdGVyaWFsVmFyaWFudFskdmFyaWFudEluZGljZXNdKCkuYWRkKHZhcmlhbnRJbmRleCk7XG4gICAgICAgIC8vIFVwZGF0ZXMgaW50ZXJuYWwgbWFwcGluZ3MuXG4gICAgICAgIHRoaXMudmFyaWFudFRvTWF0ZXJpYWxNYXAuc2V0KHZhcmlhbnRJbmRleCwgbWF0ZXJpYWxWYXJpYW50KTtcbiAgICAgICAgdGhpcy5tYXRlcmlhbHMuc2V0KG1hdGVyaWFsVmFyaWFudC5pbmRleCwgbWF0ZXJpYWxWYXJpYW50KTtcbiAgICAgICAgdGhpcy51cGRhdGVWYXJpYW50VXNlckRhdGEodmFyaWFudEluZGV4LCBtYXRlcmlhbFZhcmlhbnQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZGVsZXRlVmFyaWFudCh2YXJpYW50SW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFyaWFudEluZm8uaGFzKHZhcmlhbnRJbmRleCkpIHtcbiAgICAgICAgICAgIHRoaXMudmFyaWFudEluZm8uZGVsZXRlKHZhcmlhbnRJbmRleCk7XG4gICAgICAgICAgICBjb25zdCB1c2VyRGF0YU1hcCA9IHRoaXMubWVzaC51c2VyRGF0YS52YXJpYW50TWF0ZXJpYWxzO1xuICAgICAgICAgICAgaWYgKHVzZXJEYXRhTWFwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB1c2VyRGF0YU1hcC5kZWxldGUodmFyaWFudEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVWYXJpYW50VXNlckRhdGEodmFyaWFudEluZGV4LCBtYXRlcmlhbFZhcmlhbnQpIHtcbiAgICAgICAgLy8gQWRkcyB2YXJpYW50cyBuYW1lIHRvIG1hdGVyaWFsIHZhcmlhbnRzIHNldC5cbiAgICAgICAgbWF0ZXJpYWxWYXJpYW50WyR2YXJpYW50SW5kaWNlc10oKS5hZGQodmFyaWFudEluZGV4KTtcbiAgICAgICAgdGhpcy5tZXNoLnVzZXJEYXRhLnZhcmlhbnREYXRhID0gdGhpcy5tb2RlbFZhcmlhbnRzO1xuICAgICAgICAvLyBVcGRhdGVzIGltcG9ydCBkYXRhIChzZWUgVmFyaWFudE1hdGVyaWFsTG9hZGVyUGx1Z2luLnRzKS5cbiAgICAgICAgdGhpcy5tZXNoLnVzZXJEYXRhLnZhcmlhbnRNYXRlcmlhbHMgPSB0aGlzLm1lc2gudXNlckRhdGEudmFyaWFudE1hdGVyaWFscyB8fFxuICAgICAgICAgICAgbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCBtYXAgPSB0aGlzLm1lc2gudXNlckRhdGEudmFyaWFudE1hdGVyaWFscztcbiAgICAgICAgbWFwLnNldCh2YXJpYW50SW5kZXgsIHtcbiAgICAgICAgICAgIG1hdGVyaWFsOiBtYXRlcmlhbFZhcmlhbnRbJGNvcnJlbGF0ZWRPYmplY3RzXS52YWx1ZXMoKS5uZXh0KCkudmFsdWUsXG4gICAgICAgICAgICBnbHRmTWF0ZXJpYWxJbmRleDogbWF0ZXJpYWxWYXJpYW50LmluZGV4LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZW5zdXJlVmFyaWFudElzVW51c2VkKHZhcmlhbnROYW1lKSB7XG4gICAgICAgIGNvbnN0IG1vZGVsVmFyaWFudHMgPSB0aGlzLm1vZGVsVmFyaWFudHMuZ2V0KHZhcmlhbnROYW1lKTtcbiAgICAgICAgaWYgKG1vZGVsVmFyaWFudHMgIT0gbnVsbCAmJiB0aGlzLnZhcmlhbnRJbmZvLmhhcyhtb2RlbFZhcmlhbnRzLmluZGV4KSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBQcmltaXRpdmUgY2Fubm90IGFkZCB2YXJpYW50ICcke3ZhcmlhbnROYW1lfScgZm9yIHRoaXMgbWF0ZXJpYWwsIGl0IGFscmVhZHkgZXhpc3RzLmApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByaW1pdGl2ZS1ub2RlLmpzLm1hcCIsIi8qIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICdMaWNlbnNlJyk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gJ0FTIElTJyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IENvbG9yIH0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgVGV4dHVyZUluZm8sIFRleHR1cmVVc2FnZSB9IGZyb20gJy4vdGV4dHVyZS1pbmZvLmpzJztcbmltcG9ydCB7ICRjb3JyZWxhdGVkT2JqZWN0cywgJG9uVXBkYXRlLCAkc291cmNlT2JqZWN0LCBUaHJlZURPTUVsZW1lbnQgfSBmcm9tICcuL3RocmVlLWRvbS1lbGVtZW50LmpzJztcbmNvbnN0ICR0aHJlZU1hdGVyaWFscyA9IFN5bWJvbCgndGhyZWVNYXRlcmlhbHMnKTtcbmNvbnN0ICRiYXNlQ29sb3JUZXh0dXJlID0gU3ltYm9sKCdiYXNlQ29sb3JUZXh0dXJlJyk7XG5jb25zdCAkbWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlID0gU3ltYm9sKCdtZXRhbGxpY1JvdWdobmVzc1RleHR1cmUnKTtcbi8qKlxuICogUEJSIG1hdGVyaWFsIHByb3BlcnRpZXMgZmFjYWRlIGltcGxlbWVudGF0aW9uIGZvciBUaHJlZS5qcyBtYXRlcmlhbHNcbiAqL1xuZXhwb3J0IGNsYXNzIFBCUk1ldGFsbGljUm91Z2huZXNzIGV4dGVuZHMgVGhyZWVET01FbGVtZW50IHtcbiAgICBjb25zdHJ1Y3RvcihvblVwZGF0ZSwgZ2x0ZiwgcGJyTWV0YWxsaWNSb3VnaG5lc3MsIGNvcnJlbGF0ZWRNYXRlcmlhbHMpIHtcbiAgICAgICAgc3VwZXIob25VcGRhdGUsIHBick1ldGFsbGljUm91Z2huZXNzLCBjb3JyZWxhdGVkTWF0ZXJpYWxzKTtcbiAgICAgICAgLy8gQXNzaWduIGdsVEYgZGVmYXVsdCB2YWx1ZXNcbiAgICAgICAgaWYgKHBick1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvckZhY3RvciA9PSBudWxsKSB7XG4gICAgICAgICAgICBwYnJNZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JGYWN0b3IgPSBbMSwgMSwgMSwgMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBick1ldGFsbGljUm91Z2huZXNzLnJvdWdobmVzc0ZhY3RvciA9PSBudWxsKSB7XG4gICAgICAgICAgICBwYnJNZXRhbGxpY1JvdWdobmVzcy5yb3VnaG5lc3NGYWN0b3IgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYnJNZXRhbGxpY1JvdWdobmVzcy5tZXRhbGxpY0ZhY3RvciA9PSBudWxsKSB7XG4gICAgICAgICAgICBwYnJNZXRhbGxpY1JvdWdobmVzcy5tZXRhbGxpY0ZhY3RvciA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBiYXNlQ29sb3JUZXh0dXJlOiBnbHRmQmFzZUNvbG9yVGV4dHVyZSwgbWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlOiBnbHRmTWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlIH0gPSBwYnJNZXRhbGxpY1JvdWdobmVzcztcbiAgICAgICAgY29uc3QgeyBtYXAsIG1ldGFsbmVzc01hcCB9ID0gY29ycmVsYXRlZE1hdGVyaWFscy52YWx1ZXMoKS5uZXh0KCkudmFsdWU7XG4gICAgICAgIHRoaXNbJGJhc2VDb2xvclRleHR1cmVdID0gbmV3IFRleHR1cmVJbmZvKG9uVXBkYXRlLCBUZXh0dXJlVXNhZ2UuQmFzZSwgbWFwLCBjb3JyZWxhdGVkTWF0ZXJpYWxzLCBnbHRmLCBnbHRmQmFzZUNvbG9yVGV4dHVyZSA/IGdsdGZCYXNlQ29sb3JUZXh0dXJlIDogbnVsbCk7XG4gICAgICAgIHRoaXNbJG1ldGFsbGljUm91Z2huZXNzVGV4dHVyZV0gPSBuZXcgVGV4dHVyZUluZm8ob25VcGRhdGUsIFRleHR1cmVVc2FnZS5NZXRhbGxpY1JvdWdobmVzcywgbWV0YWxuZXNzTWFwLCBjb3JyZWxhdGVkTWF0ZXJpYWxzLCBnbHRmLCBnbHRmTWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlID8gZ2x0Zk1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSA6IG51bGwpO1xuICAgIH1cbiAgICBnZXQgWyR0aHJlZU1hdGVyaWFsc10oKSB7XG4gICAgICAgIHJldHVybiB0aGlzWyRjb3JyZWxhdGVkT2JqZWN0c107XG4gICAgfVxuICAgIGdldCBiYXNlQ29sb3JGYWN0b3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzWyRzb3VyY2VPYmplY3RdXG4gICAgICAgICAgICAuYmFzZUNvbG9yRmFjdG9yO1xuICAgIH1cbiAgICBnZXQgbWV0YWxsaWNGYWN0b3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzWyRzb3VyY2VPYmplY3RdXG4gICAgICAgICAgICAubWV0YWxsaWNGYWN0b3I7XG4gICAgfVxuICAgIGdldCByb3VnaG5lc3NGYWN0b3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzWyRzb3VyY2VPYmplY3RdXG4gICAgICAgICAgICAucm91Z2huZXNzRmFjdG9yO1xuICAgIH1cbiAgICBnZXQgYmFzZUNvbG9yVGV4dHVyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbJGJhc2VDb2xvclRleHR1cmVdO1xuICAgIH1cbiAgICBnZXQgbWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlKCkge1xuICAgICAgICByZXR1cm4gdGhpc1skbWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlXTtcbiAgICB9XG4gICAgc2V0QmFzZUNvbG9yRmFjdG9yKHJnYmEpIHtcbiAgICAgICAgY29uc3QgY29sb3IgPSBuZXcgQ29sb3IoKTtcbiAgICAgICAgaWYgKHJnYmEgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgY29sb3IuZnJvbUFycmF5KHJnYmEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29sb3Iuc2V0KHJnYmEpLmNvbnZlcnRTUkdCVG9MaW5lYXIoKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IG1hdGVyaWFsIG9mIHRoaXNbJHRocmVlTWF0ZXJpYWxzXSkge1xuICAgICAgICAgICAgbWF0ZXJpYWwuY29sb3Iuc2V0KGNvbG9yKTtcbiAgICAgICAgICAgIGlmIChyZ2JhIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBtYXRlcmlhbC5vcGFjaXR5ID0gKHJnYmEpWzNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmdiYSA9IFswLCAwLCAwLCBtYXRlcmlhbC5vcGFjaXR5XTtcbiAgICAgICAgICAgICAgICBjb2xvci50b0FycmF5KHJnYmEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBick1ldGFsbGljUm91Z2huZXNzID0gdGhpc1skc291cmNlT2JqZWN0XTtcbiAgICAgICAgcGJyTWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yRmFjdG9yID0gcmdiYTtcbiAgICAgICAgdGhpc1skb25VcGRhdGVdKCk7XG4gICAgfVxuICAgIHNldE1ldGFsbGljRmFjdG9yKHZhbHVlKSB7XG4gICAgICAgIGZvciAoY29uc3QgbWF0ZXJpYWwgb2YgdGhpc1skdGhyZWVNYXRlcmlhbHNdKSB7XG4gICAgICAgICAgICBtYXRlcmlhbC5tZXRhbG5lc3MgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYnJNZXRhbGxpY1JvdWdobmVzcyA9IHRoaXNbJHNvdXJjZU9iamVjdF07XG4gICAgICAgIHBick1ldGFsbGljUm91Z2huZXNzLm1ldGFsbGljRmFjdG9yID0gdmFsdWU7XG4gICAgICAgIHRoaXNbJG9uVXBkYXRlXSgpO1xuICAgIH1cbiAgICBzZXRSb3VnaG5lc3NGYWN0b3IodmFsdWUpIHtcbiAgICAgICAgZm9yIChjb25zdCBtYXRlcmlhbCBvZiB0aGlzWyR0aHJlZU1hdGVyaWFsc10pIHtcbiAgICAgICAgICAgIG1hdGVyaWFsLnJvdWdobmVzcyA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBick1ldGFsbGljUm91Z2huZXNzID0gdGhpc1skc291cmNlT2JqZWN0XTtcbiAgICAgICAgcGJyTWV0YWxsaWNSb3VnaG5lc3Mucm91Z2huZXNzRmFjdG9yID0gdmFsdWU7XG4gICAgICAgIHRoaXNbJG9uVXBkYXRlXSgpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBici1tZXRhbGxpYy1yb3VnaG5lc3MuanMubWFwIiwiLyogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgJ0xpY2Vuc2UnKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAnQVMgSVMnIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgRmlsdGVyLCBXcmFwIH0gZnJvbSAnLi4vLi4vdGhyZWUtY29tcG9uZW50cy9nbHRmLWluc3RhbmNlL2dsdGYtMi4wLmpzJztcbmltcG9ydCB7ICRjb3JyZWxhdGVkT2JqZWN0cywgJG9uVXBkYXRlLCAkc291cmNlT2JqZWN0LCBUaHJlZURPTUVsZW1lbnQgfSBmcm9tICcuL3RocmVlLWRvbS1lbGVtZW50LmpzJztcbmNvbnN0IGlzTWluRmlsdGVyID0gKCgpID0+IHtcbiAgICBjb25zdCBtaW5GaWx0ZXJWYWx1ZXMgPSBbXG4gICAgICAgIEZpbHRlci5OZWFyZXN0LFxuICAgICAgICBGaWx0ZXIuTGluZWFyLFxuICAgICAgICBGaWx0ZXIuTmVhcmVzdE1pcG1hcE5lYXJlc3QsXG4gICAgICAgIEZpbHRlci5MaW5lYXJNaXBtYXBMaW5lYXIsXG4gICAgICAgIEZpbHRlci5OZWFyZXN0TWlwbWFwTGluZWFyLFxuICAgICAgICBGaWx0ZXIuTGluZWFyTWlwbWFwTGluZWFyXG4gICAgXTtcbiAgICByZXR1cm4gKHZhbHVlKSA9PiBtaW5GaWx0ZXJWYWx1ZXMuaW5kZXhPZih2YWx1ZSkgPiAtMTtcbn0pKCk7XG5jb25zdCBpc01hZ0ZpbHRlciA9ICgoKSA9PiB7XG4gICAgY29uc3QgbWFnRmlsdGVyVmFsdWVzID0gW0ZpbHRlci5OZWFyZXN0LCBGaWx0ZXIuTGluZWFyXTtcbiAgICByZXR1cm4gKHZhbHVlKSA9PiBtYWdGaWx0ZXJWYWx1ZXMuaW5kZXhPZih2YWx1ZSkgPiAtMTtcbn0pKCk7XG5jb25zdCBpc1dyYXBNb2RlID0gKCgpID0+IHtcbiAgICBjb25zdCB3cmFwTW9kZXMgPSBbV3JhcC5DbGFtcFRvRWRnZSwgV3JhcC5NaXJyb3JlZFJlcGVhdCwgV3JhcC5SZXBlYXRdO1xuICAgIHJldHVybiAodmFsdWUpID0+IHdyYXBNb2Rlcy5pbmRleE9mKHZhbHVlKSA+IC0xO1xufSkoKTtcbmNvbnN0IGlzVmFsaWRTYW1wbGVyVmFsdWUgPSAocHJvcGVydHksIHZhbHVlKSA9PiB7XG4gICAgc3dpdGNoIChwcm9wZXJ0eSkge1xuICAgICAgICBjYXNlICdtaW5GaWx0ZXInOlxuICAgICAgICAgICAgcmV0dXJuIGlzTWluRmlsdGVyKHZhbHVlKTtcbiAgICAgICAgY2FzZSAnbWFnRmlsdGVyJzpcbiAgICAgICAgICAgIHJldHVybiBpc01hZ0ZpbHRlcih2YWx1ZSk7XG4gICAgICAgIGNhc2UgJ3dyYXBTJzpcbiAgICAgICAgY2FzZSAnd3JhcFQnOlxuICAgICAgICAgICAgcmV0dXJuIGlzV3JhcE1vZGUodmFsdWUpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY29uZmlndXJlIHByb3BlcnR5IFwiJHtwcm9wZXJ0eX1cIiBvbiBTYW1wbGVyYCk7XG4gICAgfVxufTtcbmNvbnN0ICR0aHJlZVRleHR1cmVzID0gU3ltYm9sKCd0aHJlZVRleHR1cmVzJyk7XG5jb25zdCAkc2V0UHJvcGVydHkgPSBTeW1ib2woJ3NldFByb3BlcnR5Jyk7XG5jb25zdCAkc291cmNlU2FtcGxlciA9IFN5bWJvbCgnc291cmNlU2FtcGxlcicpO1xuLyoqXG4gKiBTYW1wbGVyIGZhY2FkZSBpbXBsZW1lbnRhdGlvbiBmb3IgVGhyZWUuanMgdGV4dHVyZXNcbiAqL1xuZXhwb3J0IGNsYXNzIFNhbXBsZXIgZXh0ZW5kcyBUaHJlZURPTUVsZW1lbnQge1xuICAgIGdldCBbJHRocmVlVGV4dHVyZXNdKCkge1xuICAgICAgICBjb25zb2xlLmFzc2VydCh0aGlzWyRjb3JyZWxhdGVkT2JqZWN0c10gIT0gbnVsbCAmJiB0aGlzWyRjb3JyZWxhdGVkT2JqZWN0c10uc2l6ZSA+IDAsICdTYW1wbGVyIGNvcnJlbGF0ZWQgb2JqZWN0IGlzIHVuZGVmaW5lZCcpO1xuICAgICAgICByZXR1cm4gdGhpc1skY29ycmVsYXRlZE9iamVjdHNdO1xuICAgIH1cbiAgICBnZXQgWyRzb3VyY2VTYW1wbGVyXSgpIHtcbiAgICAgICAgY29uc29sZS5hc3NlcnQodGhpc1skc291cmNlT2JqZWN0XSAhPSBudWxsLCAnU2FtcGxlciBzb3VyY2UgaXMgdW5kZWZpbmVkJyk7XG4gICAgICAgIHJldHVybiB0aGlzWyRzb3VyY2VPYmplY3RdO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihvblVwZGF0ZSwgdGV4dHVyZSwgZ2x0ZlNhbXBsZXIpIHtcbiAgICAgICAgZ2x0ZlNhbXBsZXIgPSBnbHRmU2FtcGxlciAhPT0gbnVsbCAmJiBnbHRmU2FtcGxlciAhPT0gdm9pZCAwID8gZ2x0ZlNhbXBsZXIgOiB7fTtcbiAgICAgICAgLy8gVGhlc2UgZGVmYXVsdHMgcmVwcmVzZW50IGEgY29udmVyZ2VuY2Ugb2YgZ2xURiBkZWZhdWx0cyBmb3Igd3JhcCBtb2RlIGFuZFxuICAgICAgICAvLyBUaHJlZS5qcyBkZWZhdWx0cyBmb3IgZmlsdGVycy4gUGVyIGdsVEYgMi4wIHNwZWMsIGEgcmVuZGVyZXIgbWF5IGNob29zZVxuICAgICAgICAvLyBpdHMgb3duIGRlZmF1bHRzIGZvciBmaWx0ZXJzLlxuICAgICAgICAvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMCNyZWZlcmVuY2Utc2FtcGxlclxuICAgICAgICAvLyBAc2VlIGh0dHBzOi8vdGhyZWVqcy5vcmcvZG9jcy8jYXBpL2VuL3RleHR1cmVzL1RleHR1cmVcbiAgICAgICAgaWYgKGdsdGZTYW1wbGVyLm1pbkZpbHRlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBnbHRmU2FtcGxlci5taW5GaWx0ZXIgPVxuICAgICAgICAgICAgICAgIHRleHR1cmUgPyB0ZXh0dXJlLm1pbkZpbHRlciA6IEZpbHRlci5MaW5lYXJNaXBtYXBMaW5lYXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdsdGZTYW1wbGVyLm1hZ0ZpbHRlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBnbHRmU2FtcGxlci5tYWdGaWx0ZXIgPVxuICAgICAgICAgICAgICAgIHRleHR1cmUgPyB0ZXh0dXJlLm1hZ0ZpbHRlciA6IEZpbHRlci5MaW5lYXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdsdGZTYW1wbGVyLndyYXBTID09IG51bGwpIHtcbiAgICAgICAgICAgIGdsdGZTYW1wbGVyLndyYXBTID0gdGV4dHVyZSA/IHRleHR1cmUud3JhcFMgOiBXcmFwLlJlcGVhdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2x0ZlNhbXBsZXIud3JhcFQgPT0gbnVsbCkge1xuICAgICAgICAgICAgZ2x0ZlNhbXBsZXIud3JhcFQgPSB0ZXh0dXJlID8gdGV4dHVyZS53cmFwVCA6IFdyYXAuUmVwZWF0O1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKG9uVXBkYXRlLCBnbHRmU2FtcGxlciwgbmV3IFNldCh0ZXh0dXJlID8gW3RleHR1cmVdIDogW10pKTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzWyRzb3VyY2VPYmplY3RdLm5hbWUgfHwgJyc7XG4gICAgfVxuICAgIGdldCBtaW5GaWx0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzWyRzb3VyY2VTYW1wbGVyXS5taW5GaWx0ZXI7XG4gICAgfVxuICAgIGdldCBtYWdGaWx0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzWyRzb3VyY2VTYW1wbGVyXS5tYWdGaWx0ZXI7XG4gICAgfVxuICAgIGdldCB3cmFwUygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbJHNvdXJjZVNhbXBsZXJdLndyYXBTO1xuICAgIH1cbiAgICBnZXQgd3JhcFQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzWyRzb3VyY2VTYW1wbGVyXS53cmFwVDtcbiAgICB9XG4gICAgc2V0TWluRmlsdGVyKGZpbHRlcikge1xuICAgICAgICB0aGlzWyRzZXRQcm9wZXJ0eV0oJ21pbkZpbHRlcicsIGZpbHRlcik7XG4gICAgfVxuICAgIHNldE1hZ0ZpbHRlcihmaWx0ZXIpIHtcbiAgICAgICAgdGhpc1skc2V0UHJvcGVydHldKCdtYWdGaWx0ZXInLCBmaWx0ZXIpO1xuICAgIH1cbiAgICBzZXRXcmFwUyhtb2RlKSB7XG4gICAgICAgIHRoaXNbJHNldFByb3BlcnR5XSgnd3JhcFMnLCBtb2RlKTtcbiAgICB9XG4gICAgc2V0V3JhcFQobW9kZSkge1xuICAgICAgICB0aGlzWyRzZXRQcm9wZXJ0eV0oJ3dyYXBUJywgbW9kZSk7XG4gICAgfVxuICAgIFskc2V0UHJvcGVydHldKHByb3BlcnR5LCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBzYW1wbGVyID0gdGhpc1skc291cmNlU2FtcGxlcl07XG4gICAgICAgIGlmIChzYW1wbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkU2FtcGxlclZhbHVlKHByb3BlcnR5LCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBzYW1wbGVyW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdGV4dHVyZSBvZiB0aGlzWyR0aHJlZVRleHR1cmVzXSkge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzWyRvblVwZGF0ZV0oKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNhbXBsZXIuanMubWFwIiwiLyogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgJ0xpY2Vuc2UnKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAnQVMgSVMnIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIF9hLCBfYiwgX2M7XG5pbXBvcnQgeyBMaW5lYXJFbmNvZGluZywgc1JHQkVuY29kaW5nLCBWZWN0b3IyIH0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgJHRocmVlVGV4dHVyZSB9IGZyb20gJy4vaW1hZ2UuanMnO1xuaW1wb3J0IHsgVGV4dHVyZSB9IGZyb20gJy4vdGV4dHVyZS5qcyc7XG5jb25zdCAkdGV4dHVyZSA9IFN5bWJvbCgndGV4dHVyZScpO1xuY29uc3QgJHRyYW5zZm9ybSA9IFN5bWJvbCgndHJhbnNmb3JtJyk7XG5leHBvcnQgY29uc3QgJG1hdGVyaWFscyA9IFN5bWJvbCgnbWF0ZXJpYWxzJyk7XG5leHBvcnQgY29uc3QgJHVzYWdlID0gU3ltYm9sKCd1c2FnZScpO1xuY29uc3QgJG9uVXBkYXRlID0gU3ltYm9sKCdvblVwZGF0ZScpO1xuY29uc3QgJGFjdGl2ZVZpZGVvID0gU3ltYm9sKCdhY3RpdmVWaWRlbycpO1xuLy8gRGVmaW5lcyB3aGF0IGEgdGV4dHVyZSB3aWxsIGJlIHVzZWQgZm9yLlxuZXhwb3J0IHZhciBUZXh0dXJlVXNhZ2U7XG4oZnVuY3Rpb24gKFRleHR1cmVVc2FnZSkge1xuICAgIFRleHR1cmVVc2FnZVtUZXh0dXJlVXNhZ2VbXCJCYXNlXCJdID0gMF0gPSBcIkJhc2VcIjtcbiAgICBUZXh0dXJlVXNhZ2VbVGV4dHVyZVVzYWdlW1wiTWV0YWxsaWNSb3VnaG5lc3NcIl0gPSAxXSA9IFwiTWV0YWxsaWNSb3VnaG5lc3NcIjtcbiAgICBUZXh0dXJlVXNhZ2VbVGV4dHVyZVVzYWdlW1wiTm9ybWFsXCJdID0gMl0gPSBcIk5vcm1hbFwiO1xuICAgIFRleHR1cmVVc2FnZVtUZXh0dXJlVXNhZ2VbXCJPY2NsdXNpb25cIl0gPSAzXSA9IFwiT2NjbHVzaW9uXCI7XG4gICAgVGV4dHVyZVVzYWdlW1RleHR1cmVVc2FnZVtcIkVtaXNzaXZlXCJdID0gNF0gPSBcIkVtaXNzaXZlXCI7XG59KShUZXh0dXJlVXNhZ2UgfHwgKFRleHR1cmVVc2FnZSA9IHt9KSk7XG4vKipcbiAqIFRleHR1cmVJbmZvIGZhY2FkZSBpbXBsZW1lbnRhdGlvbiBmb3IgVGhyZWUuanMgbWF0ZXJpYWxzXG4gKi9cbmV4cG9ydCBjbGFzcyBUZXh0dXJlSW5mbyB7XG4gICAgY29uc3RydWN0b3Iob25VcGRhdGUsIHVzYWdlLCB0aHJlZVRleHR1cmUsIG1hdGVyaWFsLCBnbHRmLCBnbHRmVGV4dHVyZUluZm8pIHtcbiAgICAgICAgdGhpc1tfYV0gPSBudWxsO1xuICAgICAgICB0aGlzW19iXSA9IHtcbiAgICAgICAgICAgIHJvdGF0aW9uOiAwLFxuICAgICAgICAgICAgc2NhbGU6IG5ldyBWZWN0b3IyKDEsIDEpLFxuICAgICAgICAgICAgb2Zmc2V0OiBuZXcgVmVjdG9yMigwLCAwKVxuICAgICAgICB9O1xuICAgICAgICB0aGlzW19jXSA9IGZhbHNlO1xuICAgICAgICAvLyBDcmVhdGVzIGltYWdlLCBzYW1wbGVyLCBhbmQgdGV4dHVyZSBpZiB2YWxpZCB0ZXh0dXJlIGluZm8gaXMgcHJvdmlkZWQuXG4gICAgICAgIGlmIChnbHRmVGV4dHVyZUluZm8gJiYgdGhyZWVUZXh0dXJlKSB7XG4gICAgICAgICAgICBjb25zdCBnbHRmVGV4dHVyZSA9IGdsdGYudGV4dHVyZXMgPyBnbHRmLnRleHR1cmVzW2dsdGZUZXh0dXJlSW5mby5pbmRleF0gOiBudWxsO1xuICAgICAgICAgICAgY29uc3Qgc2FtcGxlciA9IGdsdGZUZXh0dXJlID9cbiAgICAgICAgICAgICAgICAoZ2x0Zi5zYW1wbGVycyA/IGdsdGYuc2FtcGxlcnNbZ2x0ZlRleHR1cmUuc2FtcGxlcl0gOiBudWxsKSA6XG4gICAgICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IGltYWdlID0gZ2x0ZlRleHR1cmUgP1xuICAgICAgICAgICAgICAgIChnbHRmLmltYWdlcyA/IGdsdGYuaW1hZ2VzW2dsdGZUZXh0dXJlLnNvdXJjZV0gOiBudWxsKSA6XG4gICAgICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgICAgIHRoaXNbJHRyYW5zZm9ybV0ucm90YXRpb24gPSB0aHJlZVRleHR1cmUucm90YXRpb247XG4gICAgICAgICAgICB0aGlzWyR0cmFuc2Zvcm1dLnNjYWxlLmNvcHkodGhyZWVUZXh0dXJlLnJlcGVhdCk7XG4gICAgICAgICAgICB0aGlzWyR0cmFuc2Zvcm1dLm9mZnNldC5jb3B5KHRocmVlVGV4dHVyZS5vZmZzZXQpO1xuICAgICAgICAgICAgdGhpc1skdGV4dHVyZV0gPVxuICAgICAgICAgICAgICAgIG5ldyBUZXh0dXJlKG9uVXBkYXRlLCB0aHJlZVRleHR1cmUsIGdsdGZUZXh0dXJlLCBzYW1wbGVyLCBpbWFnZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1skb25VcGRhdGVdID0gb25VcGRhdGU7XG4gICAgICAgIHRoaXNbJG1hdGVyaWFsc10gPSBtYXRlcmlhbDtcbiAgICAgICAgdGhpc1skdXNhZ2VdID0gdXNhZ2U7XG4gICAgfVxuICAgIGdldCB0ZXh0dXJlKCkge1xuICAgICAgICByZXR1cm4gdGhpc1skdGV4dHVyZV07XG4gICAgfVxuICAgIHNldFRleHR1cmUodGV4dHVyZSkge1xuICAgICAgICB2YXIgX2QsIF9lO1xuICAgICAgICBjb25zdCB0aHJlZVRleHR1cmUgPSB0ZXh0dXJlICE9IG51bGwgPyB0ZXh0dXJlLnNvdXJjZVskdGhyZWVUZXh0dXJlXSA6IG51bGw7XG4gICAgICAgIGNvbnN0IG9sZFRleHR1cmUgPSAoX2QgPSB0aGlzWyR0ZXh0dXJlXSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnNvdXJjZVskdGhyZWVUZXh0dXJlXTtcbiAgICAgICAgaWYgKG9sZFRleHR1cmUgIT0gbnVsbCAmJiBvbGRUZXh0dXJlLmlzVmlkZW9UZXh0dXJlKSB7XG4gICAgICAgICAgICB0aGlzWyRhY3RpdmVWaWRlb10gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoX2UgPSB0aGlzWyR0ZXh0dXJlXSkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnNvdXJjZS5hbmltYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXNbJHRleHR1cmVdLnNvdXJjZS5hbmltYXRpb24ucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW50ZXJGcmFtZScsIHRoaXNbJG9uVXBkYXRlXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1skdGV4dHVyZV0gPSB0ZXh0dXJlO1xuICAgICAgICBpZiAodGhyZWVUZXh0dXJlICE9IG51bGwgJiYgdGhyZWVUZXh0dXJlLmlzVmlkZW9UZXh0dXJlKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhyZWVUZXh0dXJlLmltYWdlO1xuICAgICAgICAgICAgdGhpc1skYWN0aXZlVmlkZW9dID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50LnJlcXVlc3RWaWRlb0ZyYW1lQ2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzWyRhY3RpdmVWaWRlb10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzWyRvblVwZGF0ZV0oKTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5yZXF1ZXN0VmlkZW9GcmFtZUNhbGxiYWNrKHVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnJlcXVlc3RWaWRlb0ZyYW1lQ2FsbGJhY2sodXBkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzWyRhY3RpdmVWaWRlb10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzWyRvblVwZGF0ZV0oKTtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodXBkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgodGV4dHVyZSA9PT0gbnVsbCB8fCB0ZXh0dXJlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0ZXh0dXJlLnNvdXJjZS5hbmltYXRpb24pICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRleHR1cmUuc291cmNlLmFuaW1hdGlvbi5hZGRFdmVudExpc3RlbmVyKCdlbnRlckZyYW1lJywgdGhpc1skb25VcGRhdGVdKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZW5jb2RpbmcgPSBzUkdCRW5jb2Rpbmc7XG4gICAgICAgIGlmICh0aGlzWyRtYXRlcmlhbHNdKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG1hdGVyaWFsIG9mIHRoaXNbJG1hdGVyaWFsc10pIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXNbJHVzYWdlXSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFRleHR1cmVVc2FnZS5CYXNlOlxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWwubWFwID0gdGhyZWVUZXh0dXJlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgVGV4dHVyZVVzYWdlLk1ldGFsbGljUm91Z2huZXNzOlxuICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RpbmcgPSBMaW5lYXJFbmNvZGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsLm1ldGFsbmVzc01hcCA9IHRocmVlVGV4dHVyZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsLnJvdWdobmVzc01hcCA9IHRocmVlVGV4dHVyZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFRleHR1cmVVc2FnZS5Ob3JtYWw6XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGluZyA9IExpbmVhckVuY29kaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWwubm9ybWFsTWFwID0gdGhyZWVUZXh0dXJlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgVGV4dHVyZVVzYWdlLk9jY2x1c2lvbjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kaW5nID0gTGluZWFyRW5jb2Rpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbC5hb01hcCA9IHRocmVlVGV4dHVyZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFRleHR1cmVVc2FnZS5FbWlzc2l2ZTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsLmVtaXNzaXZlTWFwID0gdGhyZWVUZXh0dXJlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhyZWVUZXh0dXJlKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGVzIHRoZSBlbmNvZGluZyBmb3IgdGhlIHRleHR1cmUsIGFmZmVjdHMgYWxsIHJlZmVyZW5jZXMuXG4gICAgICAgICAgICB0aHJlZVRleHR1cmUuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgICAgICAgICAgIHRocmVlVGV4dHVyZS5yb3RhdGlvbiA9IHRoaXNbJHRyYW5zZm9ybV0ucm90YXRpb247XG4gICAgICAgICAgICB0aHJlZVRleHR1cmUucmVwZWF0ID0gdGhpc1skdHJhbnNmb3JtXS5zY2FsZTtcbiAgICAgICAgICAgIHRocmVlVGV4dHVyZS5vZmZzZXQgPSB0aGlzWyR0cmFuc2Zvcm1dLm9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzWyRvblVwZGF0ZV0oKTtcbiAgICB9XG59XG5fYSA9ICR0ZXh0dXJlLCBfYiA9ICR0cmFuc2Zvcm0sIF9jID0gJGFjdGl2ZVZpZGVvO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGV4dHVyZS1pbmZvLmpzLm1hcCIsIi8qIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICdMaWNlbnNlJyk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gJ0FTIElTJyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IEltYWdlIH0gZnJvbSAnLi9pbWFnZS5qcyc7XG5pbXBvcnQgeyBTYW1wbGVyIH0gZnJvbSAnLi9zYW1wbGVyLmpzJztcbmltcG9ydCB7ICRzb3VyY2VPYmplY3QsIFRocmVlRE9NRWxlbWVudCB9IGZyb20gJy4vdGhyZWUtZG9tLWVsZW1lbnQuanMnO1xuY29uc3QgJGltYWdlID0gU3ltYm9sKCdpbWFnZScpO1xuY29uc3QgJHNhbXBsZXIgPSBTeW1ib2woJ3NhbXBsZXInKTtcbi8qKlxuICogTWF0ZXJpYWwgZmFjYWRlIGltcGxlbWVudGF0aW9uIGZvciBUaHJlZS5qcyBtYXRlcmlhbHNcbiAqL1xuZXhwb3J0IGNsYXNzIFRleHR1cmUgZXh0ZW5kcyBUaHJlZURPTUVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKG9uVXBkYXRlLCB0aHJlZVRleHR1cmUsIGdsdGZUZXh0dXJlID0gbnVsbCwgZ2x0ZlNhbXBsZXIgPSBudWxsLCBnbHRmSW1hZ2UgPSBudWxsKSB7XG4gICAgICAgIHN1cGVyKG9uVXBkYXRlLCBnbHRmVGV4dHVyZSA/IGdsdGZUZXh0dXJlIDoge30sIG5ldyBTZXQodGhyZWVUZXh0dXJlID8gW3RocmVlVGV4dHVyZV0gOiBbXSkpO1xuICAgICAgICB0aGlzWyRzYW1wbGVyXSA9IG5ldyBTYW1wbGVyKG9uVXBkYXRlLCB0aHJlZVRleHR1cmUsIGdsdGZTYW1wbGVyKTtcbiAgICAgICAgdGhpc1skaW1hZ2VdID0gbmV3IEltYWdlKG9uVXBkYXRlLCB0aHJlZVRleHR1cmUsIGdsdGZJbWFnZSk7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpc1skc291cmNlT2JqZWN0XS5uYW1lIHx8ICcnO1xuICAgIH1cbiAgICBzZXQgbmFtZShuYW1lKSB7XG4gICAgICAgIHRoaXNbJHNvdXJjZU9iamVjdF0ubmFtZSA9IG5hbWU7XG4gICAgfVxuICAgIGdldCBzYW1wbGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpc1skc2FtcGxlcl07XG4gICAgfVxuICAgIGdldCBzb3VyY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzWyRpbWFnZV07XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGV4dHVyZS5qcy5tYXAiLCIvKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAnTGljZW5zZScpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICdBUyBJUycgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5leHBvcnQgY29uc3QgJGNvcnJlbGF0ZWRPYmplY3RzID0gU3ltYm9sKCdjb3JyZWxhdGVkT2JqZWN0cycpO1xuZXhwb3J0IGNvbnN0ICRzb3VyY2VPYmplY3QgPSBTeW1ib2woJ3NvdXJjZU9iamVjdCcpO1xuZXhwb3J0IGNvbnN0ICRvblVwZGF0ZSA9IFN5bWJvbCgnb25VcGRhdGUnKTtcbi8qKlxuICogQSBTZXJpYWxpemFibGVUaHJlZURPTUVsZW1lbnQgaXMgdGhlIGNvbW1vbiBwcmltaXRpdmUgb2YgYWxsIHNjZW5lIGdyYXBoXG4gKiBlbGVtZW50cyB0aGF0IGhhdmUgYmVlbiBmYWNhZGVkIGluIHRoZSBob3N0IGV4ZWN1dGlvbiBjb250ZXh0LiBJdCBhZGRzXG4gKiBhIGNvbW1vbiBpbnRlcmZhY2UgdG8gdGhlc2UgZWxlbWVudHMgaW4gc3VwcG9ydCBvZiBjb252ZW5pZW50XG4gKiBzZXJpYWxpemFiaWxpdHkuXG4gKi9cbmV4cG9ydCBjbGFzcyBUaHJlZURPTUVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKG9uVXBkYXRlLCBlbGVtZW50LCBjb3JyZWxhdGVkT2JqZWN0cyA9IG51bGwpIHtcbiAgICAgICAgdGhpc1skb25VcGRhdGVdID0gb25VcGRhdGU7XG4gICAgICAgIHRoaXNbJHNvdXJjZU9iamVjdF0gPSBlbGVtZW50O1xuICAgICAgICB0aGlzWyRjb3JyZWxhdGVkT2JqZWN0c10gPSBjb3JyZWxhdGVkT2JqZWN0cztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aHJlZS1kb20tZWxlbWVudC5qcy5tYXAiLCIvKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAnTGljZW5zZScpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICdBUyBJUycgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5pbXBvcnQgeyBwcm9wZXJ0eSB9IGZyb20gJ2xpdC9kZWNvcmF0b3JzLmpzJztcbmltcG9ydCB7IHN0eWxlIH0gZnJvbSAnLi4vZGVjb3JhdG9ycy5qcyc7XG5pbXBvcnQgeyAkZ2V0TW9kZWxJc1Zpc2libGUsICRyZW5kZXJlciwgJHNjZW5lLCAkdGljayB9IGZyb20gJy4uL21vZGVsLXZpZXdlci1iYXNlLmpzJztcbmltcG9ydCB7IGRlZ3JlZXNUb1JhZGlhbnMgfSBmcm9tICcuLi9zdHlsZXMvY29udmVyc2lvbnMuanMnO1xuaW1wb3J0IHsgbnVtYmVyTm9kZSB9IGZyb20gJy4uL3N0eWxlcy9wYXJzZXJzLmpzJztcbi8vIEhvdyBtdWNoIHRoZSBtb2RlbCB3aWxsIHJvdGF0ZSBwZXJcbi8vIHNlY29uZCBpbiByYWRpYW5zOlxuY29uc3QgREVGQVVMVF9ST1RBVElPTl9TUEVFRCA9IE1hdGguUEkgLyAzMjtcbmV4cG9ydCBjb25zdCBBVVRPX1JPVEFURV9ERUxBWV9ERUZBVUxUID0gMzAwMDtcbmNvbnN0IHJvdGF0aW9uUmF0ZUludHJpbnNpY3MgPSB7XG4gICAgYmFzaXM6IFtkZWdyZWVzVG9SYWRpYW5zKG51bWJlck5vZGUoREVGQVVMVF9ST1RBVElPTl9TUEVFRCwgJ3JhZCcpKV0sXG4gICAga2V5d29yZHM6IHsgYXV0bzogW251bGxdIH1cbn07XG5jb25zdCAkYXV0b1JvdGF0ZVN0YXJ0VGltZSA9IFN5bWJvbCgnYXV0b1JvdGF0ZVN0YXJ0VGltZScpO1xuY29uc3QgJHJhZGlhbnNQZXJTZWNvbmQgPSBTeW1ib2woJ3JhZGlhbnNQZXJTZWNvbmQnKTtcbmNvbnN0ICRzeW5jUm90YXRpb25SYXRlID0gU3ltYm9sKCdzeW5jUm90YXRpb25SYXRlJyk7XG5jb25zdCAkb25DYW1lcmFDaGFuZ2UgPSBTeW1ib2woJ29uQ2FtZXJhQ2hhbmdlJyk7XG5leHBvcnQgY29uc3QgU3RhZ2luZ01peGluID0gKE1vZGVsVmlld2VyRWxlbWVudCkgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGNsYXNzIFN0YWdpbmdNb2RlbFZpZXdlckVsZW1lbnQgZXh0ZW5kcyBNb2RlbFZpZXdlckVsZW1lbnQge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgICAgICB0aGlzLmF1dG9Sb3RhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuYXV0b1JvdGF0ZURlbGF5ID0gQVVUT19ST1RBVEVfREVMQVlfREVGQVVMVDtcbiAgICAgICAgICAgIHRoaXMucm90YXRpb25QZXJTZWNvbmQgPSAnYXV0byc7XG4gICAgICAgICAgICB0aGlzW19hXSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgdGhpc1tfYl0gPSAwO1xuICAgICAgICAgICAgdGhpc1tfY10gPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYXV0b1JvdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChldmVudC5kZXRhaWwuc291cmNlID09PSAndXNlci1pbnRlcmFjdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1skYXV0b1JvdGF0ZVN0YXJ0VGltZV0gPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICAgICAgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY2FtZXJhLWNoYW5nZScsIHRoaXNbJG9uQ2FtZXJhQ2hhbmdlXSk7XG4gICAgICAgICAgICB0aGlzWyRhdXRvUm90YXRlU3RhcnRUaW1lXSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICB9XG4gICAgICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICAgICAgc3VwZXIuZGlzY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2FtZXJhLWNoYW5nZScsIHRoaXNbJG9uQ2FtZXJhQ2hhbmdlXSk7XG4gICAgICAgICAgICB0aGlzWyRhdXRvUm90YXRlU3RhcnRUaW1lXSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZWQoY2hhbmdlZFByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHN1cGVyLnVwZGF0ZWQoY2hhbmdlZFByb3BlcnRpZXMpO1xuICAgICAgICAgICAgaWYgKGNoYW5nZWRQcm9wZXJ0aWVzLmhhcygnYXV0b1JvdGF0ZScpKSB7XG4gICAgICAgICAgICAgICAgdGhpc1skYXV0b1JvdGF0ZVN0YXJ0VGltZV0gPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBbKF9hID0gJGF1dG9Sb3RhdGVTdGFydFRpbWUsIF9iID0gJHJhZGlhbnNQZXJTZWNvbmQsICRzeW5jUm90YXRpb25SYXRlKV0oc3R5bGUpIHtcbiAgICAgICAgICAgIHRoaXNbJHJhZGlhbnNQZXJTZWNvbmRdID0gc3R5bGVbMF07XG4gICAgICAgIH1cbiAgICAgICAgWyR0aWNrXSh0aW1lLCBkZWx0YSkge1xuICAgICAgICAgICAgc3VwZXJbJHRpY2tdKHRpbWUsIGRlbHRhKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5hdXRvUm90YXRlIHx8ICF0aGlzWyRnZXRNb2RlbElzVmlzaWJsZV0oKSB8fFxuICAgICAgICAgICAgICAgIHRoaXNbJHJlbmRlcmVyXS5pc1ByZXNlbnRpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByb3RhdGlvbkRlbHRhID0gTWF0aC5taW4oZGVsdGEsIHRpbWUgLSB0aGlzWyRhdXRvUm90YXRlU3RhcnRUaW1lXSAtIHRoaXMuYXV0b1JvdGF0ZURlbGF5KTtcbiAgICAgICAgICAgIGlmIChyb3RhdGlvbkRlbHRhID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXNbJHNjZW5lXS55YXcgPSB0aGlzLnR1cm50YWJsZVJvdGF0aW9uICtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1skcmFkaWFuc1BlclNlY29uZF0gKiByb3RhdGlvbkRlbHRhICogMC4wMDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHR1cm50YWJsZVJvdGF0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbJHNjZW5lXS55YXc7XG4gICAgICAgIH1cbiAgICAgICAgcmVzZXRUdXJudGFibGVSb3RhdGlvbih0aGV0YSA9IDApIHtcbiAgICAgICAgICAgIHRoaXNbJHNjZW5lXS55YXcgPSB0aGV0YTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfYyA9ICRvbkNhbWVyYUNoYW5nZTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgcHJvcGVydHkoeyB0eXBlOiBCb29sZWFuLCBhdHRyaWJ1dGU6ICdhdXRvLXJvdGF0ZScgfSlcbiAgICBdLCBTdGFnaW5nTW9kZWxWaWV3ZXJFbGVtZW50LnByb3RvdHlwZSwgXCJhdXRvUm90YXRlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHByb3BlcnR5KHsgdHlwZTogTnVtYmVyLCBhdHRyaWJ1dGU6ICdhdXRvLXJvdGF0ZS1kZWxheScgfSlcbiAgICBdLCBTdGFnaW5nTW9kZWxWaWV3ZXJFbGVtZW50LnByb3RvdHlwZSwgXCJhdXRvUm90YXRlRGVsYXlcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgc3R5bGUoeyBpbnRyaW5zaWNzOiByb3RhdGlvblJhdGVJbnRyaW5zaWNzLCB1cGRhdGVIYW5kbGVyOiAkc3luY1JvdGF0aW9uUmF0ZSB9KSxcbiAgICAgICAgcHJvcGVydHkoeyB0eXBlOiBTdHJpbmcsIGF0dHJpYnV0ZTogJ3JvdGF0aW9uLXBlci1zZWNvbmQnIH0pXG4gICAgXSwgU3RhZ2luZ01vZGVsVmlld2VyRWxlbWVudC5wcm90b3R5cGUsIFwicm90YXRpb25QZXJTZWNvbmRcIiwgdm9pZCAwKTtcbiAgICByZXR1cm4gU3RhZ2luZ01vZGVsVmlld2VyRWxlbWVudDtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdGFnaW5nLmpzLm1hcCIsIi8qIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICdMaWNlbnNlJyk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gJ0FTIElTJyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qLCBfaywgX2wsIF9tLCBfbztcbmltcG9ydCB7IFJlYWN0aXZlRWxlbWVudCB9IGZyb20gJ2xpdCc7XG5pbXBvcnQgeyBwcm9wZXJ0eSB9IGZyb20gJ2xpdC9kZWNvcmF0b3JzLmpzJztcbmltcG9ydCB7IEhBU19JTlRFUlNFQ1RJT05fT0JTRVJWRVIsIEhBU19SRVNJWkVfT0JTRVJWRVIgfSBmcm9tICcuL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyAkdXBkYXRlRW52aXJvbm1lbnQgfSBmcm9tICcuL2ZlYXR1cmVzL2Vudmlyb25tZW50LmpzJztcbmltcG9ydCB7IG1ha2VUZW1wbGF0ZSB9IGZyb20gJy4vdGVtcGxhdGUuanMnO1xuaW1wb3J0IHsgJGV2aWN0aW9uUG9saWN5LCBDYWNoaW5nR0xURkxvYWRlciB9IGZyb20gJy4vdGhyZWUtY29tcG9uZW50cy9DYWNoaW5nR0xURkxvYWRlci5qcyc7XG5pbXBvcnQgeyBNb2RlbFNjZW5lIH0gZnJvbSAnLi90aHJlZS1jb21wb25lbnRzL01vZGVsU2NlbmUuanMnO1xuaW1wb3J0IHsgUmVuZGVyZXIgfSBmcm9tICcuL3RocmVlLWNvbXBvbmVudHMvUmVuZGVyZXIuanMnO1xuaW1wb3J0IHsgY2xhbXAsIGRlYm91bmNlIH0gZnJvbSAnLi91dGlsaXRpZXMuanMnO1xuaW1wb3J0IHsgZGF0YVVybFRvQmxvYiB9IGZyb20gJy4vdXRpbGl0aWVzL2RhdGEtY29udmVyc2lvbi5qcyc7XG5pbXBvcnQgeyBQcm9ncmVzc1RyYWNrZXIgfSBmcm9tICcuL3V0aWxpdGllcy9wcm9ncmVzcy10cmFja2VyLmpzJztcbmNvbnN0IENMRUFSX01PREVMX1RJTUVPVVRfTVMgPSAxMDtcbmNvbnN0IEZBTExCQUNLX1NJWkVfVVBEQVRFX1RIUkVTSE9MRF9NUyA9IDUwO1xuY29uc3QgQU5OT1VOQ0VfTU9ERUxfVklTSUJJTElUWV9ERUJPVU5DRV9USFJFU0hPTEQgPSAwO1xuY29uc3QgVU5TSVpFRF9NRURJQV9XSURUSCA9IDMwMDtcbmNvbnN0IFVOU0laRURfTUVESUFfSEVJR0hUID0gMTUwO1xuZXhwb3J0IGNvbnN0IGJsb2JDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbmNvbnN0ICRmYWxsYmFja1Jlc2l6ZUhhbmRsZXIgPSBTeW1ib2woJ2ZhbGxiYWNrUmVzaXplSGFuZGxlcicpO1xuY29uc3QgJGRlZmF1bHRBcmlhTGFiZWwgPSBTeW1ib2woJ2RlZmF1bHRBcmlhTGFiZWwnKTtcbmNvbnN0ICRyZXNpemVPYnNlcnZlciA9IFN5bWJvbCgncmVzaXplT2JzZXJ2ZXInKTtcbmNvbnN0ICRjbGVhck1vZGVsVGltZW91dCA9IFN5bWJvbCgnY2xlYXJNb2RlbFRpbWVvdXQnKTtcbmNvbnN0ICRvbkNvbnRleHRMb3N0ID0gU3ltYm9sKCdvbkNvbnRleHRMb3N0Jyk7XG5jb25zdCAkbG9hZGVkID0gU3ltYm9sKCdsb2FkZWQnKTtcbmNvbnN0ICRzdGF0dXMgPSBTeW1ib2woJ3N0YXR1cycpO1xuY29uc3QgJG9uRm9jdXMgPSBTeW1ib2woJ29uRm9jdXMnKTtcbmNvbnN0ICRvbkJsdXIgPSBTeW1ib2woJ29uQmx1cicpO1xuZXhwb3J0IGNvbnN0ICR1cGRhdGVTaXplID0gU3ltYm9sKCd1cGRhdGVTaXplJyk7XG5leHBvcnQgY29uc3QgJGludGVyc2VjdGlvbk9ic2VydmVyID0gU3ltYm9sKCdpbnRlcnNlY3Rpb25PYnNlcnZlcicpO1xuZXhwb3J0IGNvbnN0ICRpc0VsZW1lbnRJblZpZXdwb3J0ID0gU3ltYm9sKCdpc0VsZW1lbnRJblZpZXdwb3J0Jyk7XG5leHBvcnQgY29uc3QgJGFubm91bmNlTW9kZWxWaXNpYmlsaXR5ID0gU3ltYm9sKCdhbm5vdW5jZU1vZGVsVmlzaWJpbGl0eScpO1xuZXhwb3J0IGNvbnN0ICRhcmlhTGFiZWwgPSBTeW1ib2woJ2FyaWFMYWJlbCcpO1xuZXhwb3J0IGNvbnN0ICRhbHREZWZhdWx0ZWQgPSBTeW1ib2woJ2FsdERlZmF1bHRlZCcpO1xuZXhwb3J0IGNvbnN0ICRzdGF0dXNFbGVtZW50ID0gU3ltYm9sKCdzdGF0dXNFbGVtZW50Jyk7XG5leHBvcnQgY29uc3QgJHVwZGF0ZVN0YXR1cyA9IFN5bWJvbCgndXBkYXRlU3RhdHVzJyk7XG5leHBvcnQgY29uc3QgJGxvYWRlZFRpbWUgPSBTeW1ib2woJ2xvYWRlZFRpbWUnKTtcbmV4cG9ydCBjb25zdCAkdXBkYXRlU291cmNlID0gU3ltYm9sKCd1cGRhdGVTb3VyY2UnKTtcbmV4cG9ydCBjb25zdCAkbWFya0xvYWRlZCA9IFN5bWJvbCgnbWFya0xvYWRlZCcpO1xuZXhwb3J0IGNvbnN0ICRjb250YWluZXIgPSBTeW1ib2woJ2NvbnRhaW5lcicpO1xuZXhwb3J0IGNvbnN0ICR1c2VySW5wdXRFbGVtZW50ID0gU3ltYm9sKCdpbnB1dCcpO1xuZXhwb3J0IGNvbnN0ICRjYW52YXMgPSBTeW1ib2woJ2NhbnZhcycpO1xuZXhwb3J0IGNvbnN0ICRzY2VuZSA9IFN5bWJvbCgnc2NlbmUnKTtcbmV4cG9ydCBjb25zdCAkbmVlZHNSZW5kZXIgPSBTeW1ib2woJ25lZWRzUmVuZGVyJyk7XG5leHBvcnQgY29uc3QgJHRpY2sgPSBTeW1ib2woJ3RpY2snKTtcbmV4cG9ydCBjb25zdCAkb25Nb2RlbExvYWQgPSBTeW1ib2woJ29uTW9kZWxMb2FkJyk7XG5leHBvcnQgY29uc3QgJG9uUmVzaXplID0gU3ltYm9sKCdvblJlc2l6ZScpO1xuZXhwb3J0IGNvbnN0ICRyZW5kZXJlciA9IFN5bWJvbCgncmVuZGVyZXInKTtcbmV4cG9ydCBjb25zdCAkcHJvZ3Jlc3NUcmFja2VyID0gU3ltYm9sKCdwcm9ncmVzc1RyYWNrZXInKTtcbmV4cG9ydCBjb25zdCAkZ2V0TG9hZGVkID0gU3ltYm9sKCdnZXRMb2FkZWQnKTtcbmV4cG9ydCBjb25zdCAkZ2V0TW9kZWxJc1Zpc2libGUgPSBTeW1ib2woJ2dldE1vZGVsSXNWaXNpYmxlJyk7XG5leHBvcnQgY29uc3QgJHNob3VsZEF0dGVtcHRQcmVsb2FkID0gU3ltYm9sKCdzaG91bGRBdHRlbXB0UHJlbG9hZCcpO1xuZXhwb3J0IGNvbnN0IHRvVmVjdG9yM0QgPSAodikgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHYueCxcbiAgICAgICAgeTogdi55LFxuICAgICAgICB6OiB2LnosXG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuIGAke3RoaXMueH1tICR7dGhpcy55fW0gJHt0aGlzLnp9bWA7XG4gICAgICAgIH1cbiAgICB9O1xufTtcbmV4cG9ydCBjb25zdCB0b1ZlY3RvcjJEID0gKHYpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICB1OiB2LngsXG4gICAgICAgIHY6IHYueSxcbiAgICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7dGhpcy51fSAke3RoaXMudn1gO1xuICAgICAgICB9XG4gICAgfTtcbn07XG4vKipcbiAqIERlZmluaXRpb24gZm9yIGEgYmFzaWMgPG1vZGVsLXZpZXdlcj4gZWxlbWVudC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW9kZWxWaWV3ZXJFbGVtZW50QmFzZSBleHRlbmRzIFJlYWN0aXZlRWxlbWVudCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBNb2RlbFZpZXdlckVsZW1lbnQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYWx0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5zcmMgPSBudWxsO1xuICAgICAgICB0aGlzLndpdGhDcmVkZW50aWFscyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogR2VuZXJhdGVzIGEgM0QgbW9kZWwgc2NoZW1hIGh0dHBzOi8vc2NoZW1hLm9yZy8zRE1vZGVsIGFzc29jaWF0ZWQgd2l0aFxuICAgICAgICAgKiB0aGUgbG9hZGVkIHNyYyBhbmQgaW5zZXJ0cyBpdCBpbnRvIHRoZSBoZWFkZXIgb2YgdGhlIHBhZ2UgZm9yIHNlYXJjaFxuICAgICAgICAgKiBlbmdpbmVzIHRvIGNyYXdsLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZW5lcmF0ZVNjaGVtYSA9IGZhbHNlO1xuICAgICAgICB0aGlzW19hXSA9IGZhbHNlO1xuICAgICAgICB0aGlzW19iXSA9IGZhbHNlO1xuICAgICAgICB0aGlzW19jXSA9IDA7XG4gICAgICAgIHRoaXNbX2RdID0gJyc7XG4gICAgICAgIHRoaXNbX2VdID0gbnVsbDtcbiAgICAgICAgdGhpc1tfZl0gPSBkZWJvdW5jZSgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBib3VuZGluZ1JlY3QgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgdGhpc1skdXBkYXRlU2l6ZV0oYm91bmRpbmdSZWN0KTtcbiAgICAgICAgfSwgRkFMTEJBQ0tfU0laRV9VUERBVEVfVEhSRVNIT0xEX01TKTtcbiAgICAgICAgdGhpc1tfZ10gPSBkZWJvdW5jZSgob2xkVmlzaWJpbGl0eSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV3VmlzaWJpbGl0eSA9IHRoaXMubW9kZWxJc1Zpc2libGU7XG4gICAgICAgICAgICBpZiAobmV3VmlzaWJpbGl0eSAhPT0gb2xkVmlzaWJpbGl0eSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ21vZGVsLXZpc2liaWxpdHknLCB7IGRldGFpbDogeyB2aXNpYmxlOiBuZXdWaXNpYmlsaXR5IH0gfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBBTk5PVU5DRV9NT0RFTF9WSVNJQklMSVRZX0RFQk9VTkNFX1RIUkVTSE9MRCk7XG4gICAgICAgIHRoaXNbX2hdID0gbnVsbDtcbiAgICAgICAgdGhpc1tfal0gPSBudWxsO1xuICAgICAgICB0aGlzW19rXSA9IG5ldyBQcm9ncmVzc1RyYWNrZXIoKTtcbiAgICAgICAgdGhpc1tfbF0gPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzWyRzdGF0dXNFbGVtZW50XS50ZXh0Q29udGVudCA9IHRoaXNbJHN0YXR1c107XG4gICAgICAgIH07XG4gICAgICAgIHRoaXNbX21dID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpc1skc3RhdHVzRWxlbWVudF0udGV4dENvbnRlbnQgPSAnJztcbiAgICAgICAgfTtcbiAgICAgICAgdGhpc1tfb10gPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2Vycm9yJywgeyBkZXRhaWw6IHsgdHlwZTogJ3dlYmdsY29udGV4dGxvc3QnLCBzb3VyY2VFcnJvcjogZXZlbnQuc291cmNlRXZlbnQgfSB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYXR0YWNoU2hhZG93KHsgbW9kZTogJ29wZW4nIH0pO1xuICAgICAgICBjb25zdCBzaGFkb3dSb290ID0gdGhpcy5zaGFkb3dSb290O1xuICAgICAgICBtYWtlVGVtcGxhdGUoc2hhZG93Um9vdCk7XG4gICAgICAgIHRoaXNbJGNvbnRhaW5lcl0gPSBzaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJy5jb250YWluZXInKTtcbiAgICAgICAgdGhpc1skdXNlcklucHV0RWxlbWVudF0gPVxuICAgICAgICAgICAgc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCcudXNlcklucHV0Jyk7XG4gICAgICAgIHRoaXNbJGNhbnZhc10gPSBzaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJ2NhbnZhcycpO1xuICAgICAgICB0aGlzWyRzdGF0dXNFbGVtZW50XSA9XG4gICAgICAgICAgICBzaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJyNzdGF0dXMnKTtcbiAgICAgICAgdGhpc1skZGVmYXVsdEFyaWFMYWJlbF0gPVxuICAgICAgICAgICAgdGhpc1skdXNlcklucHV0RWxlbWVudF0uZ2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJyk7XG4gICAgICAgIC8vIEJlY2F1c2Ugb2YgcG90ZW50aWFsIHJhY2UgY29uZGl0aW9ucyByZWxhdGVkIHRvIGludm9raW5nIHRoZSBjb25zdHJ1Y3RvclxuICAgICAgICAvLyB3ZSBvbmx5IHVzZSB0aGUgYm91bmRpbmcgcmVjdCB0byBzZXQgdGhlIGluaXRpYWwgc2l6ZSBpZiB0aGUgZWxlbWVudCBpc1xuICAgICAgICAvLyBhbHJlYWR5IGNvbm5lY3RlZCB0byB0aGUgZG9jdW1lbnQ6XG4gICAgICAgIGxldCB3aWR0aCwgaGVpZ2h0O1xuICAgICAgICBpZiAodGhpcy5pc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgY29uc3QgcmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB3aWR0aCA9IHJlY3Qud2lkdGg7XG4gICAgICAgICAgICBoZWlnaHQgPSByZWN0LmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdpZHRoID0gVU5TSVpFRF9NRURJQV9XSURUSDtcbiAgICAgICAgICAgIGhlaWdodCA9IFVOU0laRURfTUVESUFfSEVJR0hUO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSB0aGUgdW5kZXJseWluZyBNb2RlbFNjZW5lLlxuICAgICAgICB0aGlzWyRzY2VuZV0gPVxuICAgICAgICAgICAgbmV3IE1vZGVsU2NlbmUoeyBjYW52YXM6IHRoaXNbJGNhbnZhc10sIGVsZW1lbnQ6IHRoaXMsIHdpZHRoLCBoZWlnaHQgfSk7XG4gICAgICAgIC8vIFVwZGF0ZSBpbml0aWFsIHNpemUgb24gbWljcm90YXNrIHRpbWluZyBzbyB0aGF0IHN1YmNsYXNzZXMgaGF2ZSBhXG4gICAgICAgIC8vIGNoYW5jZSB0byBpbml0aWFsaXplXG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpc1skdXBkYXRlU2l6ZV0odGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoSEFTX1JFU0laRV9PQlNFUlZFUikge1xuICAgICAgICAgICAgLy8gU2V0IHVwIGEgcmVzaXplIG9ic2VydmVyIHNvIHdlIGNhbiBzY2FsZSBvdXIgY2FudmFzXG4gICAgICAgICAgICAvLyBpZiBvdXIgPG1vZGVsLXZpZXdlcj4gY2hhbmdlc1xuICAgICAgICAgICAgdGhpc1skcmVzaXplT2JzZXJ2ZXJdID1cbiAgICAgICAgICAgICAgICBuZXcgUmVzaXplT2JzZXJ2ZXIoKGVudHJpZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgcmVzaXplIGFueXRoaW5nIGlmIGluIEFSIG1vZGU7IG90aGVyd2lzZSB0aGUgY2FudmFzXG4gICAgICAgICAgICAgICAgICAgIC8vIHNjYWxpbmcgdG8gZnVsbHNjcmVlbiBvbiBlbnRlcmluZyBBUiB3aWxsIGNsb2JiZXIgdGhlIGZsYXQvMmRcbiAgICAgICAgICAgICAgICAgICAgLy8gZGltZW5zaW9ucyBvZiB0aGUgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXNbJHJlbmRlcmVyXS5pc1ByZXNlbnRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnkudGFyZ2V0ID09PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1skdXBkYXRlU2l6ZV0oZW50cnkuY29udGVudFJlY3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEhBU19JTlRFUlNFQ1RJT05fT0JTRVJWRVIpIHtcbiAgICAgICAgICAgIHRoaXNbJGludGVyc2VjdGlvbk9ic2VydmVyXSA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbnRyeS50YXJnZXQgPT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9sZFZpc2liaWxpdHkgPSB0aGlzLm1vZGVsSXNWaXNpYmxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1skaXNFbGVtZW50SW5WaWV3cG9ydF0gPSBlbnRyeS5pc0ludGVyc2VjdGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbJGFubm91bmNlTW9kZWxWaXNpYmlsaXR5XShvbGRWaXNpYmlsaXR5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzWyRpc0VsZW1lbnRJblZpZXdwb3J0XSAmJiAhdGhpcy5sb2FkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzWyR1cGRhdGVTb3VyY2VdKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgcm9vdDogbnVsbCxcbiAgICAgICAgICAgICAgICAvLyBXZSB1c2VkIHRvIGhhdmUgbWFyZ2luIGhlcmUsIGJ1dCBpdCB3YXMgY2F1c2luZyBhbmltYXRlZCBtb2RlbHMgYmVsb3dcbiAgICAgICAgICAgICAgICAvLyB0aGUgZm9sZCB0byBzdGVhbCB0aGUgZnJhbWUgYnVkZ2V0LiBXZWlyZGVyIHN0aWxsLCBpdCB3b3VsZCBhbHNvXG4gICAgICAgICAgICAgICAgLy8gY2F1c2UgaW5wdXQgZXZlbnRzIHRvIGJlIHN3YWxsb3dlZCwgc29tZXRpbWVzIGZvciBzZWNvbmRzIG9uIHRoZVxuICAgICAgICAgICAgICAgIC8vIG1vZGVsIGFib3ZlIHRoZSBmb2xkLCBidXQgb25seSB3aGVuIHRoZSBhbmltYXRlZCBtb2RlbCB3YXMgY29tcGxldGVseVxuICAgICAgICAgICAgICAgIC8vIGJlbG93LiBTZXR0aW5nIHRoaXMgbWFyZ2luIHRvIHplcm8gZml4ZWQgaXQuXG4gICAgICAgICAgICAgICAgcm9vdE1hcmdpbjogJzBweCcsXG4gICAgICAgICAgICAgICAgLy8gV2l0aCB6ZXJvIHRocmVzaG9sZCwgYW4gZWxlbWVudCBhZGphY2VudCB0byBidXQgbm90IGludGVyc2VjdGluZyB0aGVcbiAgICAgICAgICAgICAgICAvLyB2aWV3cG9ydCB3aWxsIGJlIHJlcG9ydGVkIGFzIGludGVyc2VjdGluZywgd2hpY2ggd2lsbCBjYXVzZVxuICAgICAgICAgICAgICAgIC8vIHVubmVjZXNzYXJ5IHJlbmRlcmluZy4gQW55IHNsaWdodCBwb3NpdGl2ZSB0aHJlc2hvbGQgYWxsZXZpYXRlcyB0aGlzLlxuICAgICAgICAgICAgICAgIHRocmVzaG9sZDogMC4wMDAwMSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gaW50ZXJzZWN0aW9uIG9ic2VydmVyLCB0aGVuIGFsbCBtb2RlbHMgc2hvdWxkIGJlIHZpc2libGVcbiAgICAgICAgICAgIC8vIGF0IGFsbCB0aW1lczpcbiAgICAgICAgICAgIHRoaXNbJGlzRWxlbWVudEluVmlld3BvcnRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZ2V0IGlzKCkge1xuICAgICAgICByZXR1cm4gJ21vZGVsLXZpZXdlcic7XG4gICAgfVxuICAgIC8qKiBAZXhwb3J0ICovXG4gICAgc3RhdGljIHNldCBtb2RlbENhY2hlU2l6ZSh2YWx1ZSkge1xuICAgICAgICBDYWNoaW5nR0xURkxvYWRlclskZXZpY3Rpb25Qb2xpY3ldLmV2aWN0aW9uVGhyZXNob2xkID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKiBAZXhwb3J0ICovXG4gICAgc3RhdGljIGdldCBtb2RlbENhY2hlU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIENhY2hpbmdHTFRGTG9hZGVyWyRldmljdGlvblBvbGljeV0uZXZpY3Rpb25UaHJlc2hvbGQ7XG4gICAgfVxuICAgIC8qKiBAZXhwb3J0ICovXG4gICAgc3RhdGljIHNldCBtaW5pbXVtUmVuZGVyU2NhbGUodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID4gMSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCc8bW9kZWwtdmlld2VyPiBtaW5pbXVtUmVuZGVyU2NhbGUgaGFzIGJlZW4gY2xhbXBlZCB0byBhIG1heGltdW0gdmFsdWUgb2YgMS4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPD0gMCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCc8bW9kZWwtdmlld2VyPiBtaW5pbXVtUmVuZGVyU2NhbGUgaGFzIGJlZW4gY2xhbXBlZCB0byBhIG1pbmltdW0gdmFsdWUgb2YgMC4yNS4nKTtcbiAgICAgICAgfVxuICAgICAgICBSZW5kZXJlci5zaW5nbGV0b24ubWluU2NhbGUgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqIEBleHBvcnQgKi9cbiAgICBzdGF0aWMgZ2V0IG1pbmltdW1SZW5kZXJTY2FsZSgpIHtcbiAgICAgICAgcmV0dXJuIFJlbmRlcmVyLnNpbmdsZXRvbi5taW5TY2FsZTtcbiAgICB9XG4gICAgLyoqIEBleHBvcnQgKi9cbiAgICBnZXQgbG9hZGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpc1skZ2V0TG9hZGVkXSgpO1xuICAgIH1cbiAgICBnZXQgWyhfYSA9ICRpc0VsZW1lbnRJblZpZXdwb3J0LCBfYiA9ICRsb2FkZWQsIF9jID0gJGxvYWRlZFRpbWUsIF9kID0gJHN0YXR1cywgX2UgPSAkY2xlYXJNb2RlbFRpbWVvdXQsIF9mID0gJGZhbGxiYWNrUmVzaXplSGFuZGxlciwgX2cgPSAkYW5ub3VuY2VNb2RlbFZpc2liaWxpdHksIF9oID0gJHJlc2l6ZU9ic2VydmVyLCBfaiA9ICRpbnRlcnNlY3Rpb25PYnNlcnZlciwgX2sgPSAkcHJvZ3Jlc3NUcmFja2VyLCAkcmVuZGVyZXIpXSgpIHtcbiAgICAgICAgcmV0dXJuIFJlbmRlcmVyLnNpbmdsZXRvbjtcbiAgICB9XG4gICAgLyoqIEBleHBvcnQgKi9cbiAgICBnZXQgbW9kZWxJc1Zpc2libGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzWyRnZXRNb2RlbElzVmlzaWJsZV0oKTtcbiAgICB9XG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgIHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrICYmIHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgICAgIGlmIChIQVNfUkVTSVpFX09CU0VSVkVSKSB7XG4gICAgICAgICAgICB0aGlzWyRyZXNpemVPYnNlcnZlcl0ub2JzZXJ2ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpc1skZmFsbGJhY2tSZXNpemVIYW5kbGVyXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEhBU19JTlRFUlNFQ1RJT05fT0JTRVJWRVIpIHtcbiAgICAgICAgICAgIHRoaXNbJGludGVyc2VjdGlvbk9ic2VydmVyXS5vYnNlcnZlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzWyRvbkZvY3VzXSk7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXNbJG9uQmx1cl0pO1xuICAgICAgICBjb25zdCByZW5kZXJlciA9IHRoaXNbJHJlbmRlcmVyXTtcbiAgICAgICAgcmVuZGVyZXIuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dGxvc3QnLCB0aGlzWyRvbkNvbnRleHRMb3N0XSk7XG4gICAgICAgIHJlbmRlcmVyLnJlZ2lzdGVyU2NlbmUodGhpc1skc2NlbmVdKTtcbiAgICAgICAgaWYgKHRoaXNbJGNsZWFyTW9kZWxUaW1lb3V0XSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzWyRjbGVhck1vZGVsVGltZW91dF0pO1xuICAgICAgICAgICAgdGhpc1skY2xlYXJNb2RlbFRpbWVvdXRdID0gbnVsbDtcbiAgICAgICAgICAgIC8vIEZvcmNlIGFuIHVwZGF0ZSBpbiBjYXNlIHRoZSBtb2RlbCBoYXMgYmVlbiBldmljdGVkIGZyb20gb3VyIEdMVEYgY2FjaGVcbiAgICAgICAgICAgIC8vIEBzZWUgaHR0cHM6Ly9saXQtZWxlbWVudC5wb2x5bWVyLXByb2plY3Qub3JnL2d1aWRlL2xpZmVjeWNsZSNyZXF1ZXN0dXBkYXRlXG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RVcGRhdGUoJ3NyYycsIG51bGwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICBzdXBlci5kaXNjb25uZWN0ZWRDYWxsYmFjayAmJiBzdXBlci5kaXNjb25uZWN0ZWRDYWxsYmFjaygpO1xuICAgICAgICBpZiAoSEFTX1JFU0laRV9PQlNFUlZFUikge1xuICAgICAgICAgICAgdGhpc1skcmVzaXplT2JzZXJ2ZXJdLnVub2JzZXJ2ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpc1skZmFsbGJhY2tSZXNpemVIYW5kbGVyXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEhBU19JTlRFUlNFQ1RJT05fT0JTRVJWRVIpIHtcbiAgICAgICAgICAgIHRoaXNbJGludGVyc2VjdGlvbk9ic2VydmVyXS51bm9ic2VydmUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXNbJG9uRm9jdXNdKTtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgdGhpc1skb25CbHVyXSk7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpc1skcmVuZGVyZXJdO1xuICAgICAgICByZW5kZXJlci5yZW1vdmVFdmVudExpc3RlbmVyKCdjb250ZXh0bG9zdCcsIHRoaXNbJG9uQ29udGV4dExvc3RdKTtcbiAgICAgICAgcmVuZGVyZXIudW5yZWdpc3RlclNjZW5lKHRoaXNbJHNjZW5lXSk7XG4gICAgICAgIHRoaXNbJGNsZWFyTW9kZWxUaW1lb3V0XSA9IHNlbGYuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzWyRzY2VuZV0uZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpc1skY2xlYXJNb2RlbFRpbWVvdXRdID0gbnVsbDtcbiAgICAgICAgfSwgQ0xFQVJfTU9ERUxfVElNRU9VVF9NUyk7XG4gICAgfVxuICAgIHVwZGF0ZWQoY2hhbmdlZFByb3BlcnRpZXMpIHtcbiAgICAgICAgc3VwZXIudXBkYXRlZChjaGFuZ2VkUHJvcGVydGllcyk7XG4gICAgICAgIC8vIE5PVEUoY2RhdGEpOiBJZiBhIHByb3BlcnR5IGNoYW5nZXMgZnJvbSB2YWx1ZXMgQSAtPiBCIC0+IEEgaW4gdGhlIHNwYWNlXG4gICAgICAgIC8vIG9mIGEgbWljcm90YXNrLCBMaXRFbGVtZW50L1VwZGF0aW5nRWxlbWVudCB3aWxsIG5vdGlmeSBvZiBhIGNoYW5nZSBldmVuXG4gICAgICAgIC8vIHRob3VnaCB0aGUgdmFsdWUgaGFzIGVmZmVjdGl2ZWx5IG5vdCBjaGFuZ2VkLCBzbyB3ZSBuZWVkIHRvIGNoZWNrIHRvIG1ha2VcbiAgICAgICAgLy8gc3VyZSB0aGF0IHRoZSB2YWx1ZSBoYXMgYWN0dWFsbHkgY2hhbmdlZCBiZWZvcmUgY2hhbmdpbmcgdGhlIGxvYWRlZCBmbGFnLlxuICAgICAgICBpZiAoY2hhbmdlZFByb3BlcnRpZXMuaGFzKCdzcmMnKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3JjID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzWyRsb2FkZWRdID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpc1skbG9hZGVkVGltZV0gPSAwO1xuICAgICAgICAgICAgICAgIHRoaXNbJHNjZW5lXS5yZXNldCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5zcmMgIT09IHRoaXNbJHNjZW5lXS51cmwpIHtcbiAgICAgICAgICAgICAgICB0aGlzWyRsb2FkZWRdID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpc1skbG9hZGVkVGltZV0gPSAwO1xuICAgICAgICAgICAgICAgIHRoaXNbJHVwZGF0ZVNvdXJjZV0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlZFByb3BlcnRpZXMuaGFzKCdhbHQnKSkge1xuICAgICAgICAgICAgdGhpc1skdXNlcklucHV0RWxlbWVudF0uc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgdGhpc1skYXJpYUxhYmVsXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZWRQcm9wZXJ0aWVzLmhhcygnd2l0aENyZWRlbnRpYWxzJykpIHtcbiAgICAgICAgICAgIENhY2hpbmdHTFRGTG9hZGVyLndpdGhDcmVkZW50aWFscyA9IHRoaXMud2l0aENyZWRlbnRpYWxzO1xuICAgICAgICAgICAgdGhpc1skcmVuZGVyZXJdLnRleHR1cmVVdGlscy53aXRoQ3JlZGVudGlhbHMgPSB0aGlzLndpdGhDcmVkZW50aWFscztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlZFByb3BlcnRpZXMuaGFzKCdnZW5lcmF0ZVNjaGVtYScpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5nZW5lcmF0ZVNjaGVtYSkge1xuICAgICAgICAgICAgICAgIHRoaXNbJHNjZW5lXS51cGRhdGVTY2hlbWEodGhpcy5zcmMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpc1skc2NlbmVdLnVwZGF0ZVNjaGVtYShudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQGV4cG9ydCAqL1xuICAgIHRvRGF0YVVSTCh0eXBlLCBlbmNvZGVyT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpc1skcmVuZGVyZXJdXG4gICAgICAgICAgICAuZGlzcGxheUNhbnZhcyh0aGlzWyRzY2VuZV0pXG4gICAgICAgICAgICAudG9EYXRhVVJMKHR5cGUsIGVuY29kZXJPcHRpb25zKTtcbiAgICB9XG4gICAgLyoqIEBleHBvcnQgKi9cbiAgICBhc3luYyB0b0Jsb2Iob3B0aW9ucykge1xuICAgICAgICBjb25zdCBtaW1lVHlwZSA9IG9wdGlvbnMgPyBvcHRpb25zLm1pbWVUeXBlIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBxdWFsaXR5QXJndW1lbnQgPSBvcHRpb25zID8gb3B0aW9ucy5xdWFsaXR5QXJndW1lbnQgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHVzZUlkZWFsQXNwZWN0ID0gb3B0aW9ucyA/IG9wdGlvbnMuaWRlYWxBc3BlY3QgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgaWRlYWxBc3BlY3QsIGFzcGVjdCB9ID0gdGhpc1skc2NlbmVdO1xuICAgICAgICBjb25zdCB7IGRwciwgc2NhbGVGYWN0b3IgfSA9IHRoaXNbJHJlbmRlcmVyXTtcbiAgICAgICAgbGV0IG91dHB1dFdpZHRoID0gd2lkdGggKiBzY2FsZUZhY3RvciAqIGRwcjtcbiAgICAgICAgbGV0IG91dHB1dEhlaWdodCA9IGhlaWdodCAqIHNjYWxlRmFjdG9yICogZHByO1xuICAgICAgICBsZXQgb2Zmc2V0WCA9IDA7XG4gICAgICAgIGxldCBvZmZzZXRZID0gMDtcbiAgICAgICAgaWYgKHVzZUlkZWFsQXNwZWN0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBpZiAoaWRlYWxBc3BlY3QgPiBhc3BlY3QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvbGRIZWlnaHQgPSBvdXRwdXRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgb3V0cHV0SGVpZ2h0ID0gTWF0aC5yb3VuZChvdXRwdXRXaWR0aCAvIGlkZWFsQXNwZWN0KTtcbiAgICAgICAgICAgICAgICBvZmZzZXRZID0gKG9sZEhlaWdodCAtIG91dHB1dEhlaWdodCkgLyAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkV2lkdGggPSBvdXRwdXRXaWR0aDtcbiAgICAgICAgICAgICAgICBvdXRwdXRXaWR0aCA9IE1hdGgucm91bmQob3V0cHV0SGVpZ2h0ICogaWRlYWxBc3BlY3QpO1xuICAgICAgICAgICAgICAgIG9mZnNldFggPSAob2xkV2lkdGggLSBvdXRwdXRXaWR0aCkgLyAyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJsb2JDYW52YXMud2lkdGggPSBvdXRwdXRXaWR0aDtcbiAgICAgICAgYmxvYkNhbnZhcy5oZWlnaHQgPSBvdXRwdXRIZWlnaHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGJsb2JDYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5kcmF3SW1hZ2UodGhpc1skcmVuZGVyZXJdLmRpc3BsYXlDYW52YXModGhpc1skc2NlbmVdKSwgb2Zmc2V0WCwgb2Zmc2V0WSwgb3V0cHV0V2lkdGgsIG91dHB1dEhlaWdodCwgMCwgMCwgb3V0cHV0V2lkdGgsIG91dHB1dEhlaWdodCk7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2JDYW52YXMubXNUb0Jsb2IpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogbXNUb0Jsb2Igb25seSByZXR1cm5zIGltYWdlL3BuZ1xuICAgICAgICAgICAgICAgICAgICAvLyBzbyBlbnN1cmUgbWltZVR5cGUgaXMgbm90IHNwZWNpZmllZCAoZGVmYXVsdHMgdG8gaW1hZ2UvcG5nKVxuICAgICAgICAgICAgICAgICAgICAvLyBvciBpcyBpbWFnZS9wbmcsIG90aGVyd2lzZSBmYWxsYmFjayB0byB1c2luZyB0b0RhdGFVUkwgb24gSUUuXG4gICAgICAgICAgICAgICAgICAgIGlmICghbWltZVR5cGUgfHwgbWltZVR5cGUgPT09ICdpbWFnZS9wbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShibG9iQ2FudmFzLm1zVG9CbG9iKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghYmxvYkNhbnZhcy50b0Jsb2IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoYXdhaXQgZGF0YVVybFRvQmxvYihibG9iQ2FudmFzLnRvRGF0YVVSTChtaW1lVHlwZSwgcXVhbGl0eUFyZ3VtZW50KSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBibG9iQ2FudmFzLnRvQmxvYigoYmxvYikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWJsb2IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKCdVbmFibGUgdG8gcmV0cmlldmUgY2FudmFzIGJsb2InKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShibG9iKTtcbiAgICAgICAgICAgICAgICB9LCBtaW1lVHlwZSwgcXVhbGl0eUFyZ3VtZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpc1skdXBkYXRlU2l6ZV0oeyB3aWR0aCwgaGVpZ2h0IH0pO1xuICAgICAgICB9XG4gICAgICAgIDtcbiAgICB9XG4gICAgcmVnaXN0ZXJSZW5kZXJlcihyZW5kZXJlcikge1xuICAgICAgICB0aGlzWyRzY2VuZV0uZXh0ZXJuYWxSZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgIH1cbiAgICB1bnJlZ2lzdGVyUmVuZGVyZXIoKSB7XG4gICAgICAgIHRoaXNbJHNjZW5lXS5leHRlcm5hbFJlbmRlcmVyID0gbnVsbDtcbiAgICB9XG4gICAgZ2V0IFskYXJpYUxhYmVsXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbJGFsdERlZmF1bHRlZF07XG4gICAgfVxuICAgIGdldCBbJGFsdERlZmF1bHRlZF0oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5hbHQgPT0gbnVsbCB8fCB0aGlzLmFsdCA9PT0gJ251bGwnKSA/IHRoaXNbJGRlZmF1bHRBcmlhTGFiZWxdIDpcbiAgICAgICAgICAgIHRoaXMuYWx0O1xuICAgIH1cbiAgICAvLyBOT1RFKGNkYXRhKTogQWx0aG91Z2ggdGhpcyBtYXkgc2VlbSBleHRyZW1lbHkgcmVkdW5kYW50LCBpdCBpcyByZXF1aXJlZCBpblxuICAgIC8vIG9yZGVyIHRvIHN1cHBvcnQgb3ZlcmxvYWRpbmcgd2hlbiBUeXBlU2NyaXB0IGlzIGNvbXBpbGVkIHRvIEVTNVxuICAgIC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL1BvbHltZXIvbGl0LWVsZW1lbnQvcHVsbC83NDVcbiAgICAvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMzM4XG4gICAgWyRnZXRMb2FkZWRdKCkge1xuICAgICAgICByZXR1cm4gdGhpc1skbG9hZGVkXTtcbiAgICB9XG4gICAgLy8gQHNlZSBbJGdldExvYWRlZF1cbiAgICBbJGdldE1vZGVsSXNWaXNpYmxlXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZGVkICYmIHRoaXNbJGlzRWxlbWVudEluVmlld3BvcnRdO1xuICAgIH1cbiAgICBbJHNob3VsZEF0dGVtcHRQcmVsb2FkXSgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5zcmMgJiYgdGhpc1skaXNFbGVtZW50SW5WaWV3cG9ydF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCBvbiBpbml0aWFsaXphdGlvbiBhbmQgd2hlbiB0aGUgcmVzaXplIG9ic2VydmVyIGZpcmVzLlxuICAgICAqL1xuICAgIFskdXBkYXRlU2l6ZV0oeyB3aWR0aCwgaGVpZ2h0IH0pIHtcbiAgICAgICAgaWYgKHdpZHRoID09PSAwIHx8IGhlaWdodCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbJGNvbnRhaW5lcl0uc3R5bGUud2lkdGggPSBgJHt3aWR0aH1weGA7XG4gICAgICAgIHRoaXNbJGNvbnRhaW5lcl0uc3R5bGUuaGVpZ2h0ID0gYCR7aGVpZ2h0fXB4YDtcbiAgICAgICAgdGhpc1skb25SZXNpemVdKHsgd2lkdGgsIGhlaWdodCB9KTtcbiAgICB9XG4gICAgWyR0aWNrXShfdGltZSwgX2RlbHRhKSB7XG4gICAgfVxuICAgIFskbWFya0xvYWRlZF0oKSB7XG4gICAgICAgIGlmICh0aGlzWyRsb2FkZWRdKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1skbG9hZGVkXSA9IHRydWU7XG4gICAgICAgIHRoaXNbJGxvYWRlZFRpbWVdID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgfVxuICAgIFskbmVlZHNSZW5kZXJdKCkge1xuICAgICAgICB0aGlzWyRzY2VuZV0ucXVldWVSZW5kZXIoKTtcbiAgICB9XG4gICAgWyRvbk1vZGVsTG9hZF0oKSB7XG4gICAgfVxuICAgIFskdXBkYXRlU3RhdHVzXShzdGF0dXMpIHtcbiAgICAgICAgdGhpc1skc3RhdHVzXSA9IHN0YXR1cztcbiAgICAgICAgY29uc3Qgcm9vdE5vZGUgPSB0aGlzLmdldFJvb3ROb2RlKCk7XG4gICAgICAgIC8vIE9ubHkgY2hhbmdlIHRoZSBhcmlhLWxhYmVsIGlmIDxtb2RlbC12aWV3ZXI+IGlzIGN1cnJlbnRseSBmb2N1c2VkOlxuICAgICAgICBpZiAocm9vdE5vZGUgIT0gbnVsbCAmJiByb290Tm9kZS5hY3RpdmVFbGVtZW50ID09PSB0aGlzICYmXG4gICAgICAgICAgICB0aGlzWyRzdGF0dXNFbGVtZW50XS50ZXh0Q29udGVudCAhPSBzdGF0dXMpIHtcbiAgICAgICAgICAgIHRoaXNbJHN0YXR1c0VsZW1lbnRdLnRleHRDb250ZW50ID0gc3RhdHVzO1xuICAgICAgICB9XG4gICAgfVxuICAgIFsoX2wgPSAkb25Gb2N1cywgX20gPSAkb25CbHVyLCAkb25SZXNpemUpXShlKSB7XG4gICAgICAgIHRoaXNbJHNjZW5lXS5zZXRTaXplKGUud2lkdGgsIGUuaGVpZ2h0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2VzIHRoZSBlbGVtZW50IGZvciBhbiBhcHByb3ByaWF0ZSBzb3VyY2UgVVJMIGFuZFxuICAgICAqIHNldHMgdGhlIHZpZXdzIHRvIHVzZSB0aGUgbmV3IG1vZGVsIGJhc2VkLlxuICAgICAqL1xuICAgIGFzeW5jIFsoX28gPSAkb25Db250ZXh0TG9zdCwgJHVwZGF0ZVNvdXJjZSldKCkge1xuICAgICAgICBjb25zdCBzY2VuZSA9IHRoaXNbJHNjZW5lXTtcbiAgICAgICAgaWYgKHRoaXMubG9hZGVkIHx8ICF0aGlzWyRzaG91bGRBdHRlbXB0UHJlbG9hZF0oKSB8fFxuICAgICAgICAgICAgdGhpcy5zcmMgPT09IHNjZW5lLnVybCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmdlbmVyYXRlU2NoZW1hKSB7XG4gICAgICAgICAgICBzY2VuZS51cGRhdGVTY2hlbWEodGhpcy5zcmMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbJHVwZGF0ZVN0YXR1c10oJ0xvYWRpbmcnKTtcbiAgICAgICAgLy8gSWYgd2UgYXJlIGxvYWRpbmcgYSBuZXcgbW9kZWwsIHdlIG5lZWQgdG8gc3RvcCB0aGUgYW5pbWF0aW9uIG9mXG4gICAgICAgIC8vIHRoZSBjdXJyZW50IG9uZSAoaWYgYW55IGlzIHBsYXlpbmcpLiBPdGhlcndpc2UsIHdlIG1pZ2h0IGxvc2VcbiAgICAgICAgLy8gdGhlIHJlZmVyZW5jZSB0byB0aGUgc2NlbmUgcm9vdCBhbmQgcnVubmluZyBhY3Rpb25zIHN0YXJ0IHRvXG4gICAgICAgIC8vIHRocm93IGV4Y2VwdGlvbnMgYW5kL29yIGJlaGF2ZSBpbiB1bmV4cGVjdGVkIHdheXM6XG4gICAgICAgIHNjZW5lLnN0b3BBbmltYXRpb24oKTtcbiAgICAgICAgY29uc3QgdXBkYXRlU291cmNlUHJvZ3Jlc3MgPSB0aGlzWyRwcm9ncmVzc1RyYWNrZXJdLmJlZ2luQWN0aXZpdHkoKTtcbiAgICAgICAgY29uc3Qgc291cmNlID0gdGhpcy5zcmM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBzcmNVcGRhdGVkID0gc2NlbmUuc2V0U291cmNlKHNvdXJjZSwgKHByb2dyZXNzKSA9PiB1cGRhdGVTb3VyY2VQcm9ncmVzcyhjbGFtcChwcm9ncmVzcywgMCwgMSkgKiAwLjk1KSk7XG4gICAgICAgICAgICBjb25zdCBlbnZVcGRhdGVkID0gdGhpc1skdXBkYXRlRW52aXJvbm1lbnRdKCk7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbc3JjVXBkYXRlZCwgZW52VXBkYXRlZF0pO1xuICAgICAgICAgICAgdGhpc1skbWFya0xvYWRlZF0oKTtcbiAgICAgICAgICAgIHRoaXNbJG9uTW9kZWxMb2FkXSgpO1xuICAgICAgICAgICAgLy8gV2FpdCBmb3Igc2hhZGVycyB0byBjb21waWxlIGFuZCBwaXhlbHMgdG8gYmUgZHJhd24uXG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnbG9hZCcsIHsgZGV0YWlsOiB7IHVybDogc291cmNlIH0gfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnZXJyb3InLCB7IGRldGFpbDogeyB0eXBlOiAnbG9hZGZhaWx1cmUnLCBzb3VyY2VFcnJvcjogZXJyb3IgfSB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB1cGRhdGVTb3VyY2VQcm9ncmVzcygxLjApO1xuICAgICAgICB9XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgcHJvcGVydHkoeyB0eXBlOiBTdHJpbmcgfSlcbl0sIE1vZGVsVmlld2VyRWxlbWVudEJhc2UucHJvdG90eXBlLCBcImFsdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgcHJvcGVydHkoeyB0eXBlOiBTdHJpbmcgfSlcbl0sIE1vZGVsVmlld2VyRWxlbWVudEJhc2UucHJvdG90eXBlLCBcInNyY1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgcHJvcGVydHkoeyB0eXBlOiBCb29sZWFuLCBhdHRyaWJ1dGU6ICd3aXRoLWNyZWRlbnRpYWxzJyB9KVxuXSwgTW9kZWxWaWV3ZXJFbGVtZW50QmFzZS5wcm90b3R5cGUsIFwid2l0aENyZWRlbnRpYWxzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBwcm9wZXJ0eSh7IHR5cGU6IEJvb2xlYW4sIGF0dHJpYnV0ZTogJ2dlbmVyYXRlLXNjaGVtYScgfSlcbl0sIE1vZGVsVmlld2VyRWxlbWVudEJhc2UucHJvdG90eXBlLCBcImdlbmVyYXRlU2NoZW1hXCIsIHZvaWQgMCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2RlbC12aWV3ZXItYmFzZS5qcy5tYXAiLCIvKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAnTGljZW5zZScpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICdBUyBJUycgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBBbmltYXRpb25NaXhpbiB9IGZyb20gJy4vZmVhdHVyZXMvYW5pbWF0aW9uLmpzJztcbmltcG9ydCB7IEFubm90YXRpb25NaXhpbiB9IGZyb20gJy4vZmVhdHVyZXMvYW5ub3RhdGlvbi5qcyc7XG5pbXBvcnQgeyBBUk1peGluIH0gZnJvbSAnLi9mZWF0dXJlcy9hci5qcyc7XG5pbXBvcnQgeyBDb250cm9sc01peGluIH0gZnJvbSAnLi9mZWF0dXJlcy9jb250cm9scy5qcyc7XG5pbXBvcnQgeyBFbnZpcm9ubWVudE1peGluIH0gZnJvbSAnLi9mZWF0dXJlcy9lbnZpcm9ubWVudC5qcyc7XG5pbXBvcnQgeyBMb2FkaW5nTWl4aW4gfSBmcm9tICcuL2ZlYXR1cmVzL2xvYWRpbmcuanMnO1xuaW1wb3J0IHsgU2NlbmVHcmFwaE1peGluIH0gZnJvbSAnLi9mZWF0dXJlcy9zY2VuZS1ncmFwaC5qcyc7XG5pbXBvcnQgeyBTdGFnaW5nTWl4aW4gfSBmcm9tICcuL2ZlYXR1cmVzL3N0YWdpbmcuanMnO1xuaW1wb3J0IE1vZGVsVmlld2VyRWxlbWVudEJhc2UgZnJvbSAnLi9tb2RlbC12aWV3ZXItYmFzZS5qcyc7XG4vLyBFeHBvcnQgdGhlc2UgdG8gYWxsb3cgbGF6eS1sb2FkZWQgTG90dGllTG9hZGVyLmpzIHRvIGZpbmQgd2hhdCBpdCBuZWVkcy5cbi8vIFJlcXVpcmVzIGFuIGltcG9ydCBtYXAgLSBcInRocmVlXCI6IFwicGF0aC90by9tb2RlbC12aWV3ZXIubWluLmpzXCIuXG5leHBvcnQgeyBDYW52YXNUZXh0dXJlLCBGaWxlTG9hZGVyLCBMb2FkZXIsIE5lYXJlc3RGaWx0ZXIgfSBmcm9tICd0aHJlZSc7XG5leHBvcnQgY29uc3QgTW9kZWxWaWV3ZXJFbGVtZW50ID0gQW5ub3RhdGlvbk1peGluKFNjZW5lR3JhcGhNaXhpbihTdGFnaW5nTWl4aW4oRW52aXJvbm1lbnRNaXhpbihDb250cm9sc01peGluKEFSTWl4aW4oTG9hZGluZ01peGluKEFuaW1hdGlvbk1peGluKE1vZGVsVmlld2VyRWxlbWVudEJhc2UpKSkpKSkpKTtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnbW9kZWwtdmlld2VyJywgTW9kZWxWaWV3ZXJFbGVtZW50KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZGVsLXZpZXdlci5qcy5tYXAiLCIvKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAnTGljZW5zZScpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICdBUyBJUycgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBaRVJPIH0gZnJvbSAnLi9wYXJzZXJzJztcbi8qKlxuICogRW5zdXJlcyB0aGF0IGEgZ2l2ZW4gbnVtYmVyIGlzIGV4cHJlc3NlZCBpbiByYWRpYW5zLiBJZiB0aGUgbnVtYmVyIGlzIGFscmVhZHlcbiAqIGluIHJhZGlhbnMsIGRvZXMgbm90aGluZy4gSWYgdGhlIHZhbHVlIGlzIGluIGRlZ3JlZXMsIGNvbnZlcnRzIGl0IHRvIHJhZGlhbnMuXG4gKiBJZiB0aGUgdmFsdWUgaGFzIG5vIHNwZWNpZmllZCB1bml0LCB0aGUgdW5pdCBpcyBhc3N1bWVkIHRvIGJlIHJhZGlhbnMuIElmIHRoZVxuICogdmFsdWUgaXMgbm90IGluIHJhZGlhbnMgb3IgZGVncmVlcywgdGhlIHZhbHVlIGlzIHJlc29sdmVkIGFzIDAgcmFkaWFucy5cbiAqXG4gKiBBbHNvIGFjY2VwdHMgYSBzZWNvbmQgYXJndW1lbnQgdGhhdCBpcyBhIGRlZmF1bHQgdmFsdWUgdG8gdXNlIGlmIHRoZSBpbnB1dFxuICogbnVtYmVyTm9kZSBudW1iZXIgaXMgTmFOIG9yIEluZmluaXR5LlxuICovXG5leHBvcnQgY29uc3QgZGVncmVlc1RvUmFkaWFucyA9IChudW1iZXJOb2RlLCBmYWxsYmFja1JhZGlhblZhbHVlID0gMCkgPT4ge1xuICAgIGxldCB7IG51bWJlciwgdW5pdCB9ID0gbnVtYmVyTm9kZTtcbiAgICBpZiAoIWlzRmluaXRlKG51bWJlcikpIHtcbiAgICAgICAgbnVtYmVyID0gZmFsbGJhY2tSYWRpYW5WYWx1ZTtcbiAgICAgICAgdW5pdCA9ICdyYWQnO1xuICAgIH1cbiAgICBlbHNlIGlmIChudW1iZXJOb2RlLnVuaXQgPT09ICdyYWQnIHx8IG51bWJlck5vZGUudW5pdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudW1iZXJOb2RlO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZUlzRGVncmVlcyA9IHVuaXQgPT09ICdkZWcnICYmIG51bWJlciAhPSBudWxsO1xuICAgIGNvbnN0IHZhbHVlID0gdmFsdWVJc0RlZ3JlZXMgPyBudW1iZXIgOiAwO1xuICAgIGNvbnN0IHJhZGlhbnMgPSB2YWx1ZSAqIE1hdGguUEkgLyAxODA7XG4gICAgcmV0dXJuIHsgdHlwZTogJ251bWJlcicsIG51bWJlcjogcmFkaWFucywgdW5pdDogJ3JhZCcgfTtcbn07XG4vKipcbiAqIEVuc3VyZXMgdGhhdCBhIGdpdmVuIG51bWJlciBpcyBleHByZXNzZWQgaW4gZGVncmVlcy4gSWYgdGhlIG51bWJlciBpcyBhbHJlYWR5XG4gKiBpbiBkZWdyZWVzLCBkb2VzIG5vdGhpbmcuIElmIHRoZSB2YWx1ZSBpcyBpbiByYWRpYW5zIG9yIGhhcyBubyBzcGVjaWZpZWRcbiAqIHVuaXQsIGNvbnZlcnRzIGl0IHRvIGRlZ3JlZXMuIElmIHRoZSB2YWx1ZSBpcyBub3QgaW4gcmFkaWFucyBvciBkZWdyZWVzLCB0aGVcbiAqIHZhbHVlIGlzIHJlc29sdmVkIGFzIDAgZGVncmVlcy5cbiAqXG4gKiBBbHNvIGFjY2VwdHMgYSBzZWNvbmQgYXJndW1lbnQgdGhhdCBpcyBhIGRlZmF1bHQgdmFsdWUgdG8gdXNlIGlmIHRoZSBpbnB1dFxuICogbnVtYmVyTm9kZSBudW1iZXIgaXMgTmFOIG9yIEluZmluaXR5LlxuICovXG5leHBvcnQgY29uc3QgcmFkaWFuc1RvRGVncmVlcyA9IChudW1iZXJOb2RlLCBmYWxsYmFja0RlZ3JlZVZhbHVlID0gMCkgPT4ge1xuICAgIGxldCB7IG51bWJlciwgdW5pdCB9ID0gbnVtYmVyTm9kZTtcbiAgICBpZiAoIWlzRmluaXRlKG51bWJlcikpIHtcbiAgICAgICAgbnVtYmVyID0gZmFsbGJhY2tEZWdyZWVWYWx1ZTtcbiAgICAgICAgdW5pdCA9ICdkZWcnO1xuICAgIH1cbiAgICBlbHNlIGlmIChudW1iZXJOb2RlLnVuaXQgPT09ICdkZWcnKSB7XG4gICAgICAgIHJldHVybiBudW1iZXJOb2RlO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZUlzUmFkaWFucyA9ICh1bml0ID09PSBudWxsIHx8IHVuaXQgPT09ICdyYWQnKSAmJiBudW1iZXIgIT0gbnVsbDtcbiAgICBjb25zdCB2YWx1ZSA9IHZhbHVlSXNSYWRpYW5zID8gbnVtYmVyIDogMDtcbiAgICBjb25zdCBkZWdyZWVzID0gdmFsdWUgKiAxODAgLyBNYXRoLlBJO1xuICAgIHJldHVybiB7IHR5cGU6ICdudW1iZXInLCBudW1iZXI6IGRlZ3JlZXMsIHVuaXQ6ICdkZWcnIH07XG59O1xuLyoqXG4gKiBDb252ZXJ0cyBhIGdpdmVuIGxlbmd0aCB0byBtZXRlcnMuIEN1cnJlbnRseSBzdXBwb3J0ZWQgaW5wdXQgdW5pdHMgYXJlXG4gKiBtZXRlcnMsIGNlbnRpbWV0ZXJzIGFuZCBtaWxsaW1ldGVycy5cbiAqXG4gKiBBbHNvIGFjY2VwdHMgYSBzZWNvbmQgYXJndW1lbnQgdGhhdCBpcyBhIGRlZmF1bHQgdmFsdWUgdG8gdXNlIGlmIHRoZSBpbnB1dFxuICogbnVtYmVyTm9kZSBudW1iZXIgaXMgTmFOIG9yIEluZmluaXR5LlxuICovXG5leHBvcnQgY29uc3QgbGVuZ3RoVG9CYXNlTWV0ZXJzID0gKG51bWJlck5vZGUsIGZhbGxiYWNrTWV0ZXJWYWx1ZSA9IDApID0+IHtcbiAgICBsZXQgeyBudW1iZXIsIHVuaXQgfSA9IG51bWJlck5vZGU7XG4gICAgaWYgKCFpc0Zpbml0ZShudW1iZXIpKSB7XG4gICAgICAgIG51bWJlciA9IGZhbGxiYWNrTWV0ZXJWYWx1ZTtcbiAgICAgICAgdW5pdCA9ICdtJztcbiAgICB9XG4gICAgZWxzZSBpZiAobnVtYmVyTm9kZS51bml0ID09PSAnbScpIHtcbiAgICAgICAgcmV0dXJuIG51bWJlck5vZGU7XG4gICAgfVxuICAgIGxldCBzY2FsZTtcbiAgICBzd2l0Y2ggKHVuaXQpIHtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHNjYWxlID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjbSc6XG4gICAgICAgICAgICBzY2FsZSA9IDEgLyAxMDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbW0nOlxuICAgICAgICAgICAgc2NhbGUgPSAxIC8gMTAwMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IHNjYWxlICogbnVtYmVyO1xuICAgIHJldHVybiB7IHR5cGU6ICdudW1iZXInLCBudW1iZXI6IHZhbHVlLCB1bml0OiAnbScgfTtcbn07XG4vKipcbiAqIE5vcm1hbGl6ZXMgdGhlIHVuaXQgb2YgYSBnaXZlbiBpbnB1dCBudW1iZXIgc28gdGhhdCBpdCBpcyBleHByZXNzZWQgaW4gYVxuICogcHJlZmVycmVkIHVuaXQuIEZvciBsZW5ndGggbm9kZXMsIHRoZSByZXR1cm4gdmFsdWUgd2lsbCBiZSBleHByZXNzZWQgaW5cbiAqIG1ldGVycy4gRm9yIGFuZ2xlIG5vZGVzLCB0aGUgcmV0dXJuIHZhbHVlIHdpbGwgYmUgZXhwcmVzc2VkIGluIHJhZGlhbnMuXG4gKlxuICogQWxzbyB0YWtlcyBhIGZhbGxiYWNrIG51bWJlciB0aGF0IGlzIHVzZWQgd2hlbiB0aGUgbnVtYmVyIHZhbHVlIGlzIG5vdCBhXG4gKiB2YWxpZCBudW1iZXIgb3Igd2hlbiB0aGUgdW5pdCBvZiB0aGUgZ2l2ZW4gbnVtYmVyIGNhbm5vdCBiZSBub3JtYWxpemVkLlxuICovXG5leHBvcnQgY29uc3Qgbm9ybWFsaXplVW5pdCA9ICgoKSA9PiB7XG4gICAgY29uc3QgaWRlbnRpdHkgPSAobm9kZSkgPT4gbm9kZTtcbiAgICBjb25zdCB1bml0Tm9ybWFsaXplcnMgPSB7XG4gICAgICAgICdyYWQnOiBpZGVudGl0eSxcbiAgICAgICAgJ2RlZyc6IGRlZ3JlZXNUb1JhZGlhbnMsXG4gICAgICAgICdtJzogaWRlbnRpdHksXG4gICAgICAgICdtbSc6IGxlbmd0aFRvQmFzZU1ldGVycyxcbiAgICAgICAgJ2NtJzogbGVuZ3RoVG9CYXNlTWV0ZXJzXG4gICAgfTtcbiAgICByZXR1cm4gKG5vZGUsIGZhbGxiYWNrID0gWkVSTykgPT4ge1xuICAgICAgICBpZiAoIWlzRmluaXRlKG5vZGUubnVtYmVyKSkge1xuICAgICAgICAgICAgbm9kZS5udW1iZXIgPSBmYWxsYmFjay5udW1iZXI7XG4gICAgICAgICAgICBub2RlLnVuaXQgPSBmYWxsYmFjay51bml0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgdW5pdCB9ID0gbm9kZTtcbiAgICAgICAgaWYgKHVuaXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm9ybWFsaXplID0gdW5pdE5vcm1hbGl6ZXJzW3VuaXRdO1xuICAgICAgICBpZiAobm9ybWFsaXplID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxsYmFjaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9ybWFsaXplKG5vZGUpO1xuICAgIH07XG59KSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udmVyc2lvbnMuanMubWFwIiwiLyogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgJ0xpY2Vuc2UnKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAnQVMgSVMnIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgcGFyc2VFeHByZXNzaW9ucyB9IGZyb20gJy4vcGFyc2Vycy5qcyc7XG4vKipcbiAqIEZvciBvdXIgcHVycG9zZXMsIGFuIGVudW1lcmF0aW9uIGlzIGEgZml4ZWQgc2V0IG9mIENTUy1leHByZXNzaW9uLWNvbXBhdGlibGVcbiAqIG5hbWVzLiBXaGVuIHNlcmlhbGl6ZWQsIGEgc2VsZWN0ZWQgc3Vic2V0IG9mIHRoZSBtZW1iZXJzIG1heSBiZSBzcGVjaWZpZWQgYXNcbiAqIHdoaXRlc3BhY2Utc2VwYXJhdGVkIHN0cmluZ3MuIEFuIGVudW1lcmF0aW9uIGRlc2VyaWFsaXplciBpcyBhIGZ1bmN0aW9uIHRoYXRcbiAqIHBhcnNlcyBhIHNlcmlhbGl6ZWQgc3Vic2V0IG9mIGFuIGVudW1lcmF0aW9uIGFuZCByZXR1cm5zIGFueSBtZW1iZXJzIHRoYXQgYXJlXG4gKiBmb3VuZCBhcyBhIFNldC5cbiAqXG4gKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgd2lsbCBwcm9kdWNlIGEgZGVzZXJpYWxpemVyIGZvciB0aGUgZGF5cyBvZiB0aGVcbiAqIHdlZWs6XG4gKlxuICogY29uc3QgZGVzZXJpYWxpemVEYXlzT2ZUaGVXZWVrID0gZW51bWVyYXRpb25EZXNlcmlhbGl6ZXIoW1xuICogICAnTW9uZGF5JyxcbiAqICAgJ1R1ZXNkYXknLFxuICogICAnV2VkbmVzZGF5JyxcbiAqICAgJ1RodXJzZGF5JyxcbiAqICAgJ0ZyaWRheScsXG4gKiAgICdTYXR1cmRheScsXG4gKiAgICdTdW5kYXknXG4gKiBdKTtcbiAqL1xuZXhwb3J0IGNvbnN0IGVudW1lcmF0aW9uRGVzZXJpYWxpemVyID0gKGFsbG93ZWROYW1lcykgPT4gKHZhbHVlU3RyaW5nKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbnMgPSBwYXJzZUV4cHJlc3Npb25zKHZhbHVlU3RyaW5nKTtcbiAgICAgICAgY29uc3QgbmFtZXMgPSAoZXhwcmVzc2lvbnMubGVuZ3RoID8gZXhwcmVzc2lvbnNbMF0udGVybXMgOiBbXSlcbiAgICAgICAgICAgIC5maWx0ZXIoKHZhbHVlTm9kZSkgPT4gdmFsdWVOb2RlICYmIHZhbHVlTm9kZS50eXBlID09PSAnaWRlbnQnKVxuICAgICAgICAgICAgLm1hcCh2YWx1ZU5vZGUgPT4gdmFsdWVOb2RlLnZhbHVlKVxuICAgICAgICAgICAgLmZpbHRlcihuYW1lID0+IGFsbG93ZWROYW1lcy5pbmRleE9mKG5hbWUpID4gLTEpO1xuICAgICAgICAvLyBOT1RFKGNkYXRhKTogSUUxMSBkb2VzIG5vdCBzdXBwb3J0IGNvbnN0cnVjdGluZyBhIFNldCBkaXJlY3RseSBmcm9tXG4gICAgICAgIC8vIGFuIGl0ZXJhYmxlLCBzbyB3ZSBuZWVkIHRvIG1hbnVhbGx5IGFkZCBhbGwgdGhlIGl0ZW1zOlxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgU2V0KCk7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBuYW1lcykge1xuICAgICAgICAgICAgcmVzdWx0LmFkZChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBjYXRjaCAoX2Vycm9yKSB7XG4gICAgfVxuICAgIHJldHVybiBuZXcgU2V0KCk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVzZXJpYWxpemVycy5qcy5tYXAiLCIvKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAnTGljZW5zZScpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICdBUyBJUycgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgX2EsIF9iLCBfYztcbmltcG9ydCB7IG5vcm1hbGl6ZVVuaXQgfSBmcm9tICcuL2NvbnZlcnNpb25zJztcbmltcG9ydCB7IG51bWJlck5vZGUsIFpFUk8gfSBmcm9tICcuL3BhcnNlcnMnO1xuY29uc3QgJGV2YWx1YXRlID0gU3ltYm9sKCdldmFsdWF0ZScpO1xuY29uc3QgJGxhc3RWYWx1ZSA9IFN5bWJvbCgnbGFzdFZhbHVlJyk7XG4vKipcbiAqIEFuIEV2YWx1YXRvciBpcyB1c2VkIHRvIGRlcml2ZSBhIGNvbXB1dGVkIHN0eWxlIGZyb20gcGFydCAob3IgYWxsKSBvZiBhIENTU1xuICogZXhwcmVzc2lvbiBBU1QuIFRoaXMgY29uc3RydWN0IGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIGNvbXBsZXggQVNUc1xuICogY29udGFpbmluZyBmdW5jdGlvbiBjYWxscyBzdWNoIGFzIGNhbGMsIHZhciBhbmQgZW52LiBTdWNoIHN0eWxlcyBjb3VsZCBiZVxuICogY29zdGx5IHRvIHJlLWV2YWx1YXRlIG9uIGV2ZXJ5IGZyYW1lIChhbmQgaW4gc29tZSBjYXNlcyB3ZSBtYXkgdHJ5IHRvIGRvXG4gKiB0aGF0KS4gVGhlIEV2YWx1YXRvciBjb25zdHJ1Y3QgYWxsb3dzIHVzIHRvIG1hcmsgc3ViLXRyZWVzIG9mIHRoZSBBU1QgYXNcbiAqIGNvbnN0YW50LCBzbyB0aGF0IG9ubHkgdGhlIGR5bmFtaWMgcGFydHMgYXJlIHJlLWV2YWx1YXRlZC4gSXQgYWxzbyBzZXBhcmF0ZXNcbiAqIG9uZS10aW1lIEFTVCBwcmVwYXJhdGlvbiB3b3JrIGZyb20gd29yayB0aGF0IG5lY2Vzc2FyaWx5IGhhcyB0byBoYXBwZW4gdXBvblxuICogZWFjaCBldmFsdWF0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgRXZhbHVhdG9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpc1tfYV0gPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbiBFdmFsdWF0YWJsZSBpcyBhIE51bWJlck5vZGUgb3IgYW4gRXZhbHVhdG9yIHRoYXQgZXZhbHVhdGVzIGEgTnVtYmVyTm9kZVxuICAgICAqIGFzIHRoZSByZXN1bHQgb2YgaW52b2tpbmcgaXRzIGV2YWx1YXRlIG1ldGhvZC4gVGhpcyBpcyBtYWlubHkgdXNlZCB0b1xuICAgICAqIGVuc3VyZSB0aGF0IENTUyBmdW5jdGlvbiBub2RlcyBhcmUgY2FzdCB0byB0aGUgY29ycmVzcG9uZGluZyBFdmFsdWF0b3JzXG4gICAgICogdGhhdCB3aWxsIHJlc29sdmUgdGhlIHJlc3VsdCBvZiB0aGUgZnVuY3Rpb24sIGJ1dCBpcyBhbHNvIHVzZWQgdG8gZW5zdXJlXG4gICAgICogdGhhdCBhIHBlcmNlbnRhZ2UgbmVzdGVkIGF0IGFyYml0cmFyeSBkZXB0aCBpbiB0aGUgZXhwcmVzc2lvbiB3aWxsIGFsd2F5c1xuICAgICAqIGJlIGV2YWx1YXRlZCBhZ2FpbnN0IHRoZSBjb3JyZWN0IGJhc2lzLlxuICAgICAqL1xuICAgIHN0YXRpYyBldmFsdWF0YWJsZUZvcihub2RlLCBiYXNpcyA9IFpFUk8pIHtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBFdmFsdWF0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBpZiAobm9kZS51bml0ID09PSAnJScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBlcmNlbnRhZ2VFdmFsdWF0b3Iobm9kZSwgYmFzaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChub2RlLm5hbWUudmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2NhbGMnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ2FsY0V2YWx1YXRvcihub2RlLCBiYXNpcyk7XG4gICAgICAgICAgICBjYXNlICdlbnYnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRW52RXZhbHVhdG9yKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBaRVJPO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgaW5wdXQgaXMgYW4gRXZhbHVhdG9yLCByZXR1cm5zIHRoZSByZXN1bHQgb2YgZXZhbHVhdGluZyBpdC5cbiAgICAgKiBPdGhlcndpc2UsIHJldHVybnMgdGhlIGlucHV0LlxuICAgICAqXG4gICAgICogVGhpcyBpcyBhIGhlbHBlciB0byBhaWRlIGluIHJlc29sdmluZyBhIE51bWJlck5vZGUgd2l0aG91dCBjb25kaXRpb25hbGx5XG4gICAgICogY2hlY2tpbmcgaWYgdGhlIEV2YWx1YXRhYmxlIGlzIGFuIEV2YWx1YXRvciBldmVyeXdoZXJlLlxuICAgICAqL1xuICAgIHN0YXRpYyBldmFsdWF0ZShldmFsdWF0YWJsZSkge1xuICAgICAgICBpZiAoZXZhbHVhdGFibGUgaW5zdGFuY2VvZiBFdmFsdWF0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBldmFsdWF0YWJsZS5ldmFsdWF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBldmFsdWF0YWJsZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgdGhlIGlucHV0IGlzIGFuIEV2YWx1YXRvciwgcmV0dXJucyB0aGUgdmFsdWUgb2YgaXRzIGlzQ29uc3RhbnQgcHJvcGVydHkuXG4gICAgICogUmV0dXJucyB0cnVlIGZvciBhbGwgb3RoZXIgaW5wdXQgdmFsdWVzLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0NvbnN0YW50KGV2YWx1YXRhYmxlKSB7XG4gICAgICAgIGlmIChldmFsdWF0YWJsZSBpbnN0YW5jZW9mIEV2YWx1YXRvcikge1xuICAgICAgICAgICAgcmV0dXJuIGV2YWx1YXRhYmxlLmlzQ29uc3RhbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGFwcGxpZXMgYSBzZXQgb2Ygc3RydWN0dXJlZCBpbnRyaW5zaWMgbWV0YWRhdGEgdG8gYW4gZXZhbHVhdGVkXG4gICAgICogcmVzdWx0IGZyb20gYSBwYXJzZWQgQ1NTLWxpa2Ugc3RyaW5nIG9mIGV4cHJlc3Npb25zLiBJbnRyaW5zaWNzIHByb3ZpZGVcbiAgICAgKiBzdWZmaWNpZW50IG1ldGFkYXRhIChlLmcuLCBiYXNpcyB2YWx1ZXMsIGFuYWxvZ3MgZm9yIGtleXdvcmRzKSBzdWNoIHRoYXRcbiAgICAgKiBvbWl0dGVkIHZhbHVlcyBpbiB0aGUgaW5wdXQgc3RyaW5nIGNhbiBiZSBiYWNrZmlsbGVkLCBhbmQga2V5d29yZHMgY2FuIGJlXG4gICAgICogY29udmVydGVkIHRvIGNvbmNyZXRlIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBUaGUgcmVzdWx0IG9mIGFwcGx5aW5nIGludHJpbnNpY3MgaXMgYSB0dXBsZSBvZiBOdW1iZXJOb2RlIHZhbHVlcyB3aG9zZVxuICAgICAqIHVuaXRzIG1hdGNoIHRoZSB1bml0cyB1c2VkIGJ5IHRoZSBiYXNpcyBvZiB0aGUgaW50cmluc2ljcy5cbiAgICAgKlxuICAgICAqIFRoZSBmb2xsb3dpbmcgaXMgYSBoaWdoLWxldmVsIGRlc2NyaXB0aW9uIG9mIGhvdyBpbnRyaW5zaWNzIGFyZSBhcHBsaWVkOlxuICAgICAqXG4gICAgICogIDEuIERldGVybWluZSB0aGUgdmFsdWUgb2YgJ2F1dG8nIGZvciB0aGUgY3VycmVudCB0ZXJtXG4gICAgICogIDIuIElmIHRoZXJlIGlzIG5vIGNvcnJlc3BvbmRpbmcgaW5wdXQgdmFsdWUgZm9yIHRoaXMgdGVybSwgc3Vic3RpdHV0ZSB0aGVcbiAgICAgKiAgICAgJ2F1dG8nIHZhbHVlLlxuICAgICAqICAzLiBJZiB0aGUgdGVybSBpcyBhbiBJZGVudE5vZGUsIHRyZWF0IGl0IGFzIGEga2V5d29yZCBhbmQgcGVyZm9ybSB0aGVcbiAgICAgKiAgICAgYXBwcm9wcmlhdGUgc3Vic3RpdHV0aW9uLlxuICAgICAqICA0LiBJZiB0aGUgdGVybSBpcyBzdGlsbCBudWxsLCBmYWxsYmFjayB0byB0aGUgJ2F1dG8nIHZhbHVlXG4gICAgICogIDUuIElmIHRoZSB0ZXJtIGlzIGEgcGVyY2VudGFnZSwgYXBwbHkgaXQgdG8gdGhlIGJhc2lzIGFuZCByZXR1cm4gdGhhdFxuICAgICAqICAgICB2YWx1ZVxuICAgICAqICA2LiBOb3JtYWxpemUgdGhlIHVuaXQgb2YgdGhlIHRlcm1cbiAgICAgKiAgNy4gSWYgdGhlIHRlcm0ncyB1bml0IGRvZXMgbm90IG1hdGNoIHRoZSBiYXNpcyB1bml0LCByZXR1cm4gdGhlIGJhc2lzXG4gICAgICogICAgIHZhbHVlXG4gICAgICogIDguIFJldHVybiB0aGUgdGVybSBhcyBpc1xuICAgICAqL1xuICAgIHN0YXRpYyBhcHBseUludHJpbnNpY3MoZXZhbHVhdGVkLCBpbnRyaW5zaWNzKSB7XG4gICAgICAgIGNvbnN0IHsgYmFzaXMsIGtleXdvcmRzIH0gPSBpbnRyaW5zaWNzO1xuICAgICAgICBjb25zdCB7IGF1dG8gfSA9IGtleXdvcmRzO1xuICAgICAgICByZXR1cm4gYmFzaXMubWFwKChiYXNpc05vZGUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAvLyBVc2UgYW4gYXV0byB2YWx1ZSBpZiB3ZSBoYXZlIGl0LCBvdGhlcndpc2UgdGhlIGF1dG8gdmFsdWUgaXMgdGhlIGJhc2lzOlxuICAgICAgICAgICAgY29uc3QgYXV0b1N1YnN0aXR1dGVOb2RlID0gYXV0b1tpbmRleF0gPT0gbnVsbCA/IGJhc2lzTm9kZSA6IGF1dG9baW5kZXhdO1xuICAgICAgICAgICAgLy8gSWYgdGhlIGV2YWx1YXRlZCBub2RlcyBkbyBub3QgaGF2ZSBhIG5vZGUgYXQgdGhlIGN1cnJlbnRcbiAgICAgICAgICAgIC8vIGluZGV4LCBmYWxsYmFjayB0byB0aGUgXCJhdXRvXCIgc3Vic3RpdHV0ZSByaWdodCBhd2F5OlxuICAgICAgICAgICAgbGV0IGV2YWx1YXRlZE5vZGUgPSBldmFsdWF0ZWRbaW5kZXhdID8gZXZhbHVhdGVkW2luZGV4XSA6IGF1dG9TdWJzdGl0dXRlTm9kZTtcbiAgICAgICAgICAgIC8vIEFueSBpZGVudCBub2RlIGlzIGNvbnNpZGVyZWQgYSBrZXl3b3JkOlxuICAgICAgICAgICAgaWYgKGV2YWx1YXRlZE5vZGUudHlwZSA9PT0gJ2lkZW50Jykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleXdvcmQgPSBldmFsdWF0ZWROb2RlLnZhbHVlO1xuICAgICAgICAgICAgICAgIC8vIFN1YnN0aXR1dGUgYW55IGtleXdvcmRzIGZvciBjb25jcmV0ZSB2YWx1ZXMgZmlyc3Q6XG4gICAgICAgICAgICAgICAgaWYgKGtleXdvcmQgaW4ga2V5d29yZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZhbHVhdGVkTm9kZSA9IGtleXdvcmRzW2tleXdvcmRdW2luZGV4XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgTnVtYmVyTm9kZSBhdCB0aGlzIHBvaW50LCBmYWxsIGJhY2sgdG8gd2hhdGV2ZXJcbiAgICAgICAgICAgIC8vIGlzIHNwZWNpZmllZCBmb3IgYXV0bzpcbiAgICAgICAgICAgIGlmIChldmFsdWF0ZWROb2RlID09IG51bGwgfHwgZXZhbHVhdGVkTm9kZS50eXBlID09PSAnaWRlbnQnKSB7XG4gICAgICAgICAgICAgICAgZXZhbHVhdGVkTm9kZSA9IGF1dG9TdWJzdGl0dXRlTm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZvciBwZXJjZW50YWdlcywgd2UgYWx3YXlzIGFwcGx5IHRoZSBwZXJjZW50YWdlIHRvIHRoZSBiYXNpcyB2YWx1ZTpcbiAgICAgICAgICAgIGlmIChldmFsdWF0ZWROb2RlLnVuaXQgPT09ICclJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXJOb2RlKGV2YWx1YXRlZE5vZGUubnVtYmVyIC8gMTAwICogYmFzaXNOb2RlLm51bWJlciwgYmFzaXNOb2RlLnVuaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBub3JtYWxpemUgd2hhdGV2ZXIgd2UgaGF2ZTpcbiAgICAgICAgICAgIGV2YWx1YXRlZE5vZGUgPSBub3JtYWxpemVVbml0KGV2YWx1YXRlZE5vZGUsIGJhc2lzTm9kZSk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgbm9ybWFsaXplZCB1bml0cyBkbyBub3QgbWF0Y2gsIHJldHVybiB0aGUgYmFzaXMgYXMgYSBmYWxsYmFjazpcbiAgICAgICAgICAgIGlmIChldmFsdWF0ZWROb2RlLnVuaXQgIT09IGJhc2lzTm9kZS51bml0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhc2lzTm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZpbmFsbHksIHJldHVybiB0aGUgZXZhbHVhdGVkIG5vZGUgd2l0aCBpbnRyaW5zaWNzIGFwcGxpZWQ6XG4gICAgICAgICAgICByZXR1cm4gZXZhbHVhdGVkTm9kZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHRoZSBFdmFsdWF0b3Igd2lsbCBvbmx5IGV2YWx1YXRlIGl0cyBBU1Qgb25lIHRpbWUuIElmIGZhbHNlLCB0aGVcbiAgICAgKiBFdmFsdWF0b3Igd2lsbCByZS1ldmFsdWF0ZSB0aGUgQVNUIGVhY2ggdGltZSB0aGF0IHRoZSBwdWJsaWMgZXZhbHVhdGVcbiAgICAgKiBtZXRob2QgaXMgaW52b2tlZC5cbiAgICAgKi9cbiAgICBnZXQgaXNDb25zdGFudCgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZSB0aGUgRXZhbHVhdG9yIGFuZCByZXR1cm4gdGhlIHJlc3VsdC4gSWYgdGhlIEV2YWx1YXRvciBpcyBjb25zdGFudCxcbiAgICAgKiB0aGUgY29ycmVzcG9uZGluZyBBU1Qgd2lsbCBvbmx5IGJlIGV2YWx1YXRlZCBvbmNlLCBhbmQgdGhlIHJlc3VsdCBvZlxuICAgICAqIGV2YWx1YXRpbmcgaXQgdGhlIGZpcnN0IHRpbWUgd2lsbCBiZSByZXR1cm5lZCBvbiBhbGwgc3Vic2VxdWVudFxuICAgICAqIGV2YWx1YXRpb25zLlxuICAgICAqL1xuICAgIGV2YWx1YXRlKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNDb25zdGFudCB8fCB0aGlzWyRsYXN0VmFsdWVdID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXNbJGxhc3RWYWx1ZV0gPSB0aGlzWyRldmFsdWF0ZV0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1skbGFzdFZhbHVlXTtcbiAgICB9XG59XG5fYSA9ICRsYXN0VmFsdWU7XG5jb25zdCAkcGVyY2VudGFnZSA9IFN5bWJvbCgncGVyY2VudGFnZScpO1xuY29uc3QgJGJhc2lzID0gU3ltYm9sKCdiYXNpcycpO1xuLyoqXG4gKiBBIFBlcmNlbnRhZ2VFdmFsdWF0b3Igc2NhbGVzIGEgZ2l2ZW4gYmFzaXMgdmFsdWUgYnkgYSBnaXZlbiBwZXJjZW50YWdlIHZhbHVlLlxuICogVGhlIGV2YWx1YXRlZCByZXN1bHQgaXMgYWx3YXlzIGNvbnNpZGVyZWQgdG8gYmUgY29uc3RhbnQuXG4gKi9cbmV4cG9ydCBjbGFzcyBQZXJjZW50YWdlRXZhbHVhdG9yIGV4dGVuZHMgRXZhbHVhdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihwZXJjZW50YWdlLCBiYXNpcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzWyRwZXJjZW50YWdlXSA9IHBlcmNlbnRhZ2U7XG4gICAgICAgIHRoaXNbJGJhc2lzXSA9IGJhc2lzO1xuICAgIH1cbiAgICBnZXQgaXNDb25zdGFudCgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFskZXZhbHVhdGVdKCkge1xuICAgICAgICByZXR1cm4gbnVtYmVyTm9kZSh0aGlzWyRwZXJjZW50YWdlXS5udW1iZXIgLyAxMDAgKiB0aGlzWyRiYXNpc10ubnVtYmVyLCB0aGlzWyRiYXNpc10udW5pdCk7XG4gICAgfVxufVxuY29uc3QgJGlkZW50Tm9kZSA9IFN5bWJvbCgnaWRlbnROb2RlJyk7XG4vKipcbiAqIEV2YWx1YXRvciBmb3IgQ1NTLWxpa2UgZW52KCkgZnVuY3Rpb25zLiBDdXJyZW50bHksIG9ubHkgb25lIGVudmlyb25tZW50XG4gKiB2YXJpYWJsZSBpcyBhY2NlcHRlZCBhcyBhbiBhcmd1bWVudCBmb3Igc3VjaCBmdW5jdGlvbnM6IHdpbmRvdy1zY3JvbGwteS5cbiAqXG4gKiBUaGUgZW52KCkgRXZhbHVhdG9yIGlzIGV4cGxpY2l0bHkgZHluYW1pYyBiZWNhdXNlIGl0IGFsd2F5cyByZWZlcnMgdG9cbiAqIGV4dGVybmFsIHN0YXRlIHRoYXQgY2hhbmdlcyBhcyB0aGUgdXNlciBzY3JvbGxzLCBzbyBpdCBzaG91bGQgYWx3YXlzIGJlXG4gKiByZS1ldmFsdWF0ZWQgdG8gZW5zdXJlIHdlIGdldCB0aGUgbW9zdCByZWNlbnQgdmFsdWUuXG4gKlxuICogU29tZSBpbXBvcnRhbnQgbm90ZXMgYWJvdXQgdGhpcyBmZWF0dXJlIGluY2x1ZGU6XG4gKlxuICogIC0gVGhlcmUgaXMgbm8gc3VjaCB0aGluZyBhcyBhIFwid2luZG93LXNjcm9sbC15XCIgQ1NTIGVudmlyb25tZW50IHZhcmlhYmxlIGluXG4gKiAgICBhbnkgc3RhYmxlIGJyb3dzZXIgYXQgdGhlIHRpbWUgdGhhdCB0aGlzIGNvbW1lbnQgaXMgYmVpbmcgd3JpdHRlbi5cbiAqICAtIFRoZSBhY3R1YWwgQ1NTIGVudigpIGZ1bmN0aW9uIGFjY2VwdHMgYSBzZWNvbmQgYXJndW1lbnQgYXMgYSBmYWxsYmFjayBmb3JcbiAqICAgIHRoZSBjYXNlIHRoYXQgdGhlIHNwZWNpZmllZCBmaXJzdCBhcmd1bWVudCBpc24ndCBzZXQ7IG91ciBzeW50YXggZG9lcyBub3RcbiAqICAgIHN1cHBvcnQgdGhpcyBzZWNvbmQgYXJndW1lbnQuXG4gKlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvZW52XG4gKi9cbmV4cG9ydCBjbGFzcyBFbnZFdmFsdWF0b3IgZXh0ZW5kcyBFdmFsdWF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGVudkZ1bmN0aW9uKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXNbX2JdID0gbnVsbDtcbiAgICAgICAgY29uc3QgaWRlbnROb2RlID0gZW52RnVuY3Rpb24uYXJndW1lbnRzLmxlbmd0aCA/IGVudkZ1bmN0aW9uLmFyZ3VtZW50c1swXS50ZXJtc1swXSA6IG51bGw7XG4gICAgICAgIGlmIChpZGVudE5vZGUgIT0gbnVsbCAmJiBpZGVudE5vZGUudHlwZSA9PT0gJ2lkZW50Jykge1xuICAgICAgICAgICAgdGhpc1skaWRlbnROb2RlXSA9IGlkZW50Tm9kZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaXNDb25zdGFudCgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICA7XG4gICAgWyhfYiA9ICRpZGVudE5vZGUsICRldmFsdWF0ZSldKCkge1xuICAgICAgICBpZiAodGhpc1skaWRlbnROb2RlXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXNbJGlkZW50Tm9kZV0udmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICd3aW5kb3ctc2Nyb2xsLXknOlxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2ZXJ0aWNhbFNjcm9sbFBvc2l0aW9uID0gd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2ZXJ0aWNhbFNjcm9sbE1heCA9IE1hdGgubWF4KGRvY3VtZW50LmJvZHkuc2Nyb2xsSGVpZ2h0LCBkb2N1bWVudC5ib2R5Lm9mZnNldEhlaWdodCwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodCwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm9mZnNldEhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjcm9sbFkgPSB2ZXJ0aWNhbFNjcm9sbFBvc2l0aW9uIC9cbiAgICAgICAgICAgICAgICAgICAgICAgICh2ZXJ0aWNhbFNjcm9sbE1heCAtIHdpbmRvdy5pbm5lckhlaWdodCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIDA7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6ICdudW1iZXInLCBudW1iZXI6IHNjcm9sbFksIHVuaXQ6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWkVSTztcbiAgICB9XG59XG5jb25zdCBJU19NVUxUSVBMSUNBVElPTl9SRSA9IC9bXFwqXFwvXS87XG5jb25zdCAkZXZhbHVhdG9yID0gU3ltYm9sKCdldmFsdWF0b3InKTtcbi8qKlxuICogRXZhbHVhdG9yIGZvciBDU1MtbGlrZSBjYWxjKCkgZnVuY3Rpb25zLiBPdXIgaW1wbGVtZW50YXRpb24gb2YgY2FsYygpXG4gKiBldmFsdWF0aW9uIGN1cnJlbnRseSBzdXBwb3J0IG5lc3RlZCBmdW5jdGlvbiBjYWxscywgYW4gdW5saW1pdGVkIG51bWJlciBvZlxuICogdGVybXMsIGFuZCBhbGwgZm91ciBhbGdlYnJhaWMgb3BlcmF0b3JzICgrLCAtLCAqIGFuZCAvKS5cbiAqXG4gKiBUaGUgRXZhbHVhdG9yIGlzIG1hcmtlZCBhcyBjb25zdGFudCB1bmxlc3MgdGhlIGNhbGMgZXhwcmVzc2lvbiBjb250YWlucyBhblxuICogaW50ZXJuYWwgZW52IGV4cHJlc3Npb24gYXQgYW55IGRlcHRoLCBpbiB3aGljaCBjYXNlIGl0IHdpbGwgYmUgbWFya2VkIGFzXG4gKiBkeW5hbWljLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy12YWx1ZXMtMy8jY2FsYy1zeW50YXhcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2NhbGNcbiAqL1xuZXhwb3J0IGNsYXNzIENhbGNFdmFsdWF0b3IgZXh0ZW5kcyBFdmFsdWF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGNhbGNGdW5jdGlvbiwgYmFzaXMgPSBaRVJPKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXNbX2NdID0gbnVsbDtcbiAgICAgICAgaWYgKGNhbGNGdW5jdGlvbi5hcmd1bWVudHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGVybXMgPSBjYWxjRnVuY3Rpb24uYXJndW1lbnRzWzBdLnRlcm1zLnNsaWNlKCk7XG4gICAgICAgIGNvbnN0IHNlY29uZE9yZGVyVGVybXMgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRlcm1zLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgdGVybSA9IHRlcm1zLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAoc2Vjb25kT3JkZXJUZXJtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNUZXJtID0gc2Vjb25kT3JkZXJUZXJtc1tzZWNvbmRPcmRlclRlcm1zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c1Rlcm0udHlwZSA9PT0gJ29wZXJhdG9yJyAmJlxuICAgICAgICAgICAgICAgICAgICBJU19NVUxUSVBMSUNBVElPTl9SRS50ZXN0KHByZXZpb3VzVGVybS52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3BlcmF0b3IgPSBzZWNvbmRPcmRlclRlcm1zLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsZWZ0VmFsdWUgPSBzZWNvbmRPcmRlclRlcm1zLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZWNvbmRPcmRlclRlcm1zLnB1c2gobmV3IE9wZXJhdG9yRXZhbHVhdG9yKG9wZXJhdG9yLCBFdmFsdWF0b3IuZXZhbHVhdGFibGVGb3IobGVmdFZhbHVlLCBiYXNpcyksIEV2YWx1YXRvci5ldmFsdWF0YWJsZUZvcih0ZXJtLCBiYXNpcykpKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2Vjb25kT3JkZXJUZXJtcy5wdXNoKHRlcm0udHlwZSA9PT0gJ29wZXJhdG9yJyA/IHRlcm0gOlxuICAgICAgICAgICAgICAgIEV2YWx1YXRvci5ldmFsdWF0YWJsZUZvcih0ZXJtLCBiYXNpcykpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChzZWNvbmRPcmRlclRlcm1zLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IFtsZWZ0LCBvcGVyYXRvciwgcmlnaHRdID0gc2Vjb25kT3JkZXJUZXJtcy5zcGxpY2UoMCwgMyk7XG4gICAgICAgICAgICBpZiAob3BlcmF0b3IudHlwZSAhPT0gJ29wZXJhdG9yJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlY29uZE9yZGVyVGVybXMudW5zaGlmdChuZXcgT3BlcmF0b3JFdmFsdWF0b3Iob3BlcmF0b3IsIEV2YWx1YXRvci5ldmFsdWF0YWJsZUZvcihsZWZ0LCBiYXNpcyksIEV2YWx1YXRvci5ldmFsdWF0YWJsZUZvcihyaWdodCwgYmFzaXMpKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlcmUgc2hvdWxkIG9ubHkgYmUgb25lIGNvbWJpbmVkIGV2YWx1YXRvciBhdCB0aGlzIHBvaW50OlxuICAgICAgICBpZiAoc2Vjb25kT3JkZXJUZXJtcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXNbJGV2YWx1YXRvcl0gPSBzZWNvbmRPcmRlclRlcm1zWzBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBpc0NvbnN0YW50KCkge1xuICAgICAgICByZXR1cm4gdGhpc1skZXZhbHVhdG9yXSA9PSBudWxsIHx8IEV2YWx1YXRvci5pc0NvbnN0YW50KHRoaXNbJGV2YWx1YXRvcl0pO1xuICAgIH1cbiAgICBbKF9jID0gJGV2YWx1YXRvciwgJGV2YWx1YXRlKV0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzWyRldmFsdWF0b3JdICE9IG51bGwgPyBFdmFsdWF0b3IuZXZhbHVhdGUodGhpc1skZXZhbHVhdG9yXSkgOlxuICAgICAgICAgICAgWkVSTztcbiAgICB9XG59XG5jb25zdCAkb3BlcmF0b3IgPSBTeW1ib2woJ29wZXJhdG9yJyk7XG5jb25zdCAkbGVmdCA9IFN5bWJvbCgnbGVmdCcpO1xuY29uc3QgJHJpZ2h0ID0gU3ltYm9sKCdyaWdodCcpO1xuLyoqXG4gKiBBbiBFdmFsdWF0b3IgZm9yIHRoZSBvcGVyYXRvcnMgZm91bmQgaW5zaWRlIENTUyBjYWxjKCkgZnVuY3Rpb25zLlxuICogVGhlIGV2YWx1YXRvciBhY2NlcHRzIGFuIG9wZXJhdG9yIGFuZCBsZWZ0L3JpZ2h0IG9wZXJhbmRzLiBUaGUgb3BlcmFuZHMgY2FuXG4gKiBiZSBhbnkgdmFsaWQgZXhwcmVzc2lvbiB0ZXJtIHR5cGljYWxseSBhbGxvd2VkIGluc2lkZSBhIENTUyBjYWxjIGZ1bmN0aW9uLlxuICpcbiAqIEFzIGRldGFpbCBvZiB0aGlzIGltcGxlbWVudGF0aW9uLCB0aGUgb25seSBzdXBwb3J0ZWQgdW5pdCB0eXBlcyBhcmUgYW5nbGVzXG4gKiBleHByZXNzZWQgYXMgcmFkaWFucyBvciBkZWdyZWVzLCBhbmQgbGVuZ3RocyBleHByZXNzZWQgYXMgbWV0ZXJzLCBjZW50aW1ldGVyc1xuICogb3IgbWlsbGltZXRlcnMuXG4gKlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvY2FsY1xuICovXG5leHBvcnQgY2xhc3MgT3BlcmF0b3JFdmFsdWF0b3IgZXh0ZW5kcyBFdmFsdWF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKG9wZXJhdG9yLCBsZWZ0LCByaWdodCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzWyRvcGVyYXRvcl0gPSBvcGVyYXRvcjtcbiAgICAgICAgdGhpc1skbGVmdF0gPSBsZWZ0O1xuICAgICAgICB0aGlzWyRyaWdodF0gPSByaWdodDtcbiAgICB9XG4gICAgZ2V0IGlzQ29uc3RhbnQoKSB7XG4gICAgICAgIHJldHVybiBFdmFsdWF0b3IuaXNDb25zdGFudCh0aGlzWyRsZWZ0XSkgJiZcbiAgICAgICAgICAgIEV2YWx1YXRvci5pc0NvbnN0YW50KHRoaXNbJHJpZ2h0XSk7XG4gICAgfVxuICAgIFskZXZhbHVhdGVdKCkge1xuICAgICAgICBjb25zdCBsZWZ0Tm9kZSA9IG5vcm1hbGl6ZVVuaXQoRXZhbHVhdG9yLmV2YWx1YXRlKHRoaXNbJGxlZnRdKSk7XG4gICAgICAgIGNvbnN0IHJpZ2h0Tm9kZSA9IG5vcm1hbGl6ZVVuaXQoRXZhbHVhdG9yLmV2YWx1YXRlKHRoaXNbJHJpZ2h0XSkpO1xuICAgICAgICBjb25zdCB7IG51bWJlcjogbGVmdFZhbHVlLCB1bml0OiBsZWZ0VW5pdCB9ID0gbGVmdE5vZGU7XG4gICAgICAgIGNvbnN0IHsgbnVtYmVyOiByaWdodFZhbHVlLCB1bml0OiByaWdodFVuaXQgfSA9IHJpZ2h0Tm9kZTtcbiAgICAgICAgLy8gRGlzYWxsb3cgb3BlcmF0aW9ucyBmb3IgbWlzbWF0Y2hlZCBub3JtYWxpemVkIHVuaXRzIGUuZy4sIG0gYW5kIHJhZDpcbiAgICAgICAgaWYgKHJpZ2h0VW5pdCAhPSBudWxsICYmIGxlZnRVbml0ICE9IG51bGwgJiYgcmlnaHRVbml0ICE9IGxlZnRVbml0KSB7XG4gICAgICAgICAgICByZXR1cm4gWkVSTztcbiAgICAgICAgfVxuICAgICAgICAvLyBOT1RFKGNkYXRhKTogcnVsZXMgZm9yIGNhbGMgdHlwZSBjaGVja2luZyBhcmUgZGVmaW5lZCBoZXJlXG4gICAgICAgIC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3MtdmFsdWVzLTMvI2NhbGMtdHlwZS1jaGVja2luZ1xuICAgICAgICAvLyBUaGlzIGlzIGEgc2ltcGxpZmljYXRpb24gYW5kIG1heSBub3QgaG9sZCB1cCBvbmNlIHdlIGJlZ2luIHRvIHN1cHBvcnRcbiAgICAgICAgLy8gYWRkaXRpb25hbCB1bml0IHR5cGVzOlxuICAgICAgICBjb25zdCB1bml0ID0gbGVmdFVuaXQgfHwgcmlnaHRVbml0O1xuICAgICAgICBsZXQgdmFsdWU7XG4gICAgICAgIHN3aXRjaCAodGhpc1skb3BlcmF0b3JdLnZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGxlZnRWYWx1ZSArIHJpZ2h0VmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGxlZnRWYWx1ZSAtIHJpZ2h0VmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICcvJzpcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGxlZnRWYWx1ZSAvIHJpZ2h0VmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICcqJzpcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGxlZnRWYWx1ZSAqIHJpZ2h0VmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBaRVJPO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHR5cGU6ICdudW1iZXInLCBudW1iZXI6IHZhbHVlLCB1bml0IH07XG4gICAgfVxufVxuY29uc3QgJGV2YWx1YXRhYmxlcyA9IFN5bWJvbCgnZXZhbHVhdGFibGVzJyk7XG5jb25zdCAkaW50cmluc2ljcyA9IFN5bWJvbCgnaW50cmluc2ljcycpO1xuLyoqXG4gKiBBIFZlY3RvckV2YWx1YXRvciBldmFsdWF0ZXMgYSBzZXJpZXMgb2YgbnVtZXJpYyB0ZXJtcyB0aGF0IHVzdWFsbHkgcmVwcmVzZW50XG4gKiBhIGRhdGEgc3RydWN0dXJlIHN1Y2ggYXMgYSBtdWx0aS1kaW1lbnNpb25hbCB2ZWN0b3Igb3IgYSBzcGhlcmljYWxcbiAqXG4gKiBUaGUgZm9ybSBvZiB0aGUgZXZhbHVhdG9yJ3MgcmVzdWx0IGlzIGRldGVybWluZWQgYnkgdGhlIEludHJpbnNpY3MgdGhhdCBhcmVcbiAqIGdpdmVuIHRvIGl0IHdoZW4gaXQgaXMgY29uc3RydWN0ZWQuIEZvciBleGFtcGxlLCBzcGhlcmljYWwgaW50cmluc2ljcyB3b3VsZFxuICogZXN0YWJsaXNoIHR3byBhbmdsZSB0ZXJtcyBhbmQgYSBsZW5ndGggdGVybSwgc28gdGhlIHJlc3VsdCBvZiBldmFsdWF0aW5nIHRoZVxuICogZXZhbHVhdG9yIHRoYXQgaXMgY29uZmlndXJlZCB3aXRoIHNwaGVyaWNhbCBpbnRyaW5zaWNzIGlzIGEgdGhyZWUgZWxlbWVudFxuICogYXJyYXkgd2hlcmUgdGhlIGZpcnN0IHR3byBlbGVtZW50cyByZXByZXNlbnQgYW5nbGVzIGluIHJhZGlhbnMgYW5kIHRoZSB0aGlyZFxuICogZWxlbWVudCByZXByZXNlbnRpbmcgYSBsZW5ndGggaW4gbWV0ZXJzLlxuICovXG5leHBvcnQgY2xhc3MgU3R5bGVFdmFsdWF0b3IgZXh0ZW5kcyBFdmFsdWF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGV4cHJlc3Npb25zLCBpbnRyaW5zaWNzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXNbJGludHJpbnNpY3NdID0gaW50cmluc2ljcztcbiAgICAgICAgY29uc3QgZmlyc3RFeHByZXNzaW9uID0gZXhwcmVzc2lvbnNbMF07XG4gICAgICAgIGNvbnN0IHRlcm1zID0gZmlyc3RFeHByZXNzaW9uICE9IG51bGwgPyBmaXJzdEV4cHJlc3Npb24udGVybXMgOiBbXTtcbiAgICAgICAgdGhpc1skZXZhbHVhdGFibGVzXSA9XG4gICAgICAgICAgICBpbnRyaW5zaWNzLmJhc2lzLm1hcCgoYmFzaXNOb2RlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlcm0gPSB0ZXJtc1tpbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKHRlcm0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiAnaWRlbnQnLCB2YWx1ZTogJ2F1dG8nIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0ZXJtLnR5cGUgPT09ICdpZGVudCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRlcm07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBFdmFsdWF0b3IuZXZhbHVhdGFibGVGb3IodGVybSwgYmFzaXNOb2RlKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgaXNDb25zdGFudCgpIHtcbiAgICAgICAgZm9yIChjb25zdCBldmFsdWF0YWJsZSBvZiB0aGlzWyRldmFsdWF0YWJsZXNdKSB7XG4gICAgICAgICAgICBpZiAoIUV2YWx1YXRvci5pc0NvbnN0YW50KGV2YWx1YXRhYmxlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgWyRldmFsdWF0ZV0oKSB7XG4gICAgICAgIGNvbnN0IGV2YWx1YXRlZCA9IHRoaXNbJGV2YWx1YXRhYmxlc10ubWFwKGV2YWx1YXRhYmxlID0+IEV2YWx1YXRvci5ldmFsdWF0ZShldmFsdWF0YWJsZSkpO1xuICAgICAgICByZXR1cm4gRXZhbHVhdG9yLmFwcGx5SW50cmluc2ljcyhldmFsdWF0ZWQsIHRoaXNbJGludHJpbnNpY3NdKVxuICAgICAgICAgICAgLm1hcChudW1iZXJOb2RlID0+IG51bWJlck5vZGUubnVtYmVyKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ldmFsdWF0b3JzLmpzLm1hcCIsIi8qIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICdMaWNlbnNlJyk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gJ0FTIElTJyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmV4cG9ydCBjb25zdCBudW1iZXJOb2RlID0gKHZhbHVlLCB1bml0KSA9PiAoeyB0eXBlOiAnbnVtYmVyJywgbnVtYmVyOiB2YWx1ZSwgdW5pdCB9KTtcbi8qKlxuICogR2l2ZW4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgY29tbWEtc2VwYXJhdGVkIHNldCBvZiBDU1MtbGlrZSBleHByZXNzaW9ucyxcbiAqIHBhcnNlcyBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiBBU1RzIHRoYXQgY29ycmVzcG9uZCB0byB0aG9zZSBleHByZXNzaW9ucy5cbiAqXG4gKiBDdXJyZW50bHkgc3VwcG9ydGVkIHN5bnRheCBpbmNsdWRlczpcbiAqXG4gKiAgLSBmdW5jdGlvbnMgKHRvcC1sZXZlbCBhbmQgbmVzdGVkKVxuICogIC0gY2FsYygpIGFyaXRobWV0aWMgb3BlcmF0b3JzXG4gKiAgLSBudW1iZXJzIHdpdGggdW5pdHNcbiAqICAtIGhleGFkZWNpbWFsLWVuY29kZWQgY29sb3JzIGluIDMsIDYgb3IgOCBkaWdpdCBmb3JtXG4gKiAgLSBpZGVudHNcbiAqXG4gKiBBbGwgc3ludGF4IGlzIGludGVuZGVkIHRvIG1hdGNoIHRoZSBwYXJzaW5nIHJ1bGVzIGFuZCBzZW1hbnRpY3Mgb2YgdGhlIGFjdHVhbFxuICogQ1NTIHNwZWMgYXMgY2xvc2VseSBhcyBwb3NzaWJsZS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9DU1MyL1xuICogQHNlZSBodHRwczovL3d3dy53My5vcmcvVFIvY3NzLXZhbHVlcy0zL1xuICovXG5leHBvcnQgY29uc3QgcGFyc2VFeHByZXNzaW9ucyA9ICgoKSA9PiB7XG4gICAgY29uc3QgY2FjaGUgPSB7fTtcbiAgICBjb25zdCBNQVhfUEFSU0VfSVRFUkFUSU9OUyA9IDEwMDA7IC8vIEFyYml0cmFyaWx5IGxhcmdlXG4gICAgcmV0dXJuIChpbnB1dFN0cmluZykgPT4ge1xuICAgICAgICBjb25zdCBjYWNoZUtleSA9IGlucHV0U3RyaW5nO1xuICAgICAgICBpZiAoY2FjaGVLZXkgaW4gY2FjaGUpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZVtjYWNoZUtleV07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbnMgPSBbXTtcbiAgICAgICAgbGV0IHBhcnNlSXRlcmF0aW9ucyA9IDA7XG4gICAgICAgIHdoaWxlIChpbnB1dFN0cmluZykge1xuICAgICAgICAgICAgaWYgKCsrcGFyc2VJdGVyYXRpb25zID4gTUFYX1BBUlNFX0lURVJBVElPTlMpIHtcbiAgICAgICAgICAgICAgICAvLyBBdm9pZCBhIHBvdGVudGlhbGx5IGluZmluaXRlIGxvb3AgZHVlIHRvIHR5cG9zOlxuICAgICAgICAgICAgICAgIGlucHV0U3RyaW5nID0gJyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBleHByZXNzaW9uUGFyc2VSZXN1bHQgPSBwYXJzZUV4cHJlc3Npb24oaW5wdXRTdHJpbmcpO1xuICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IGV4cHJlc3Npb25QYXJzZVJlc3VsdC5ub2Rlc1swXTtcbiAgICAgICAgICAgIGlmIChleHByZXNzaW9uID09IG51bGwgfHwgZXhwcmVzc2lvbi50ZXJtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2goZXhwcmVzc2lvbik7XG4gICAgICAgICAgICBpbnB1dFN0cmluZyA9IGV4cHJlc3Npb25QYXJzZVJlc3VsdC5yZW1haW5pbmdJbnB1dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FjaGVbY2FjaGVLZXldID0gZXhwcmVzc2lvbnM7XG4gICAgfTtcbn0pKCk7XG4vKipcbiAqIFBhcnNlIGEgc2luZ2xlIGV4cHJlc3Npb24uIEZvciB0aGUgcHVycG9zZXMgb2Ygb3VyIHN1cHBvcnRlZCBzeW50YXgsIGFuXG4gKiBleHByZXNzaW9uIGlzIHRoZSBzZXQgb2Ygc2VtYW50aWNhbGx5IG1lYW5pbmdmdWwgdGVybXMgdGhhdCBhcHBlYXIgYmVmb3JlIHRoZVxuICogbmV4dCBjb21tYSwgb3IgYmV0d2VlbiB0aGUgcGFyZW5zIG9mIGEgZnVuY3Rpb24gaW52b2NhdGlvbi5cbiAqL1xuY29uc3QgcGFyc2VFeHByZXNzaW9uID0gKCgpID0+IHtcbiAgICBjb25zdCBJU19JREVOVF9SRSA9IC9eKFxcLVxcLXxbYS16XFx1MDI0MC1cXHVmZmZmXSkvaTtcbiAgICBjb25zdCBJU19PUEVSQVRPUl9SRSA9IC9eKFtcXCpcXCtcXC9dfFtcXC1dXFxzKS9pO1xuICAgIGNvbnN0IElTX0VYUFJFU1NJT05fRU5EX1JFID0gL15bXFwpLF0vO1xuICAgIGNvbnN0IEZVTkNUSU9OX0FSR1VNRU5UU19GSVJTVF9UT0tFTiA9ICcoJztcbiAgICBjb25zdCBIRVhfRklSU1RfVE9LRU4gPSAnIyc7XG4gICAgcmV0dXJuIChpbnB1dFN0cmluZykgPT4ge1xuICAgICAgICBjb25zdCB0ZXJtcyA9IFtdO1xuICAgICAgICB3aGlsZSAoaW5wdXRTdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICBpbnB1dFN0cmluZyA9IGlucHV0U3RyaW5nLnRyaW0oKTtcbiAgICAgICAgICAgIGlmIChJU19FWFBSRVNTSU9OX0VORF9SRS50ZXN0KGlucHV0U3RyaW5nKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW5wdXRTdHJpbmdbMF0gPT09IEZVTkNUSU9OX0FSR1VNRU5UU19GSVJTVF9UT0tFTikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbm9kZXMsIHJlbWFpbmluZ0lucHV0IH0gPSBwYXJzZUZ1bmN0aW9uQXJndW1lbnRzKGlucHV0U3RyaW5nKTtcbiAgICAgICAgICAgICAgICBpbnB1dFN0cmluZyA9IHJlbWFpbmluZ0lucHV0O1xuICAgICAgICAgICAgICAgIHRlcm1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiB7IHR5cGU6ICdpZGVudCcsIHZhbHVlOiAnY2FsYycgfSxcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBub2Rlc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoSVNfSURFTlRfUkUudGVzdChpbnB1dFN0cmluZykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpZGVudFBhcnNlUmVzdWx0ID0gcGFyc2VJZGVudChpbnB1dFN0cmluZyk7XG4gICAgICAgICAgICAgICAgY29uc3QgaWRlbnROb2RlID0gaWRlbnRQYXJzZVJlc3VsdC5ub2Rlc1swXTtcbiAgICAgICAgICAgICAgICBpbnB1dFN0cmluZyA9IGlkZW50UGFyc2VSZXN1bHQucmVtYWluaW5nSW5wdXQ7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0U3RyaW5nWzBdID09PSBGVU5DVElPTl9BUkdVTUVOVFNfRklSU1RfVE9LRU4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBub2RlcywgcmVtYWluaW5nSW5wdXQgfSA9IHBhcnNlRnVuY3Rpb25Bcmd1bWVudHMoaW5wdXRTdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICB0ZXJtcy5wdXNoKHsgdHlwZTogJ2Z1bmN0aW9uJywgbmFtZTogaWRlbnROb2RlLCBhcmd1bWVudHM6IG5vZGVzIH0pO1xuICAgICAgICAgICAgICAgICAgICBpbnB1dFN0cmluZyA9IHJlbWFpbmluZ0lucHV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGVybXMucHVzaChpZGVudE5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKElTX09QRVJBVE9SX1JFLnRlc3QoaW5wdXRTdHJpbmcpKSB7XG4gICAgICAgICAgICAgICAgLy8gT3BlcmF0b3JzIGFyZSBhbHdheXMgYSBzaW5nbGUgY2hhcmFjdGVyLCBzbyBqdXN0IHBsdWNrIHRoZW0gb3V0OlxuICAgICAgICAgICAgICAgIHRlcm1zLnB1c2goeyB0eXBlOiAnb3BlcmF0b3InLCB2YWx1ZTogaW5wdXRTdHJpbmdbMF0gfSk7XG4gICAgICAgICAgICAgICAgaW5wdXRTdHJpbmcgPSBpbnB1dFN0cmluZy5zbGljZSgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbm9kZXMsIHJlbWFpbmluZ0lucHV0IH0gPSBpbnB1dFN0cmluZ1swXSA9PT0gSEVYX0ZJUlNUX1RPS0VOID9cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VIZXgoaW5wdXRTdHJpbmcpIDpcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VOdW1iZXIoaW5wdXRTdHJpbmcpO1xuICAgICAgICAgICAgICAgIC8vIFRoZSByZW1haW5pbmcgc3RyaW5nIG1heSBub3QgaGF2ZSBoYWQgYW55IG1lYW5pbmdmdWwgY29udGVudC4gRXhpdFxuICAgICAgICAgICAgICAgIC8vIGVhcmx5IGlmIHRoaXMgaXMgdGhlIGNhc2U6XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGVybXMucHVzaChub2Rlc1swXSk7XG4gICAgICAgICAgICAgICAgaW5wdXRTdHJpbmcgPSByZW1haW5pbmdJbnB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBub2RlczogW3sgdHlwZTogJ2V4cHJlc3Npb24nLCB0ZXJtcyB9XSwgcmVtYWluaW5nSW5wdXQ6IGlucHV0U3RyaW5nIH07XG4gICAgfTtcbn0pKCk7XG4vKipcbiAqIEFuIGlkZW50IGlzIHNvbWV0aGluZyBsaWtlIGEgZnVuY3Rpb24gbmFtZSBvciB0aGUga2V5d29yZCBcImF1dG9cIi5cbiAqL1xuY29uc3QgcGFyc2VJZGVudCA9ICgoKSA9PiB7XG4gICAgY29uc3QgTk9UX0lERU5UX1JFID0gL1teYS16MC05X1xcLVxcdTAyNDAtXFx1ZmZmZl0vaTtcbiAgICByZXR1cm4gKGlucHV0U3RyaW5nKSA9PiB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gaW5wdXRTdHJpbmcubWF0Y2goTk9UX0lERU5UX1JFKTtcbiAgICAgICAgY29uc3QgaWRlbnQgPSBtYXRjaCA9PSBudWxsID8gaW5wdXRTdHJpbmcgOiBpbnB1dFN0cmluZy5zdWJzdHIoMCwgbWF0Y2guaW5kZXgpO1xuICAgICAgICBjb25zdCByZW1haW5pbmdJbnB1dCA9IG1hdGNoID09IG51bGwgPyAnJyA6IGlucHV0U3RyaW5nLnN1YnN0cihtYXRjaC5pbmRleCk7XG4gICAgICAgIHJldHVybiB7IG5vZGVzOiBbeyB0eXBlOiAnaWRlbnQnLCB2YWx1ZTogaWRlbnQgfV0sIHJlbWFpbmluZ0lucHV0IH07XG4gICAgfTtcbn0pKCk7XG4vKipcbiAqIFBhcnNlcyBhIG51bWJlci4gQSBudW1iZXIgdmFsdWUgY2FuIGJlIGV4cHJlc3NlZCB3aXRoIGFuIGludGVnZXIgb3JcbiAqIG5vbi1pbnRlZ2VyIHN5bnRheCwgYW5kIHVzdWFsbHkgaW5jbHVkZXMgYSB1bml0IChidXQgZG9lcyBub3Qgc3RyaWN0bHlcbiAqIHJlcXVpcmUgb25lIGZvciBvdXIgcHVycG9zZXMpLlxuICovXG5jb25zdCBwYXJzZU51bWJlciA9ICgoKSA9PiB7XG4gICAgLy8gQHNlZSBodHRwczovL3d3dy53My5vcmcvVFIvY3NzLXN5bnRheC8jbnVtYmVyLXRva2VuLWRpYWdyYW1cbiAgICBjb25zdCBWQUxVRV9SRSA9IC9bXFwrXFwtXT8oXFxkK1tcXC5dXFxkK3xcXGQrfFtcXC5dXFxkKykoW2VFXVtcXCtcXC1dP1xcZCspPy87XG4gICAgY29uc3QgVU5JVF9SRSA9IC9eW2EteiVdKy9pO1xuICAgIGNvbnN0IEFMTE9XRURfVU5JVFMgPSAvXihtfG1tfGNtfHJhZHxkZWd8WyVdKSQvO1xuICAgIHJldHVybiAoaW5wdXRTdHJpbmcpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWVNYXRjaCA9IGlucHV0U3RyaW5nLm1hdGNoKFZBTFVFX1JFKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZU1hdGNoID09IG51bGwgPyAnMCcgOiB2YWx1ZU1hdGNoWzBdO1xuICAgICAgICBpbnB1dFN0cmluZyA9IHZhbHVlID09IG51bGwgPyBpbnB1dFN0cmluZyA6IGlucHV0U3RyaW5nLnNsaWNlKHZhbHVlLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHVuaXRNYXRjaCA9IGlucHV0U3RyaW5nLm1hdGNoKFVOSVRfUkUpO1xuICAgICAgICBsZXQgdW5pdCA9IHVuaXRNYXRjaCAhPSBudWxsICYmIHVuaXRNYXRjaFswXSAhPT0gJycgPyB1bml0TWF0Y2hbMF0gOiBudWxsO1xuICAgICAgICBjb25zdCByZW1haW5pbmdJbnB1dCA9IHVuaXRNYXRjaCA9PSBudWxsID8gaW5wdXRTdHJpbmcgOiBpbnB1dFN0cmluZy5zbGljZSh1bml0Lmxlbmd0aCk7XG4gICAgICAgIGlmICh1bml0ICE9IG51bGwgJiYgIUFMTE9XRURfVU5JVFMudGVzdCh1bml0KSkge1xuICAgICAgICAgICAgdW5pdCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5vZGVzOiBbe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyOiBwYXJzZUZsb2F0KHZhbHVlKSB8fCAwLFxuICAgICAgICAgICAgICAgICAgICB1bml0OiB1bml0XG4gICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICByZW1haW5pbmdJbnB1dFxuICAgICAgICB9O1xuICAgIH07XG59KSgpO1xuLyoqXG4gKiBQYXJzZXMgYSBoZXhhZGVjaW1hbC1lbmNvZGVkIGNvbG9yIGluIDMsIDYgb3IgOCBkaWdpdCBmb3JtLlxuICovXG5jb25zdCBwYXJzZUhleCA9ICgoKSA9PiB7XG4gICAgLy8gVE9ETyhjZGF0YSk6IHJpZ2h0IG5vdyB3ZSBkb24ndCBhY3R1YWxseSBlbmZvcmNlIHRoZSBudW1iZXIgb2YgZGlnaXRzXG4gICAgY29uc3QgSEVYX1JFID0gL15bYS1mMC05XSovaTtcbiAgICByZXR1cm4gKGlucHV0U3RyaW5nKSA9PiB7XG4gICAgICAgIGlucHV0U3RyaW5nID0gaW5wdXRTdHJpbmcuc2xpY2UoMSkudHJpbSgpO1xuICAgICAgICBjb25zdCBoZXhNYXRjaCA9IGlucHV0U3RyaW5nLm1hdGNoKEhFWF9SRSk7XG4gICAgICAgIGNvbnN0IG5vZGVzID0gaGV4TWF0Y2ggPT0gbnVsbCA/IFtdIDogW3sgdHlwZTogJ2hleCcsIHZhbHVlOiBoZXhNYXRjaFswXSB9XTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5vZGVzLFxuICAgICAgICAgICAgcmVtYWluaW5nSW5wdXQ6IGhleE1hdGNoID09IG51bGwgPyBpbnB1dFN0cmluZyA6XG4gICAgICAgICAgICAgICAgaW5wdXRTdHJpbmcuc2xpY2UoaGV4TWF0Y2hbMF0ubGVuZ3RoKVxuICAgICAgICB9O1xuICAgIH07XG59KSgpO1xuLyoqXG4gKiBQYXJzZXMgYXJndW1lbnRzIHBhc3NlZCB0byBhIGZ1bmN0aW9uIGludm9jYXRpb24gKGUuZy4sIHRoZSBleHByZXNzaW9uc1xuICogd2l0aGluIGEgbWF0Y2hlZCBzZXQgb2YgcGFyZW5zKS5cbiAqL1xuY29uc3QgcGFyc2VGdW5jdGlvbkFyZ3VtZW50cyA9IChpbnB1dFN0cmluZykgPT4ge1xuICAgIGNvbnN0IGV4cHJlc3Npb25Ob2RlcyA9IFtdO1xuICAgIC8vIENvbnN1bWUgdGhlIG9wZW5pbmcgcGFyZW5cbiAgICBpbnB1dFN0cmluZyA9IGlucHV0U3RyaW5nLnNsaWNlKDEpLnRyaW0oKTtcbiAgICB3aGlsZSAoaW5wdXRTdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb25QYXJzZVJlc3VsdCA9IHBhcnNlRXhwcmVzc2lvbihpbnB1dFN0cmluZyk7XG4gICAgICAgIGV4cHJlc3Npb25Ob2Rlcy5wdXNoKGV4cHJlc3Npb25QYXJzZVJlc3VsdC5ub2Rlc1swXSk7XG4gICAgICAgIGlucHV0U3RyaW5nID0gZXhwcmVzc2lvblBhcnNlUmVzdWx0LnJlbWFpbmluZ0lucHV0LnRyaW0oKTtcbiAgICAgICAgaWYgKGlucHV0U3RyaW5nWzBdID09PSAnLCcpIHtcbiAgICAgICAgICAgIGlucHV0U3RyaW5nID0gaW5wdXRTdHJpbmcuc2xpY2UoMSkudHJpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlucHV0U3RyaW5nWzBdID09PSAnKScpIHtcbiAgICAgICAgICAgIC8vIENvbnN1bWUgdGhlIGNsb3NpbmcgcGFyZW4gYW5kIHN0b3AgcGFyc2luZ1xuICAgICAgICAgICAgaW5wdXRTdHJpbmcgPSBpbnB1dFN0cmluZy5zbGljZSgxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IG5vZGVzOiBleHByZXNzaW9uTm9kZXMsIHJlbWFpbmluZ0lucHV0OiBpbnB1dFN0cmluZyB9O1xufTtcbmNvbnN0ICR2aXNpdGVkVHlwZXMgPSBTeW1ib2woJ3Zpc2l0ZWRUeXBlcycpO1xuLyoqXG4gKiBBbiBBU1RXYWxrZXIgd2Fsa3MgYW4gYXJyYXkgb2YgQVNUcyBzdWNoIGFzIHRoZSB0eXBlIHByb2R1Y2VkIGJ5XG4gKiBwYXJzZUV4cHJlc3Npb25zIGFuZCBpbnZva2VzIGEgY2FsbGJhY2sgZm9yIGEgY29uZmlndXJlZCBzZXQgb2Ygbm9kZXMgdGhhdFxuICogdGhlIHVzZXIgd2lzaGVzIHRvIFwidmlzaXRcIiBkdXJpbmcgdGhlIHdhbGsuXG4gKi9cbmV4cG9ydCBjbGFzcyBBU1RXYWxrZXIge1xuICAgIGNvbnN0cnVjdG9yKHZpc2l0ZWRUeXBlcykge1xuICAgICAgICB0aGlzWyR2aXNpdGVkVHlwZXNdID0gdmlzaXRlZFR5cGVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXYWxrIHRoZSBnaXZlbiBzZXQgb2YgQVNUcywgYW5kIGludm9rZSB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgZm9yIG5vZGVzIHRoYXRcbiAgICAgKiBtYXRjaCB0aGUgZmlsdGVyZWQgc2V0IHRoYXQgdGhlIEFTVFdhbGtlciB3YXMgY29uc3RydWN0ZWQgd2l0aC5cbiAgICAgKi9cbiAgICB3YWxrKGFzdCwgY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgcmVtYWluaW5nID0gYXN0LnNsaWNlKCk7XG4gICAgICAgIHdoaWxlIChyZW1haW5pbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gcmVtYWluaW5nLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAodGhpc1skdmlzaXRlZFR5cGVzXS5pbmRleE9mKG5leHQudHlwZSkgPiAtMSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5leHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChuZXh0LnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdleHByZXNzaW9uJzpcbiAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nLnVuc2hpZnQoLi4ubmV4dC50ZXJtcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nLnVuc2hpZnQobmV4dC5uYW1lLCAuLi5uZXh0LmFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IFpFUk8gPSBPYmplY3QuZnJlZXplKHsgdHlwZTogJ251bWJlcicsIG51bWJlcjogMCwgdW5pdDogbnVsbCB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnNlcnMuanMubWFwIiwiLyogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgJ0xpY2Vuc2UnKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAnQVMgSVMnIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIF9hLCBfYiwgX2MsIF9kO1xuaW1wb3J0IHsgQVNUV2Fsa2VyIH0gZnJvbSAnLi9wYXJzZXJzJztcbmNvbnN0ICRpbnN0YW5jZXMgPSBTeW1ib2woJ2luc3RhbmNlcycpO1xuY29uc3QgJGFjdGl2YXRlTGlzdGVuZXIgPSBTeW1ib2woJ2FjdGl2YXRlTGlzdGVuZXInKTtcbmNvbnN0ICRkZWFjdGl2YXRlTGlzdGVuZXIgPSBTeW1ib2woJ2RlYWN0aXZhdGVMaXN0ZW5lcicpO1xuY29uc3QgJG5vdGlmeUluc3RhbmNlcyA9IFN5bWJvbCgnbm90aWZ5SW5zdGFuY2VzJyk7XG5jb25zdCAkbm90aWZ5ID0gU3ltYm9sKCdub3RpZnknKTtcbmNvbnN0ICRzY3JvbGxDYWxsYmFjayA9IFN5bWJvbCgnY2FsbGJhY2snKTtcbi8qKlxuICogVGhpcyBpbnRlcm5hbCBoZWxwZXIgaXMgaW50ZW5kZWQgdG8gd29yayBhcyBhIHJlZmVyZW5jZS1jb3VudGluZyBtYW5hZ2VyIG9mXG4gKiBzY3JvbGwgZXZlbnQgbGlzdGVuZXJzLiBPbmx5IG9uZSBzY3JvbGwgbGlzdGVuZXIgaXMgZXZlciByZWdpc3RlcmVkIGZvciBhbGxcbiAqIGluc3RhbmNlcyBvZiB0aGUgY2xhc3MsIGFuZCB3aGVuIHRoZSBsYXN0IFNjcm9sbE9ic2VydmVyIFwiZGlzY29ubmVjdHNcIiwgdGhhdFxuICogZXZlbnQgbGlzdGVuZXIgaXMgcmVtb3ZlZC4gVGhpcyBzcGFyZXMgdXMgZnJvbSB0aHJhc2hpbmdcbiAqIHRoZSB7YWRkLHJlbW92ZX1FdmVudExpc3RlbmVyIEFQSSAodGhlIGJpbmRpbmcgY29zdCBvZiB0aGVzZSBtZXRob2RzIGhhcyBiZWVuXG4gKiBrbm93biB0byBzaG93IHVwIGluIHBlcmZvcm1hbmNlIGFuYWx5c2VzKSBhcyB3ZWxsIGFzIHBvdGVudGlhbCBtZW1vcnkgbGVha3MuXG4gKi9cbmNsYXNzIFNjcm9sbE9ic2VydmVyIHtcbiAgICBjb25zdHJ1Y3RvcihjYWxsYmFjaykge1xuICAgICAgICB0aGlzWyRzY3JvbGxDYWxsYmFja10gPSBjYWxsYmFjaztcbiAgICB9XG4gICAgc3RhdGljIFskbm90aWZ5SW5zdGFuY2VzXSgpIHtcbiAgICAgICAgZm9yIChjb25zdCBpbnN0YW5jZSBvZiBTY3JvbGxPYnNlcnZlclskaW5zdGFuY2VzXSkge1xuICAgICAgICAgICAgaW5zdGFuY2VbJG5vdGlmeV0oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgWyhfYSA9ICRpbnN0YW5jZXMsICRhY3RpdmF0ZUxpc3RlbmVyKV0oKSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzWyRub3RpZnlJbnN0YW5jZXNdLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBbJGRlYWN0aXZhdGVMaXN0ZW5lcl0oKSB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzWyRub3RpZnlJbnN0YW5jZXNdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdGVuIGZvciBzY3JvbGwgZXZlbnRzLiBUaGUgY29uZmlndXJlZCBjYWxsYmFjayAocGFzc2VkIHRvIHRoZVxuICAgICAqIGNvbnN0cnVjdG9yKSB3aWxsIGJlIGludm9rZWQgZm9yIHN1YnNlcXVlbnQgZ2xvYmFsIHNjcm9sbCBldmVudHMuXG4gICAgICovXG4gICAgb2JzZXJ2ZSgpIHtcbiAgICAgICAgaWYgKFNjcm9sbE9ic2VydmVyWyRpbnN0YW5jZXNdLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIFNjcm9sbE9ic2VydmVyWyRhY3RpdmF0ZUxpc3RlbmVyXSgpO1xuICAgICAgICB9XG4gICAgICAgIFNjcm9sbE9ic2VydmVyWyRpbnN0YW5jZXNdLmFkZCh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcCBsaXN0ZW5pbmcgZm9yIHNjcm9sbCBldmVudHMuXG4gICAgICovXG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgU2Nyb2xsT2JzZXJ2ZXJbJGluc3RhbmNlc10uZGVsZXRlKHRoaXMpO1xuICAgICAgICBpZiAoU2Nyb2xsT2JzZXJ2ZXJbJGluc3RhbmNlc10uc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgU2Nyb2xsT2JzZXJ2ZXJbJGRlYWN0aXZhdGVMaXN0ZW5lcl0oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBbJG5vdGlmeV0oKSB7XG4gICAgICAgIHRoaXNbJHNjcm9sbENhbGxiYWNrXSgpO1xuICAgIH1cbiAgICA7XG59XG5TY3JvbGxPYnNlcnZlcltfYV0gPSBuZXcgU2V0KCk7XG5jb25zdCAkY29tcHV0ZVN0eWxlQ2FsbGJhY2sgPSBTeW1ib2woJ2NvbXB1dGVTdHlsZUNhbGxiYWNrJyk7XG5jb25zdCAkYXN0V2Fsa2VyID0gU3ltYm9sKCdhc3RXYWxrZXInKTtcbmNvbnN0ICRkZXBlbmRlbmNpZXMgPSBTeW1ib2woJ2RlcGVuZGVuY2llcycpO1xuY29uc3QgJG9uU2Nyb2xsID0gU3ltYm9sKCdvblNjcm9sbCcpO1xuLyoqXG4gKiBUaGUgU3R5bGVFZmZlY3RvciBpcyBjb25maWd1cmVkIHdpdGggYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgaW52b2tlZCBhdCB0aGVcbiAqIG9wdGltYWwgdGltZSB0aGF0IHNvbWUgYXJyYXkgb2YgQ1NTIGV4cHJlc3Npb24gQVNUcyBvdWdodCB0byBiZSBldmFsdWF0ZWQuXG4gKlxuICogRm9yIGV4YW1wbGUsIG91ciBDU1MtbGlrZSBleHByZXNzaW9uIHN5bnRheCBzdXBwb3J0cyB1c2FnZSBvZiB0aGUgZW52KClcbiAqIGZ1bmN0aW9uIHRvIGluY29ycG9yYXRlIHRoZSBjdXJyZW50IHRvcC1sZXZlbCBzY3JvbGwgcG9zaXRpb24gaW50byBhIENTU1xuICogZXhwcmVzc2lvbjogZW52KHdpbmRvdy1zY3JvbGwteSkuXG4gKlxuICogVGhpcyBcImVudmlyb25tZW50IHZhcmlhYmxlXCIgd2lsbCBjaGFuZ2UgZHluYW1pY2FsbHkgYXMgdGhlIHVzZXIgc2Nyb2xscyB0aGVcbiAqIHBhZ2UuIElmIGFuIEFTVCBjb250YWlucyBzdWNoIGEgdXNhZ2Ugb2YgZW52KCksIHdlIHdvdWxkIGhhdmUgdG8gZXZhbHVhdGUgdGhlXG4gKiBBU1Qgb24gZXZlcnkgZnJhbWUgaW4gb3JkZXIgdG8gYmUgc3VyZSB0aGF0IHRoZSBjb21wdXRlZCBzdHlsZSBzdGF5cyB1cCB0b1xuICogZGF0ZS5cbiAqXG4gKiBUaGUgU3R5bGVFZmZlY3RvciBzcGFyZXMgdXMgZnJvbSBldmFsdWF0aW5nIHRoZSBleHByZXNzaW9ucyBvbiBldmVyeSBmcmFtZSBieVxuICogY29ycmVsYXRpbmcgc3BlY2lmaWMgcGFydHMgb2YgYW4gQVNUIHdpdGggb2JzZXJ2ZXJzIG9mIHRoZSBleHRlcm5hbCBlZmZlY3RzXG4gKiB0aGF0IHRoZXkgcmVmZXIgdG8gKGlmIGFueSkuIFNvLCBpZiB0aGUgQVNUIGNvbnRhaW5zIGVudih3aW5kb3ctc2Nyb2xsLXkpLFxuICogdGhlIFN0eWxlRWZmZWN0b3IgbWFuYWdlcyB0aGUgbGlmZXRpbWUgb2YgYSBnbG9iYWwgc2Nyb2xsIGV2ZW50IGxpc3RlbmVyIGFuZFxuICogbm90aWZpZXMgdGhlIHVzZXIgYXQgdGhlIG9wdGltYWwgdGltZSB0byBldmFsdWF0ZSB0aGUgY29tcHV0ZWQgc3R5bGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBTdHlsZUVmZmVjdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihjYWxsYmFjaykge1xuICAgICAgICB0aGlzW19iXSA9IHt9O1xuICAgICAgICB0aGlzW19jXSA9IG5ldyBBU1RXYWxrZXIoWydmdW5jdGlvbiddKTtcbiAgICAgICAgdGhpc1tfZF0gPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzWyRjb21wdXRlU3R5bGVDYWxsYmFja10oeyByZWxhdGVkU3RhdGU6ICd3aW5kb3ctc2Nyb2xsJyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpc1skY29tcHV0ZVN0eWxlQ2FsbGJhY2tdID0gY2FsbGJhY2s7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGV4cHJlc3Npb25zIHRoYXQgZ292ZXJuIHdoZW4gdGhlIFN0eWxlRWZmZWN0b3IgY2FsbGJhY2sgd2lsbCBiZVxuICAgICAqIGludm9rZWQuXG4gICAgICovXG4gICAgb2JzZXJ2ZUVmZmVjdHNGb3IoYXN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RlcGVuZGVuY2llcyA9IHt9O1xuICAgICAgICBjb25zdCBvbGREZXBlbmRlbmNpZXMgPSB0aGlzWyRkZXBlbmRlbmNpZXNdO1xuICAgICAgICB0aGlzWyRhc3RXYWxrZXJdLndhbGsoYXN0LCBmdW5jdGlvbk5vZGUgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBuYW1lIH0gPSBmdW5jdGlvbk5vZGU7XG4gICAgICAgICAgICBjb25zdCBmaXJzdEFyZ3VtZW50ID0gZnVuY3Rpb25Ob2RlLmFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0VGVybSA9IGZpcnN0QXJndW1lbnQudGVybXNbMF07XG4gICAgICAgICAgICBpZiAobmFtZS52YWx1ZSAhPT0gJ2VudicgfHwgZmlyc3RUZXJtID09IG51bGwgfHxcbiAgICAgICAgICAgICAgICBmaXJzdFRlcm0udHlwZSAhPT0gJ2lkZW50Jykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAoZmlyc3RUZXJtLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnd2luZG93LXNjcm9sbC15JzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0RlcGVuZGVuY2llc1snd2luZG93LXNjcm9sbCddID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9ic2VydmVyID0gJ3dpbmRvdy1zY3JvbGwnIGluIG9sZERlcGVuZGVuY2llcyA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkRGVwZW5kZW5jaWVzWyd3aW5kb3ctc2Nyb2xsJ10gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBTY3JvbGxPYnNlcnZlcih0aGlzWyRvblNjcm9sbF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9sZERlcGVuZGVuY2llc1snd2luZG93LXNjcm9sbCddO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RGVwZW5kZW5jaWVzWyd3aW5kb3ctc2Nyb2xsJ10gPSBvYnNlcnZlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAoY29uc3QgZW52aXJvbm1lbnRTdGF0ZSBpbiBvbGREZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IG9ic2VydmVyID0gb2xkRGVwZW5kZW5jaWVzW2Vudmlyb25tZW50U3RhdGVdO1xuICAgICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbJGRlcGVuZGVuY2llc10gPSBuZXdEZXBlbmRlbmNpZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc3Bvc2VzIG9mIHRoZSBTdHlsZUVmZmVjdG9yIGJ5IGRpc2Nvbm5lY3RpbmcgYWxsIG9ic2VydmVycyBvZiBleHRlcm5hbFxuICAgICAqIGVmZmVjdHMuXG4gICAgICovXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbnZpcm9ubWVudFN0YXRlIGluIHRoaXNbJGRlcGVuZGVuY2llc10pIHtcbiAgICAgICAgICAgIGNvbnN0IG9ic2VydmVyID0gdGhpc1skZGVwZW5kZW5jaWVzXVtlbnZpcm9ubWVudFN0YXRlXTtcbiAgICAgICAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbl9iID0gJGRlcGVuZGVuY2llcywgX2MgPSAkYXN0V2Fsa2VyLCBfZCA9ICRvblNjcm9sbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0eWxlLWVmZmVjdG9yLmpzLm1hcCIsIi8qIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICdMaWNlbnNlJyk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gJ0FTIElTJyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IGh0bWwsIHJlbmRlciB9IGZyb20gJ2xpdCc7XG5pbXBvcnQgQ2xvc2VJY29uIGZyb20gJy4vYXNzZXRzL2Nsb3NlLW1hdGVyaWFsLXN2Zy5qcyc7XG5pbXBvcnQgQ29udHJvbHNQcm9tcHQgZnJvbSAnLi9hc3NldHMvY29udHJvbHMtc3ZnLmpzJztcbmltcG9ydCBBUkdseXBoIGZyb20gJy4vYXNzZXRzL3ZpZXctaW4tYXItbWF0ZXJpYWwtc3ZnLmpzJztcbmNvbnN0IHRlbXBsYXRlUmVzdWx0ID0gaHRtbCBgXG48c3R5bGU+XG46aG9zdCB7XG4gIGRpc3BsYXk6IGJsb2NrO1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gIGNvbnRhaW46IHN0cmljdDtcbiAgd2lkdGg6IDMwMHB4O1xuICBoZWlnaHQ6IDE1MHB4O1xufVxuXG4uY29udGFpbmVyIHtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICBvdmVyZmxvdzogaGlkZGVuO1xufVxuXG4udXNlcklucHV0IHtcbiAgd2lkdGg6IDEwMCU7XG4gIGhlaWdodDogMTAwJTtcbiAgZGlzcGxheTogbm9uZTtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICBvdXRsaW5lLW9mZnNldDogLTFweDtcbiAgb3V0bGluZS13aWR0aDogMXB4O1xufVxuXG5jYW52YXMge1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIGRpc3BsYXk6IG5vbmU7XG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAvKiBOT1RFKGNkYXRhKTogQ2hyb21lIDc2IGFuZCBiZWxvdyBhcHBhcmVudGx5IGhhdmUgYSBidWdcbiAgICogdGhhdCBjYXVzZXMgb3VyIGNhbnZhcyBub3QgdG8gZGlzcGxheSBwaXhlbHMgdW5sZXNzIGl0IGlzXG4gICAqIG9uIGl0cyBvd24gcmVuZGVyIGxheWVyXG4gICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9tb2RlbC12aWV3ZXIvcHVsbC83NTUjaXNzdWVjb21tZW50LTUzNjU5Nzg5M1xuICAgKi9cbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGVaKDApO1xufVxuXG4uc2hvdyB7XG4gIGRpc3BsYXk6IGJsb2NrO1xufVxuXG4vKiBBZGFwdGVkIGZyb20gSFRNTDUgQm9pbGVycGxhdGVcbiAqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9oNWJwL2h0bWw1LWJvaWxlcnBsYXRlL2Jsb2IvY2ViNDYyMGM3OGZjODJlMTM1MzRmYzQ0MjAyYTNmMTY4NzU0ODczZi9kaXN0L2Nzcy9tYWluLmNzcyNMMTIyLUwxMzMgKi9cbi5zY3JlZW4tcmVhZGVyLW9ubHkge1xuICBib3JkZXI6IDA7XG4gIGxlZnQ6IDA7XG4gIHRvcDogMDtcbiAgY2xpcDogcmVjdCgwLCAwLCAwLCAwKTtcbiAgaGVpZ2h0OiAxcHg7XG4gIG1hcmdpbjogLTFweDtcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgcGFkZGluZzogMDtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xuICB3aWR0aDogMXB4O1xuICBwb2ludGVyLWV2ZW50czogbm9uZTtcbn1cblxuLnNsb3Qge1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICB0b3A6IDA7XG4gIGxlZnQ6IDA7XG4gIHdpZHRoOiAxMDAlO1xuICBoZWlnaHQ6IDEwMCU7XG59XG5cbi5zbG90ID4gKiB7XG4gIHBvaW50ZXItZXZlbnRzOiBpbml0aWFsO1xufVxuXG4uYW5ub3RhdGlvbi13cmFwcGVyIDo6c2xvdHRlZCgqKSB7XG4gIG9wYWNpdHk6IHZhcigtLW1heC1ob3RzcG90LW9wYWNpdHksIDEpO1xuICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuM3M7XG59XG5cbi5wb2ludGVyLXR1bWJsaW5nIC5hbm5vdGF0aW9uLXdyYXBwZXIgOjpzbG90dGVkKCopIHtcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG59XG5cbi5hbm5vdGF0aW9uLXdyYXBwZXIgOjpzbG90dGVkKCopIHtcbiAgcG9pbnRlci1ldmVudHM6IGluaXRpYWw7XG59XG5cbi5hbm5vdGF0aW9uLXdyYXBwZXIuaGlkZSA6OnNsb3R0ZWQoKikge1xuICBvcGFjaXR5OiB2YXIoLS1taW4taG90c3BvdC1vcGFjaXR5LCAwLjI1KTtcbn1cblxuLnNsb3QucG9zdGVyIHtcbiAgZGlzcGxheTogbm9uZTtcbiAgYmFja2dyb3VuZC1jb2xvcjogaW5oZXJpdDtcbn1cblxuLnNsb3QucG9zdGVyLnNob3cge1xuICBkaXNwbGF5OiBpbmhlcml0O1xufVxuXG4uc2xvdC5wb3N0ZXIgPiAqIHtcbiAgcG9pbnRlci1ldmVudHM6IGluaXRpYWw7XG59XG5cbi5zbG90LnBvc3Rlcjpub3QoLnNob3cpID4gKiB7XG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xufVxuXG4jZGVmYXVsdC1wb3N0ZXIge1xuICB3aWR0aDogMTAwJTtcbiAgaGVpZ2h0OiAxMDAlO1xuICAvKiBUaGUgZGVmYXVsdCBwb3N0ZXIgaXMgYSA8YnV0dG9uPiBzbyB3ZSBuZWVkIHRvIHNldCBkaXNwbGF5XG4gICAqIHRvIHByZXZlbnQgaXQgZnJvbSBiZWluZyBhZmZlY3RlZCBieSB0ZXh0LWFsaWduOiAqL1xuICBkaXNwbGF5OiBibG9jaztcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICBib3JkZXI6IG5vbmU7XG4gIHBhZGRpbmc6IDA7XG4gIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcbiAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcbiAgYmFja2dyb3VuZC1wb3NpdGlvbjogY2VudGVyO1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmMDtcbn1cblxuI2RlZmF1bHQtcHJvZ3Jlc3MtYmFyIHtcbiAgZGlzcGxheTogYmxvY2s7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgd2lkdGg6IDEwMCU7XG4gIGhlaWdodDogMTAwJTtcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gIG92ZXJmbG93OiBoaWRkZW47XG59XG5cbiNkZWZhdWx0LXByb2dyZXNzLWJhciA+IC5iYXIge1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHRvcDogMDtcbiAgbGVmdDogMDtcbiAgd2lkdGg6IDEwMCU7XG4gIGhlaWdodDogdmFyKC0tcHJvZ3Jlc3MtYmFyLWhlaWdodCwgNXB4KTtcbiAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tcHJvZ3Jlc3MtYmFyLWNvbG9yLCByZ2JhKDAsIDAsIDAsIDAuNCkpO1xuICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC4wOXM7XG4gIHRyYW5zZm9ybS1vcmlnaW46IHRvcCBsZWZ0O1xuICB0cmFuc2Zvcm06IHNjYWxlWCgwKTtcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcbn1cblxuI2RlZmF1bHQtcHJvZ3Jlc3MtYmFyID4gLmJhci5oaWRlIHtcbiAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjNzIDFzO1xuICBvcGFjaXR5OiAwO1xufVxuXG4uY2VudGVyZWQge1xuICBhbGlnbi1pdGVtczogY2VudGVyO1xuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbn1cblxuLmNvdmVyIHtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB0b3A6IDA7XG4gIGxlZnQ6IDA7XG4gIHdpZHRoOiAxMDAlO1xuICBoZWlnaHQ6IDEwMCU7XG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xufVxuXG4uc2xvdC5pbnRlcmFjdGlvbi1wcm9tcHQge1xuICBkaXNwbGF5OiB2YXIoLS1pbnRlcmFjdGlvbi1wcm9tcHQtZGlzcGxheSwgZmxleCk7XG4gIG92ZXJmbG93OiBoaWRkZW47XG4gIG9wYWNpdHk6IDA7XG4gIHdpbGwtY2hhbmdlOiBvcGFjaXR5O1xuICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuM3M7XG59XG5cbi5zbG90LmludGVyYWN0aW9uLXByb21wdC52aXNpYmxlIHtcbiAgb3BhY2l0eTogMTtcbn1cblxuLmFuaW1hdGVkLWNvbnRhaW5lciB7XG4gIHdpbGwtY2hhbmdlOiB0cmFuc2Zvcm0sIG9wYWNpdHk7XG4gIG9wYWNpdHk6IDA7XG4gIHRyYW5zaXRpb246IG9wYWNpdHkgMC4zcztcbn1cblxuLnNsb3QuaW50ZXJhY3Rpb24tcHJvbXB0ID4gKiB7XG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xufVxuXG4uc2xvdC5hci1idXR0b24ge1xuICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xuICAtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHRyYW5zcGFyZW50O1xuICB1c2VyLXNlbGVjdDogbm9uZTtcblxuICBkaXNwbGF5OiB2YXIoLS1hci1idXR0b24tZGlzcGxheSwgYmxvY2spO1xufVxuXG4uc2xvdC5hci1idXR0b246bm90KC5lbmFibGVkKSB7XG4gIGRpc3BsYXk6IG5vbmU7XG59XG5cbi5mYWIge1xuICBkaXNwbGF5OiBmbGV4O1xuICBhbGlnbi1pdGVtczogY2VudGVyO1xuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgd2lkdGg6IDQwcHg7XG4gIGhlaWdodDogNDBweDtcbiAgY3Vyc29yOiBwb2ludGVyO1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xuICBib3gtc2hhZG93OiAwcHggMHB4IDRweCByZ2JhKDAsIDAsIDAsIDAuMTUpO1xuICBib3JkZXItcmFkaXVzOiAxMDBweDtcbn1cblxuLmZhYiA+ICoge1xuICBvcGFjaXR5OiAwLjg3O1xufVxuXG4jZGVmYXVsdC1hci1idXR0b24ge1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIGJvdHRvbTogMTZweDtcbiAgcmlnaHQ6IDE2cHg7XG4gIHRyYW5zZm9ybTogc2NhbGUodmFyKC0tYXItYnV0dG9uLXNjYWxlLCAxKSk7XG4gIHRyYW5zZm9ybS1vcmlnaW46IGJvdHRvbSByaWdodDtcbn1cblxuLnNsb3QucGFuLXRhcmdldCB7XG4gIGRpc3BsYXk6IGJsb2NrO1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHdpZHRoOiAwO1xuICBoZWlnaHQ6IDA7XG4gIGxlZnQ6IDUwJTtcbiAgdG9wOiA1MCU7XG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoLTUwJSwgLTUwJSwgMCk7XG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuICBvcGFjaXR5OiAwO1xuICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuM3M7XG59XG5cbiNkZWZhdWx0LXBhbi10YXJnZXQge1xuICB3aWR0aDogNnB4O1xuICBoZWlnaHQ6IDZweDtcbiAgYm9yZGVyLXJhZGl1czogNnB4O1xuICBib3JkZXI6IDFweCBzb2xpZCB3aGl0ZTtcbiAgYm94LXNoYWRvdzogMHB4IDBweCAycHggMXB4IHJnYmEoMCwgMCwgMCwgMC44KTtcbn1cblxuLnNsb3QuZGVmYXVsdCB7XG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xufVxuXG4uc2xvdC5wcm9ncmVzcy1iYXIge1xuICBwb2ludGVyLWV2ZW50czogbm9uZTtcbn1cblxuLnNsb3QuZXhpdC13ZWJ4ci1hci1idXR0b24ge1xuICBwb2ludGVyLWV2ZW50czogbm9uZTtcbn1cblxuLnNsb3QuZXhpdC13ZWJ4ci1hci1idXR0b246bm90KC5lbmFibGVkKSB7XG4gIGRpc3BsYXk6IG5vbmU7XG59XG5cbiNkZWZhdWx0LWV4aXQtd2VieHItYXItYnV0dG9uIHtcbiAgZGlzcGxheTogZmxleDtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgdG9wOiBlbnYoc2FmZS1hcmVhLWluc2V0LXRvcCwgMTZweCk7XG4gIHJpZ2h0OiAxNnB4O1xuICB3aWR0aDogNDBweDtcbiAgaGVpZ2h0OiA0MHB4O1xuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xufVxuXG4jZGVmYXVsdC1leGl0LXdlYnhyLWFyLWJ1dHRvbiA+IHN2ZyB7XG4gIGZpbGw6ICNmZmY7XG59XG48L3N0eWxlPlxuPGRpdiBjbGFzcz1cImNvbnRhaW5lclwiPlxuICA8ZGl2IGNsYXNzPVwidXNlcklucHV0XCIgdGFiaW5kZXg9XCIwXCIgcm9sZT1cImltZ1wiXG4gICAgICBhcmlhLWxhYmVsPVwiM0QgbW9kZWxcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJzbG90IGNhbnZhc1wiPlxuICAgICAgICA8c2xvdCBuYW1lPVwiY2FudmFzXCI+XG4gICAgICAgICAgPGNhbnZhcz48L2NhbnZhcz5cbiAgICAgICAgPC9zbG90PlxuICAgICAgPC9kaXY+XG5cbiAgPC9kaXY+XG5cbiAgPCEtLSBOT1RFKGNkYXRhKTogV2UgbmVlZCB0byB3cmFwIHNsb3RzIGJlY2F1c2UgYnJvd3NlcnMgd2l0aG91dCBTaGFkb3dET01cbiAgICAgICAgd2lsbCBoYXZlIHRoZWlyIDxzbG90PiBlbGVtZW50cyByZW1vdmVkIGJ5IFNoYWR5Q1NTIC0tPlxuICA8ZGl2IGNsYXNzPVwic2xvdCBwb3N0ZXJcIj5cbiAgICA8c2xvdCBuYW1lPVwicG9zdGVyXCI+XG4gICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBpZD1cImRlZmF1bHQtcG9zdGVyXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCIgYXJpYS1sYWJlbD1cIkxvYWRpbmcgM0QgbW9kZWxcIj48L2J1dHRvbj5cbiAgICA8L3Nsb3Q+XG4gIDwvZGl2PlxuXG4gIDxkaXYgY2xhc3M9XCJzbG90IGFyLWJ1dHRvblwiPlxuICAgIDxzbG90IG5hbWU9XCJhci1idXR0b25cIj5cbiAgICAgIDxhIGlkPVwiZGVmYXVsdC1hci1idXR0b25cIiBwYXJ0PVwiZGVmYXVsdC1hci1idXR0b25cIiBjbGFzcz1cImZhYlwiXG4gICAgICAgICAgdGFiaW5kZXg9XCIyXCJcbiAgICAgICAgICBhcmlhLWxhYmVsPVwiVmlldyBpbiB5b3VyIHNwYWNlXCI+XG4gICAgICAgICR7QVJHbHlwaH1cbiAgICAgIDwvYT5cbiAgICA8L3Nsb3Q+XG4gIDwvZGl2PlxuXG4gIDxkaXYgY2xhc3M9XCJzbG90IHBhbi10YXJnZXRcIj5cbiAgICA8c2xvdCBuYW1lPVwicGFuLXRhcmdldFwiPlxuICAgICAgPGRpdiBpZD1cImRlZmF1bHQtcGFuLXRhcmdldFwiPlxuICAgICAgPC9kaXY+XG4gICAgPC9zbG90PlxuICA8L2Rpdj5cblxuICA8ZGl2IGNsYXNzPVwic2xvdCBpbnRlcmFjdGlvbi1wcm9tcHQgY292ZXIgY2VudGVyZWRcIj5cbiAgICA8ZGl2IGlkPVwicHJvbXB0XCIgY2xhc3M9XCJhbmltYXRlZC1jb250YWluZXJcIj5cbiAgICAgIDxzbG90IG5hbWU9XCJpbnRlcmFjdGlvbi1wcm9tcHRcIiBhcmlhLWhpZGRlbj1cInRydWVcIj5cbiAgICAgICAgJHtDb250cm9sc1Byb21wdH1cbiAgICAgIDwvc2xvdD5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG5cbiAgPGRpdiBpZD1cImZpbmdlcjBcIiBjbGFzcz1cImFuaW1hdGVkLWNvbnRhaW5lciBjb3ZlclwiPlxuICAgIDxzbG90IG5hbWU9XCJmaW5nZXIwXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+XG4gICAgPC9zbG90PlxuICA8L2Rpdj5cbiAgPGRpdiBpZD1cImZpbmdlcjFcIiBjbGFzcz1cImFuaW1hdGVkLWNvbnRhaW5lciBjb3ZlclwiPlxuICAgIDxzbG90IG5hbWU9XCJmaW5nZXIxXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+XG4gICAgPC9zbG90PlxuICA8L2Rpdj5cblxuICA8ZGl2IGNsYXNzPVwic2xvdCBkZWZhdWx0XCI+XG4gICAgPHNsb3Q+PC9zbG90PlxuXG4gICAgPGRpdiBjbGFzcz1cInNsb3QgcHJvZ3Jlc3MtYmFyXCI+XG4gICAgICA8c2xvdCBuYW1lPVwicHJvZ3Jlc3MtYmFyXCI+XG4gICAgICAgIDxkaXYgaWQ9XCJkZWZhdWx0LXByb2dyZXNzLWJhclwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJiYXJcIiBwYXJ0PVwiZGVmYXVsdC1wcm9ncmVzcy1iYXJcIj48L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L3Nsb3Q+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwic2xvdCBleGl0LXdlYnhyLWFyLWJ1dHRvblwiPlxuICAgICAgPHNsb3QgbmFtZT1cImV4aXQtd2VieHItYXItYnV0dG9uXCI+XG4gICAgICAgIDxhIGlkPVwiZGVmYXVsdC1leGl0LXdlYnhyLWFyLWJ1dHRvblwiIHBhcnQ9XCJkZWZhdWx0LWV4aXQtd2VieHItYXItYnV0dG9uXCJcbiAgICAgICAgICAgIHRhYmluZGV4PVwiM1wiXG4gICAgICAgICAgICBhcmlhLWxhYmVsPVwiRXhpdCBBUlwiXG4gICAgICAgICAgICBhcmlhLWhpZGRlbj1cInRydWVcIj5cbiAgICAgICAgICAke0Nsb3NlSWNvbn1cbiAgICAgICAgPC9hPlxuICAgICAgPC9zbG90PlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvZGl2PlxuPGRpdiBjbGFzcz1cInNjcmVlbi1yZWFkZXItb25seVwiIHJvbGU9XCJyZWdpb25cIiBhcmlhLWxhYmVsPVwiTGl2ZSBhbm5vdW5jZW1lbnRzXCI+XG4gIDxzcGFuIGlkPVwic3RhdHVzXCIgcm9sZT1cInN0YXR1c1wiPjwvc3Bhbj5cbjwvZGl2PmA7XG5leHBvcnQgY29uc3QgbWFrZVRlbXBsYXRlID0gKHNoYWRvd1Jvb3QpID0+IHtcbiAgICByZW5kZXIodGVtcGxhdGVSZXN1bHQsIHNoYWRvd1Jvb3QpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRlbXBsYXRlLmpzLm1hcCIsIi8qIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICdMaWNlbnNlJyk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gJ0FTIElTJyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IEV2ZW50RGlzcGF0Y2hlciwgTWF0cml4NCwgUGVyc3BlY3RpdmVDYW1lcmEsIFZlY3RvcjMgfSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyBYUkVzdGltYXRlZExpZ2h0IH0gZnJvbSAndGhyZWUvZXhhbXBsZXMvanNtL3dlYnhyL1hSRXN0aW1hdGVkTGlnaHQuanMnO1xuaW1wb3J0IHsgJGN1cnJlbnRCYWNrZ3JvdW5kLCAkY3VycmVudEVudmlyb25tZW50TWFwIH0gZnJvbSAnLi4vZmVhdHVyZXMvZW52aXJvbm1lbnQuanMnO1xuaW1wb3J0IHsgJG9uUmVzaXplIH0gZnJvbSAnLi4vbW9kZWwtdmlld2VyLWJhc2UuanMnO1xuaW1wb3J0IHsgYXNzZXJ0SXNBckNhbmRpZGF0ZSB9IGZyb20gJy4uL3V0aWxpdGllcy5qcyc7XG5pbXBvcnQgeyBEYW1wZXIgfSBmcm9tICcuL0RhbXBlci5qcyc7XG5pbXBvcnQgeyBQbGFjZW1lbnRCb3ggfSBmcm9tICcuL1BsYWNlbWVudEJveC5qcyc7XG5pbXBvcnQgeyBDaGFuZ2VTb3VyY2UgfSBmcm9tICcuL1Ntb290aENvbnRyb2xzLmpzJztcbi8vIG51bWJlciBvZiBpbml0aWFsIG51bGwgcG9zZSBYUkZyYW1lcyBhbGxvd2VkIGJlZm9yZSB3ZSBwb3N0IG5vdC10cmFja2luZ1xuY29uc3QgSU5JVF9GUkFNRVMgPSAzMDtcbi8vIEFSIHNoYWRvdyBpcyBub3QgdXNlci1jb25maWd1cmFibGUuIFRoaXMgaXMgdG8gcGF2ZSB0aGUgd2F5IGZvciBBUiBsaWdodGluZ1xuLy8gZXN0aW1hdGlvbiwgd2hpY2ggd2lsbCBiZSB1c2VkIG9uY2UgYXZhaWxhYmxlIGluIFdlYlhSLlxuY29uc3QgQVJfU0hBRE9XX0lOVEVOU0lUWSA9IDAuODtcbmNvbnN0IFJPVEFUSU9OX1JBVEUgPSAxLjU7XG4vLyBBbmdsZSBkb3duICh0b3dhcmRzIGJvdHRvbSBvZiBzY3JlZW4pIGZyb20gY2FtZXJhIGNlbnRlciByYXkgdG8gdXNlIGZvciBoaXRcbi8vIHRlc3RpbmcgYWdhaW5zdCB0aGUgZmxvb3IuIFRoaXMgbWFrZXMgcGxhY2VtZW50IGZhc3RlciBhbmQgbW9yZSBpbnR1aXRpdmVcbi8vIGFzc3VtaW5nIHRoZSBwaG9uZSBpcyBpbiBwb3J0cmFpdCBtb2RlLiBUaGlzIHNlZW1zIHRvIGJlIGEgcmVhc29uYWJsZVxuLy8gYXNzdW1wdGlvbiBmb3IgdGhlIHN0YXJ0IG9mIHRoZSBzZXNzaW9uIGFuZCBVSSB3aWxsIGxhY2sgbGFuZHNjYXBlIG1vZGUgdG9cbi8vIGVuY291cmFnZSB1cHJpZ2h0IHVzZS5cbmNvbnN0IEhJVF9BTkdMRV9ERUcgPSAyMDtcbmNvbnN0IFNDQUxFX1NOQVBfSElHSCA9IDEuMztcbmNvbnN0IFNDQUxFX1NOQVBfTE9XID0gMSAvIFNDQUxFX1NOQVBfSElHSDtcbi8vIEZvciBhdXRvbWF0aWMgZHluYW1pYyB2aWV3cG9ydCBzY2FsaW5nLCBkb24ndCBsZXQgdGhlIHNjYWxlIGRyb3AgYmVsb3cgdGhpc1xuLy8gbGltaXQuXG5jb25zdCBNSU5fVklFV1BPUlRfU0NBTEUgPSAwLjI1O1xuLy8gRnVydGhlc3QgYXdheSB5b3UgY2FuIG1vdmUgYW4gb2JqZWN0IChtZXRlcnMpLlxuY29uc3QgTUFYX0RJU1RBTkNFID0gMTA7XG5leHBvcnQgY29uc3QgQVJTdGF0dXMgPSB7XG4gICAgTk9UX1BSRVNFTlRJTkc6ICdub3QtcHJlc2VudGluZycsXG4gICAgU0VTU0lPTl9TVEFSVEVEOiAnc2Vzc2lvbi1zdGFydGVkJyxcbiAgICBPQkpFQ1RfUExBQ0VEOiAnb2JqZWN0LXBsYWNlZCcsXG4gICAgRkFJTEVEOiAnZmFpbGVkJ1xufTtcbmV4cG9ydCBjb25zdCBBUlRyYWNraW5nID0ge1xuICAgIFRSQUNLSU5HOiAndHJhY2tpbmcnLFxuICAgIE5PVF9UUkFDS0lORzogJ25vdC10cmFja2luZydcbn07XG5jb25zdCB2ZWN0b3IzID0gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IG1hdHJpeDQgPSBuZXcgTWF0cml4NCgpO1xuY29uc3QgaGl0UG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xuY29uc3QgY2FtZXJhID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKDQ1LCAxLCAwLjEsIDEwMCk7XG5leHBvcnQgY2xhc3MgQVJSZW5kZXJlciBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlciB7XG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmN1cnJlbnRTZXNzaW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5wbGFjZU9uV2FsbCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBsYWNlbWVudEJveCA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdFRpY2sgPSBudWxsO1xuICAgICAgICB0aGlzLnR1cm50YWJsZVJvdGF0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbGRTaGFkb3dJbnRlbnNpdHkgPSBudWxsO1xuICAgICAgICB0aGlzLmZyYW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbml0aWFsSGl0U291cmNlID0gbnVsbDtcbiAgICAgICAgdGhpcy50cmFuc2llbnRIaXRUZXN0U291cmNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbnB1dFNvdXJjZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByZXNlbnRlZFNjZW5lID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXNvbHZlQ2xlYW51cCA9IG51bGw7XG4gICAgICAgIHRoaXMuZXhpdFdlYlhSQnV0dG9uQ29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5vdmVybGF5ID0gbnVsbDtcbiAgICAgICAgdGhpcy54ckxpZ2h0ID0gbnVsbDtcbiAgICAgICAgdGhpcy50cmFja2luZyA9IHRydWU7XG4gICAgICAgIHRoaXMuZnJhbWVzID0gMDtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9sZFRhcmdldCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICAgIHRoaXMucGxhY2VtZW50Q29tcGxldGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1RyYW5zbGF0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNSb3RhdGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzVHdvRmluZ2VyaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGFzdERyYWdQb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICAgIHRoaXMuZmlyc3RSYXRpbyA9IDA7XG4gICAgICAgIHRoaXMubGFzdEFuZ2xlID0gMDtcbiAgICAgICAgdGhpcy5nb2FsUG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgICAgICB0aGlzLmdvYWxZYXcgPSAwO1xuICAgICAgICB0aGlzLmdvYWxTY2FsZSA9IDE7XG4gICAgICAgIHRoaXMueERhbXBlciA9IG5ldyBEYW1wZXIoKTtcbiAgICAgICAgdGhpcy55RGFtcGVyID0gbmV3IERhbXBlcigpO1xuICAgICAgICB0aGlzLnpEYW1wZXIgPSBuZXcgRGFtcGVyKCk7XG4gICAgICAgIHRoaXMueWF3RGFtcGVyID0gbmV3IERhbXBlcigpO1xuICAgICAgICB0aGlzLnNjYWxlRGFtcGVyID0gbmV3IERhbXBlcigpO1xuICAgICAgICB0aGlzLm9uRXhpdFdlYlhSQnV0dG9uQ29udGFpbmVyQ2xpY2sgPSAoKSA9PiB0aGlzLnN0b3BQcmVzZW50aW5nKCk7XG4gICAgICAgIHRoaXMub25VcGRhdGVTY2VuZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBsYWNlbWVudEJveCAhPSBudWxsICYmIHRoaXMuaXNQcmVzZW50aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wbGFjZW1lbnRCb3guZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMucGxhY2VtZW50Qm94ID0gbmV3IFBsYWNlbWVudEJveCh0aGlzLnByZXNlbnRlZFNjZW5lLCB0aGlzLnBsYWNlT25XYWxsID8gJ2JhY2snIDogJ2JvdHRvbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uU2VsZWN0U3RhcnQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhpdFNvdXJjZSA9IHRoaXMudHJhbnNpZW50SGl0VGVzdFNvdXJjZTtcbiAgICAgICAgICAgIGlmIChoaXRTb3VyY2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZpbmdlcnMgPSB0aGlzLmZyYW1lLmdldEhpdFRlc3RSZXN1bHRzRm9yVHJhbnNpZW50SW5wdXQoaGl0U291cmNlKTtcbiAgICAgICAgICAgIGNvbnN0IHNjZW5lID0gdGhpcy5wcmVzZW50ZWRTY2VuZTtcbiAgICAgICAgICAgIGNvbnN0IGJveCA9IHRoaXMucGxhY2VtZW50Qm94O1xuICAgICAgICAgICAgaWYgKGZpbmdlcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dFNvdXJjZSA9IGV2ZW50LmlucHV0U291cmNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgYXhlcyB9ID0gdGhpcy5pbnB1dFNvdXJjZS5nYW1lcGFkO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhpdFBvc2l0aW9uID0gYm94LmdldEhpdCh0aGlzLnByZXNlbnRlZFNjZW5lLCBheGVzWzBdLCBheGVzWzFdKTtcbiAgICAgICAgICAgICAgICBib3guc2hvdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGhpdFBvc2l0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1RyYW5zbGF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0RHJhZ1Bvc2l0aW9uLmNvcHkoaGl0UG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLnBsYWNlT25XYWxsID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzUm90YXRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RBbmdsZSA9IGF4ZXNbMF0gKiBST1RBVElPTl9SQVRFO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZpbmdlcnMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgYm94LnNob3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuaXNUd29GaW5nZXJpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgc2VwYXJhdGlvbiB9ID0gdGhpcy5maW5nZXJQb2xhcihmaW5nZXJzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcnN0UmF0aW8gPSBzZXBhcmF0aW9uIC8gc2NlbmUuc2NhbGUueDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vblNlbGVjdEVuZCA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNUcmFuc2xhdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5pc1JvdGF0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmlzVHdvRmluZ2VyaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmlucHV0U291cmNlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuZ29hbFBvc2l0aW9uLnkgKz1cbiAgICAgICAgICAgICAgICB0aGlzLnBsYWNlbWVudEJveC5vZmZzZXRIZWlnaHQgKiB0aGlzLnByZXNlbnRlZFNjZW5lLnNjYWxlLng7XG4gICAgICAgICAgICB0aGlzLnBsYWNlbWVudEJveC5zaG93ID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudGhyZWVSZW5kZXJlciA9IHJlbmRlcmVyLnRocmVlUmVuZGVyZXI7XG4gICAgICAgIHRoaXMudGhyZWVSZW5kZXJlci54ci5lbmFibGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgYXN5bmMgcmVzb2x2ZUFSU2Vzc2lvbigpIHtcbiAgICAgICAgYXNzZXJ0SXNBckNhbmRpZGF0ZSgpO1xuICAgICAgICBjb25zdCBzZXNzaW9uID0gYXdhaXQgbmF2aWdhdG9yLnhyLnJlcXVlc3RTZXNzaW9uKCdpbW1lcnNpdmUtYXInLCB7XG4gICAgICAgICAgICByZXF1aXJlZEZlYXR1cmVzOiBbJ2hpdC10ZXN0J10sXG4gICAgICAgICAgICBvcHRpb25hbEZlYXR1cmVzOiBbJ2RvbS1vdmVybGF5JywgJ2xpZ2h0LWVzdGltYXRpb24nXSxcbiAgICAgICAgICAgIGRvbU92ZXJsYXk6IHRoaXMub3ZlcmxheSA/IHsgcm9vdDogdGhpcy5vdmVybGF5IH0gOiB1bmRlZmluZWRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudGhyZWVSZW5kZXJlci54ci5zZXRSZWZlcmVuY2VTcGFjZVR5cGUoJ2xvY2FsJyk7XG4gICAgICAgIGF3YWl0IHRoaXMudGhyZWVSZW5kZXJlci54ci5zZXRTZXNzaW9uKHNlc3Npb24pO1xuICAgICAgICB0aGlzLnRocmVlUmVuZGVyZXIueHIuY2FtZXJhQXV0b1VwZGF0ZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gc2Vzc2lvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnRseSBwcmVzZW50ZWQgc2NlbmUsIGlmIGFueVxuICAgICAqL1xuICAgIGdldCBwcmVzZW50ZWRTY2VuZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByZXNlbnRlZFNjZW5lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyB0byB0cnVlIGlmIHRoZSByZW5kZXJlciBoYXMgZGV0ZWN0ZWQgYWxsIHRoZSBuZWNlc3NhcnkgcXVhbGl0aWVzXG4gICAgICogdG8gc3VwcG9ydCBwcmVzZW50YXRpb24gaW4gQVIuXG4gICAgICovXG4gICAgYXN5bmMgc3VwcG9ydHNQcmVzZW50YXRpb24oKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhc3NlcnRJc0FyQ2FuZGlkYXRlKCk7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgbmF2aWdhdG9yLnhyLmlzU2Vzc2lvblN1cHBvcnRlZCgnaW1tZXJzaXZlLWFyJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1JlcXVlc3QgdG8gcHJlc2VudCBpbiBXZWJYUiBkZW5pZWQ6Jyk7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oZXJyb3IpO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdGYWxsaW5nIGJhY2sgdG8gbmV4dCBhci1tb2RlJyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJlc2VudCBhIHNjZW5lIGluIEFSXG4gICAgICovXG4gICAgYXN5bmMgcHJlc2VudChzY2VuZSwgZW52aXJvbm1lbnRFc3RpbWF0aW9uID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNQcmVzZW50aW5nKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0Nhbm5vdCBwcmVzZW50IHdoaWxlIGEgbW9kZWwgaXMgYWxyZWFkeSBwcmVzZW50aW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHdhaXRGb3JBbmltYXRpb25GcmFtZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCBfcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gcmVzb2x2ZSgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNjZW5lLnNldEhvdHNwb3RzVmlzaWJpbGl0eShmYWxzZSk7XG4gICAgICAgIHNjZW5lLnF1ZXVlUmVuZGVyKCk7XG4gICAgICAgIC8vIFJlbmRlciBhIGZyYW1lIHRvIHR1cm4gb2ZmIHRoZSBob3RzcG90c1xuICAgICAgICBhd2FpdCB3YWl0Rm9yQW5pbWF0aW9uRnJhbWU7XG4gICAgICAgIC8vIFRoaXMgc2V0cyBpc1ByZXNlbnRpbmcgdG8gdHJ1ZVxuICAgICAgICB0aGlzLl9wcmVzZW50ZWRTY2VuZSA9IHNjZW5lO1xuICAgICAgICB0aGlzLm92ZXJsYXkgPSBzY2VuZS5lbGVtZW50LnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignZGl2LmRlZmF1bHQnKTtcbiAgICAgICAgaWYgKGVudmlyb25tZW50RXN0aW1hdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy54ckxpZ2h0ID0gbmV3IFhSRXN0aW1hdGVkTGlnaHQodGhpcy50aHJlZVJlbmRlcmVyKTtcbiAgICAgICAgICAgIHRoaXMueHJMaWdodC5hZGRFdmVudExpc3RlbmVyKCdlc3RpbWF0aW9uc3RhcnQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzUHJlc2VudGluZyB8fCB0aGlzLnhyTGlnaHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHNjZW5lID0gdGhpcy5wcmVzZW50ZWRTY2VuZTtcbiAgICAgICAgICAgICAgICBzY2VuZS5hZGQodGhpcy54ckxpZ2h0KTtcbiAgICAgICAgICAgICAgICBzY2VuZS5lbnZpcm9ubWVudCA9IHRoaXMueHJMaWdodC5lbnZpcm9ubWVudDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTZXNzaW9uID0gYXdhaXQgdGhpcy5yZXNvbHZlQVJTZXNzaW9uKCk7XG4gICAgICAgIGN1cnJlbnRTZXNzaW9uLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucG9zdFNlc3Npb25DbGVhbnVwKCk7XG4gICAgICAgIH0sIHsgb25jZTogdHJ1ZSB9KTtcbiAgICAgICAgY29uc3QgZXhpdEJ1dHRvbiA9IHNjZW5lLmVsZW1lbnQuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCcuc2xvdC5leGl0LXdlYnhyLWFyLWJ1dHRvbicpO1xuICAgICAgICBleGl0QnV0dG9uLmNsYXNzTGlzdC5hZGQoJ2VuYWJsZWQnKTtcbiAgICAgICAgZXhpdEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25FeGl0V2ViWFJCdXR0b25Db250YWluZXJDbGljayk7XG4gICAgICAgIHRoaXMuZXhpdFdlYlhSQnV0dG9uQ29udGFpbmVyID0gZXhpdEJ1dHRvbjtcbiAgICAgICAgY29uc3Qgdmlld2VyUmVmU3BhY2UgPSBhd2FpdCBjdXJyZW50U2Vzc2lvbi5yZXF1ZXN0UmVmZXJlbmNlU3BhY2UoJ3ZpZXdlcicpO1xuICAgICAgICB0aGlzLnRyYWNraW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5mcmFtZXMgPSAwO1xuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMudHVybnRhYmxlUm90YXRpb24gPSBzY2VuZS55YXc7XG4gICAgICAgIHRoaXMuZ29hbFlhdyA9IHNjZW5lLnlhdztcbiAgICAgICAgdGhpcy5nb2FsU2NhbGUgPSAxO1xuICAgICAgICBzY2VuZS5iYWNrZ3JvdW5kID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbGRTaGFkb3dJbnRlbnNpdHkgPSBzY2VuZS5zaGFkb3dJbnRlbnNpdHk7XG4gICAgICAgIHNjZW5lLnNldFNoYWRvd0ludGVuc2l0eSgwLjAxKTsgLy8gaW52aXNpYmxlLCBidXQgbm90IGNoYW5naW5nIHRoZSBzaGFkZXJcbiAgICAgICAgdGhpcy5vbGRUYXJnZXQuY29weShzY2VuZS5nZXRUYXJnZXQoKSk7XG4gICAgICAgIHNjZW5lLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXMub25VcGRhdGVTY2VuZSk7XG4gICAgICAgIGNvbnN0IHJhZGlhbnMgPSBISVRfQU5HTEVfREVHICogTWF0aC5QSSAvIDE4MDtcbiAgICAgICAgY29uc3QgcmF5ID0gdGhpcy5wbGFjZU9uV2FsbCA9PT0gdHJ1ZSA/XG4gICAgICAgICAgICB1bmRlZmluZWQgOlxuICAgICAgICAgICAgbmV3IFhSUmF5KG5ldyBET01Qb2ludCgwLCAwLCAwKSwgeyB4OiAwLCB5OiAtTWF0aC5zaW4ocmFkaWFucyksIHo6IC1NYXRoLmNvcyhyYWRpYW5zKSB9KTtcbiAgICAgICAgY3VycmVudFNlc3Npb25cbiAgICAgICAgICAgIC5yZXF1ZXN0SGl0VGVzdFNvdXJjZSh7IHNwYWNlOiB2aWV3ZXJSZWZTcGFjZSwgb2Zmc2V0UmF5OiByYXkgfSkudGhlbihoaXRUZXN0U291cmNlID0+IHtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbEhpdFNvdXJjZSA9IGhpdFRlc3RTb3VyY2U7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmN1cnJlbnRTZXNzaW9uID0gY3VycmVudFNlc3Npb247XG4gICAgICAgIHRoaXMucGxhY2VtZW50Qm94ID1cbiAgICAgICAgICAgIG5ldyBQbGFjZW1lbnRCb3goc2NlbmUsIHRoaXMucGxhY2VPbldhbGwgPyAnYmFjaycgOiAnYm90dG9tJyk7XG4gICAgICAgIHRoaXMucGxhY2VtZW50Q29tcGxldGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sYXN0VGljayA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoeyB0eXBlOiAnc3RhdHVzJywgc3RhdHVzOiBBUlN0YXR1cy5TRVNTSU9OX1NUQVJURUQgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIGN1cnJlbnRseSBwcmVzZW50aW5nIGEgc2NlbmUgaW4gQVIsIHN0b3BzIHByZXNlbnRhdGlvbiBhbmQgZXhpdHMgQVIuXG4gICAgICovXG4gICAgYXN5bmMgc3RvcFByZXNlbnRpbmcoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ByZXNlbnRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjbGVhbnVwUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmVDbGVhbnVwID0gcmVzb2x2ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmN1cnJlbnRTZXNzaW9uLmVuZCgpO1xuICAgICAgICAgICAgYXdhaXQgY2xlYW51cFByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0Vycm9yIHdoaWxlIHRyeWluZyB0byBlbmQgV2ViWFIgQVIgc2Vzc2lvbicpO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGVycm9yKTtcbiAgICAgICAgICAgIHRoaXMucG9zdFNlc3Npb25DbGVhbnVwKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiBhIHNjZW5lIGlzIGN1cnJlbnRseSBpbiB0aGUgcHJvY2VzcyBvZiBiZWluZyBwcmVzZW50ZWQgaW4gQVJcbiAgICAgKi9cbiAgICBnZXQgaXNQcmVzZW50aW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmVzZW50ZWRTY2VuZSAhPSBudWxsO1xuICAgIH1cbiAgICBnZXQgdGFyZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vbGRUYXJnZXQ7XG4gICAgfVxuICAgIHVwZGF0ZVRhcmdldCgpIHtcbiAgICAgICAgY29uc3Qgc2NlbmUgPSB0aGlzLnByZXNlbnRlZFNjZW5lO1xuICAgICAgICBpZiAoc2NlbmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gc2NlbmUuZ2V0VGFyZ2V0KCk7XG4gICAgICAgICAgICB0aGlzLm9sZFRhcmdldC5jb3B5KHRhcmdldCk7XG4gICAgICAgICAgICBpZiAodGhpcy5wbGFjZU9uV2FsbCkge1xuICAgICAgICAgICAgICAgIC8vIE1vdmUgdGhlIHNjZW5lJ3MgdGFyZ2V0IHRvIHRoZSBjZW50ZXIgb2YgdGhlIGJhY2sgb2YgdGhlIG1vZGVsJ3NcbiAgICAgICAgICAgICAgICAvLyBib3VuZGluZyBib3guXG4gICAgICAgICAgICAgICAgdGFyZ2V0LnogPSBzY2VuZS5ib3VuZGluZ0JveC5taW4uejtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE1vdmUgdGhlIHNjZW5lJ3MgdGFyZ2V0IHRvIHRoZSBtb2RlbCdzIGZsb29yIGhlaWdodC5cbiAgICAgICAgICAgICAgICB0YXJnZXQueSA9IHNjZW5lLmJvdW5kaW5nQm94Lm1pbi55O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2NlbmUuc2V0VGFyZ2V0KHRhcmdldC54LCB0YXJnZXQueSwgdGFyZ2V0LnopO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBvc3RTZXNzaW9uQ2xlYW51cCgpIHtcbiAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IHRoaXMuY3VycmVudFNlc3Npb247XG4gICAgICAgIGlmIChzZXNzaW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNlc3Npb24ucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2VsZWN0c3RhcnQnLCB0aGlzLm9uU2VsZWN0U3RhcnQpO1xuICAgICAgICAgICAgc2Vzc2lvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWxlY3RlbmQnLCB0aGlzLm9uU2VsZWN0RW5kKTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNlc3Npb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNjZW5lID0gdGhpcy5wcmVzZW50ZWRTY2VuZTtcbiAgICAgICAgdGhpcy5fcHJlc2VudGVkU2NlbmUgPSBudWxsO1xuICAgICAgICBpZiAoc2NlbmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgeyBlbGVtZW50IH0gPSBzY2VuZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnhyTGlnaHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHNjZW5lLnJlbW92ZSh0aGlzLnhyTGlnaHQpO1xuICAgICAgICAgICAgICAgIHRoaXMueHJMaWdodC5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy54ckxpZ2h0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNjZW5lLnBvc2l0aW9uLnNldCgwLCAwLCAwKTtcbiAgICAgICAgICAgIHNjZW5lLnNjYWxlLnNldCgxLCAxLCAxKTtcbiAgICAgICAgICAgIHNjZW5lLnNldFNoYWRvd09mZnNldCgwKTtcbiAgICAgICAgICAgIGNvbnN0IHlhdyA9IHRoaXMudHVybnRhYmxlUm90YXRpb247XG4gICAgICAgICAgICBpZiAoeWF3ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzY2VuZS55YXcgPSB5YXc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpbnRlbnNpdHkgPSB0aGlzLm9sZFNoYWRvd0ludGVuc2l0eTtcbiAgICAgICAgICAgIGlmIChpbnRlbnNpdHkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHNjZW5lLnNldFNoYWRvd0ludGVuc2l0eShpbnRlbnNpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2NlbmUuc2V0RW52aXJvbm1lbnRBbmRTa3lib3goZWxlbWVudFskY3VycmVudEVudmlyb25tZW50TWFwXSwgZWxlbWVudFskY3VycmVudEJhY2tncm91bmRdKTtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gdGhpcy5vbGRUYXJnZXQ7XG4gICAgICAgICAgICBzY2VuZS5zZXRUYXJnZXQocG9pbnQueCwgcG9pbnQueSwgcG9pbnQueik7XG4gICAgICAgICAgICBzY2VuZS54ckNhbWVyYSA9IG51bGw7XG4gICAgICAgICAgICBzY2VuZS5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCB0aGlzLm9uVXBkYXRlU2NlbmUpO1xuICAgICAgICAgICAgc2NlbmUub3JpZW50SG90c3BvdHMoMCk7XG4gICAgICAgICAgICBlbGVtZW50LnJlcXVlc3RVcGRhdGUoJ2NhbWVyYVRhcmdldCcpO1xuICAgICAgICAgICAgZWxlbWVudC5yZXF1ZXN0VXBkYXRlKCdtYXhDYW1lcmFPcmJpdCcpO1xuICAgICAgICAgICAgZWxlbWVudFskb25SZXNpemVdKGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgICBzY2VuZS5lbGVtZW50LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdjYW1lcmEtY2hhbmdlJywgeyBkZXRhaWw6IHsgc291cmNlOiBDaGFuZ2VTb3VyY2UuTk9ORSB9IH0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZvcmNlIHRoZSBSZW5kZXJlciB0byB1cGRhdGUgaXRzIHNpemVcbiAgICAgICAgdGhpcy5yZW5kZXJlci5oZWlnaHQgPSAwO1xuICAgICAgICBjb25zdCBleGl0QnV0dG9uID0gdGhpcy5leGl0V2ViWFJCdXR0b25Db250YWluZXI7XG4gICAgICAgIGlmIChleGl0QnV0dG9uICE9IG51bGwpIHtcbiAgICAgICAgICAgIGV4aXRCdXR0b24uY2xhc3NMaXN0LnJlbW92ZSgnZW5hYmxlZCcpO1xuICAgICAgICAgICAgZXhpdEJ1dHRvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25FeGl0V2ViWFJCdXR0b25Db250YWluZXJDbGljayk7XG4gICAgICAgICAgICB0aGlzLmV4aXRXZWJYUkJ1dHRvbkNvbnRhaW5lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGl0U291cmNlID0gdGhpcy50cmFuc2llbnRIaXRUZXN0U291cmNlO1xuICAgICAgICBpZiAoaGl0U291cmNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGhpdFNvdXJjZS5jYW5jZWwoKTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNpZW50SGl0VGVzdFNvdXJjZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGl0U291cmNlSW5pdGlhbCA9IHRoaXMuaW5pdGlhbEhpdFNvdXJjZTtcbiAgICAgICAgaWYgKGhpdFNvdXJjZUluaXRpYWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgaGl0U291cmNlSW5pdGlhbC5jYW5jZWwoKTtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbEhpdFNvdXJjZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGxhY2VtZW50Qm94ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMucGxhY2VtZW50Qm94LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMucGxhY2VtZW50Qm94ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3RUaWNrID0gbnVsbDtcbiAgICAgICAgdGhpcy50dXJudGFibGVSb3RhdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMub2xkU2hhZG93SW50ZW5zaXR5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5mcmFtZSA9IG51bGw7XG4gICAgICAgIHRoaXMuaW5wdXRTb3VyY2UgPSBudWxsO1xuICAgICAgICB0aGlzLm92ZXJsYXkgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5yZXNvbHZlQ2xlYW51cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmVDbGVhbnVwKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHsgdHlwZTogJ3N0YXR1cycsIHN0YXR1czogQVJTdGF0dXMuTk9UX1BSRVNFTlRJTkcgfSk7XG4gICAgfVxuICAgIHVwZGF0ZVZpZXcodmlldykge1xuICAgICAgICBjb25zdCBzY2VuZSA9IHRoaXMucHJlc2VudGVkU2NlbmU7XG4gICAgICAgIGNvbnN0IHhyID0gdGhpcy50aHJlZVJlbmRlcmVyLnhyO1xuICAgICAgICB4ci51cGRhdGVDYW1lcmEoY2FtZXJhKTtcbiAgICAgICAgc2NlbmUueHJDYW1lcmEgPSB4ci5nZXRDYW1lcmEoKTtcbiAgICAgICAgY29uc3QgeyBlbGVtZW50cyB9ID0gc2NlbmUuZ2V0Q2FtZXJhKCkubWF0cml4V29ybGQ7XG4gICAgICAgIHNjZW5lLm9yaWVudEhvdHNwb3RzKE1hdGguYXRhbjIoZWxlbWVudHNbMV0sIGVsZW1lbnRzWzVdKSk7XG4gICAgICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgdGhpcy5wbGFjZUluaXRpYWxseSgpO1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXNlIGF1dG9tYXRpYyBkeW5hbWljIHZpZXdwb3J0IHNjYWxpbmcgaWYgc3VwcG9ydGVkLlxuICAgICAgICBpZiAodmlldy5yZXF1ZXN0Vmlld3BvcnRTY2FsZSAmJiB2aWV3LnJlY29tbWVuZGVkVmlld3BvcnRTY2FsZSkge1xuICAgICAgICAgICAgY29uc3Qgc2NhbGUgPSB2aWV3LnJlY29tbWVuZGVkVmlld3BvcnRTY2FsZTtcbiAgICAgICAgICAgIHZpZXcucmVxdWVzdFZpZXdwb3J0U2NhbGUoTWF0aC5tYXgoc2NhbGUsIE1JTl9WSUVXUE9SVF9TQ0FMRSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxheWVyID0geHIuZ2V0QmFzZUxheWVyKCk7XG4gICAgICAgIGlmIChsYXllciAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCB2aWV3cG9ydCA9IGxheWVyIGluc3RhbmNlb2YgWFJXZWJHTExheWVyID9cbiAgICAgICAgICAgICAgICBsYXllci5nZXRWaWV3cG9ydCh2aWV3KSA6XG4gICAgICAgICAgICAgICAgeHIuZ2V0QmluZGluZygpLmdldFZpZXdTdWJJbWFnZShsYXllciwgdmlldykudmlld3BvcnQ7XG4gICAgICAgICAgICB0aGlzLnRocmVlUmVuZGVyZXIuc2V0Vmlld3BvcnQodmlld3BvcnQueCwgdmlld3BvcnQueSwgdmlld3BvcnQud2lkdGgsIHZpZXdwb3J0LmhlaWdodCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGxhY2VJbml0aWFsbHkoKSB7XG4gICAgICAgIGNvbnN0IHNjZW5lID0gdGhpcy5wcmVzZW50ZWRTY2VuZTtcbiAgICAgICAgY29uc3QgeyBwb3NpdGlvbiwgZWxlbWVudCB9ID0gc2NlbmU7XG4gICAgICAgIGNvbnN0IHhyQ2FtZXJhID0gc2NlbmUuZ2V0Q2FtZXJhKCk7XG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdGhpcy5vdmVybGF5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBzY2VuZS5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB4ckNhbWVyYS5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZS5jb3B5KHhyQ2FtZXJhLnByb2plY3Rpb25NYXRyaXgpLmludmVydCgpO1xuICAgICAgICBjb25zdCB7IHRoZXRhLCByYWRpdXMgfSA9IGVsZW1lbnRcbiAgICAgICAgICAgIC5nZXRDYW1lcmFPcmJpdCgpO1xuICAgICAgICAvLyBPcmllbnQgbW9kZWwgdG8gbWF0Y2ggdGhlIDNEIGNhbWVyYSB2aWV3XG4gICAgICAgIGNvbnN0IGNhbWVyYURpcmVjdGlvbiA9IHhyQ2FtZXJhLmdldFdvcmxkRGlyZWN0aW9uKHZlY3RvcjMpO1xuICAgICAgICBzY2VuZS55YXcgPSBNYXRoLmF0YW4yKC1jYW1lcmFEaXJlY3Rpb24ueCwgLWNhbWVyYURpcmVjdGlvbi56KSAtIHRoZXRhO1xuICAgICAgICB0aGlzLmdvYWxZYXcgPSBzY2VuZS55YXc7XG4gICAgICAgIHBvc2l0aW9uLmNvcHkoeHJDYW1lcmEucG9zaXRpb24pXG4gICAgICAgICAgICAuYWRkKGNhbWVyYURpcmVjdGlvbi5tdWx0aXBseVNjYWxhcihyYWRpdXMpKTtcbiAgICAgICAgdGhpcy51cGRhdGVUYXJnZXQoKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gc2NlbmUuZ2V0VGFyZ2V0KCk7XG4gICAgICAgIHBvc2l0aW9uLmFkZCh0YXJnZXQpLnN1Yih0aGlzLm9sZFRhcmdldCk7XG4gICAgICAgIHRoaXMuZ29hbFBvc2l0aW9uLmNvcHkocG9zaXRpb24pO1xuICAgICAgICBzY2VuZS5zZXRIb3RzcG90c1Zpc2liaWxpdHkodHJ1ZSk7XG4gICAgICAgIGNvbnN0IHsgc2Vzc2lvbiB9ID0gdGhpcy5mcmFtZTtcbiAgICAgICAgc2Vzc2lvbi5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIHRoaXMub25TZWxlY3RTdGFydCk7XG4gICAgICAgIHNlc3Npb24uYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0ZW5kJywgdGhpcy5vblNlbGVjdEVuZCk7XG4gICAgICAgIHNlc3Npb25cbiAgICAgICAgICAgIC5yZXF1ZXN0SGl0VGVzdFNvdXJjZUZvclRyYW5zaWVudElucHV0KHsgcHJvZmlsZTogJ2dlbmVyaWMtdG91Y2hzY3JlZW4nIH0pLnRoZW4oaGl0VGVzdFNvdXJjZSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zaWVudEhpdFRlc3RTb3VyY2UgPSBoaXRUZXN0U291cmNlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0VG91Y2hMb2NhdGlvbigpIHtcbiAgICAgICAgY29uc3QgeyBheGVzIH0gPSB0aGlzLmlucHV0U291cmNlLmdhbWVwYWQ7XG4gICAgICAgIGxldCBsb2NhdGlvbiA9IHRoaXMucGxhY2VtZW50Qm94LmdldEV4cGFuZGVkSGl0KHRoaXMucHJlc2VudGVkU2NlbmUsIGF4ZXNbMF0sIGF4ZXNbMV0pO1xuICAgICAgICBpZiAobG9jYXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgdmVjdG9yMy5jb3B5KGxvY2F0aW9uKS5zdWIodGhpcy5wcmVzZW50ZWRTY2VuZS5nZXRDYW1lcmEoKS5wb3NpdGlvbik7XG4gICAgICAgICAgICBpZiAodmVjdG9yMy5sZW5ndGgoKSA+IE1BWF9ESVNUQU5DRSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9jYXRpb247XG4gICAgfVxuICAgIGdldEhpdFBvaW50KGhpdFJlc3VsdCkge1xuICAgICAgICBjb25zdCByZWZTcGFjZSA9IHRoaXMudGhyZWVSZW5kZXJlci54ci5nZXRSZWZlcmVuY2VTcGFjZSgpO1xuICAgICAgICBjb25zdCBwb3NlID0gaGl0UmVzdWx0LmdldFBvc2UocmVmU3BhY2UpO1xuICAgICAgICBpZiAocG9zZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoaXRNYXRyaXggPSBtYXRyaXg0LmZyb21BcnJheShwb3NlLnRyYW5zZm9ybS5tYXRyaXgpO1xuICAgICAgICBpZiAodGhpcy5wbGFjZU9uV2FsbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgLy8gT3JpZW50IHRoZSBtb2RlbCB0byB0aGUgd2FsbCdzIG5vcm1hbCB2ZWN0b3IuXG4gICAgICAgICAgICB0aGlzLmdvYWxZYXcgPSBNYXRoLmF0YW4yKGhpdE1hdHJpeC5lbGVtZW50c1s0XSwgaGl0TWF0cml4LmVsZW1lbnRzWzZdKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIG5vcm1hbCBpcyBsYXJnZSBlbm91Z2ggdGhhdCB0aGUgbm9ybWFsXG4gICAgICAgIC8vIGlzIHBvaW50aW5nIHVwIGZvciBmbG9vciBwbGFjZW1lbnQ7IG9wcG9zaXRlIGZvciB3YWxsIHBsYWNlbWVudC5cbiAgICAgICAgcmV0dXJuIGhpdE1hdHJpeC5lbGVtZW50c1s1XSA+IDAuNzUgIT09IHRoaXMucGxhY2VPbldhbGwgP1xuICAgICAgICAgICAgaGl0UG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGhpdE1hdHJpeCkgOlxuICAgICAgICAgICAgbnVsbDtcbiAgICB9XG4gICAgbW92ZVRvRmxvb3IoZnJhbWUpIHtcbiAgICAgICAgY29uc3QgaGl0U291cmNlID0gdGhpcy5pbml0aWFsSGl0U291cmNlO1xuICAgICAgICBpZiAoaGl0U291cmNlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoaXRUZXN0UmVzdWx0cyA9IGZyYW1lLmdldEhpdFRlc3RSZXN1bHRzKGhpdFNvdXJjZSk7XG4gICAgICAgIGlmIChoaXRUZXN0UmVzdWx0cy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhpdCA9IGhpdFRlc3RSZXN1bHRzWzBdO1xuICAgICAgICBjb25zdCBoaXRQb2ludCA9IHRoaXMuZ2V0SGl0UG9pbnQoaGl0KTtcbiAgICAgICAgaWYgKGhpdFBvaW50ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBsYWNlbWVudEJveC5zaG93ID0gdHJ1ZTtcbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgaXMgdHJhbnNsYXRpbmcsIGxldCB0aGUgZmluZ2VyIGhpdC1yYXkgdGFrZSBwcmVjZWRlbmNlIGFuZFxuICAgICAgICAvLyBpZ25vcmUgdGhpcyBoaXQgcmVzdWx0LlxuICAgICAgICBpZiAoIXRoaXMuaXNUcmFuc2xhdGluZykge1xuICAgICAgICAgICAgaWYgKHRoaXMucGxhY2VPbldhbGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdvYWxQb3NpdGlvbi5jb3B5KGhpdFBvaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZ29hbFBvc2l0aW9uLnkgPSBoaXRQb2ludC55O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGhpdFNvdXJjZS5jYW5jZWwoKTtcbiAgICAgICAgdGhpcy5pbml0aWFsSGl0U291cmNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHsgdHlwZTogJ3N0YXR1cycsIHN0YXR1czogQVJTdGF0dXMuT0JKRUNUX1BMQUNFRCB9KTtcbiAgICB9XG4gICAgZmluZ2VyUG9sYXIoZmluZ2Vycykge1xuICAgICAgICBjb25zdCBmaW5nZXJPbmUgPSBmaW5nZXJzWzBdLmlucHV0U291cmNlLmdhbWVwYWQuYXhlcztcbiAgICAgICAgY29uc3QgZmluZ2VyVHdvID0gZmluZ2Vyc1sxXS5pbnB1dFNvdXJjZS5nYW1lcGFkLmF4ZXM7XG4gICAgICAgIGNvbnN0IGRlbHRhWCA9IGZpbmdlclR3b1swXSAtIGZpbmdlck9uZVswXTtcbiAgICAgICAgY29uc3QgZGVsdGFZID0gZmluZ2VyVHdvWzFdIC0gZmluZ2VyT25lWzFdO1xuICAgICAgICBjb25zdCBhbmdsZSA9IE1hdGguYXRhbjIoZGVsdGFZLCBkZWx0YVgpO1xuICAgICAgICBsZXQgZGVsdGFZYXcgPSB0aGlzLmxhc3RBbmdsZSAtIGFuZ2xlO1xuICAgICAgICBpZiAoZGVsdGFZYXcgPiBNYXRoLlBJKSB7XG4gICAgICAgICAgICBkZWx0YVlhdyAtPSAyICogTWF0aC5QSTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkZWx0YVlhdyA8IC1NYXRoLlBJKSB7XG4gICAgICAgICAgICBkZWx0YVlhdyArPSAyICogTWF0aC5QSTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3RBbmdsZSA9IGFuZ2xlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2VwYXJhdGlvbjogTWF0aC5zcXJ0KGRlbHRhWCAqIGRlbHRhWCArIGRlbHRhWSAqIGRlbHRhWSksXG4gICAgICAgICAgICBkZWx0YVlhdzogZGVsdGFZYXdcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcHJvY2Vzc0lucHV0KGZyYW1lKSB7XG4gICAgICAgIGNvbnN0IGhpdFNvdXJjZSA9IHRoaXMudHJhbnNpZW50SGl0VGVzdFNvdXJjZTtcbiAgICAgICAgaWYgKGhpdFNvdXJjZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmlzVHJhbnNsYXRpbmcgJiYgIXRoaXMuaXNUd29GaW5nZXJpbmcgJiYgIXRoaXMuaXNSb3RhdGluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpbmdlcnMgPSBmcmFtZS5nZXRIaXRUZXN0UmVzdWx0c0ZvclRyYW5zaWVudElucHV0KGhpdFNvdXJjZSk7XG4gICAgICAgIGNvbnN0IHNjZW5lID0gdGhpcy5wcmVzZW50ZWRTY2VuZTtcbiAgICAgICAgY29uc3Qgc2NhbGUgPSBzY2VuZS5zY2FsZS54O1xuICAgICAgICAvLyBSb3RhdGluZywgdHJhbnNsYXRpbmcgYW5kIHNjYWxpbmcgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZSBvcGVyYXRpb25zOyBvbmx5XG4gICAgICAgIC8vIG9uZSBjYW4gaGFwcGVuIGF0IGEgdGltZSwgYnV0IHdlIGNhbiBzd2l0Y2ggZHVyaW5nIGEgZ2VzdHVyZS5cbiAgICAgICAgaWYgKHRoaXMuaXNUd29GaW5nZXJpbmcpIHtcbiAgICAgICAgICAgIGlmIChmaW5nZXJzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBsb3NlIHRoZSBzZWNvbmQgZmluZ2VyLCBzdG9wIHNjYWxpbmcgKGluIGZhY3QsIHN0b3AgcHJvY2Vzc2luZ1xuICAgICAgICAgICAgICAgIC8vIGlucHV0IGFsdG9nZXRoZXIgdW50aWwgYSBuZXcgZ2VzdHVyZSBzdGFydHMpLlxuICAgICAgICAgICAgICAgIHRoaXMuaXNUd29GaW5nZXJpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgc2VwYXJhdGlvbiwgZGVsdGFZYXcgfSA9IHRoaXMuZmluZ2VyUG9sYXIoZmluZ2Vycyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGxhY2VPbldhbGwgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ29hbFlhdyArPSBkZWx0YVlhdztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNjZW5lLmNhblNjYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjYWxlID0gc2VwYXJhdGlvbiAvIHRoaXMuZmlyc3RSYXRpbztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nb2FsU2NhbGUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgKHNjYWxlIDwgU0NBTEVfU05BUF9ISUdIICYmIHNjYWxlID4gU0NBTEVfU05BUF9MT1cpID8gMSA6IHNjYWxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmaW5nZXJzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgLy8gSWYgd2Ugd2VyZSByb3RhdGluZyBvciB0cmFuc2xhdGluZyBhbmQgd2UgZ2V0IGEgc2Vjb25kIGZpbmdlciwgc3dpdGNoXG4gICAgICAgICAgICAvLyB0byBzY2FsaW5nIGluc3RlYWQuXG4gICAgICAgICAgICB0aGlzLmlzVHJhbnNsYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuaXNSb3RhdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5pc1R3b0ZpbmdlcmluZyA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCB7IHNlcGFyYXRpb24gfSA9IHRoaXMuZmluZ2VyUG9sYXIoZmluZ2Vycyk7XG4gICAgICAgICAgICB0aGlzLmZpcnN0UmF0aW8gPSBzZXBhcmF0aW9uIC8gc2NhbGU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNSb3RhdGluZykge1xuICAgICAgICAgICAgY29uc3QgYW5nbGUgPSB0aGlzLmlucHV0U291cmNlLmdhbWVwYWQuYXhlc1swXSAqIFJPVEFUSU9OX1JBVEU7XG4gICAgICAgICAgICB0aGlzLmdvYWxZYXcgKz0gYW5nbGUgLSB0aGlzLmxhc3RBbmdsZTtcbiAgICAgICAgICAgIHRoaXMubGFzdEFuZ2xlID0gYW5nbGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pc1RyYW5zbGF0aW5nKSB7XG4gICAgICAgICAgICBmaW5nZXJzLmZvckVhY2goZmluZ2VyID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZmluZ2VyLmlucHV0U291cmNlICE9PSB0aGlzLmlucHV0U291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGhpdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGZpbmdlci5yZXN1bHRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaGl0ID0gdGhpcy5nZXRIaXRQb2ludChmaW5nZXIucmVzdWx0c1swXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoaXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBoaXQgPSB0aGlzLmdldFRvdWNoTG9jYXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhpdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5nb2FsUG9zaXRpb24uc3ViKHRoaXMubGFzdERyYWdQb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGxhY2VPbldhbGwgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IGhpdC55IC0gdGhpcy5sYXN0RHJhZ1Bvc2l0aW9uLnk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gYSBsb3dlciBmbG9vciBpcyBmb3VuZCwga2VlcCB0aGUgbW9kZWwgYXQgdGhlIHNhbWUgaGVpZ2h0LCBidXRcbiAgICAgICAgICAgICAgICAgICAgLy8gZHJvcCB0aGUgcGxhY2VtZW50IGJveCB0byB0aGUgZmxvb3IuIFRoZSBtb2RlbCBmYWxscyBvbiBzZWxlY3QgZW5kLlxuICAgICAgICAgICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbGFjZW1lbnRCb3gub2Zmc2V0SGVpZ2h0ID0gb2Zmc2V0IC8gc2NhbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByZXNlbnRlZFNjZW5lLnNldFNoYWRvd09mZnNldChvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW50ZXJwb2xhdGUgaGl0IHJheSB1cCB0byBkcmFnIHBsYW5lXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYW1lcmFQb3NpdGlvbiA9IHZlY3RvcjMuY29weShzY2VuZS5nZXRDYW1lcmEoKS5wb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhbHBoYSA9IC1vZmZzZXQgLyAoY2FtZXJhUG9zaXRpb24ueSAtIGhpdC55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbWVyYVBvc2l0aW9uLm11bHRpcGx5U2NhbGFyKGFscGhhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpdC5tdWx0aXBseVNjYWxhcigxIC0gYWxwaGEpLmFkZChjYW1lcmFQb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5nb2FsUG9zaXRpb24uYWRkKGhpdCk7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0RHJhZ1Bvc2l0aW9uLmNvcHkoaGl0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1vdmVTY2VuZShkZWx0YSkge1xuICAgICAgICBjb25zdCBzY2VuZSA9IHRoaXMucHJlc2VudGVkU2NlbmU7XG4gICAgICAgIGNvbnN0IHsgcG9zaXRpb24sIHlhdyB9ID0gc2NlbmU7XG4gICAgICAgIGNvbnN0IGJvdW5kaW5nUmFkaXVzID0gc2NlbmUuYm91bmRpbmdTcGhlcmUucmFkaXVzO1xuICAgICAgICBjb25zdCBnb2FsID0gdGhpcy5nb2FsUG9zaXRpb247XG4gICAgICAgIGNvbnN0IG9sZFNjYWxlID0gc2NlbmUuc2NhbGUueDtcbiAgICAgICAgY29uc3QgYm94ID0gdGhpcy5wbGFjZW1lbnRCb3g7XG4gICAgICAgIGxldCBzb3VyY2UgPSBDaGFuZ2VTb3VyY2UuTk9ORTtcbiAgICAgICAgaWYgKCFnb2FsLmVxdWFscyhwb3NpdGlvbikgfHwgdGhpcy5nb2FsU2NhbGUgIT09IG9sZFNjYWxlKSB7XG4gICAgICAgICAgICBzb3VyY2UgPSBDaGFuZ2VTb3VyY2UuVVNFUl9JTlRFUkFDVElPTjtcbiAgICAgICAgICAgIGxldCB7IHgsIHksIHogfSA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgeCA9IHRoaXMueERhbXBlci51cGRhdGUoeCwgZ29hbC54LCBkZWx0YSwgYm91bmRpbmdSYWRpdXMpO1xuICAgICAgICAgICAgeSA9IHRoaXMueURhbXBlci51cGRhdGUoeSwgZ29hbC55LCBkZWx0YSwgYm91bmRpbmdSYWRpdXMpO1xuICAgICAgICAgICAgeiA9IHRoaXMuekRhbXBlci51cGRhdGUoeiwgZ29hbC56LCBkZWx0YSwgYm91bmRpbmdSYWRpdXMpO1xuICAgICAgICAgICAgcG9zaXRpb24uc2V0KHgsIHksIHopO1xuICAgICAgICAgICAgY29uc3QgbmV3U2NhbGUgPSB0aGlzLnNjYWxlRGFtcGVyLnVwZGF0ZShvbGRTY2FsZSwgdGhpcy5nb2FsU2NhbGUsIGRlbHRhLCAxKTtcbiAgICAgICAgICAgIHNjZW5lLnNjYWxlLnNldChuZXdTY2FsZSwgbmV3U2NhbGUsIG5ld1NjYWxlKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1RyYW5zbGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gZ29hbC55IC0geTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wbGFjZW1lbnRDb21wbGV0ZSAmJiB0aGlzLnBsYWNlT25XYWxsID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICBib3gub2Zmc2V0SGVpZ2h0ID0gb2Zmc2V0IC8gbmV3U2NhbGU7XG4gICAgICAgICAgICAgICAgICAgIHNjZW5lLnNldFNoYWRvd09mZnNldChvZmZzZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvZmZzZXQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbGFjZW1lbnRDb21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJveC5zaG93ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHNjZW5lLnNldFNoYWRvd0ludGVuc2l0eShBUl9TSEFET1dfSU5URU5TSVRZKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYm94LnVwZGF0ZU9wYWNpdHkoZGVsdGEpO1xuICAgICAgICBzY2VuZS51cGRhdGVUYXJnZXQoZGVsdGEpO1xuICAgICAgICAvLyB5YXcgbXVzdCBiZSB1cGRhdGVkIGxhc3QsIHNpbmNlIHRoaXMgYWxzbyB1cGRhdGVzIHRoZSBzaGFkb3cgcG9zaXRpb24uXG4gICAgICAgIHNjZW5lLnlhdyA9IHRoaXMueWF3RGFtcGVyLnVwZGF0ZSh5YXcsIHRoaXMuZ29hbFlhdywgZGVsdGEsIE1hdGguUEkpO1xuICAgICAgICAvLyBjYW1lcmEgY2hhbmdlcyBvbiBldmVyeSBmcmFtZSAtIHVzZXItaW50ZXJhY3Rpb24gb25seSBpZiB0b3VjaGluZyB0aGVcbiAgICAgICAgLy8gc2NyZWVuLCBwbHVzIGRhbXBpbmcgdGltZS5cbiAgICAgICAgc2NlbmUuZWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnY2FtZXJhLWNoYW5nZScsIHsgZGV0YWlsOiB7IHNvdXJjZSB9IH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT25seSBwdWJsaWMgdG8gbWFrZSBpdCB0ZXN0YWJsZS5cbiAgICAgKi9cbiAgICBvbldlYlhSRnJhbWUodGltZSwgZnJhbWUpIHtcbiAgICAgICAgdGhpcy5mcmFtZSA9IGZyYW1lO1xuICAgICAgICArK3RoaXMuZnJhbWVzO1xuICAgICAgICBjb25zdCByZWZTcGFjZSA9IHRoaXMudGhyZWVSZW5kZXJlci54ci5nZXRSZWZlcmVuY2VTcGFjZSgpO1xuICAgICAgICBjb25zdCBwb3NlID0gZnJhbWUuZ2V0Vmlld2VyUG9zZShyZWZTcGFjZSk7XG4gICAgICAgIGlmIChwb3NlID09IG51bGwgJiYgdGhpcy50cmFja2luZyA9PT0gdHJ1ZSAmJiB0aGlzLmZyYW1lcyA+IElOSVRfRlJBTUVTKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNraW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoeyB0eXBlOiAndHJhY2tpbmcnLCBzdGF0dXM6IEFSVHJhY2tpbmcuTk9UX1RSQUNLSU5HIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNjZW5lID0gdGhpcy5wcmVzZW50ZWRTY2VuZTtcbiAgICAgICAgaWYgKHBvc2UgPT0gbnVsbCB8fCBzY2VuZSA9PSBudWxsIHx8ICFzY2VuZS5lbGVtZW50LmxvYWRlZCkge1xuICAgICAgICAgICAgdGhpcy50aHJlZVJlbmRlcmVyLmNsZWFyKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudHJhY2tpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNraW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh7IHR5cGU6ICd0cmFja2luZycsIHN0YXR1czogQVJUcmFja2luZy5UUkFDS0lORyB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZWJYUiBtYXkgcmV0dXJuIG11bHRpcGxlIHZpZXdzLCBpLmUuIGZvciBoZWFkc2V0IEFSLiBUaGlzXG4gICAgICAgIC8vIGlzbid0IHJlYWxseSBzdXBwb3J0ZWQgYXQgdGhpcyBwb2ludCwgYnV0IG1ha2UgYSBiZXN0LWVmZm9ydFxuICAgICAgICAvLyBhdHRlbXB0IHRvIHJlbmRlciBvdGhlciB2aWV3cyBhbHNvLCB1c2luZyB0aGUgZmlyc3Qgdmlld1xuICAgICAgICAvLyBhcyB0aGUgbWFpbiB2aWV3cG9pbnQuXG4gICAgICAgIGxldCBpc0ZpcnN0VmlldyA9IHRydWU7XG4gICAgICAgIGZvciAoY29uc3QgdmlldyBvZiBwb3NlLnZpZXdzKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZpZXcodmlldyk7XG4gICAgICAgICAgICBpZiAoaXNGaXJzdFZpZXcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVUb0Zsb29yKGZyYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NJbnB1dChmcmFtZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVsdGEgPSB0aW1lIC0gdGhpcy5sYXN0VGljaztcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVTY2VuZShkZWx0YSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5wcmVSZW5kZXIoc2NlbmUsIHRpbWUsIGRlbHRhKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RUaWNrID0gdGltZTtcbiAgICAgICAgICAgICAgICBzY2VuZS5yZW5kZXJTaGFkb3codGhpcy50aHJlZVJlbmRlcmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudGhyZWVSZW5kZXJlci5yZW5kZXIoc2NlbmUsIHNjZW5lLmdldENhbWVyYSgpKTtcbiAgICAgICAgICAgIGlzRmlyc3RWaWV3ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BUlJlbmRlcmVyLmpzLm1hcCIsIi8qIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICdMaWNlbnNlJyk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gJ0FTIElTJyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBfYSwgX2I7XG5pbXBvcnQgeyBFdmVudERpc3BhdGNoZXIsIFRleHR1cmUgfSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyBEUkFDT0xvYWRlciB9IGZyb20gJ3RocmVlL2V4YW1wbGVzL2pzbS9sb2FkZXJzL0RSQUNPTG9hZGVyLmpzJztcbmltcG9ydCB7IEdMVEZMb2FkZXIgfSBmcm9tICd0aHJlZS9leGFtcGxlcy9qc20vbG9hZGVycy9HTFRGTG9hZGVyLmpzJztcbmltcG9ydCB7IEtUWDJMb2FkZXIgfSBmcm9tICd0aHJlZS9leGFtcGxlcy9qc20vbG9hZGVycy9LVFgyTG9hZGVyLmpzJztcbmltcG9ydCB7IENhY2hlRXZpY3Rpb25Qb2xpY3kgfSBmcm9tICcuLi91dGlsaXRpZXMvY2FjaGUtZXZpY3Rpb24tcG9saWN5LmpzJztcbmltcG9ydCBHTFRGTWF0ZXJpYWxzVmFyaWFudHNFeHRlbnNpb24gZnJvbSAnLi9nbHRmLWluc3RhbmNlL1ZhcmlhbnRNYXRlcmlhbExvYWRlclBsdWdpbic7XG5UZXh0dXJlLkRFRkFVTFRfQU5JU09UUk9QWSA9IDQ7XG4vKipcbiAqIEEgaGVscGVyIHRvIFByb21pc2UtaWZ5IGEgVGhyZWUuanMgR0xURkxvYWRlclxuICovXG5leHBvcnQgY29uc3QgbG9hZFdpdGhMb2FkZXIgPSAodXJsLCBsb2FkZXIsIHByb2dyZXNzQ2FsbGJhY2sgPSAoKSA9PiB7IH0pID0+IHtcbiAgICBjb25zdCBvblByb2dyZXNzID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IGZyYWN0aW9uID0gZXZlbnQubG9hZGVkIC8gZXZlbnQudG90YWw7XG4gICAgICAgIHByb2dyZXNzQ2FsbGJhY2soTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgaXNGaW5pdGUoZnJhY3Rpb24pID8gZnJhY3Rpb24gOiAxKSkpO1xuICAgIH07XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgbG9hZGVyLmxvYWQodXJsLCByZXNvbHZlLCBvblByb2dyZXNzLCByZWplY3QpO1xuICAgIH0pO1xufTtcbi8qKiBIZWxwZXIgdG8gbG9hZCBhIHNjcmlwdCB0YWcuICovXG5jb25zdCBmZXRjaFNjcmlwdCA9IChzcmMpID0+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICBzY3JpcHQub25sb2FkID0gcmVzb2x2ZTtcbiAgICAgICAgc2NyaXB0Lm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICAgIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gICAgICAgIHNjcmlwdC5zcmMgPSBzcmM7XG4gICAgfSk7XG59O1xuY29uc3QgY2FjaGUgPSBuZXcgTWFwKCk7XG5jb25zdCBwcmVsb2FkZWQgPSBuZXcgTWFwKCk7XG5sZXQgZHJhY29EZWNvZGVyTG9jYXRpb247XG5jb25zdCBkcmFjb0xvYWRlciA9IG5ldyBEUkFDT0xvYWRlcigpO1xubGV0IGt0eDJUcmFuc2NvZGVyTG9jYXRpb247XG5jb25zdCBrdHgyTG9hZGVyID0gbmV3IEtUWDJMb2FkZXIoKTtcbmxldCBtZXNob3B0RGVjb2RlckxvY2F0aW9uO1xubGV0IG1lc2hvcHREZWNvZGVyO1xuZXhwb3J0IGNvbnN0ICRsb2FkZXIgPSBTeW1ib2woJ2xvYWRlcicpO1xuZXhwb3J0IGNvbnN0ICRldmljdGlvblBvbGljeSA9IFN5bWJvbCgnZXZpY3Rpb25Qb2xpY3knKTtcbmNvbnN0ICRHTFRGSW5zdGFuY2UgPSBTeW1ib2woJ0dMVEZJbnN0YW5jZScpO1xuZXhwb3J0IGNsYXNzIENhY2hpbmdHTFRGTG9hZGVyIGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3RvcihHTFRGSW5zdGFuY2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpc1tfYl0gPSBuZXcgR0xURkxvYWRlcigpLnJlZ2lzdGVyKHBhcnNlciA9PiBuZXcgR0xURk1hdGVyaWFsc1ZhcmlhbnRzRXh0ZW5zaW9uKHBhcnNlcikpO1xuICAgICAgICB0aGlzWyRHTFRGSW5zdGFuY2VdID0gR0xURkluc3RhbmNlO1xuICAgICAgICB0aGlzWyRsb2FkZXJdLnNldERSQUNPTG9hZGVyKGRyYWNvTG9hZGVyKTtcbiAgICAgICAgdGhpc1skbG9hZGVyXS5zZXRLVFgyTG9hZGVyKGt0eDJMb2FkZXIpO1xuICAgIH1cbiAgICBzdGF0aWMgc2V0RFJBQ09EZWNvZGVyTG9jYXRpb24odXJsKSB7XG4gICAgICAgIGRyYWNvRGVjb2RlckxvY2F0aW9uID0gdXJsO1xuICAgICAgICBkcmFjb0xvYWRlci5zZXREZWNvZGVyUGF0aCh1cmwpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0RFJBQ09EZWNvZGVyTG9jYXRpb24oKSB7XG4gICAgICAgIHJldHVybiBkcmFjb0RlY29kZXJMb2NhdGlvbjtcbiAgICB9XG4gICAgc3RhdGljIHNldEtUWDJUcmFuc2NvZGVyTG9jYXRpb24odXJsKSB7XG4gICAgICAgIGt0eDJUcmFuc2NvZGVyTG9jYXRpb24gPSB1cmw7XG4gICAgICAgIGt0eDJMb2FkZXIuc2V0VHJhbnNjb2RlclBhdGgodXJsKTtcbiAgICB9XG4gICAgc3RhdGljIGdldEtUWDJUcmFuc2NvZGVyTG9jYXRpb24oKSB7XG4gICAgICAgIHJldHVybiBrdHgyVHJhbnNjb2RlckxvY2F0aW9uO1xuICAgIH1cbiAgICBzdGF0aWMgc2V0TWVzaG9wdERlY29kZXJMb2NhdGlvbih1cmwpIHtcbiAgICAgICAgaWYgKG1lc2hvcHREZWNvZGVyTG9jYXRpb24gIT09IHVybCkge1xuICAgICAgICAgICAgbWVzaG9wdERlY29kZXJMb2NhdGlvbiA9IHVybDtcbiAgICAgICAgICAgIG1lc2hvcHREZWNvZGVyID0gZmV0Y2hTY3JpcHQodXJsKVxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IE1lc2hvcHREZWNvZGVyLnJlYWR5KVxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IE1lc2hvcHREZWNvZGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZ2V0TWVzaG9wdERlY29kZXJMb2NhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG1lc2hvcHREZWNvZGVyTG9jYXRpb247XG4gICAgfVxuICAgIHN0YXRpYyBpbml0aWFsaXplS1RYMkxvYWRlcihyZW5kZXJlcikge1xuICAgICAgICBrdHgyTG9hZGVyLmRldGVjdFN1cHBvcnQocmVuZGVyZXIpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IGNhY2hlKCkge1xuICAgICAgICByZXR1cm4gY2FjaGU7XG4gICAgfVxuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIHN0YXRpYyBjbGVhckNhY2hlKCkge1xuICAgICAgICBjYWNoZS5mb3JFYWNoKChfdmFsdWUsIHVybCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kZWxldGUodXJsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXNbJGV2aWN0aW9uUG9saWN5XS5yZXNldCgpO1xuICAgIH1cbiAgICBzdGF0aWMgaGFzKHVybCkge1xuICAgICAgICByZXR1cm4gY2FjaGUuaGFzKHVybCk7XG4gICAgfVxuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIHN0YXRpYyBhc3luYyBkZWxldGUodXJsKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXModXJsKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGdsdGZMb2FkcyA9IGNhY2hlLmdldCh1cmwpO1xuICAgICAgICBwcmVsb2FkZWQuZGVsZXRlKHVybCk7XG4gICAgICAgIGNhY2hlLmRlbGV0ZSh1cmwpO1xuICAgICAgICBjb25zdCBnbHRmID0gYXdhaXQgZ2x0ZkxvYWRzO1xuICAgICAgICAvLyBEaXNwb3NlIG9mIHRoZSBjYWNoZWQgZ2xURidzIG1hdGVyaWFscyBhbmQgZ2VvbWV0cmllczpcbiAgICAgICAgZ2x0Zi5kaXNwb3NlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgbW9kZWwgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgc3BlY2lmaWVkIHVybCBpc1xuICAgICAqIGF2YWlsYWJsZSBpbiBvdXIgbG9jYWwgY2FjaGUuXG4gICAgICovXG4gICAgc3RhdGljIGhhc0ZpbmlzaGVkTG9hZGluZyh1cmwpIHtcbiAgICAgICAgcmV0dXJuICEhcHJlbG9hZGVkLmdldCh1cmwpO1xuICAgIH1cbiAgICBnZXQgWyhfYSA9ICRldmljdGlvblBvbGljeSwgX2IgPSAkbG9hZGVyLCAkZXZpY3Rpb25Qb2xpY3kpXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3JbJGV2aWN0aW9uUG9saWN5XTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJlbG9hZHMgYSBnbFRGLCBwb3B1bGF0aW5nIHRoZSBjYWNoZS4gUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlc1xuICAgICAqIHdoZW4gdGhlIGNhY2hlIGlzIHBvcHVsYXRlZC5cbiAgICAgKi9cbiAgICBhc3luYyBwcmVsb2FkKHVybCwgZWxlbWVudCwgcHJvZ3Jlc3NDYWxsYmFjayA9ICgpID0+IHsgfSkge1xuICAgICAgICB0aGlzWyRsb2FkZXJdLnNldFdpdGhDcmVkZW50aWFscyhDYWNoaW5nR0xURkxvYWRlci53aXRoQ3JlZGVudGlhbHMpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoeyB0eXBlOiAncHJlbG9hZCcsIGVsZW1lbnQ6IGVsZW1lbnQsIHNyYzogdXJsIH0pO1xuICAgICAgICBpZiAoIWNhY2hlLmhhcyh1cmwpKSB7XG4gICAgICAgICAgICBpZiAobWVzaG9wdERlY29kZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXNbJGxvYWRlcl0uc2V0TWVzaG9wdERlY29kZXIoYXdhaXQgbWVzaG9wdERlY29kZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmF3R0xURkxvYWRzID0gbG9hZFdpdGhMb2FkZXIodXJsLCB0aGlzWyRsb2FkZXJdLCAocHJvZ3Jlc3MpID0+IHtcbiAgICAgICAgICAgICAgICBwcm9ncmVzc0NhbGxiYWNrKHByb2dyZXNzICogMC44KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgR0xURkluc3RhbmNlID0gdGhpc1skR0xURkluc3RhbmNlXTtcbiAgICAgICAgICAgIGNvbnN0IGdsdGZJbnN0YW5jZUxvYWRzID0gcmF3R0xURkxvYWRzXG4gICAgICAgICAgICAgICAgLnRoZW4oKHJhd0dMVEYpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gR0xURkluc3RhbmNlLnByZXBhcmUocmF3R0xURik7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChwcmVwYXJlZEdMVEYpID0+IHtcbiAgICAgICAgICAgICAgICBwcm9ncmVzc0NhbGxiYWNrKDAuOSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBHTFRGSW5zdGFuY2UocHJlcGFyZWRHTFRGKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKChyZWFzb24gPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IocmVhc29uKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEdMVEZJbnN0YW5jZSgpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgY2FjaGUuc2V0KHVybCwgZ2x0Zkluc3RhbmNlTG9hZHMpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGNhY2hlLmdldCh1cmwpO1xuICAgICAgICBwcmVsb2FkZWQuc2V0KHVybCwgdHJ1ZSk7XG4gICAgICAgIGlmIChwcm9ncmVzc0NhbGxiYWNrKSB7XG4gICAgICAgICAgICBwcm9ncmVzc0NhbGxiYWNrKDEuMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9hZHMgYSBnbFRGIGZyb20gdGhlIHNwZWNpZmllZCB1cmwgYW5kIHJlc29sdmVzIGEgdW5pcXVlIGNsb25lIG9mIHRoZVxuICAgICAqIGdsVEYuIElmIHRoZSBnbFRGIGhhcyBhbHJlYWR5IGJlZW4gbG9hZGVkLCBtYWtlcyBhIGNsb25lIG9mIHRoZSBjYWNoZWRcbiAgICAgKiBjb3B5LlxuICAgICAqL1xuICAgIGFzeW5jIGxvYWQodXJsLCBlbGVtZW50LCBwcm9ncmVzc0NhbGxiYWNrID0gKCkgPT4geyB9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMucHJlbG9hZCh1cmwsIGVsZW1lbnQsIHByb2dyZXNzQ2FsbGJhY2spO1xuICAgICAgICBjb25zdCBnbHRmID0gYXdhaXQgY2FjaGUuZ2V0KHVybCk7XG4gICAgICAgIGNvbnN0IGNsb25lID0gYXdhaXQgZ2x0Zi5jbG9uZSgpO1xuICAgICAgICB0aGlzWyRldmljdGlvblBvbGljeV0ucmV0YWluKHVybCk7XG4gICAgICAgIC8vIFBhdGNoIGRpc3Bvc2Ugc28gdGhhdCB3ZSBjYW4gcHJvcGVybHkgYWNjb3VudCBmb3IgaW5zdGFuY2UgdXNlXG4gICAgICAgIC8vIGluIHRoZSBjYWNoaW5nIGxheWVyOlxuICAgICAgICBjbG9uZS5kaXNwb3NlID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpc1skZXZpY3Rpb25Qb2xpY3ldLnJlbGVhc2UodXJsKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH1cbn1cbkNhY2hpbmdHTFRGTG9hZGVyW19hXSA9IG5ldyBDYWNoZUV2aWN0aW9uUG9saWN5KENhY2hpbmdHTFRGTG9hZGVyKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNhY2hpbmdHTFRGTG9hZGVyLmpzLm1hcCIsIi8qIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICdMaWNlbnNlJyk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gJ0FTIElTJyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmV4cG9ydCBjb25zdCBTRVRUTElOR19USU1FID0gMTAwMDA7IC8vIHBsZW50eSBsb25nIGVub3VnaFxuY29uc3QgTUlOX0RFQ0FZX01JTExJU0VDT05EUyA9IDAuMDAxO1xuZXhwb3J0IGNvbnN0IERFQ0FZX01JTExJU0VDT05EUyA9IDUwO1xuLyoqXG4gKiBUaGUgRGFtcGVyIGNsYXNzIGlzIGEgZ2VuZXJpYyBzZWNvbmQtb3JkZXIgY3JpdGljYWxseSBkYW1wZWQgc3lzdGVtIHRoYXQgZG9lc1xuICogb25lIGxpbmVhciBzdGVwIG9mIHRoZSBkZXNpcmVkIGxlbmd0aCBvZiB0aW1lLiBUaGUgb25seSBwYXJhbWV0ZXIgaXNcbiAqIERFQ0FZX01JTExJU0VDT05EUy4gVGhpcyBjb21tb24gcGFyYW1ldGVyIG1ha2VzIGFsbCBzdGF0ZXMgY29udmVyZ2UgYXQgdGhlXG4gKiBzYW1lIHJhdGUgcmVnYXJkbGVzcyBvZiBzY2FsZS4geE5vcm1hbGl6YXRpb24gaXMgYSBudW1iZXIgdG8gcHJvdmlkZSB0aGVcbiAqIHJvdWdoIHNjYWxlIG9mIHgsIHN1Y2ggdGhhdCBOSUxfU1BFRUQgY2xhbXBpbmcgYWxzbyBoYXBwZW5zIGF0IHJvdWdobHkgdGhlXG4gKiBzYW1lIGNvbnZlcmdlbmNlIGZvciBhbGwgc3RhdGVzLlxuICovXG5leHBvcnQgY2xhc3MgRGFtcGVyIHtcbiAgICBjb25zdHJ1Y3RvcihkZWNheU1pbGxpc2Vjb25kcyA9IERFQ0FZX01JTExJU0VDT05EUykge1xuICAgICAgICB0aGlzLnZlbG9jaXR5ID0gMDtcbiAgICAgICAgdGhpcy5uYXR1cmFsRnJlcXVlbmN5ID0gMDtcbiAgICAgICAgdGhpcy5zZXREZWNheVRpbWUoZGVjYXlNaWxsaXNlY29uZHMpO1xuICAgIH1cbiAgICBzZXREZWNheVRpbWUoZGVjYXlNaWxsaXNlY29uZHMpIHtcbiAgICAgICAgdGhpcy5uYXR1cmFsRnJlcXVlbmN5ID1cbiAgICAgICAgICAgIDEgLyBNYXRoLm1heChNSU5fREVDQVlfTUlMTElTRUNPTkRTLCBkZWNheU1pbGxpc2Vjb25kcyk7XG4gICAgfVxuICAgIHVwZGF0ZSh4LCB4R29hbCwgdGltZVN0ZXBNaWxsaXNlY29uZHMsIHhOb3JtYWxpemF0aW9uKSB7XG4gICAgICAgIGNvbnN0IG5pbFNwZWVkID0gMC4wMDAyICogdGhpcy5uYXR1cmFsRnJlcXVlbmN5O1xuICAgICAgICBpZiAoeCA9PSBudWxsIHx8IHhOb3JtYWxpemF0aW9uID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4geEdvYWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHggPT09IHhHb2FsICYmIHRoaXMudmVsb2NpdHkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB4R29hbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZVN0ZXBNaWxsaXNlY29uZHMgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfVxuICAgICAgICAvLyBFeGFjdCBzb2x1dGlvbiB0byBhIGNyaXRpY2FsbHkgZGFtcGVkIHNlY29uZC1vcmRlciBzeXN0ZW0sIHdoZXJlOlxuICAgICAgICAvLyBhY2NlbGVyYXRpb24gPSB0aGlzLm5hdHVyYWxGcmVxdWVuY3kgKiB0aGlzLm5hdHVyYWxGcmVxdWVuY3kgKiAoeEdvYWxcbiAgICAgICAgLy8gLSB4KSAtIDIgKiB0aGlzLm5hdHVyYWxGcmVxdWVuY3kgKiB0aGlzLnZlbG9jaXR5O1xuICAgICAgICBjb25zdCBkZWx0YVggPSAoeCAtIHhHb2FsKTtcbiAgICAgICAgY29uc3QgaW50ZXJtZWRpYXRlVmVsb2NpdHkgPSB0aGlzLnZlbG9jaXR5ICsgdGhpcy5uYXR1cmFsRnJlcXVlbmN5ICogZGVsdGFYO1xuICAgICAgICBjb25zdCBpbnRlcm1lZGlhdGVYID0gZGVsdGFYICsgdGltZVN0ZXBNaWxsaXNlY29uZHMgKiBpbnRlcm1lZGlhdGVWZWxvY2l0eTtcbiAgICAgICAgY29uc3QgZGVjYXkgPSBNYXRoLmV4cCgtdGhpcy5uYXR1cmFsRnJlcXVlbmN5ICogdGltZVN0ZXBNaWxsaXNlY29uZHMpO1xuICAgICAgICBjb25zdCBuZXdWZWxvY2l0eSA9IChpbnRlcm1lZGlhdGVWZWxvY2l0eSAtIHRoaXMubmF0dXJhbEZyZXF1ZW5jeSAqIGludGVybWVkaWF0ZVgpICogZGVjYXk7XG4gICAgICAgIGNvbnN0IGFjY2VsZXJhdGlvbiA9IC10aGlzLm5hdHVyYWxGcmVxdWVuY3kgKiAobmV3VmVsb2NpdHkgKyBpbnRlcm1lZGlhdGVWZWxvY2l0eSAqIGRlY2F5KTtcbiAgICAgICAgaWYgKE1hdGguYWJzKG5ld1ZlbG9jaXR5KSA8IG5pbFNwZWVkICogTWF0aC5hYnMoeE5vcm1hbGl6YXRpb24pICYmXG4gICAgICAgICAgICBhY2NlbGVyYXRpb24gKiBkZWx0YVggPj0gMCkge1xuICAgICAgICAgICAgLy8gVGhpcyBlbnN1cmVzIHRoZSBjb250cm9scyBzZXR0bGUgYW5kIHN0b3AgY2FsbGluZyB0aGlzIGZ1bmN0aW9uIGluc3RlYWRcbiAgICAgICAgICAgIC8vIG9mIGFzeW1wdG90aWNhbGx5IGFwcHJvYWNoaW5nIHRoZWlyIGdvYWwuXG4gICAgICAgICAgICB0aGlzLnZlbG9jaXR5ID0gMDtcbiAgICAgICAgICAgIHJldHVybiB4R29hbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmVsb2NpdHkgPSBuZXdWZWxvY2l0eTtcbiAgICAgICAgICAgIHJldHVybiB4R29hbCArIGludGVybWVkaWF0ZVggKiBkZWNheTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURhbXBlci5qcy5tYXAiLCIvKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAnTGljZW5zZScpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICdBUyBJUycgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBNZXNoLCBPcnRob2dyYXBoaWNDYW1lcmEsIFBsYW5lR2VvbWV0cnksIFNjZW5lLCBTaGFkZXJNYXRlcmlhbCwgVGV4dHVyZSwgV2ViR0xSZW5kZXJUYXJnZXQgfSBmcm9tICd0aHJlZSc7XG4vKipcbiAqIFRoaXMgRGVidWdnZXIgZXhwb3NlcyBpbnRlcm5hbCBkZXRhaWxzIG9mIHRoZSA8bW9kZWwtdmlld2VyPiByZW5kZXJpbmdcbiAqIHN1YnN0cnVjdHVyZSBzbyB0aGF0IGV4dGVybmFsIHRvb2xzIGNhbiBtb3JlIGVhc2lseSBpbnNwZWN0IGFuZCBvcGVyYXRlIG9uXG4gKiB0aGVtLlxuICpcbiAqIEl0IGFsc28gYWN0aXZhdGVzIHNoYWRlciBkZWJ1Z2dpbmcgb24gdGhlIGFzc29jaWF0ZWQgR0wgY29udGV4dC4gU2hhZGVyXG4gKiBkZWJ1Z2dpbmcgdHJhZGVzIHBlcmZvcm1hbmNlIGZvciB1c2VmdWwgZXJyb3IgaW5mb3JtYXRpb24sIHNvIGl0IGlzIG5vdFxuICogcmVjb21tZW5kZWQgdG8gYWN0aXZhdGUgdGhpcyB1bmxlc3MgbmVlZGVkLlxuICovXG5leHBvcnQgY2xhc3MgRGVidWdnZXIge1xuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgICAgIC8vIEZvcmNlIFdlYkdMIHNoYWRlciBkZWJ1Z2dpbmcgb246XG4gICAgICAgIHJlbmRlcmVyLnRocmVlUmVuZGVyZXIuZGVidWcgPSB7IGNoZWNrU2hhZGVyRXJyb3JzOiB0cnVlIH07XG4gICAgICAgIC8vIEFubm91bmNlIGRlYnVnIGRldGFpbHMgYXQgbWljcm90YXNrIHRpbWluZyB0byBnaXZlIHRoZSBgUmVuZGVyZXJgXG4gICAgICAgIC8vIGNvbnN0cnVjdG9yIHRpbWUgdG8gY29tcGxldGUgaXRzIGluaXRpYWxpemF0aW9uLCBqdXN0IHRvIGJlIG9uIHRoZSBzYWZlXG4gICAgICAgIC8vIHNpZGU6XG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnbW9kZWwtdmlld2VyLXJlbmRlcmVyLWRlYnVnJywge1xuICAgICAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJlcixcbiAgICAgICAgICAgICAgICAgICAgVEhSRUU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFNoYWRlck1hdGVyaWFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgVGV4dHVyZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIE1lc2gsXG4gICAgICAgICAgICAgICAgICAgICAgICBTY2VuZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFBsYW5lR2VvbWV0cnksXG4gICAgICAgICAgICAgICAgICAgICAgICBPcnRob2dyYXBoaWNDYW1lcmEsXG4gICAgICAgICAgICAgICAgICAgICAgICBXZWJHTFJlbmRlclRhcmdldFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYWRkU2NlbmUoc2NlbmUpIHtcbiAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnbW9kZWwtdmlld2VyLXNjZW5lLWFkZGVkLWRlYnVnJywgeyBkZXRhaWw6IHsgc2NlbmUgfSB9KSk7XG4gICAgfVxuICAgIHJlbW92ZVNjZW5lKHNjZW5lKSB7XG4gICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ21vZGVsLXZpZXdlci1zY2VuZS1yZW1vdmVkLWRlYnVnJywgeyBkZXRhaWw6IHsgc2NlbmUgfSB9KSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGVidWdnZXIuanMubWFwIiwiLyogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgJ0xpY2Vuc2UnKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAnQVMgSVMnIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgQmFja1NpZGUsIEJveEdlb21ldHJ5LCBNZXNoLCBNZXNoQmFzaWNNYXRlcmlhbCwgTWVzaFN0YW5kYXJkTWF0ZXJpYWwsIFBvaW50TGlnaHQsIFNjZW5lIH0gZnJvbSAndGhyZWUnO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRW52aXJvbm1lbnRTY2VuZSBleHRlbmRzIFNjZW5lIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbi55ID0gLTMuNTtcbiAgICAgICAgY29uc3QgZ2VvbWV0cnkgPSBuZXcgQm94R2VvbWV0cnkoKTtcbiAgICAgICAgZ2VvbWV0cnkuZGVsZXRlQXR0cmlidXRlKCd1dicpO1xuICAgICAgICBjb25zdCByb29tTWF0ZXJpYWwgPSBuZXcgTWVzaFN0YW5kYXJkTWF0ZXJpYWwoeyBtZXRhbG5lc3M6IDAsIHNpZGU6IEJhY2tTaWRlIH0pO1xuICAgICAgICBjb25zdCBib3hNYXRlcmlhbCA9IG5ldyBNZXNoU3RhbmRhcmRNYXRlcmlhbCh7IG1ldGFsbmVzczogMCB9KTtcbiAgICAgICAgY29uc3QgbWFpbkxpZ2h0ID0gbmV3IFBvaW50TGlnaHQoMHhmZmZmZmYsIDUwMC4wLCAyOCwgMik7XG4gICAgICAgIG1haW5MaWdodC5wb3NpdGlvbi5zZXQoMC40MTgsIDE2LjE5OSwgMC4zMDApO1xuICAgICAgICB0aGlzLmFkZChtYWluTGlnaHQpO1xuICAgICAgICBjb25zdCByb29tID0gbmV3IE1lc2goZ2VvbWV0cnksIHJvb21NYXRlcmlhbCk7XG4gICAgICAgIHJvb20ucG9zaXRpb24uc2V0KC0wLjc1NywgMTMuMjE5LCAwLjcxNyk7XG4gICAgICAgIHJvb20uc2NhbGUuc2V0KDMxLjcxMywgMjguMzA1LCAyOC41OTEpO1xuICAgICAgICB0aGlzLmFkZChyb29tKTtcbiAgICAgICAgY29uc3QgYm94MSA9IG5ldyBNZXNoKGdlb21ldHJ5LCBib3hNYXRlcmlhbCk7XG4gICAgICAgIGJveDEucG9zaXRpb24uc2V0KC0xMC45MDYsIDIuMDA5LCAxLjg0Nik7XG4gICAgICAgIGJveDEucm90YXRpb24uc2V0KDAsIC0wLjE5NSwgMCk7XG4gICAgICAgIGJveDEuc2NhbGUuc2V0KDIuMzI4LCA3LjkwNSwgNC42NTEpO1xuICAgICAgICB0aGlzLmFkZChib3gxKTtcbiAgICAgICAgY29uc3QgYm94MiA9IG5ldyBNZXNoKGdlb21ldHJ5LCBib3hNYXRlcmlhbCk7XG4gICAgICAgIGJveDIucG9zaXRpb24uc2V0KC01LjYwNywgLTAuNzU0LCAtMC43NTgpO1xuICAgICAgICBib3gyLnJvdGF0aW9uLnNldCgwLCAwLjk5NCwgMCk7XG4gICAgICAgIGJveDIuc2NhbGUuc2V0KDEuOTcwLCAxLjUzNCwgMy45NTUpO1xuICAgICAgICB0aGlzLmFkZChib3gyKTtcbiAgICAgICAgY29uc3QgYm94MyA9IG5ldyBNZXNoKGdlb21ldHJ5LCBib3hNYXRlcmlhbCk7XG4gICAgICAgIGJveDMucG9zaXRpb24uc2V0KDYuMTY3LCAwLjg1NywgNy44MDMpO1xuICAgICAgICBib3gzLnJvdGF0aW9uLnNldCgwLCAwLjU2MSwgMCk7XG4gICAgICAgIGJveDMuc2NhbGUuc2V0KDMuOTI3LCA2LjI4NSwgMy42ODcpO1xuICAgICAgICB0aGlzLmFkZChib3gzKTtcbiAgICAgICAgY29uc3QgYm94NCA9IG5ldyBNZXNoKGdlb21ldHJ5LCBib3hNYXRlcmlhbCk7XG4gICAgICAgIGJveDQucG9zaXRpb24uc2V0KC0yLjAxNywgMC4wMTgsIDYuMTI0KTtcbiAgICAgICAgYm94NC5yb3RhdGlvbi5zZXQoMCwgMC4zMzMsIDApO1xuICAgICAgICBib3g0LnNjYWxlLnNldCgyLjAwMiwgNC41NjYsIDIuMDY0KTtcbiAgICAgICAgdGhpcy5hZGQoYm94NCk7XG4gICAgICAgIGNvbnN0IGJveDUgPSBuZXcgTWVzaChnZW9tZXRyeSwgYm94TWF0ZXJpYWwpO1xuICAgICAgICBib3g1LnBvc2l0aW9uLnNldCgyLjI5MSwgLTAuNzU2LCAtMi42MjEpO1xuICAgICAgICBib3g1LnJvdGF0aW9uLnNldCgwLCAtMC4yODYsIDApO1xuICAgICAgICBib3g1LnNjYWxlLnNldCgxLjU0NiwgMS41NTIsIDEuNDk2KTtcbiAgICAgICAgdGhpcy5hZGQoYm94NSk7XG4gICAgICAgIGNvbnN0IGJveDYgPSBuZXcgTWVzaChnZW9tZXRyeSwgYm94TWF0ZXJpYWwpO1xuICAgICAgICBib3g2LnBvc2l0aW9uLnNldCgtMi4xOTMsIC0wLjM2OSwgLTUuNTQ3KTtcbiAgICAgICAgYm94Ni5yb3RhdGlvbi5zZXQoMCwgMC41MTYsIDApO1xuICAgICAgICBib3g2LnNjYWxlLnNldCgzLjg3NSwgMy40ODcsIDIuOTg2KTtcbiAgICAgICAgdGhpcy5hZGQoYm94Nik7XG4gICAgICAgIC8vIC14IHJpZ2h0XG4gICAgICAgIGNvbnN0IGxpZ2h0MSA9IG5ldyBNZXNoKGdlb21ldHJ5LCB0aGlzLmNyZWF0ZUFyZWFMaWdodE1hdGVyaWFsKDUwKSk7XG4gICAgICAgIGxpZ2h0MS5wb3NpdGlvbi5zZXQoLTE2LjExNiwgMTQuMzcsIDguMjA4KTtcbiAgICAgICAgbGlnaHQxLnNjYWxlLnNldCgwLjEsIDIuNDI4LCAyLjczOSk7XG4gICAgICAgIHRoaXMuYWRkKGxpZ2h0MSk7XG4gICAgICAgIC8vIC14IGxlZnRcbiAgICAgICAgY29uc3QgbGlnaHQyID0gbmV3IE1lc2goZ2VvbWV0cnksIHRoaXMuY3JlYXRlQXJlYUxpZ2h0TWF0ZXJpYWwoNTApKTtcbiAgICAgICAgbGlnaHQyLnBvc2l0aW9uLnNldCgtMTYuMTA5LCAxOC4wMjEsIC04LjIwNyk7XG4gICAgICAgIGxpZ2h0Mi5zY2FsZS5zZXQoMC4xLCAyLjQyNSwgMi43NTEpO1xuICAgICAgICB0aGlzLmFkZChsaWdodDIpO1xuICAgICAgICAvLyAreFxuICAgICAgICBjb25zdCBsaWdodDMgPSBuZXcgTWVzaChnZW9tZXRyeSwgdGhpcy5jcmVhdGVBcmVhTGlnaHRNYXRlcmlhbCgxNykpO1xuICAgICAgICBsaWdodDMucG9zaXRpb24uc2V0KDE0LjkwNCwgMTIuMTk4LCAtMS44MzIpO1xuICAgICAgICBsaWdodDMuc2NhbGUuc2V0KDAuMTUsIDQuMjY1LCA2LjMzMSk7XG4gICAgICAgIHRoaXMuYWRkKGxpZ2h0Myk7XG4gICAgICAgIC8vICt6XG4gICAgICAgIGNvbnN0IGxpZ2h0NCA9IG5ldyBNZXNoKGdlb21ldHJ5LCB0aGlzLmNyZWF0ZUFyZWFMaWdodE1hdGVyaWFsKDQzKSk7XG4gICAgICAgIGxpZ2h0NC5wb3NpdGlvbi5zZXQoLTAuNDYyLCA4Ljg5LCAxNC41MjApO1xuICAgICAgICBsaWdodDQuc2NhbGUuc2V0KDQuMzgsIDUuNDQxLCAwLjA4OCk7XG4gICAgICAgIHRoaXMuYWRkKGxpZ2h0NCk7XG4gICAgICAgIC8vIC16XG4gICAgICAgIGNvbnN0IGxpZ2h0NSA9IG5ldyBNZXNoKGdlb21ldHJ5LCB0aGlzLmNyZWF0ZUFyZWFMaWdodE1hdGVyaWFsKDIwKSk7XG4gICAgICAgIGxpZ2h0NS5wb3NpdGlvbi5zZXQoMy4yMzUsIDExLjQ4NiwgLTEyLjU0MSk7XG4gICAgICAgIGxpZ2h0NS5zY2FsZS5zZXQoMi41LCAyLjAsIDAuMSk7XG4gICAgICAgIHRoaXMuYWRkKGxpZ2h0NSk7XG4gICAgICAgIC8vICt5XG4gICAgICAgIGNvbnN0IGxpZ2h0NiA9IG5ldyBNZXNoKGdlb21ldHJ5LCB0aGlzLmNyZWF0ZUFyZWFMaWdodE1hdGVyaWFsKDEwMCkpO1xuICAgICAgICBsaWdodDYucG9zaXRpb24uc2V0KDAuMCwgMjAuMCwgMC4wKTtcbiAgICAgICAgbGlnaHQ2LnNjYWxlLnNldCgxLjAsIDAuMSwgMS4wKTtcbiAgICAgICAgdGhpcy5hZGQobGlnaHQ2KTtcbiAgICB9XG4gICAgY3JlYXRlQXJlYUxpZ2h0TWF0ZXJpYWwoaW50ZW5zaXR5KSB7XG4gICAgICAgIGNvbnN0IG1hdGVyaWFsID0gbmV3IE1lc2hCYXNpY01hdGVyaWFsKCk7XG4gICAgICAgIG1hdGVyaWFsLmNvbG9yLnNldFNjYWxhcihpbnRlbnNpdHkpO1xuICAgICAgICByZXR1cm4gbWF0ZXJpYWw7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RW52aXJvbm1lbnRTY2VuZS5qcy5tYXAiLCIvKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAnTGljZW5zZScpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICdBUyBJUycgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBCYWNrU2lkZSwgQm94R2VvbWV0cnksIE1lc2gsIE1lc2hCYXNpY01hdGVyaWFsLCBNZXNoU3RhbmRhcmRNYXRlcmlhbCwgUG9pbnRMaWdodCwgU2NlbmUgfSBmcm9tICd0aHJlZSc7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbnZpcm9ubWVudFNjZW5lQWx0IGV4dGVuZHMgU2NlbmUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uLnkgPSAtMy41O1xuICAgICAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyBCb3hHZW9tZXRyeSgpO1xuICAgICAgICBnZW9tZXRyeS5kZWxldGVBdHRyaWJ1dGUoJ3V2Jyk7XG4gICAgICAgIGNvbnN0IHJvb21NYXRlcmlhbCA9IG5ldyBNZXNoU3RhbmRhcmRNYXRlcmlhbCh7IG1ldGFsbmVzczogMCwgc2lkZTogQmFja1NpZGUgfSk7XG4gICAgICAgIGNvbnN0IGJveE1hdGVyaWFsID0gbmV3IE1lc2hTdGFuZGFyZE1hdGVyaWFsKHsgbWV0YWxuZXNzOiAwIH0pO1xuICAgICAgICBjb25zdCBtYWluTGlnaHQgPSBuZXcgUG9pbnRMaWdodCgweGZmZmZmZiwgNDAwLjAsIDI4LCAyKTtcbiAgICAgICAgbWFpbkxpZ2h0LnBvc2l0aW9uLnNldCgwLjUsIDE0LjAsIDAuNSk7XG4gICAgICAgIHRoaXMuYWRkKG1haW5MaWdodCk7XG4gICAgICAgIGNvbnN0IHJvb20gPSBuZXcgTWVzaChnZW9tZXRyeSwgcm9vbU1hdGVyaWFsKTtcbiAgICAgICAgcm9vbS5wb3NpdGlvbi5zZXQoMC4wLCAxMy4yLCAwLjApO1xuICAgICAgICByb29tLnNjYWxlLnNldCgzMS41LCAyOC41LCAzMS41KTtcbiAgICAgICAgdGhpcy5hZGQocm9vbSk7XG4gICAgICAgIGNvbnN0IGJveDEgPSBuZXcgTWVzaChnZW9tZXRyeSwgYm94TWF0ZXJpYWwpO1xuICAgICAgICBib3gxLnBvc2l0aW9uLnNldCgtMTAuOTA2LCAtMS4wLCAxLjg0Nik7XG4gICAgICAgIGJveDEucm90YXRpb24uc2V0KDAsIC0wLjE5NSwgMCk7XG4gICAgICAgIGJveDEuc2NhbGUuc2V0KDIuMzI4LCA3LjkwNSwgNC42NTEpO1xuICAgICAgICB0aGlzLmFkZChib3gxKTtcbiAgICAgICAgY29uc3QgYm94MiA9IG5ldyBNZXNoKGdlb21ldHJ5LCBib3hNYXRlcmlhbCk7XG4gICAgICAgIGJveDIucG9zaXRpb24uc2V0KC01LjYwNywgLTAuNzU0LCAtMC43NTgpO1xuICAgICAgICBib3gyLnJvdGF0aW9uLnNldCgwLCAwLjk5NCwgMCk7XG4gICAgICAgIGJveDIuc2NhbGUuc2V0KDEuOTcwLCAxLjUzNCwgMy45NTUpO1xuICAgICAgICB0aGlzLmFkZChib3gyKTtcbiAgICAgICAgY29uc3QgYm94MyA9IG5ldyBNZXNoKGdlb21ldHJ5LCBib3hNYXRlcmlhbCk7XG4gICAgICAgIGJveDMucG9zaXRpb24uc2V0KDYuMTY3LCAtMC4xNiwgNy44MDMpO1xuICAgICAgICBib3gzLnJvdGF0aW9uLnNldCgwLCAwLjU2MSwgMCk7XG4gICAgICAgIGJveDMuc2NhbGUuc2V0KDMuOTI3LCA2LjI4NSwgMy42ODcpO1xuICAgICAgICB0aGlzLmFkZChib3gzKTtcbiAgICAgICAgY29uc3QgYm94NCA9IG5ldyBNZXNoKGdlb21ldHJ5LCBib3hNYXRlcmlhbCk7XG4gICAgICAgIGJveDQucG9zaXRpb24uc2V0KC0yLjAxNywgMC4wMTgsIDYuMTI0KTtcbiAgICAgICAgYm94NC5yb3RhdGlvbi5zZXQoMCwgMC4zMzMsIDApO1xuICAgICAgICBib3g0LnNjYWxlLnNldCgyLjAwMiwgNC41NjYsIDIuMDY0KTtcbiAgICAgICAgdGhpcy5hZGQoYm94NCk7XG4gICAgICAgIGNvbnN0IGJveDUgPSBuZXcgTWVzaChnZW9tZXRyeSwgYm94TWF0ZXJpYWwpO1xuICAgICAgICBib3g1LnBvc2l0aW9uLnNldCgyLjI5MSwgLTAuNzU2LCAtMi42MjEpO1xuICAgICAgICBib3g1LnJvdGF0aW9uLnNldCgwLCAtMC4yODYsIDApO1xuICAgICAgICBib3g1LnNjYWxlLnNldCgxLjU0NiwgMS41NTIsIDEuNDk2KTtcbiAgICAgICAgdGhpcy5hZGQoYm94NSk7XG4gICAgICAgIGNvbnN0IGJveDYgPSBuZXcgTWVzaChnZW9tZXRyeSwgYm94TWF0ZXJpYWwpO1xuICAgICAgICBib3g2LnBvc2l0aW9uLnNldCgtMi4xOTMsIC0wLjM2OSwgLTUuNTQ3KTtcbiAgICAgICAgYm94Ni5yb3RhdGlvbi5zZXQoMCwgMC41MTYsIDApO1xuICAgICAgICBib3g2LnNjYWxlLnNldCgzLjg3NSwgMy40ODcsIDIuOTg2KTtcbiAgICAgICAgdGhpcy5hZGQoYm94Nik7XG4gICAgICAgIC8vIC14X2xlZnRcbiAgICAgICAgY29uc3QgbGlnaHQxID0gbmV3IE1lc2goZ2VvbWV0cnksIHRoaXMuY3JlYXRlQXJlYUxpZ2h0TWF0ZXJpYWwoODApKTtcbiAgICAgICAgbGlnaHQxLnBvc2l0aW9uLnNldCgtMTQuMCwgMTAuMCwgOC4wKTtcbiAgICAgICAgbGlnaHQxLnNjYWxlLnNldCgwLjEsIDIuNSwgMi41KTtcbiAgICAgICAgdGhpcy5hZGQobGlnaHQxKTtcbiAgICAgICAgLy8gLXhfcmlnaHRcbiAgICAgICAgY29uc3QgbGlnaHQyID0gbmV3IE1lc2goZ2VvbWV0cnksIHRoaXMuY3JlYXRlQXJlYUxpZ2h0TWF0ZXJpYWwoODApKTtcbiAgICAgICAgbGlnaHQyLnBvc2l0aW9uLnNldCgtMTQuMCwgMTQuMCwgLTQuMCk7XG4gICAgICAgIGxpZ2h0Mi5zY2FsZS5zZXQoMC4xLCAyLjUsIDIuNSk7XG4gICAgICAgIHRoaXMuYWRkKGxpZ2h0Mik7XG4gICAgICAgIC8vICt4IG9ubHkgb24gbGlnaHRcbiAgICAgICAgY29uc3QgbGlnaHQzID0gbmV3IE1lc2goZ2VvbWV0cnksIHRoaXMuY3JlYXRlQXJlYUxpZ2h0TWF0ZXJpYWwoMjMpKTtcbiAgICAgICAgbGlnaHQzLnBvc2l0aW9uLnNldCgxNC4wLCAxMi4wLCAwLjApO1xuICAgICAgICBsaWdodDMuc2NhbGUuc2V0KDAuMSwgNS4wLCA1LjApO1xuICAgICAgICB0aGlzLmFkZChsaWdodDMpO1xuICAgICAgICAvLyArelxuICAgICAgICBjb25zdCBsaWdodDQgPSBuZXcgTWVzaChnZW9tZXRyeSwgdGhpcy5jcmVhdGVBcmVhTGlnaHRNYXRlcmlhbCgxNikpO1xuICAgICAgICBsaWdodDQucG9zaXRpb24uc2V0KDAuMCwgOS4wLCAxNC4wKTtcbiAgICAgICAgbGlnaHQ0LnNjYWxlLnNldCg1LjAsIDUuMCwgMC4xKTtcbiAgICAgICAgdGhpcy5hZGQobGlnaHQ0KTtcbiAgICAgICAgLy8gLXogcmlnaHRcbiAgICAgICAgY29uc3QgbGlnaHQ1ID0gbmV3IE1lc2goZ2VvbWV0cnksIHRoaXMuY3JlYXRlQXJlYUxpZ2h0TWF0ZXJpYWwoODApKTtcbiAgICAgICAgbGlnaHQ1LnBvc2l0aW9uLnNldCg3LjAsIDguMCwgLTE0LjApO1xuICAgICAgICBsaWdodDUuc2NhbGUuc2V0KDIuNSwgMi41LCAwLjEpO1xuICAgICAgICB0aGlzLmFkZChsaWdodDUpO1xuICAgICAgICAvLyAteiBsZWZ0XG4gICAgICAgIGNvbnN0IGxpZ2h0NiA9IG5ldyBNZXNoKGdlb21ldHJ5LCB0aGlzLmNyZWF0ZUFyZWFMaWdodE1hdGVyaWFsKDgwKSk7XG4gICAgICAgIGxpZ2h0Ni5wb3NpdGlvbi5zZXQoLTcuMCwgMTYuMCwgLTE0LjApO1xuICAgICAgICBsaWdodDYuc2NhbGUuc2V0KDIuNSwgMi41LCAwLjEpO1xuICAgICAgICB0aGlzLmFkZChsaWdodDYpO1xuICAgICAgICAvLyAreVxuICAgICAgICBjb25zdCBsaWdodDcgPSBuZXcgTWVzaChnZW9tZXRyeSwgdGhpcy5jcmVhdGVBcmVhTGlnaHRNYXRlcmlhbCgxKSk7XG4gICAgICAgIGxpZ2h0Ny5wb3NpdGlvbi5zZXQoMC4wLCAyMC4wLCAwLjApO1xuICAgICAgICBsaWdodDcuc2NhbGUuc2V0KDAuMSwgMC4xLCAwLjEpO1xuICAgICAgICB0aGlzLmFkZChsaWdodDcpO1xuICAgIH1cbiAgICBjcmVhdGVBcmVhTGlnaHRNYXRlcmlhbChpbnRlbnNpdHkpIHtcbiAgICAgICAgY29uc3QgbWF0ZXJpYWwgPSBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoKTtcbiAgICAgICAgbWF0ZXJpYWwuY29sb3Iuc2V0U2NhbGFyKGludGVuc2l0eSk7XG4gICAgICAgIHJldHVybiBtYXRlcmlhbDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FbnZpcm9ubWVudFNjZW5lQWx0LmpzLm1hcCIsIi8qIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICdMaWNlbnNlJyk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gJ0FTIElTJyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IFRleHR1cmUgfSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgKiBhcyBTa2VsZXRvblV0aWxzIGZyb20gJ3RocmVlL2V4YW1wbGVzL2pzbS91dGlscy9Ta2VsZXRvblV0aWxzLmpzJztcbmV4cG9ydCBjb25zdCAkcHJlcGFyZWQgPSBTeW1ib2woJ3ByZXBhcmVkJyk7XG5leHBvcnQgY29uc3QgJHByZXBhcmUgPSBTeW1ib2woJ3ByZXBhcmUnKTtcbmV4cG9ydCBjb25zdCAkcHJlcGFyZWRHTFRGID0gU3ltYm9sKCdwcmVwYXJlZEdMVEYnKTtcbmV4cG9ydCBjb25zdCAkY2xvbmUgPSBTeW1ib2woJ2Nsb25lJyk7XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIHByZXBhcmF0aW9uIGFuZCBlbmhhbmNlbWVudCBvZiB0aGUgb3V0cHV0IG9mIGEgVGhyZWUuanNcbiAqIEdMVEZMb2FkZXIgKGEgVGhyZWUuanMtZmxhdm9yIFwiR0xURlwiKSwgdG8gbWFrZSBpdCBzdWl0YWJsZSBmb3Igb3B0aW1hbCxcbiAqIGNvcnJlY3Qgdmlld2luZyBpbiBhIGdpdmVuIHByZXNlbnRhdGlvbiBjb250ZXh0IGFuZCBhbHNvIG1ha2UgdGhlIGNsb25pbmdcbiAqIHByb2Nlc3MgbW9yZSBleHBsaWNpdCBhbmQgbGVnaWJsZS5cbiAqXG4gKiBBIEdMVEZJbnN0YW5jZSBpcyBBUEktY29tcGF0aWJsZSB3aXRoIGEgVGhyZWUuanMtZmxhdm9yIFwiR0xURlwiLCBzbyBpdCBzaG91bGRcbiAqIGJlIGNvbnNpZGVyZWQgdG8gYmUgaW50ZXJjaGFuZ2VhYmxlIHdpdGggdGhlIGxvYWRlZCByZXN1bHQgb2YgYSBHTFRGTG9hZGVyLlxuICpcbiAqIFRoaXMgYmFzaWMgaW1wbGVtZW50YXRpb24gb25seSBpbXBsZW1lbnRzIHRyaXZpYWwgcHJlcGFyYXRpb24gYW5kIGVuaGFuY2VtZW50XG4gKiBvZiBhIEdMVEYuIFRoZXNlIG9wZXJhdGlvbnMgYXJlIGludGVuZGVkIHRvIGJlIGVuaGFuY2VkIGJ5IGluaGVyaXRpbmdcbiAqIGNsYXNzZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBHTFRGSW5zdGFuY2Uge1xuICAgIGNvbnN0cnVjdG9yKHByZXBhcmVkR0xURikge1xuICAgICAgICB0aGlzWyRwcmVwYXJlZEdMVEZdID0gcHJlcGFyZWRHTFRGO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlcyBhIGdpdmVuIEdMVEYgZm9yIHByZXNlbnRhdGlvbiBhbmQgZnV0dXJlIGNsb25pbmcuIEEgR0xURiB0aGF0IGlzXG4gICAgICogcHJlcGFyZWQgY2FuIHNhZmVseSBoYXZlIHRoaXMgbWV0aG9kIGludm9rZWQgb24gaXQgbXVsdGlwbGUgdGltZXM7IGl0IHdpbGxcbiAgICAgKiBvbmx5IGJlIHByZXBhcmVkIG9uY2UsIGluY2x1ZGluZyBhZnRlciBiZWluZyBjbG9uZWQuXG4gICAgICovXG4gICAgc3RhdGljIHByZXBhcmUoc291cmNlKSB7XG4gICAgICAgIGlmIChzb3VyY2Uuc2NlbmUgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNb2RlbCBkb2VzIG5vdCBoYXZlIGEgc2NlbmUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc291cmNlWyRwcmVwYXJlZF0pIHtcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJlcGFyZWQgPSB0aGlzWyRwcmVwYXJlXShzb3VyY2UpO1xuICAgICAgICAvLyBOT1RFOiBFUzUgU3ltYm9sIHBvbHlmaWxsIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggc3ByZWFkIG9wZXJhdG9yXG4gICAgICAgIC8vIHNvIHsuLi5wcmVwYXJlZCwgWyRwcmVwYXJlZF06IHRydWV9IGRvZXMgbm90IHdvcmtcbiAgICAgICAgcHJlcGFyZWRbJHByZXBhcmVkXSA9IHRydWU7XG4gICAgICAgIHJldHVybiBwcmVwYXJlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgaW4gYW4gaW5oZXJpdGluZyBjbGFzcyB0byBhcHBseSBzcGVjaWFsdHkgb25lLXRpbWUgcHJlcGFyYXRpb25zXG4gICAgICogZm9yIGEgZ2l2ZW4gaW5wdXQgR0xURi5cbiAgICAgKi9cbiAgICBzdGF0aWMgWyRwcmVwYXJlXShzb3VyY2UpIHtcbiAgICAgICAgLy8gVE9ETygjMTk1LCMxMDAzKTogV2UgZG9uJ3QgY3VycmVudGx5IHN1cHBvcnQgbXVsdGlwbGUgc2NlbmVzLCBzbyB3ZSBkb24ndFxuICAgICAgICAvLyBib3RoZXIgcHJlcGFyaW5nIGV4dHJhIHNjZW5lcyBmb3Igbm93OlxuICAgICAgICBjb25zdCB7IHNjZW5lIH0gPSBzb3VyY2U7XG4gICAgICAgIGNvbnN0IHNjZW5lcyA9IFtzY2VuZV07XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNvdXJjZSksIHsgc2NlbmUsIHNjZW5lcyB9KTtcbiAgICB9XG4gICAgZ2V0IHBhcnNlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbJHByZXBhcmVkR0xURl0ucGFyc2VyO1xuICAgIH1cbiAgICBnZXQgYW5pbWF0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbJHByZXBhcmVkR0xURl0uYW5pbWF0aW9ucztcbiAgICB9XG4gICAgZ2V0IHNjZW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpc1skcHJlcGFyZWRHTFRGXS5zY2VuZTtcbiAgICB9XG4gICAgZ2V0IHNjZW5lcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbJHByZXBhcmVkR0xURl0uc2NlbmVzO1xuICAgIH1cbiAgICBnZXQgY2FtZXJhcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbJHByZXBhcmVkR0xURl0uY2FtZXJhcztcbiAgICB9XG4gICAgZ2V0IGFzc2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpc1skcHJlcGFyZWRHTFRGXS5hc3NldDtcbiAgICB9XG4gICAgZ2V0IHVzZXJEYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpc1skcHJlcGFyZWRHTFRGXS51c2VyRGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIGNvcHkgb2YgdGhpcyBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgY29uc3QgR0xURkluc3RhbmNlQ29uc3RydWN0b3IgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICBjb25zdCBjbG9uZWRHTFRGID0gdGhpc1skY2xvbmVdKCk7XG4gICAgICAgIHJldHVybiBuZXcgR0xURkluc3RhbmNlQ29uc3RydWN0b3IoY2xvbmVkR0xURik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFucyB1cCBhbnkgcmV0YWluZWQgbWVtb3J5IHRoYXQgbWlnaHQgbm90IG90aGVyd2lzZSBiZSByZWxlYXNlZCB3aGVuXG4gICAgICogdGhpcyBpbnN0YW5jZSBpcyBkb25lIGJlaW5nIHVzZWQuXG4gICAgICovXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5zY2VuZXMuZm9yRWFjaCgoc2NlbmUpID0+IHtcbiAgICAgICAgICAgIHNjZW5lLnRyYXZlcnNlKChvYmplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNoID0gb2JqZWN0O1xuICAgICAgICAgICAgICAgIGlmICghbWVzaC5tYXRlcmlhbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGVyaWFscyA9IEFycmF5LmlzQXJyYXkobWVzaC5tYXRlcmlhbCkgPyBtZXNoLm1hdGVyaWFsIDogW21lc2gubWF0ZXJpYWxdO1xuICAgICAgICAgICAgICAgIG1hdGVyaWFscy5mb3JFYWNoKG1hdGVyaWFsID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRXhwbGljaXRseSBkaXNwb3NlIGFueSB0ZXh0dXJlcyBhc3NpZ25lZCB0byB0aGlzIG1hdGVyaWFsXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcGVydHlOYW1lIGluIG1hdGVyaWFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0dXJlID0gbWF0ZXJpYWxbcHJvcGVydHlOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0dXJlIGluc3RhbmNlb2YgVGV4dHVyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGltYWdlID0gdGV4dHVyZS5zb3VyY2UuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2UuY2xvc2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZS5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbWVzaC5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIGluIGFuIGluaGVyaXRpbmcgY2xhc3MgdG8gaW1wbGVtZW50IHNwZWNpYWxpemVkIGNsb25pbmcgc3RyYXRlZ2llc1xuICAgICAqL1xuICAgIFskY2xvbmVdKCkge1xuICAgICAgICBjb25zdCBzb3VyY2UgPSB0aGlzWyRwcmVwYXJlZEdMVEZdO1xuICAgICAgICAvLyBUT0RPKCMxOTUsIzEwMDMpOiBXZSBkb24ndCBjdXJyZW50bHkgc3VwcG9ydCBtdWx0aXBsZSBzY2VuZXMsIHNvIHdlIGRvbid0XG4gICAgICAgIC8vIGJvdGhlciBjbG9uaW5nIGV4dHJhIHNjZW5lcyBmb3Igbm93OlxuICAgICAgICBjb25zdCBzY2VuZSA9IFNrZWxldG9uVXRpbHMuY2xvbmUodGhpcy5zY2VuZSk7XG4gICAgICAgIGNsb25lVmFyaWFudE1hdGVyaWFscyhzY2VuZSwgdGhpcy5zY2VuZSk7XG4gICAgICAgIGNvbnN0IHNjZW5lcyA9IFtzY2VuZV07XG4gICAgICAgIGNvbnN0IHVzZXJEYXRhID0gc291cmNlLnVzZXJEYXRhID8gT2JqZWN0LmFzc2lnbih7fSwgc291cmNlLnVzZXJEYXRhKSA6IHt9O1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzb3VyY2UpLCB7IHNjZW5lLCBzY2VuZXMsIHVzZXJEYXRhIH0pO1xuICAgIH1cbn1cbi8vIFZhcmlhbnQgbWF0ZXJpYWxzIGFuZCBvcmlnaW5hbCBtYXRlcmlhbCBpbnN0YW5jZXMgYXJlIHN0b3JlZCB1bmRlclxuLy8gb2JqZWN0LnVzZXJEYXRhLnZhcmlhbnRNYXRlcmlhbHMvb3JpZ2luYWxNYXRlcmlhbC5cbi8vIFRocmVlLmpzIE9iamVjdDNELmNsb25lKCkgZG9lc24ndCBjbG9uZSBUaHJlZS5qcyBvYmplY3RzIHVuZGVyXG4vLyAudXNlckRhdGEgc28gdGhpcyBmdW5jdGlvbiBpcyBhIHdvcmthcm91bmQuXG5jb25zdCBjbG9uZVZhcmlhbnRNYXRlcmlhbHMgPSAoZHN0LCBzcmMpID0+IHtcbiAgICB0cmF2ZXJzZVBhaXIoZHN0LCBzcmMsIChkc3QsIHNyYykgPT4ge1xuICAgICAgICBpZiAoc3JjLnVzZXJEYXRhLnZhcmlhbnRNYXRlcmlhbHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZHN0LnVzZXJEYXRhLnZhcmlhbnRNYXRlcmlhbHMgPSBuZXcgTWFwKHNyYy51c2VyRGF0YS52YXJpYW50TWF0ZXJpYWxzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3JjLnVzZXJEYXRhLnZhcmlhbnREYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRzdC51c2VyRGF0YS52YXJpYW50RGF0YSA9IHNyYy51c2VyRGF0YS52YXJpYW50RGF0YTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3JjLnVzZXJEYXRhLm9yaWdpbmFsTWF0ZXJpYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZHN0LnVzZXJEYXRhLm9yaWdpbmFsTWF0ZXJpYWwgPSBzcmMudXNlckRhdGEub3JpZ2luYWxNYXRlcmlhbDtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbmNvbnN0IHRyYXZlcnNlUGFpciA9IChvYmoxLCBvYmoyLCBjYWxsYmFjaykgPT4ge1xuICAgIGNhbGxiYWNrKG9iajEsIG9iajIpO1xuICAgIC8vIEFzc3VtZSBvYmoxIGFuZCBvYmoyIGhhdmUgdGhlIHNhbWUgdHJlZSBzdHJ1Y3R1cmVcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9iajEuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdHJhdmVyc2VQYWlyKG9iajEuY2hpbGRyZW5baV0sIG9iajIuY2hpbGRyZW5baV0sIGNhbGxiYWNrKTtcbiAgICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R0xURkluc3RhbmNlLmpzLm1hcCIsIi8qIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICdMaWNlbnNlJyk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gJ0FTIElTJyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IE1hdHJpeDMsIFF1YXRlcm5pb24sIFRyaWFuZ2xlLCBWZWN0b3IzIH0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgQ1NTMkRPYmplY3QgfSBmcm9tICd0aHJlZS9leGFtcGxlcy9qc20vcmVuZGVyZXJzL0NTUzJEUmVuZGVyZXIuanMnO1xuaW1wb3J0IHsgbm9ybWFsaXplVW5pdCB9IGZyb20gJy4uL3N0eWxlcy9jb252ZXJzaW9ucy5qcyc7XG5pbXBvcnQgeyBwYXJzZUV4cHJlc3Npb25zIH0gZnJvbSAnLi4vc3R5bGVzL3BhcnNlcnMuanMnO1xuY29uc3QgYSA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCBiID0gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IGMgPSBuZXcgVmVjdG9yMygpO1xuY29uc3QgbWF0ID0gbmV3IE1hdHJpeDMoKTtcbmNvbnN0IHRyaWFuZ2xlID0gbmV3IFRyaWFuZ2xlKCk7XG5jb25zdCBxdWF0ID0gbmV3IFF1YXRlcm5pb24oKTtcbi8qKlxuICogVGhlIEhvdHNwb3Qgb2JqZWN0IGlzIGEgcmVmZXJlbmNlLWNvdW50ZWQgc2xvdC4gSWYgZGVjcmVtZW50KCkgcmV0dXJucyB0cnVlLFxuICogaXQgc2hvdWxkIGJlIHJlbW92ZWQgZnJvbSB0aGUgdHJlZSBzbyBpdCBjYW4gYmUgZ2FyYmFnZS1jb2xsZWN0ZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBIb3RzcG90IGV4dGVuZHMgQ1NTMkRPYmplY3Qge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcihkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSk7XG4gICAgICAgIHRoaXMubm9ybWFsID0gbmV3IFZlY3RvcjMoMCwgMSwgMCk7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZWZlcmVuY2VDb3VudCA9IDE7XG4gICAgICAgIHRoaXMucGl2b3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5zbG90ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2xvdCcpO1xuICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnYW5ub3RhdGlvbi13cmFwcGVyJyk7XG4gICAgICAgIHRoaXMuc2xvdC5uYW1lID0gY29uZmlnLm5hbWU7XG4gICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnBpdm90KTtcbiAgICAgICAgdGhpcy5waXZvdC5hcHBlbmRDaGlsZCh0aGlzLnNsb3QpO1xuICAgICAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uKGNvbmZpZy5wb3NpdGlvbik7XG4gICAgICAgIHRoaXMudXBkYXRlTm9ybWFsKGNvbmZpZy5ub3JtYWwpO1xuICAgICAgICB0aGlzLnN1cmZhY2UgPSBjb25maWcuc3VyZmFjZTtcbiAgICB9XG4gICAgZ2V0IGZhY2luZ0NhbWVyYSgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdoaWRlJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGhvdHNwb3QgdG8gYmUgaW4gdGhlIGhpZ2hseSB2aXNpYmxlIGZvcmVncm91bmQgc3RhdGUuXG4gICAgICovXG4gICAgc2hvdygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmZhY2luZ0NhbWVyYSB8fCAhdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWaXNpYmlsaXR5KHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGhvdHNwb3QgdG8gYmUgaW4gdGhlIGRpbWluaXNoZWQgYmFja2dyb3VuZCBzdGF0ZS5cbiAgICAgKi9cbiAgICBoaWRlKCkge1xuICAgICAgICBpZiAodGhpcy5mYWNpbmdDYW1lcmEgfHwgIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmlzaWJpbGl0eShmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbCB0aGlzIHdoZW4gYWRkaW5nIGVsZW1lbnRzIHRvIHRoZSBzYW1lIHNsb3QgdG8ga2VlcCB0cmFjay5cbiAgICAgKi9cbiAgICBpbmNyZW1lbnQoKSB7XG4gICAgICAgIHRoaXMucmVmZXJlbmNlQ291bnQrKztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbCB0aGlzIHdoZW4gcmVtb3ZpbmcgZWxlbWVudHMgZnJvbSB0aGUgc2xvdDsgcmV0dXJucyB0cnVlIHdoZW4gdGhlIHNsb3RcbiAgICAgKiBpcyB1bnVzZWQuXG4gICAgICovXG4gICAgZGVjcmVtZW50KCkge1xuICAgICAgICBpZiAodGhpcy5yZWZlcmVuY2VDb3VudCA+IDApIHtcbiAgICAgICAgICAgIC0tdGhpcy5yZWZlcmVuY2VDb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZWZlcmVuY2VDb3VudCA9PT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlIHRoZSBwb3NpdGlvbiBvZiB0aGUgaG90c3BvdCB0byB0aGUgaW5wdXQgc3RyaW5nLCBpbiB0aGUgc2FtZSBmb3JtYXRcbiAgICAgKiBhcyB0aGUgZGF0YS1wb3NpdGlvbiBhdHRyaWJ1dGUuXG4gICAgICovXG4gICAgdXBkYXRlUG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICAgICAgaWYgKHBvc2l0aW9uID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uTm9kZXMgPSBwYXJzZUV4cHJlc3Npb25zKHBvc2l0aW9uKVswXS50ZXJtcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24uc2V0Q29tcG9uZW50KGksIG5vcm1hbGl6ZVVuaXQocG9zaXRpb25Ob2Rlc1tpXSkubnVtYmVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5nZSB0aGUgaG90c3BvdCdzIG5vcm1hbCB0byB0aGUgaW5wdXQgc3RyaW5nLCBpbiB0aGUgc2FtZSBmb3JtYXQgYXMgdGhlXG4gICAgICogZGF0YS1ub3JtYWwgYXR0cmlidXRlLlxuICAgICAqL1xuICAgIHVwZGF0ZU5vcm1hbChub3JtYWwpIHtcbiAgICAgICAgaWYgKG5vcm1hbCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBub3JtYWxOb2RlcyA9IHBhcnNlRXhwcmVzc2lvbnMobm9ybWFsKVswXS50ZXJtcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMubm9ybWFsLnNldENvbXBvbmVudChpLCBub3JtYWxOb2Rlc1tpXS5udW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZVN1cmZhY2UoZm9yY2VVcGRhdGUpIHtcbiAgICAgICAgaWYgKCFmb3JjZVVwZGF0ZSAmJiB0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBtZXNoLCB0cmksIGJhcnkgfSA9IHRoaXM7XG4gICAgICAgIGlmIChtZXNoID09IG51bGwgfHwgdHJpID09IG51bGwgfHwgYmFyeSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbWVzaC5nZXRWZXJ0ZXhQb3NpdGlvbih0cmkueCwgYSk7XG4gICAgICAgIG1lc2guZ2V0VmVydGV4UG9zaXRpb24odHJpLnksIGIpO1xuICAgICAgICBtZXNoLmdldFZlcnRleFBvc2l0aW9uKHRyaS56LCBjKTtcbiAgICAgICAgYS50b0FycmF5KG1hdC5lbGVtZW50cywgMCk7XG4gICAgICAgIGIudG9BcnJheShtYXQuZWxlbWVudHMsIDMpO1xuICAgICAgICBjLnRvQXJyYXkobWF0LmVsZW1lbnRzLCA2KTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbi5jb3B5KGJhcnkpLmFwcGx5TWF0cml4MyhtYXQpO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgdGFyZ2V0LndvcmxkVG9Mb2NhbChtZXNoLmxvY2FsVG9Xb3JsZCh0aGlzLnBvc2l0aW9uKSk7XG4gICAgICAgIHRyaWFuZ2xlLnNldChhLCBiLCBjKTtcbiAgICAgICAgdHJpYW5nbGUuZ2V0Tm9ybWFsKHRoaXMubm9ybWFsKS50cmFuc2Zvcm1EaXJlY3Rpb24obWVzaC5tYXRyaXhXb3JsZCk7XG4gICAgICAgIGNvbnN0IHNjZW5lID0gdGFyZ2V0LnBhcmVudDtcbiAgICAgICAgcXVhdC5zZXRGcm9tQXhpc0FuZ2xlKGEuc2V0KDAsIDEsIDApLCAtc2NlbmUueWF3KTtcbiAgICAgICAgdGhpcy5ub3JtYWwuYXBwbHlRdWF0ZXJuaW9uKHF1YXQpO1xuICAgIH1cbiAgICBvcmllbnQocmFkaWFucykge1xuICAgICAgICB0aGlzLnBpdm90LnN0eWxlLnRyYW5zZm9ybSA9IGByb3RhdGUoJHtyYWRpYW5zfXJhZClgO1xuICAgIH1cbiAgICB1cGRhdGVWaXNpYmlsaXR5KHNob3cpIHtcbiAgICAgICAgLy8gTk9URTogSUUxMSBkb2Vzbid0IHN1cHBvcnQgYSBzZWNvbmQgYXJnIGZvciBjbGFzc0xpc3QudG9nZ2xlXG4gICAgICAgIGlmIChzaG93KSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2hpZGUnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOT1RFOiBTaGFkeURPTSBkb2Vzbid0IHN1cHBvcnQgc2xvdC5hc3NpZ25lZEVsZW1lbnRzLCBvdGhlcndpc2Ugd2UgY291bGRcbiAgICAgICAgLy8gdXNlIHRoYXQgaGVyZS5cbiAgICAgICAgdGhpcy5zbG90LmFzc2lnbmVkTm9kZXMoKS5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gbm9kZTtcbiAgICAgICAgICAgIC8vIFZpc2liaWxpdHkgYXR0cmlidXRlIGNhbiBiZSBjb25maWd1cmVkIHBlci1ub2RlIGluIHRoZSBob3RzcG90OlxuICAgICAgICAgICAgY29uc3QgdmlzaWJpbGl0eUF0dHJpYnV0ZSA9IGVsZW1lbnQuZGF0YXNldC52aXNpYmlsaXR5QXR0cmlidXRlO1xuICAgICAgICAgICAgaWYgKHZpc2liaWxpdHlBdHRyaWJ1dGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZU5hbWUgPSBgZGF0YS0ke3Zpc2liaWxpdHlBdHRyaWJ1dGV9YDtcbiAgICAgICAgICAgICAgICAvLyBOT1RFOiBJRTExIGRvZXNuJ3Qgc3VwcG9ydCB0b2dnbGVBdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICBpZiAoc2hvdykge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCAnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdob3RzcG90LXZpc2liaWxpdHknLCB7XG4gICAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgICAgIHZpc2libGU6IHNob3csXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUhvdHNwb3QuanMubWFwIiwiLyogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgJ0xpY2Vuc2UnKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAnQVMgSVMnIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgQW5pbWF0aW9uTWl4ZXIsIEJveDMsIEV1bGVyLCBMb29wUGluZ1BvbmcsIExvb3BSZXBlYXQsIE1hdHJpeDMsIE9iamVjdDNELCBQZXJzcGVjdGl2ZUNhbWVyYSwgUmF5Y2FzdGVyLCBTY2VuZSwgU3BoZXJlLCBUcmlhbmdsZSwgVmVjdG9yMiwgVmVjdG9yMyB9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7IENTUzJEUmVuZGVyZXIgfSBmcm9tICd0aHJlZS9leGFtcGxlcy9qc20vcmVuZGVyZXJzL0NTUzJEUmVuZGVyZXIuanMnO1xuLy8gQHRzLWlnbm9yZVxuaW1wb3J0IHsgcmVkdWNlVmVydGljZXMgfSBmcm9tICd0aHJlZS9leGFtcGxlcy9qc20vdXRpbHMvU2NlbmVVdGlscy5qcyc7XG5pbXBvcnQgeyAkY3VycmVudEdMVEYsICRtb2RlbCwgJG9yaWdpbmFsR2x0Zkpzb24gfSBmcm9tICcuLi9mZWF0dXJlcy9zY2VuZS1ncmFwaC5qcyc7XG5pbXBvcnQgeyAkbm9kZUZyb21JbmRleCwgJG5vZGVGcm9tUG9pbnQgfSBmcm9tICcuLi9mZWF0dXJlcy9zY2VuZS1ncmFwaC9tb2RlbC5qcyc7XG5pbXBvcnQgeyAkcmVuZGVyZXIgfSBmcm9tICcuLi9tb2RlbC12aWV3ZXItYmFzZS5qcyc7XG5pbXBvcnQgeyBub3JtYWxpemVVbml0IH0gZnJvbSAnLi4vc3R5bGVzL2NvbnZlcnNpb25zLmpzJztcbmltcG9ydCB7IHBhcnNlRXhwcmVzc2lvbnMgfSBmcm9tICcuLi9zdHlsZXMvcGFyc2Vycy5qcyc7XG5pbXBvcnQgeyByZXNvbHZlRHByIH0gZnJvbSAnLi4vdXRpbGl0aWVzLmpzJztcbmltcG9ydCB7IERhbXBlciwgU0VUVExJTkdfVElNRSB9IGZyb20gJy4vRGFtcGVyLmpzJztcbmltcG9ydCB7IEhvdHNwb3QgfSBmcm9tICcuL0hvdHNwb3QuanMnO1xuaW1wb3J0IHsgU2hhZG93IH0gZnJvbSAnLi9TaGFkb3cuanMnO1xuY29uc3QgTUlOX1NIQURPV19SQVRJTyA9IDEwMDtcbmV4cG9ydCBjb25zdCBJbGx1bWluYXRpb25Sb2xlID0ge1xuICAgIFByaW1hcnk6ICdwcmltYXJ5JyxcbiAgICBTZWNvbmRhcnk6ICdzZWNvbmRhcnknXG59O1xuY29uc3QgdmlldyA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCB0YXJnZXQgPSBuZXcgVmVjdG9yMygpO1xuY29uc3Qgbm9ybWFsV29ybGQgPSBuZXcgVmVjdG9yMygpO1xuY29uc3QgcmF5Y2FzdGVyID0gbmV3IFJheWNhc3RlcigpO1xuY29uc3QgdmVjdG9yMyA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCBuZGMgPSBuZXcgVmVjdG9yMigpO1xuLyoqXG4gKiBBIFRIUkVFLlNjZW5lIG9iamVjdCB0aGF0IHRha2VzIGEgTW9kZWwgYW5kIENhbnZhc0hUTUxFbGVtZW50IGFuZFxuICogY29uc3RydWN0cyBhIGZyYW1lZCBzY2VuZSBiYXNlZCBvZmYgb2YgdGhlIGNhbnZhcyBkaW1lbnNpb25zLlxuICogUHJvdmlkZXMgbGlnaHRzIGFuZCBjYW1lcmFzIHRvIGJlIHVzZWQgaW4gYSByZW5kZXJlci5cbiAqL1xuZXhwb3J0IGNsYXNzIE1vZGVsU2NlbmUgZXh0ZW5kcyBTY2VuZSB7XG4gICAgY29uc3RydWN0b3IoeyBjYW52YXMsIGVsZW1lbnQsIHdpZHRoLCBoZWlnaHQgfSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFubm90YXRpb25SZW5kZXJlciA9IG5ldyBDU1MyRFJlbmRlcmVyKCk7XG4gICAgICAgIHRoaXMuc2NoZW1hRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICB0aGlzLndpZHRoID0gMTtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAxO1xuICAgICAgICB0aGlzLmFzcGVjdCA9IDE7XG4gICAgICAgIHRoaXMuc2NhbGVTdGVwID0gMDtcbiAgICAgICAgdGhpcy5yZW5kZXJDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuZXh0ZXJuYWxSZW5kZXJlciA9IG51bGw7XG4gICAgICAgIC8vIFRoZXNlIGRlZmF1bHQgY2FtZXJhIHZhbHVlcyBhcmUgbmV2ZXIgdXNlZCwgYXMgdGhleSBhcmUgcmVzZXQgb25jZSB0aGVcbiAgICAgICAgLy8gbW9kZWwgaXMgbG9hZGVkIGFuZCBmcmFtaW5nIGlzIGNvbXB1dGVkLlxuICAgICAgICB0aGlzLmNhbWVyYSA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSg0NSwgMSwgMC4xLCAxMDApO1xuICAgICAgICB0aGlzLnhyQ2FtZXJhID0gbnVsbDtcbiAgICAgICAgdGhpcy51cmwgPSBudWxsO1xuICAgICAgICB0aGlzLnRhcmdldCA9IG5ldyBPYmplY3QzRCgpO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbk5hbWVzID0gW107XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3ggPSBuZXcgQm94MygpO1xuICAgICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFNwaGVyZSgpO1xuICAgICAgICB0aGlzLnNpemUgPSBuZXcgVmVjdG9yMygpO1xuICAgICAgICB0aGlzLmlkZWFsQXNwZWN0ID0gMDtcbiAgICAgICAgdGhpcy5mcmFtZWRGb1ZEZWcgPSAwO1xuICAgICAgICB0aGlzLnNoYWRvdyA9IG51bGw7XG4gICAgICAgIHRoaXMuc2hhZG93SW50ZW5zaXR5ID0gMDtcbiAgICAgICAgdGhpcy5zaGFkb3dTb2Z0bmVzcyA9IDE7XG4gICAgICAgIHRoaXMuYmFrZWRTaGFkb3dzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLmV4cG9zdXJlID0gMTtcbiAgICAgICAgdGhpcy5jYW5TY2FsZSA9IHRydWU7XG4gICAgICAgIHRoaXMuaXNEaXJ0eSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmdvYWxUYXJnZXQgPSBuZXcgVmVjdG9yMygpO1xuICAgICAgICB0aGlzLnRhcmdldERhbXBlclggPSBuZXcgRGFtcGVyKCk7XG4gICAgICAgIHRoaXMudGFyZ2V0RGFtcGVyWSA9IG5ldyBEYW1wZXIoKTtcbiAgICAgICAgdGhpcy50YXJnZXREYW1wZXJaID0gbmV3IERhbXBlcigpO1xuICAgICAgICB0aGlzLl9jdXJyZW50R0xURiA9IG51bGw7XG4gICAgICAgIHRoaXMuX21vZGVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5jYW5jZWxQZW5kaW5nU291cmNlQ2hhbmdlID0gbnVsbDtcbiAgICAgICAgdGhpcy5hbmltYXRpb25zQnlOYW1lID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmN1cnJlbnRBbmltYXRpb25BY3Rpb24gPSBudWxsO1xuICAgICAgICB0aGlzLm5hbWUgPSAnTW9kZWxTY2VuZSc7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgICAgICAvLyBUaGVzZSBkZWZhdWx0IGNhbWVyYSB2YWx1ZXMgYXJlIG5ldmVyIHVzZWQsIGFzIHRoZXkgYXJlIHJlc2V0IG9uY2UgdGhlXG4gICAgICAgIC8vIG1vZGVsIGlzIGxvYWRlZCBhbmQgZnJhbWluZyBpcyBjb21wdXRlZC5cbiAgICAgICAgdGhpcy5jYW1lcmEgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoNDUsIDEsIDAuMSwgMTAwKTtcbiAgICAgICAgdGhpcy5jYW1lcmEubmFtZSA9ICdNYWluQ2FtZXJhJztcbiAgICAgICAgdGhpcy5hZGQodGhpcy50YXJnZXQpO1xuICAgICAgICB0aGlzLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMudGFyZ2V0Lm5hbWUgPSAnVGFyZ2V0JztcbiAgICAgICAgdGhpcy5taXhlciA9IG5ldyBBbmltYXRpb25NaXhlcih0aGlzLnRhcmdldCk7XG4gICAgICAgIGNvbnN0IHsgZG9tRWxlbWVudCB9ID0gdGhpcy5hbm5vdGF0aW9uUmVuZGVyZXI7XG4gICAgICAgIGNvbnN0IHsgc3R5bGUgfSA9IGRvbUVsZW1lbnQ7XG4gICAgICAgIHN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIHN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgICAgIHN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgc3R5bGUudG9wID0gJzAnO1xuICAgICAgICB0aGlzLmVsZW1lbnQuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCcuZGVmYXVsdCcpLmFwcGVuZENoaWxkKGRvbUVsZW1lbnQpO1xuICAgICAgICB0aGlzLnNjaGVtYUVsZW1lbnQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ2FwcGxpY2F0aW9uL2xkK2pzb24nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdG8gY3JlYXRlIHRoZSBjb250ZXh0IGxhemlseSwgYXMgd2hlbiB0aGVyZSBpcyBvbmx5IG9uZVxuICAgICAqIDxtb2RlbC12aWV3ZXI+IGVsZW1lbnQsIHRoZSByZW5kZXJlcidzIDNEIGNvbnRleHQgY2FuIGJlIGRpc3BsYXllZFxuICAgICAqIGRpcmVjdGx5LiBUaGlzIGV4dHJhIGNvbnRleHQgaXMgbmVjZXNzYXJ5IHRvIGNvcHkgdGhlIHJlbmRlcmluZ3MgaW50byB3aGVuXG4gICAgICogdGhlcmUgYXJlIG1vcmUgdGhhbiBvbmUuXG4gICAgICovXG4gICAgZ2V0IGNvbnRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIH1cbiAgICBnZXRDYW1lcmEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnhyQ2FtZXJhICE9IG51bGwgPyB0aGlzLnhyQ2FtZXJhIDogdGhpcy5jYW1lcmE7XG4gICAgfVxuICAgIHF1ZXVlUmVuZGVyKCkge1xuICAgICAgICB0aGlzLmlzRGlydHkgPSB0cnVlO1xuICAgIH1cbiAgICBzaG91bGRSZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzRGlydHk7XG4gICAgfVxuICAgIGhhc1JlbmRlcmVkKCkge1xuICAgICAgICB0aGlzLmlzRGlydHkgPSBmYWxzZTtcbiAgICB9XG4gICAgZm9yY2VSZXNjYWxlKCkge1xuICAgICAgICB0aGlzLnNjYWxlU3RlcCA9IC0xO1xuICAgICAgICB0aGlzLnF1ZXVlUmVuZGVyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhc3MgaW4gYSBUSFJFRS5PYmplY3QzRCB0byBiZSBjb250cm9sbGVkXG4gICAgICogYnkgdGhpcyBtb2RlbC5cbiAgICAgKi9cbiAgICBhc3luYyBzZXRPYmplY3QobW9kZWwpIHtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB0aGlzLl9tb2RlbCA9IG1vZGVsO1xuICAgICAgICB0aGlzLnRhcmdldC5hZGQobW9kZWwpO1xuICAgICAgICBhd2FpdCB0aGlzLnNldHVwU2NlbmUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbW9kZWwgdmlhIFVSTC5cbiAgICAgKi9cbiAgICBhc3luYyBzZXRTb3VyY2UodXJsLCBwcm9ncmVzc0NhbGxiYWNrID0gKCkgPT4geyB9KSB7XG4gICAgICAgIGlmICghdXJsIHx8IHVybCA9PT0gdGhpcy51cmwpIHtcbiAgICAgICAgICAgIHByb2dyZXNzQ2FsbGJhY2soMSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgaWYgKHRoaXMuZXh0ZXJuYWxSZW5kZXJlciAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBmcmFtaW5nSW5mbyA9IGF3YWl0IHRoaXMuZXh0ZXJuYWxSZW5kZXJlci5sb2FkKHByb2dyZXNzQ2FsbGJhY2spO1xuICAgICAgICAgICAgdGhpcy5ib3VuZGluZ1NwaGVyZS5yYWRpdXMgPSBmcmFtaW5nSW5mby5mcmFtZWRSYWRpdXM7XG4gICAgICAgICAgICB0aGlzLmlkZWFsQXNwZWN0ID0gZnJhbWluZ0luZm8uZmllbGRPZlZpZXdBc3BlY3Q7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBwZW5kaW5nIHdvcmsgZHVlIHRvIGEgcHJldmlvdXMgc291cmNlIGNoYW5nZSBpbiBwcm9ncmVzcyxcbiAgICAgICAgLy8gY2FuY2VsIGl0IHNvIHRoYXQgd2UgZG8gbm90IGluY3VyIGEgcmFjZSBjb25kaXRpb246XG4gICAgICAgIGlmICh0aGlzLmNhbmNlbFBlbmRpbmdTb3VyY2VDaGFuZ2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jYW5jZWxQZW5kaW5nU291cmNlQ2hhbmdlKCk7XG4gICAgICAgICAgICB0aGlzLmNhbmNlbFBlbmRpbmdTb3VyY2VDaGFuZ2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCBnbHRmO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZ2x0ZiA9IGF3YWl0IG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbFBlbmRpbmdTb3VyY2VDaGFuZ2UgPSAoKSA9PiByZWplY3QoKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmVsZW1lbnRbJHJlbmRlcmVyXS5sb2FkZXIubG9hZCh1cmwsIHRoaXMuZWxlbWVudCwgcHJvZ3Jlc3NDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIExvYWRpbmcgd2FzIGNhbmNlbGxlZCwgc28gc2lsZW50bHkgcmV0dXJuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYW5jZWxQZW5kaW5nU291cmNlQ2hhbmdlID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgdGhpcy5fY3VycmVudEdMVEYgPSBnbHRmO1xuICAgICAgICBpZiAoZ2x0ZiAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9tb2RlbCA9IGdsdGYuc2NlbmU7XG4gICAgICAgICAgICB0aGlzLnRhcmdldC5hZGQoZ2x0Zi5zY2VuZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBhbmltYXRpb25zIH0gPSBnbHRmO1xuICAgICAgICBjb25zdCBhbmltYXRpb25zQnlOYW1lID0gbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCBhbmltYXRpb25OYW1lcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGFuaW1hdGlvbiBvZiBhbmltYXRpb25zKSB7XG4gICAgICAgICAgICBhbmltYXRpb25zQnlOYW1lLnNldChhbmltYXRpb24ubmFtZSwgYW5pbWF0aW9uKTtcbiAgICAgICAgICAgIGFuaW1hdGlvbk5hbWVzLnB1c2goYW5pbWF0aW9uLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IGFuaW1hdGlvbnM7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uc0J5TmFtZSA9IGFuaW1hdGlvbnNCeU5hbWU7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uTmFtZXMgPSBhbmltYXRpb25OYW1lcztcbiAgICAgICAgYXdhaXQgdGhpcy5zZXR1cFNjZW5lKCk7XG4gICAgfVxuICAgIGFzeW5jIHNldHVwU2NlbmUoKSB7XG4gICAgICAgIHRoaXMuYXBwbHlUcmFuc2Zvcm0oKTtcbiAgICAgICAgdGhpcy51cGRhdGVCb3VuZGluZ0JveCgpO1xuICAgICAgICBhd2FpdCB0aGlzLnVwZGF0ZUZyYW1pbmcoKTtcbiAgICAgICAgdGhpcy51cGRhdGVTaGFkb3coKTtcbiAgICAgICAgdGhpcy5zZXRTaGFkb3dJbnRlbnNpdHkodGhpcy5zaGFkb3dJbnRlbnNpdHkpO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy51cmwgPSBudWxsO1xuICAgICAgICB0aGlzLnJlbmRlckNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5xdWV1ZVJlbmRlcigpO1xuICAgICAgICBpZiAodGhpcy5zaGFkb3cgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5zaGFkb3cuc2V0SW50ZW5zaXR5KDApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmFrZWRTaGFkb3dzLmNsZWFyKCk7XG4gICAgICAgIGNvbnN0IHsgX21vZGVsIH0gPSB0aGlzO1xuICAgICAgICBpZiAoX21vZGVsICE9IG51bGwpIHtcbiAgICAgICAgICAgIF9tb2RlbC5yZW1vdmVGcm9tUGFyZW50KCk7XG4gICAgICAgICAgICB0aGlzLl9tb2RlbCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZ2x0ZiA9IHRoaXMuX2N1cnJlbnRHTFRGO1xuICAgICAgICBpZiAoZ2x0ZiAhPSBudWxsKSB7XG4gICAgICAgICAgICBnbHRmLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRHTFRGID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jdXJyZW50QW5pbWF0aW9uQWN0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEFuaW1hdGlvbkFjdGlvbi5zdG9wKCk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRBbmltYXRpb25BY3Rpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWl4ZXIuc3RvcEFsbEFjdGlvbigpO1xuICAgICAgICB0aGlzLm1peGVyLnVuY2FjaGVSb290KHRoaXMpO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIGlmICh0aGlzLnNoYWRvdyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnNoYWRvdy5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLnNoYWRvdyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbGVtZW50WyRjdXJyZW50R0xURl0gPSBudWxsO1xuICAgICAgICB0aGlzLmVsZW1lbnRbJG9yaWdpbmFsR2x0Zkpzb25dID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbGVtZW50WyRtb2RlbF0gPSBudWxsO1xuICAgIH1cbiAgICBnZXQgY3VycmVudEdMVEYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50R0xURjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgTW9kZWxTY2VuZSBmb3IgYSBuZXcgY29udGFpbmVyIHNpemUgaW4gQ1NTIHBpeGVscy5cbiAgICAgKi9cbiAgICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgaWYgKHRoaXMud2lkdGggPT09IHdpZHRoICYmIHRoaXMuaGVpZ2h0ID09PSBoZWlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndpZHRoID0gTWF0aC5tYXgod2lkdGgsIDEpO1xuICAgICAgICB0aGlzLmhlaWdodCA9IE1hdGgubWF4KGhlaWdodCwgMSk7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvblJlbmRlcmVyLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMuYXNwZWN0ID0gdGhpcy53aWR0aCAvIHRoaXMuaGVpZ2h0O1xuICAgICAgICBpZiAodGhpcy5leHRlcm5hbFJlbmRlcmVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGRwciA9IHJlc29sdmVEcHIoKTtcbiAgICAgICAgICAgIHRoaXMuZXh0ZXJuYWxSZW5kZXJlci5yZXNpemUod2lkdGggKiBkcHIsIGhlaWdodCAqIGRwcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5xdWV1ZVJlbmRlcigpO1xuICAgIH1cbiAgICBtYXJrQmFrZWRTaGFkb3cobWVzaCkge1xuICAgICAgICBtZXNoLnVzZXJEYXRhLnNoYWRvdyA9IHRydWU7XG4gICAgICAgIHRoaXMuYmFrZWRTaGFkb3dzLmFkZChtZXNoKTtcbiAgICB9XG4gICAgdW5tYXJrQmFrZWRTaGFkb3cobWVzaCkge1xuICAgICAgICBtZXNoLnVzZXJEYXRhLnNoYWRvdyA9IGZhbHNlO1xuICAgICAgICBtZXNoLnZpc2libGUgPSB0cnVlO1xuICAgICAgICB0aGlzLmJha2VkU2hhZG93cy5kZWxldGUobWVzaCk7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3guZXhwYW5kQnlPYmplY3QobWVzaCk7XG4gICAgfVxuICAgIGZpbmRCYWtlZFNoYWRvd3MoZ3JvdXApIHtcbiAgICAgICAgY29uc3QgYm91bmRpbmdCb3ggPSBuZXcgQm94MygpO1xuICAgICAgICBncm91cC50cmF2ZXJzZSgob2JqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtZXNoID0gb2JqZWN0O1xuICAgICAgICAgICAgaWYgKCFtZXNoLm1hdGVyaWFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWF0ZXJpYWwgPSBtZXNoLm1hdGVyaWFsO1xuICAgICAgICAgICAgaWYgKCFtYXRlcmlhbC50cmFuc3BhcmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJvdW5kaW5nQm94LnNldEZyb21PYmplY3QobWVzaCk7XG4gICAgICAgICAgICBjb25zdCBzaXplID0gYm91bmRpbmdCb3guZ2V0U2l6ZSh2ZWN0b3IzKTtcbiAgICAgICAgICAgIGNvbnN0IG1pbkRpbSA9IE1hdGgubWluKHNpemUueCwgc2l6ZS55LCBzaXplLnopO1xuICAgICAgICAgICAgY29uc3QgbWF4RGltID0gTWF0aC5tYXgoc2l6ZS54LCBzaXplLnksIHNpemUueik7XG4gICAgICAgICAgICBpZiAobWF4RGltIDwgTUlOX1NIQURPV19SQVRJTyAqIG1pbkRpbSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubWFya0Jha2VkU2hhZG93KG1lc2gpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2hlY2tCYWtlZFNoYWRvd3MoKSB7XG4gICAgICAgIGNvbnN0IHsgbWluLCBtYXggfSA9IHRoaXMuYm91bmRpbmdCb3g7XG4gICAgICAgIGNvbnN0IHNoYWRvd0JveCA9IG5ldyBCb3gzKCk7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3guZ2V0U2l6ZSh0aGlzLnNpemUpO1xuICAgICAgICBmb3IgKGNvbnN0IG1lc2ggb2YgdGhpcy5iYWtlZFNoYWRvd3MpIHtcbiAgICAgICAgICAgIHNoYWRvd0JveC5zZXRGcm9tT2JqZWN0KG1lc2gpO1xuICAgICAgICAgICAgaWYgKHNoYWRvd0JveC5taW4ueSA8IG1pbi55ICsgdGhpcy5zaXplLnkgLyBNSU5fU0hBRE9XX1JBVElPICYmXG4gICAgICAgICAgICAgICAgc2hhZG93Qm94Lm1pbi54IDw9IG1pbi54ICYmIHNoYWRvd0JveC5tYXgueCA+PSBtYXgueCAmJlxuICAgICAgICAgICAgICAgIHNoYWRvd0JveC5taW4ueiA8PSBtaW4ueiAmJiBzaGFkb3dCb3gubWF4LnogPj0gbWF4LnopIHtcbiAgICAgICAgICAgICAgICAvLyBmbG9vciBzaGFkb3dcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaGFkb3dCb3gubWluLnogPCBtaW4ueiArIHRoaXMuc2l6ZS56IC8gTUlOX1NIQURPV19SQVRJTyAmJlxuICAgICAgICAgICAgICAgIHNoYWRvd0JveC5taW4ueCA8PSBtaW4ueCAmJiBzaGFkb3dCb3gubWF4LnggPj0gbWF4LnggJiZcbiAgICAgICAgICAgICAgICBzaGFkb3dCb3gubWluLnkgPD0gbWluLnkgJiYgc2hhZG93Qm94Lm1heC55ID49IG1heC55KSB7XG4gICAgICAgICAgICAgICAgLy8gd2FsbCBzaGFkb3dcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudW5tYXJrQmFrZWRTaGFkb3cobWVzaCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXBwbHlUcmFuc2Zvcm0oKSB7XG4gICAgICAgIGNvbnN0IHsgbW9kZWwgfSA9IHRoaXM7XG4gICAgICAgIGlmIChtb2RlbCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3JpZW50YXRpb24gPSBwYXJzZUV4cHJlc3Npb25zKHRoaXMuZWxlbWVudC5vcmllbnRhdGlvbilbMF1cbiAgICAgICAgICAgIC50ZXJtcztcbiAgICAgICAgY29uc3Qgcm9sbCA9IG5vcm1hbGl6ZVVuaXQob3JpZW50YXRpb25bMF0pLm51bWJlcjtcbiAgICAgICAgY29uc3QgcGl0Y2ggPSBub3JtYWxpemVVbml0KG9yaWVudGF0aW9uWzFdKS5udW1iZXI7XG4gICAgICAgIGNvbnN0IHlhdyA9IG5vcm1hbGl6ZVVuaXQob3JpZW50YXRpb25bMl0pLm51bWJlcjtcbiAgICAgICAgbW9kZWwucXVhdGVybmlvbi5zZXRGcm9tRXVsZXIobmV3IEV1bGVyKHBpdGNoLCB5YXcsIHJvbGwsICdZWFonKSk7XG4gICAgICAgIGNvbnN0IHNjYWxlID0gcGFyc2VFeHByZXNzaW9ucyh0aGlzLmVsZW1lbnQuc2NhbGUpWzBdXG4gICAgICAgICAgICAudGVybXM7XG4gICAgICAgIG1vZGVsLnNjYWxlLnNldChzY2FsZVswXS5udW1iZXIsIHNjYWxlWzFdLm51bWJlciwgc2NhbGVbMl0ubnVtYmVyKTtcbiAgICB9XG4gICAgdXBkYXRlQm91bmRpbmdCb3goKSB7XG4gICAgICAgIGNvbnN0IHsgbW9kZWwgfSA9IHRoaXM7XG4gICAgICAgIGlmIChtb2RlbCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50YXJnZXQucmVtb3ZlKG1vZGVsKTtcbiAgICAgICAgdGhpcy5maW5kQmFrZWRTaGFkb3dzKG1vZGVsKTtcbiAgICAgICAgY29uc3QgYm91bmQgPSAoYm94LCB2ZXJ0ZXgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBib3guZXhwYW5kQnlQb2ludCh2ZXJ0ZXgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNldEJha2VkU2hhZG93VmlzaWJpbGl0eShmYWxzZSk7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3ggPSByZWR1Y2VWZXJ0aWNlcyhtb2RlbCwgYm91bmQsIG5ldyBCb3gzKCkpO1xuICAgICAgICAvLyBJZiB0aGVyZSdzIG5vdGhpbmcgYnV0IHRoZSBiYWtlZCBzaGFkb3csIHRoZW4gaXQncyBub3QgYSBiYWtlZCBzaGFkb3cuXG4gICAgICAgIGlmICh0aGlzLmJvdW5kaW5nQm94LmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRCYWtlZFNoYWRvd1Zpc2liaWxpdHkodHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLmJha2VkU2hhZG93cy5mb3JFYWNoKChtZXNoKSA9PiB0aGlzLnVubWFya0Jha2VkU2hhZG93KG1lc2gpKTtcbiAgICAgICAgICAgIHRoaXMuYm91bmRpbmdCb3ggPSByZWR1Y2VWZXJ0aWNlcyhtb2RlbCwgYm91bmQsIG5ldyBCb3gzKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hlY2tCYWtlZFNoYWRvd3MoKTtcbiAgICAgICAgdGhpcy5zZXRCYWtlZFNoYWRvd1Zpc2liaWxpdHkoKTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5nZXRTaXplKHRoaXMuc2l6ZSk7XG4gICAgICAgIHRoaXMudGFyZ2V0LmFkZChtb2RlbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGJvdW5kaW5nU3BoZXJlIGFuZCBpZGVhbEFzcGVjdCB0aGF0IGFsbG93cyB0aGUgM0RcbiAgICAgKiBvYmplY3QgdG8gYmUgZnJhbWVkIHRpZ2h0bHkgaW4gYSAyRCB3aW5kb3cgb2YgYW55IGFzcGVjdCByYXRpbyB3aXRob3V0XG4gICAgICogY2xpcHBpbmcgYXQgYW55IGNhbWVyYSBvcmJpdC4gVGhlIGNhbWVyYSdzIGNlbnRlciB0YXJnZXQgcG9pbnQgY2FuIGJlXG4gICAgICogb3B0aW9uYWxseSBzcGVjaWZpZWQuIElmIG5vIGNlbnRlciBpcyBzcGVjaWZpZWQsIGl0IGRlZmF1bHRzIHRvIHRoZSBjZW50ZXJcbiAgICAgKiBvZiB0aGUgYm91bmRpbmcgYm94LCB3aGljaCBtZWFucyBhc3ltbWV0cmljIG1vZGVscyB3aWxsIHRlbmQgdG8gYmUgdGlnaHQgb25cbiAgICAgKiBvbmUgc2lkZSBpbnN0ZWFkIG9mIGJvdGguIFByb3BlciBjaG9pY2Ugb2YgY2VudGVyIGNhbiBjb3JyZWN0IHRoaXMuXG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlRnJhbWluZygpIHtcbiAgICAgICAgY29uc3QgeyBtb2RlbCB9ID0gdGhpcztcbiAgICAgICAgaWYgKG1vZGVsID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRhcmdldC5yZW1vdmUobW9kZWwpO1xuICAgICAgICB0aGlzLnNldEJha2VkU2hhZG93VmlzaWJpbGl0eShmYWxzZSk7XG4gICAgICAgIGNvbnN0IHsgY2VudGVyIH0gPSB0aGlzLmJvdW5kaW5nU3BoZXJlO1xuICAgICAgICB0aGlzLmVsZW1lbnQucmVxdWVzdFVwZGF0ZSgnY2FtZXJhVGFyZ2V0Jyk7XG4gICAgICAgIGF3YWl0IHRoaXMuZWxlbWVudC51cGRhdGVDb21wbGV0ZTtcbiAgICAgICAgY2VudGVyLmNvcHkodGhpcy5nZXRUYXJnZXQoKSk7XG4gICAgICAgIGNvbnN0IHJhZGl1c1NxdWFyZWQgPSAodmFsdWUsIHZlcnRleCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHZhbHVlLCBjZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQodmVydGV4KSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmUucmFkaXVzID1cbiAgICAgICAgICAgIE1hdGguc3FydChyZWR1Y2VWZXJ0aWNlcyhtb2RlbCwgcmFkaXVzU3F1YXJlZCwgMCkpO1xuICAgICAgICBjb25zdCBob3Jpem9udGFsVGFuRm92ID0gKHZhbHVlLCB2ZXJ0ZXgpID0+IHtcbiAgICAgICAgICAgIHZlcnRleC5zdWIoY2VudGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHJhZGl1c1haID0gTWF0aC5zcXJ0KHZlcnRleC54ICogdmVydGV4LnggKyB2ZXJ0ZXgueiAqIHZlcnRleC56KTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heCh2YWx1ZSwgcmFkaXVzWFogLyAodGhpcy5pZGVhbENhbWVyYURpc3RhbmNlKCkgLSBNYXRoLmFicyh2ZXJ0ZXgueSkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5pZGVhbEFzcGVjdCA9IHJlZHVjZVZlcnRpY2VzKG1vZGVsLCBob3Jpem9udGFsVGFuRm92LCAwKSAvXG4gICAgICAgICAgICBNYXRoLnRhbigodGhpcy5mcmFtZWRGb1ZEZWcgLyAyKSAqIE1hdGguUEkgLyAxODApO1xuICAgICAgICB0aGlzLnNldEJha2VkU2hhZG93VmlzaWJpbGl0eSgpO1xuICAgICAgICB0aGlzLnRhcmdldC5hZGQobW9kZWwpO1xuICAgIH1cbiAgICBzZXRCYWtlZFNoYWRvd1Zpc2liaWxpdHkodmlzaWJsZSA9IHRoaXMuc2hhZG93SW50ZW5zaXR5IDw9IDApIHtcbiAgICAgICAgZm9yIChjb25zdCBzaGFkb3cgb2YgdGhpcy5iYWtlZFNoYWRvd3MpIHtcbiAgICAgICAgICAgIHNoYWRvdy52aXNpYmxlID0gdmlzaWJsZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZGVhbENhbWVyYURpc3RhbmNlKCkge1xuICAgICAgICBjb25zdCBoYWxmRm92UmFkID0gKHRoaXMuZnJhbWVkRm9WRGVnIC8gMikgKiBNYXRoLlBJIC8gMTgwO1xuICAgICAgICByZXR1cm4gdGhpcy5ib3VuZGluZ1NwaGVyZS5yYWRpdXMgLyBNYXRoLnNpbihoYWxmRm92UmFkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0J3MgdGhlIGZyYW1lZEZpZWxkT2ZWaWV3IGJhc2VkIG9uIHRoZSBhc3BlY3QgcmF0aW8gb2YgdGhlIHdpbmRvdyBpblxuICAgICAqIG9yZGVyIHRvIGtlZXAgdGhlIG1vZGVsIGZ1bGx5IHZpc2libGUgYXQgYW55IGNhbWVyYSBvcmllbnRhdGlvbi5cbiAgICAgKi9cbiAgICBhZGp1c3RlZEZvVihmb3ZEZWcpIHtcbiAgICAgICAgY29uc3QgdmVydGljYWwgPSBNYXRoLnRhbigoZm92RGVnIC8gMikgKiBNYXRoLlBJIC8gMTgwKSAqXG4gICAgICAgICAgICBNYXRoLm1heCgxLCB0aGlzLmlkZWFsQXNwZWN0IC8gdGhpcy5hc3BlY3QpO1xuICAgICAgICByZXR1cm4gMiAqIE1hdGguYXRhbih2ZXJ0aWNhbCkgKiAxODAgLyBNYXRoLlBJO1xuICAgIH1cbiAgICBnZXROREMoY2xpZW50WCwgY2xpZW50WSkge1xuICAgICAgICBpZiAodGhpcy54ckNhbWVyYSAhPSBudWxsKSB7XG4gICAgICAgICAgICBuZGMuc2V0KGNsaWVudFggLyB3aW5kb3cuc2NyZWVuLndpZHRoLCBjbGllbnRZIC8gd2luZG93LnNjcmVlbi5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcmVjdCA9IHRoaXMuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIG5kYy5zZXQoKGNsaWVudFggLSByZWN0LngpIC8gdGhpcy53aWR0aCwgKGNsaWVudFkgLSByZWN0LnkpIC8gdGhpcy5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIG5kYy5tdWx0aXBseVNjYWxhcigyKS5zdWJTY2FsYXIoMSk7XG4gICAgICAgIG5kYy55ICo9IC0xO1xuICAgICAgICByZXR1cm4gbmRjO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzaXplIG9mIHRoZSBjb3JyZXNwb25kaW5nIGNhbnZhcyBlbGVtZW50LlxuICAgICAqL1xuICAgIGdldFNpemUoKSB7XG4gICAgICAgIHJldHVybiB7IHdpZHRoOiB0aGlzLndpZHRoLCBoZWlnaHQ6IHRoaXMuaGVpZ2h0IH07XG4gICAgfVxuICAgIHNldEVudmlyb25tZW50QW5kU2t5Ym94KGVudmlyb25tZW50LCBza3lib3gpIHtcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudFskcmVuZGVyZXJdLmFyUmVuZGVyZXIucHJlc2VudGVkU2NlbmUgPT09IHRoaXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVudmlyb25tZW50ID0gZW52aXJvbm1lbnQ7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZCA9IHNreWJveDtcbiAgICAgICAgdGhpcy5xdWV1ZVJlbmRlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBwb2ludCBpbiBtb2RlbCBjb29yZGluYXRlcyB0aGUgbW9kZWwgc2hvdWxkIG9yYml0L3Bpdm90IGFyb3VuZC5cbiAgICAgKi9cbiAgICBzZXRUYXJnZXQobW9kZWxYLCBtb2RlbFksIG1vZGVsWikge1xuICAgICAgICB0aGlzLmdvYWxUYXJnZXQuc2V0KC1tb2RlbFgsIC1tb2RlbFksIC1tb2RlbFopO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGRlY2F5IHRpbWUgb2YsIGFmZmVjdHMgdGhlIHNwZWVkIG9mIHRhcmdldCB0cmFuc2l0aW9ucy5cbiAgICAgKi9cbiAgICBzZXRUYXJnZXREYW1wZXJEZWNheVRpbWUoZGVjYXlNaWxsaXNlY29uZHMpIHtcbiAgICAgICAgdGhpcy50YXJnZXREYW1wZXJYLnNldERlY2F5VGltZShkZWNheU1pbGxpc2Vjb25kcyk7XG4gICAgICAgIHRoaXMudGFyZ2V0RGFtcGVyWS5zZXREZWNheVRpbWUoZGVjYXlNaWxsaXNlY29uZHMpO1xuICAgICAgICB0aGlzLnRhcmdldERhbXBlclouc2V0RGVjYXlUaW1lKGRlY2F5TWlsbGlzZWNvbmRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcG9pbnQgaW4gbW9kZWwgY29vcmRpbmF0ZXMgdGhlIG1vZGVsIHNob3VsZCBvcmJpdC9waXZvdCBhcm91bmQuXG4gICAgICovXG4gICAgZ2V0VGFyZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nb2FsVGFyZ2V0LmNsb25lKCkubXVsdGlwbHlTY2FsYXIoLTEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaGlmdHMgdGhlIG1vZGVsIHRvIHRoZSB0YXJnZXQgcG9pbnQgaW1tZWRpYXRlbHkgaW5zdGVhZCBvZiBlYXNpbmcgaW4uXG4gICAgICovXG4gICAganVtcFRvR29hbCgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVUYXJnZXQoU0VUVExJTkdfVElNRSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCBldmVyeSBmcmFtZSB3aXRoIHRoZSBmcmFtZSBkZWx0YSB0byBjYXVzZSB0aGUgdGFyZ2V0XG4gICAgICogdG8gdHJhbnNpdGlvbiB0byBpdHMgc2V0IHBvaW50LlxuICAgICAqL1xuICAgIHVwZGF0ZVRhcmdldChkZWx0YSkge1xuICAgICAgICBjb25zdCBnb2FsID0gdGhpcy5nb2FsVGFyZ2V0O1xuICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLnRhcmdldC5wb3NpdGlvbjtcbiAgICAgICAgaWYgKCFnb2FsLmVxdWFscyh0YXJnZXQpKSB7XG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemF0aW9uID0gdGhpcy5ib3VuZGluZ1NwaGVyZS5yYWRpdXMgLyAxMDtcbiAgICAgICAgICAgIGxldCB7IHgsIHksIHogfSA9IHRhcmdldDtcbiAgICAgICAgICAgIHggPSB0aGlzLnRhcmdldERhbXBlclgudXBkYXRlKHgsIGdvYWwueCwgZGVsdGEsIG5vcm1hbGl6YXRpb24pO1xuICAgICAgICAgICAgeSA9IHRoaXMudGFyZ2V0RGFtcGVyWS51cGRhdGUoeSwgZ29hbC55LCBkZWx0YSwgbm9ybWFsaXphdGlvbik7XG4gICAgICAgICAgICB6ID0gdGhpcy50YXJnZXREYW1wZXJaLnVwZGF0ZSh6LCBnb2FsLnosIGRlbHRhLCBub3JtYWxpemF0aW9uKTtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0LnBvc2l0aW9uLnNldCh4LCB5LCB6KTtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG4gICAgICAgICAgICB0aGlzLnF1ZXVlUmVuZGVyKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBZYXcgdGhlICt6IChmcm9udCkgb2YgdGhlIG1vZGVsIHRvd2FyZCB0aGUgaW5kaWNhdGVkIHdvcmxkIGNvb3JkaW5hdGVzLlxuICAgICAqL1xuICAgIHBvaW50VG93YXJkcyh3b3JsZFgsIHdvcmxkWikge1xuICAgICAgICBjb25zdCB7IHgsIHogfSA9IHRoaXMucG9zaXRpb247XG4gICAgICAgIHRoaXMueWF3ID0gTWF0aC5hdGFuMih3b3JsZFggLSB4LCB3b3JsZFogLSB6KTtcbiAgICB9XG4gICAgZ2V0IG1vZGVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbW9kZWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFlhdyBpcyB0aGUgc2NlbmUncyBvcmllbnRhdGlvbiBhYm91dCB0aGUgeS1heGlzLCBhcm91bmQgdGhlIHJvdGF0aW9uXG4gICAgICogY2VudGVyLlxuICAgICAqL1xuICAgIHNldCB5YXcocmFkaWFuc1kpIHtcbiAgICAgICAgdGhpcy5yb3RhdGlvbi55ID0gcmFkaWFuc1k7XG4gICAgICAgIHRoaXMucXVldWVSZW5kZXIoKTtcbiAgICB9XG4gICAgZ2V0IHlhdygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm90YXRpb24ueTtcbiAgICB9XG4gICAgc2V0IGFuaW1hdGlvblRpbWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5taXhlci5zZXRUaW1lKHZhbHVlKTtcbiAgICAgICAgdGhpcy5xdWV1ZVNoYWRvd1JlbmRlcigpO1xuICAgIH1cbiAgICBnZXQgYW5pbWF0aW9uVGltZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEFuaW1hdGlvbkFjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBsb29wQ291bnQgPSBNYXRoLm1heCh0aGlzLmN1cnJlbnRBbmltYXRpb25BY3Rpb24uX2xvb3BDb3VudCwgMCk7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50QW5pbWF0aW9uQWN0aW9uLmxvb3AgPT09IExvb3BQaW5nUG9uZyAmJlxuICAgICAgICAgICAgICAgIChsb29wQ291bnQgJiAxKSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmR1cmF0aW9uIC0gdGhpcy5jdXJyZW50QW5pbWF0aW9uQWN0aW9uLnRpbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50QW5pbWF0aW9uQWN0aW9uLnRpbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHNldCBhbmltYXRpb25UaW1lU2NhbGUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5taXhlci50aW1lU2NhbGUgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGFuaW1hdGlvblRpbWVTY2FsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWl4ZXIudGltZVNjYWxlO1xuICAgIH1cbiAgICBnZXQgZHVyYXRpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRBbmltYXRpb25BY3Rpb24gIT0gbnVsbCAmJlxuICAgICAgICAgICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uQWN0aW9uLmdldENsaXAoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudEFuaW1hdGlvbkFjdGlvbi5nZXRDbGlwKCkuZHVyYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGdldCBoYXNBY3RpdmVBbmltYXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRBbmltYXRpb25BY3Rpb24gIT0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGxheXMgYW4gYW5pbWF0aW9uIGlmIHRoZXJlIGFyZSBhbnkgYXNzb2NpYXRlZCB3aXRoIHRoZSBjdXJyZW50IG1vZGVsLlxuICAgICAqIEFjY2VwdHMgYW4gb3B0aW9uYWwgc3RyaW5nIG5hbWUgb2YgYW4gYW5pbWF0aW9uIHRvIHBsYXkuIElmIG5vIG5hbWUgaXNcbiAgICAgKiBwcm92aWRlZCwgb3IgaWYgbm8gYW5pbWF0aW9uIGlzIGZvdW5kIGJ5IHRoZSBnaXZlbiBuYW1lLCBhbHdheXMgZmFsbHMgYmFja1xuICAgICAqIHRvIHBsYXlpbmcgdGhlIGZpcnN0IGFuaW1hdGlvbi5cbiAgICAgKi9cbiAgICBwbGF5QW5pbWF0aW9uKG5hbWUgPSBudWxsLCBjcm9zc2ZhZGVUaW1lID0gMCwgbG9vcE1vZGUgPSBMb29wUmVwZWF0LCByZXBldGl0aW9uQ291bnQgPSBJbmZpbml0eSkge1xuICAgICAgICBpZiAodGhpcy5fY3VycmVudEdMVEYgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgYW5pbWF0aW9ucyB9ID0gdGhpcztcbiAgICAgICAgaWYgKGFuaW1hdGlvbnMgPT0gbnVsbCB8fCBhbmltYXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhbmltYXRpb25DbGlwID0gbnVsbDtcbiAgICAgICAgaWYgKG5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgYW5pbWF0aW9uQ2xpcCA9IHRoaXMuYW5pbWF0aW9uc0J5TmFtZS5nZXQobmFtZSk7XG4gICAgICAgICAgICBpZiAoYW5pbWF0aW9uQ2xpcCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkQW5pbWF0aW9uSW5kZXggPSBwYXJzZUludChuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKHBhcnNlZEFuaW1hdGlvbkluZGV4KSAmJiBwYXJzZWRBbmltYXRpb25JbmRleCA+PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZEFuaW1hdGlvbkluZGV4IDwgYW5pbWF0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uQ2xpcCA9IGFuaW1hdGlvbnNbcGFyc2VkQW5pbWF0aW9uSW5kZXhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5pbWF0aW9uQ2xpcCA9PSBudWxsKSB7XG4gICAgICAgICAgICBhbmltYXRpb25DbGlwID0gYW5pbWF0aW9uc1swXTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBjdXJyZW50QW5pbWF0aW9uQWN0aW9uOiBsYXN0QW5pbWF0aW9uQWN0aW9uIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgYWN0aW9uID0gdGhpcy5taXhlci5jbGlwQWN0aW9uKGFuaW1hdGlvbkNsaXAsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uQWN0aW9uID0gYWN0aW9uO1xuICAgICAgICAgICAgaWYgKHRoaXMuZWxlbWVudC5wYXVzZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1peGVyLnN0b3BBbGxBY3Rpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFjdGlvbi5wYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdEFuaW1hdGlvbkFjdGlvbiAhPSBudWxsICYmIGFjdGlvbiAhPT0gbGFzdEFuaW1hdGlvbkFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb24uY3Jvc3NGYWRlRnJvbShsYXN0QW5pbWF0aW9uQWN0aW9uLCBjcm9zc2ZhZGVUaW1lLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuYW5pbWF0aW9uVGltZVNjYWxlID4gMCAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvblRpbWUgPT0gdGhpcy5kdXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgd29ya2Fyb3VuZCBmb3Igd2hhdCBJIGJlbGlldmUgaXMgYSB0aHJlZS5qcyBidWcuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uVGltZSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWN0aW9uLnNldExvb3AobG9vcE1vZGUsIHJlcGV0aXRpb25Db3VudCk7XG4gICAgICAgICAgICBhY3Rpb24uZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICBhY3Rpb24uY2xhbXBXaGVuRmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgYWN0aW9uLnBsYXkoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0b3BBbmltYXRpb24oKSB7XG4gICAgICAgIHRoaXMuY3VycmVudEFuaW1hdGlvbkFjdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMubWl4ZXIuc3RvcEFsbEFjdGlvbigpO1xuICAgIH1cbiAgICB1cGRhdGVBbmltYXRpb24oc3RlcCkge1xuICAgICAgICB0aGlzLm1peGVyLnVwZGF0ZShzdGVwKTtcbiAgICAgICAgdGhpcy5xdWV1ZVNoYWRvd1JlbmRlcigpO1xuICAgIH1cbiAgICBzdWJzY3JpYmVNaXhlckV2ZW50KGV2ZW50LCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLm1peGVyLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbCBpZiB0aGUgb2JqZWN0IGhhcyBiZWVuIGNoYW5nZWQgaW4gc3VjaCBhIHdheSB0aGF0IHRoZSBzaGFkb3cncyBzaGFwZVxuICAgICAqIGhhcyBjaGFuZ2VkIChub3QgYSByb3RhdGlvbiBhYm91dCB0aGUgWSBheGlzKS5cbiAgICAgKi9cbiAgICB1cGRhdGVTaGFkb3coKSB7XG4gICAgICAgIGNvbnN0IHNoYWRvdyA9IHRoaXMuc2hhZG93O1xuICAgICAgICBpZiAoc2hhZG93ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZGUgPSB0aGlzLmVsZW1lbnQuYXJQbGFjZW1lbnQgPT09ICd3YWxsJyA/ICdiYWNrJyA6ICdib3R0b20nO1xuICAgICAgICAgICAgc2hhZG93LnNldFNjZW5lKHRoaXMsIHRoaXMuc2hhZG93U29mdG5lc3MsIHNpZGUpO1xuICAgICAgICAgICAgc2hhZG93Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXJTaGFkb3cocmVuZGVyZXIpIHtcbiAgICAgICAgY29uc3Qgc2hhZG93ID0gdGhpcy5zaGFkb3c7XG4gICAgICAgIGlmIChzaGFkb3cgIT0gbnVsbCAmJiBzaGFkb3cubmVlZHNVcGRhdGUgPT0gdHJ1ZSkge1xuICAgICAgICAgICAgc2hhZG93LnJlbmRlcihyZW5kZXJlciwgdGhpcyk7XG4gICAgICAgICAgICBzaGFkb3cubmVlZHNVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZVNoYWRvd1JlbmRlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuc2hhZG93ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc2hhZG93Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzaGFkb3cncyBpbnRlbnNpdHksIGxhemlseSBjcmVhdGluZyB0aGUgc2hhZG93IGFzIG5lY2Vzc2FyeS5cbiAgICAgKi9cbiAgICBzZXRTaGFkb3dJbnRlbnNpdHkoc2hhZG93SW50ZW5zaXR5KSB7XG4gICAgICAgIHRoaXMuc2hhZG93SW50ZW5zaXR5ID0gc2hhZG93SW50ZW5zaXR5O1xuICAgICAgICBpZiAodGhpcy5fY3VycmVudEdMVEYgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0QmFrZWRTaGFkb3dWaXNpYmlsaXR5KCk7XG4gICAgICAgIGlmIChzaGFkb3dJbnRlbnNpdHkgPD0gMCAmJiB0aGlzLnNoYWRvdyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2hhZG93ID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZGUgPSB0aGlzLmVsZW1lbnQuYXJQbGFjZW1lbnQgPT09ICd3YWxsJyA/ICdiYWNrJyA6ICdib3R0b20nO1xuICAgICAgICAgICAgdGhpcy5zaGFkb3cgPSBuZXcgU2hhZG93KHRoaXMsIHRoaXMuc2hhZG93U29mdG5lc3MsIHNpZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2hhZG93LnNldEludGVuc2l0eShzaGFkb3dJbnRlbnNpdHkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzaGFkb3cncyBzb2Z0bmVzcyBieSBtYXBwaW5nIGEgWzAsIDFdIHNvZnRuZXNzIHBhcmFtZXRlciB0byB0aGVcbiAgICAgKiBzaGFkb3cncyByZXNvbHV0aW9uLiBUaGlzIGludm9sdmVzIHJlYWxsb2NhdGlvbiwgc28gaXQgc2hvdWxkIG5vdCBiZVxuICAgICAqIGNoYW5nZWQgZnJlcXVlbnRseS4gU29mdGVyIHNoYWRvd3MgYXJlIGNoZWFwZXIgdG8gcmVuZGVyLlxuICAgICAqL1xuICAgIHNldFNoYWRvd1NvZnRuZXNzKHNvZnRuZXNzKSB7XG4gICAgICAgIHRoaXMuc2hhZG93U29mdG5lc3MgPSBzb2Z0bmVzcztcbiAgICAgICAgY29uc3Qgc2hhZG93ID0gdGhpcy5zaGFkb3c7XG4gICAgICAgIGlmIChzaGFkb3cgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2hhZG93LnNldFNvZnRuZXNzKHNvZnRuZXNzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaGlmdCB0aGUgZmxvb3IgdmVydGljYWxseSBmcm9tIHRoZSBib3R0b20gb2YgdGhlIG1vZGVsJ3MgYm91bmRpbmcgYm94IGJ5XG4gICAgICogb2Zmc2V0IChzaG91bGQgZ2VuZXJhbGx5IGJlIG5lZ2F0aXZlKS5cbiAgICAgKi9cbiAgICBzZXRTaGFkb3dPZmZzZXQob2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IHNoYWRvdyA9IHRoaXMuc2hhZG93O1xuICAgICAgICBpZiAoc2hhZG93ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNoYWRvdy5zZXRPZmZzZXQob2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoaXRGcm9tUG9pbnQobmRjUG9zaXRpb24sIG9iamVjdCA9IHRoaXMpIHtcbiAgICAgICAgcmF5Y2FzdGVyLnNldEZyb21DYW1lcmEobmRjUG9zaXRpb24sIHRoaXMuZ2V0Q2FtZXJhKCkpO1xuICAgICAgICBjb25zdCBoaXRzID0gcmF5Y2FzdGVyLmludGVyc2VjdE9iamVjdChvYmplY3QsIHRydWUpO1xuICAgICAgICByZXR1cm4gaGl0cy5maW5kKChoaXQpID0+IGhpdC5vYmplY3QudmlzaWJsZSAmJiAhaGl0Lm9iamVjdC51c2VyRGF0YS5zaGFkb3cpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSB3b3JsZCBwb3NpdGlvbiwgbW9kZWwtc3BhY2Ugbm9ybWFsIGFuZCB0ZXh0dXJlXG4gICAgICogY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgb24gdGhlIG1lc2ggY29ycmVzcG9uZGluZyB0byB0aGUgaW5wdXQgcGl4ZWxcbiAgICAgKiBjb29yZGluYXRlcyBnaXZlbiByZWxhdGl2ZSB0byB0aGUgbW9kZWwtdmlld2VyIGVsZW1lbnQuIElmIHRoZSBtZXNoXG4gICAgICogaXMgbm90IGhpdCwgdGhlIHJlc3VsdCBpcyBudWxsLlxuICAgICAqL1xuICAgIHBvc2l0aW9uQW5kTm9ybWFsRnJvbVBvaW50KG5kY1Bvc2l0aW9uLCBvYmplY3QgPSB0aGlzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgaGl0ID0gdGhpcy5oaXRGcm9tUG9pbnQobmRjUG9zaXRpb24sIG9iamVjdCk7XG4gICAgICAgIGlmIChoaXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBoaXQucG9pbnQ7XG4gICAgICAgIGNvbnN0IG5vcm1hbCA9IGhpdC5mYWNlICE9IG51bGwgP1xuICAgICAgICAgICAgaGl0LmZhY2Uubm9ybWFsLmNsb25lKCkuYXBwbHlOb3JtYWxNYXRyaXgobmV3IE1hdHJpeDMoKS5nZXROb3JtYWxNYXRyaXgoaGl0Lm9iamVjdC5tYXRyaXhXb3JsZCkpIDpcbiAgICAgICAgICAgIHJheWNhc3Rlci5yYXkuZGlyZWN0aW9uLmNsb25lKCkubXVsdGlwbHlTY2FsYXIoLTEpO1xuICAgICAgICBjb25zdCB1diA9IChfYSA9IGhpdC51dikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbDtcbiAgICAgICAgcmV0dXJuIHsgcG9zaXRpb24sIG5vcm1hbCwgdXYgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBhIGR5bmFtaWMgaG90c3BvdCBJRCBzdHJpbmcgb2YgdGhlIHBvaW50IG9uIHRoZSBtZXNoXG4gICAgICogY29ycmVzcG9uZGluZyB0byB0aGUgaW5wdXQgcGl4ZWwgY29vcmRpbmF0ZXMgZ2l2ZW4gcmVsYXRpdmUgdG8gdGhlXG4gICAgICogbW9kZWwtdmlld2VyIGVsZW1lbnQuIFRoZSBJRCBzdHJpbmcgY2FuIGJlIHVzZWQgaW4gdGhlIGRhdGEtc3VyZmFjZVxuICAgICAqIGF0dHJpYnV0ZSBvZiB0aGUgaG90c3BvdCB0byBtYWtlIGl0IGZvbGxvdyB0aGlzIHBvaW50IG9uIHRoZSBzdXJmYWNlIGV2ZW5cbiAgICAgKiBhcyB0aGUgbW9kZWwgYW5pbWF0ZXMuIElmIHRoZSBtZXNoIGlzIG5vdCBoaXQsIHRoZSByZXN1bHQgaXMgbnVsbC5cbiAgICAgKi9cbiAgICBzdXJmYWNlRnJvbVBvaW50KG5kY1Bvc2l0aW9uLCBvYmplY3QgPSB0aGlzKSB7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5lbGVtZW50Lm1vZGVsO1xuICAgICAgICBpZiAobW9kZWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGl0ID0gdGhpcy5oaXRGcm9tUG9pbnQobmRjUG9zaXRpb24sIG9iamVjdCk7XG4gICAgICAgIGlmIChoaXQgPT0gbnVsbCB8fCBoaXQuZmFjZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub2RlID0gbW9kZWxbJG5vZGVGcm9tUG9pbnRdKGhpdCk7XG4gICAgICAgIGNvbnN0IHsgbWVzaGVzLCBwcmltaXRpdmVzIH0gPSBub2RlLm1lc2gudXNlckRhdGEuYXNzb2NpYXRpb25zO1xuICAgICAgICBjb25zdCB2YSA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICAgIGNvbnN0IHZiID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgICAgY29uc3QgdmMgPSBuZXcgVmVjdG9yMygpO1xuICAgICAgICBjb25zdCB7IGEsIGIsIGMgfSA9IGhpdC5mYWNlO1xuICAgICAgICBjb25zdCBtZXNoID0gaGl0Lm9iamVjdDtcbiAgICAgICAgbWVzaC5nZXRWZXJ0ZXhQb3NpdGlvbihhLCB2YSk7XG4gICAgICAgIG1lc2guZ2V0VmVydGV4UG9zaXRpb24oYiwgdmIpO1xuICAgICAgICBtZXNoLmdldFZlcnRleFBvc2l0aW9uKGMsIHZjKTtcbiAgICAgICAgY29uc3QgdHJpID0gbmV3IFRyaWFuZ2xlKHZhLCB2YiwgdmMpO1xuICAgICAgICBjb25zdCB1dncgPSBuZXcgVmVjdG9yMygpO1xuICAgICAgICB0cmkuZ2V0QmFyeWNvb3JkKG1lc2gud29ybGRUb0xvY2FsKGhpdC5wb2ludCksIHV2dyk7XG4gICAgICAgIHJldHVybiBgJHttZXNoZXN9ICR7cHJpbWl0aXZlc30gJHthfSAke2J9ICR7Y30gJHt1dncueC50b0ZpeGVkKDMpfSAke3V2dy55LnRvRml4ZWQoMyl9ICR7dXZ3LnoudG9GaXhlZCgzKX1gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZm9sbG93aW5nIG1ldGhvZHMgYXJlIGZvciBvcGVyYXRpbmcgb24gdGhlIHNldCBvZiBIb3RzcG90IG9iamVjdHNcbiAgICAgKiBhdHRhY2hlZCB0byB0aGUgc2NlbmUuIFRoZXNlIGNvbWUgZnJvbSBET00gZWxlbWVudHMsIHByb3ZpZGVkIHRvIHNsb3RzIGJ5XG4gICAgICogdGhlIEFubm90YXRpb24gTWl4aW4uXG4gICAgICovXG4gICAgYWRkSG90c3BvdChob3RzcG90KSB7XG4gICAgICAgIHRoaXMudGFyZ2V0LmFkZChob3RzcG90KTtcbiAgICAgICAgLy8gVGhpcyBoYXBwZW5zIGF1dG9tYXRpY2FsbHkgaW4gcmVuZGVyKCksIGJ1dCB3ZSBkbyBpdCBlYXJseSBzbyB0aGF0XG4gICAgICAgIC8vIHRoZSBzbG90cyBhcHBlYXIgaW4gdGhlIHNoYWRvdyBET00gYW5kIHRoZSBlbGVtZW50cyBnZXQgYXR0YWNoZWQsXG4gICAgICAgIC8vIGFsbG93aW5nIHVzIHRvIGRpc3BhdGNoIGV2ZW50cyBvbiB0aGVtLlxuICAgICAgICB0aGlzLmFubm90YXRpb25SZW5kZXJlci5kb21FbGVtZW50LmFwcGVuZENoaWxkKGhvdHNwb3QuZWxlbWVudCk7XG4gICAgfVxuICAgIHJlbW92ZUhvdHNwb3QoaG90c3BvdCkge1xuICAgICAgICB0aGlzLnRhcmdldC5yZW1vdmUoaG90c3BvdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgdG8gYXBwbHkgYSBmdW5jdGlvbiB0byBhbGwgaG90c3BvdHMuXG4gICAgICovXG4gICAgZm9ySG90c3BvdHMoZnVuYykge1xuICAgICAgICBjb25zdCB7IGNoaWxkcmVuIH0gPSB0aGlzLnRhcmdldDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGhvdHNwb3QgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChob3RzcG90IGluc3RhbmNlb2YgSG90c3BvdCkge1xuICAgICAgICAgICAgICAgIGZ1bmMoaG90c3BvdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTGF6eSBpbml0aWFsaXplciBmb3Igc3VyZmFjZSBob3RzcG90cyAtIHdpbGwgb25seSBydW4gb25jZS5cbiAgICAgKi9cbiAgICBpbml0aWFsaXplU3VyZmFjZShob3RzcG90KSB7XG4gICAgICAgIGlmIChob3RzcG90LnN1cmZhY2UgIT0gbnVsbCAmJiBob3RzcG90Lm1lc2ggPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3Qgbm9kZXMgPSBwYXJzZUV4cHJlc3Npb25zKGhvdHNwb3Quc3VyZmFjZSlbMF0udGVybXM7XG4gICAgICAgICAgICBpZiAobm9kZXMubGVuZ3RoICE9IDgpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oaG90c3BvdC5zdXJmYWNlICsgJyBkb2VzIG5vdCBoYXZlIGV4YWN0bHkgOCBudW1iZXJzLicpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHByaW1pdGl2ZU5vZGUgPSB0aGlzLmVsZW1lbnQubW9kZWxbJG5vZGVGcm9tSW5kZXhdKG5vZGVzWzBdLm51bWJlciwgbm9kZXNbMV0ubnVtYmVyKTtcbiAgICAgICAgICAgIGNvbnN0IHRyaSA9IG5ldyBWZWN0b3IzKG5vZGVzWzJdLm51bWJlciwgbm9kZXNbM10ubnVtYmVyLCBub2Rlc1s0XS5udW1iZXIpO1xuICAgICAgICAgICAgaWYgKHByaW1pdGl2ZU5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybihob3RzcG90LnN1cmZhY2UgK1xuICAgICAgICAgICAgICAgICAgICAnIGRvZXMgbm90IG1hdGNoIGEgbm9kZS9wcmltaXRpdmUgaW4gdGhpcyBnbFRGISBTa2lwcGluZyB0aGlzIGhvdHNwb3QuJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbnVtVmVydCA9IHByaW1pdGl2ZU5vZGUubWVzaC5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmNvdW50O1xuICAgICAgICAgICAgaWYgKHRyaS54ID49IG51bVZlcnQgfHwgdHJpLnkgPj0gbnVtVmVydCB8fCB0cmkueiA+PSBudW1WZXJ0KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGhvdHNwb3Quc3VyZmFjZSArXG4gICAgICAgICAgICAgICAgICAgICcgdmVydGV4IGluZGljZXMgb3V0IG9mIHJhbmdlIGluIHRoaXMgZ2xURiEgU2tpcHBpbmcgdGhpcyBob3RzcG90LicpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJhcnkgPSBuZXcgVmVjdG9yMyhub2Rlc1s1XS5udW1iZXIsIG5vZGVzWzZdLm51bWJlciwgbm9kZXNbN10ubnVtYmVyKTtcbiAgICAgICAgICAgIGhvdHNwb3QubWVzaCA9IHByaW1pdGl2ZU5vZGUubWVzaDtcbiAgICAgICAgICAgIGhvdHNwb3QudHJpID0gdHJpO1xuICAgICAgICAgICAgaG90c3BvdC5iYXJ5ID0gYmFyeTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgcG9zaXRpb25zIG9mIHN1cmZhY2UgaG90c3BvdHMgdG8gZm9sbG93IG1vZGVsIGFuaW1hdGlvbi5cbiAgICAgKi9cbiAgICB1cGRhdGVTdXJmYWNlSG90c3BvdHMoKSB7XG4gICAgICAgIGNvbnN0IGZvcmNlVXBkYXRlID0gIXRoaXMuZWxlbWVudC5wYXVzZWQ7XG4gICAgICAgIHRoaXMuZm9ySG90c3BvdHMoKGhvdHNwb3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZVN1cmZhY2UoaG90c3BvdCk7XG4gICAgICAgICAgICBob3RzcG90LnVwZGF0ZVN1cmZhY2UoZm9yY2VVcGRhdGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBDU1MgdmlzaWJpbGl0eSBvZiB0aGUgaG90c3BvdHMgYmFzZWQgb24gd2hldGhlciB0aGVpciBub3JtYWxzXG4gICAgICogcG9pbnQgdG93YXJkIHRoZSBjYW1lcmEuXG4gICAgICovXG4gICAgdXBkYXRlSG90c3BvdHNWaXNpYmlsaXR5KHZpZXdlclBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMuZm9ySG90c3BvdHMoKGhvdHNwb3QpID0+IHtcbiAgICAgICAgICAgIHZpZXcuY29weSh2aWV3ZXJQb3NpdGlvbik7XG4gICAgICAgICAgICB0YXJnZXQuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGhvdHNwb3QubWF0cml4V29ybGQpO1xuICAgICAgICAgICAgdmlldy5zdWIodGFyZ2V0KTtcbiAgICAgICAgICAgIG5vcm1hbFdvcmxkLmNvcHkoaG90c3BvdC5ub3JtYWwpXG4gICAgICAgICAgICAgICAgLnRyYW5zZm9ybURpcmVjdGlvbih0aGlzLnRhcmdldC5tYXRyaXhXb3JsZCk7XG4gICAgICAgICAgICBpZiAodmlldy5kb3Qobm9ybWFsV29ybGQpIDwgMCkge1xuICAgICAgICAgICAgICAgIGhvdHNwb3QuaGlkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaG90c3BvdC5zaG93KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSb3RhdGUgYWxsIGhvdHNwb3RzIHRvIGFuIGFic29sdXRlIG9yaWVudGF0aW9uIGdpdmVuIGJ5IHRoZSBpbnB1dCBudW1iZXIgb2ZcbiAgICAgKiByYWRpYW5zLiBaZXJvIHJldHVybnMgdGhlbSB0byB1cHJpZ2h0LlxuICAgICAqL1xuICAgIG9yaWVudEhvdHNwb3RzKHJhZGlhbnMpIHtcbiAgICAgICAgdGhpcy5mb3JIb3RzcG90cygoaG90c3BvdCkgPT4ge1xuICAgICAgICAgICAgaG90c3BvdC5vcmllbnQocmFkaWFucyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHJlbmRlcmluZyB2aXNpYmlsaXR5IG9mIGFsbCBob3RzcG90cy4gVGhpcyBpcyB1c2VkIHRvIGhpZGUgdGhlbVxuICAgICAqIGR1cmluZyB0cmFuc2l0aW9ucyBhbmQgc3VjaC5cbiAgICAgKi9cbiAgICBzZXRIb3RzcG90c1Zpc2liaWxpdHkodmlzaWJsZSkge1xuICAgICAgICB0aGlzLmZvckhvdHNwb3RzKChob3RzcG90KSA9PiB7XG4gICAgICAgICAgICBob3RzcG90LnZpc2libGUgPSB2aXNpYmxlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdXBkYXRlU2NoZW1hKHNyYykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHsgc2NoZW1hRWxlbWVudCwgZWxlbWVudCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBhbHQsIHBvc3RlciwgaW9zU3JjIH0gPSBlbGVtZW50O1xuICAgICAgICBpZiAoc3JjICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGVuY29kaW5nID0gW3tcbiAgICAgICAgICAgICAgICAgICAgJ0B0eXBlJzogJ01lZGlhT2JqZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudFVybDogc3JjLFxuICAgICAgICAgICAgICAgICAgICBlbmNvZGluZ0Zvcm1hdDogKChfYSA9IHNyYy5zcGxpdCgnLicpLnBvcCgpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9Mb3dlckNhc2UoKSkgPT09ICdnbHRmJyA/XG4gICAgICAgICAgICAgICAgICAgICAgICAnbW9kZWwvZ2x0Zitqc29uJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAnbW9kZWwvZ2x0Zi1iaW5hcnknXG4gICAgICAgICAgICAgICAgfV07XG4gICAgICAgICAgICBpZiAoaW9zU3JjKSB7XG4gICAgICAgICAgICAgICAgZW5jb2RpbmcucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICdAdHlwZSc6ICdNZWRpYU9iamVjdCcsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRVcmw6IGlvc1NyYyxcbiAgICAgICAgICAgICAgICAgICAgZW5jb2RpbmdGb3JtYXQ6ICdtb2RlbC92bmQudXNkeit6aXAnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdHJ1Y3R1cmVkRGF0YSA9IHtcbiAgICAgICAgICAgICAgICAnQGNvbnRleHQnOiAnaHR0cDovL3NjaGVtYS5vcmcvJyxcbiAgICAgICAgICAgICAgICAnQHR5cGUnOiAnM0RNb2RlbCcsXG4gICAgICAgICAgICAgICAgaW1hZ2U6IHBvc3RlciAhPT0gbnVsbCAmJiBwb3N0ZXIgIT09IHZvaWQgMCA/IHBvc3RlciA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBuYW1lOiBhbHQgIT09IG51bGwgJiYgYWx0ICE9PSB2b2lkIDAgPyBhbHQgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgZW5jb2RpbmdcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzY2hlbWFFbGVtZW50LnRleHRDb250ZW50ID0gSlNPTi5zdHJpbmdpZnkoc3RydWN0dXJlZERhdGEpO1xuICAgICAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY2hlbWFFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzY2hlbWFFbGVtZW50LnBhcmVudEVsZW1lbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2NoZW1hRWxlbWVudC5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKHNjaGVtYUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TW9kZWxTY2VuZS5qcy5tYXAiLCIvKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAnTGljZW5zZScpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICdBUyBJUycgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBCdWZmZXJHZW9tZXRyeSwgRG91YmxlU2lkZSwgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSwgTWVzaCwgUGxhbmVHZW9tZXRyeSwgVmVjdG9yMiB9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7IERhbXBlciB9IGZyb20gJy4vRGFtcGVyLmpzJztcbmNvbnN0IFJBRElVUyA9IDAuMjtcbmNvbnN0IExJTkVfV0lEVEggPSAwLjAzO1xuY29uc3QgTUFYX09QQUNJVFkgPSAwLjc1O1xuY29uc3QgU0VHTUVOVFMgPSAxMjtcbmNvbnN0IERFTFRBX1BISSA9IE1hdGguUEkgLyAoMiAqIFNFR01FTlRTKTtcbmNvbnN0IHZlY3RvcjIgPSBuZXcgVmVjdG9yMigpO1xuLyoqXG4gKiBBZGRzIGEgcXVhcnRlci1hbm51bHVzIG9mIHZlcnRpY2VzIHRvIHRoZSBhcnJheSwgY2VudGVyZWQgb24gY29ybmVyWCxcbiAqIGNvcm5lclkuXG4gKi9cbmNvbnN0IGFkZENvcm5lciA9ICh2ZXJ0aWNlcywgY29ybmVyWCwgY29ybmVyWSkgPT4ge1xuICAgIGxldCBwaGkgPSBjb3JuZXJYID4gMCA/IChjb3JuZXJZID4gMCA/IDAgOiAtTWF0aC5QSSAvIDIpIDpcbiAgICAgICAgKGNvcm5lclkgPiAwID8gTWF0aC5QSSAvIDIgOiBNYXRoLlBJKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBTRUdNRU5UUzsgKytpKSB7XG4gICAgICAgIHZlcnRpY2VzLnB1c2goY29ybmVyWCArIChSQURJVVMgLSBMSU5FX1dJRFRIKSAqIE1hdGguY29zKHBoaSksIGNvcm5lclkgKyAoUkFESVVTIC0gTElORV9XSURUSCkgKiBNYXRoLnNpbihwaGkpLCAwLCBjb3JuZXJYICsgUkFESVVTICogTWF0aC5jb3MocGhpKSwgY29ybmVyWSArIFJBRElVUyAqIE1hdGguc2luKHBoaSksIDApO1xuICAgICAgICBwaGkgKz0gREVMVEFfUEhJO1xuICAgIH1cbn07XG4vKipcbiAqIFRoaXMgY2xhc3MgaXMgYSBzZXQgb2YgdHdvIGNvaW5jaWRlbnQgcGxhbmVzLiBUaGUgZmlyc3QgaXMganVzdCBhIGN1dGUgYm94XG4gKiBvdXRsaW5lIHdpdGggcm91bmRlZCBjb3JuZXJzIGFuZCBkYW1wZWQgb3BhY2l0eSB0byBpbmRpY2F0ZSB0aGUgZmxvb3IgZXh0ZW50c1xuICogb2YgYSBzY2VuZS4gSXQgaXMgcHVycG9zZWx5IGxhcmdlciB0aGFuIHRoZSBzY2VuZSdzIGJvdW5kaW5nIGJveCBieSBSQURJVVMgb25cbiAqIGFsbCBzaWRlcyBzbyB0aGF0IHNtYWxsIHNjZW5lcyBhcmUgc3RpbGwgdmlzaWJsZSAvIHNlbGVjdGFibGUuIEl0cyBjZW50ZXIgaXNcbiAqIGFjdHVhbGx5IGNhcnZlZCBvdXQgYnkgdmVydGljZXMgdG8gZW5zdXJlIGl0cyBmcmFnbWVudCBzaGFkZXIgZG9lc24ndCBhZGRcbiAqIG11Y2ggdGltZS5cbiAqXG4gKiBUaGUgY2hpbGQgcGxhbmUgaXMgYSBzaW1wbGUgcGxhbmUgd2l0aCB0aGUgc2FtZSBleHRlbnRzIGZvciB1c2UgaW4gaGl0XG4gKiB0ZXN0aW5nICh0cmFuc2xhdGlvbiBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgdG91Y2ggaGl0cyB0aGUgcGxhbmUsIHJvdGF0aW9uXG4gKiBvdGhlcndpc2UpLlxuICovXG5leHBvcnQgY2xhc3MgUGxhY2VtZW50Qm94IGV4dGVuZHMgTWVzaCB7XG4gICAgY29uc3RydWN0b3Ioc2NlbmUsIHNpZGUpIHtcbiAgICAgICAgY29uc3QgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcbiAgICAgICAgY29uc3QgdHJpYW5nbGVzID0gW107XG4gICAgICAgIGNvbnN0IHZlcnRpY2VzID0gW107XG4gICAgICAgIGNvbnN0IHsgc2l6ZSwgYm91bmRpbmdCb3ggfSA9IHNjZW5lO1xuICAgICAgICBjb25zdCB4ID0gc2l6ZS54IC8gMjtcbiAgICAgICAgY29uc3QgeSA9IChzaWRlID09PSAnYmFjaycgPyBzaXplLnkgOiBzaXplLnopIC8gMjtcbiAgICAgICAgYWRkQ29ybmVyKHZlcnRpY2VzLCB4LCB5KTtcbiAgICAgICAgYWRkQ29ybmVyKHZlcnRpY2VzLCAteCwgeSk7XG4gICAgICAgIGFkZENvcm5lcih2ZXJ0aWNlcywgLXgsIC15KTtcbiAgICAgICAgYWRkQ29ybmVyKHZlcnRpY2VzLCB4LCAteSk7XG4gICAgICAgIGNvbnN0IG51bVZlcnRpY2VzID0gdmVydGljZXMubGVuZ3RoIC8gMztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1WZXJ0aWNlcyAtIDI7IGkgKz0gMikge1xuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2goaSwgaSArIDEsIGkgKyAzLCBpLCBpICsgMywgaSArIDIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGkgPSBudW1WZXJ0aWNlcyAtIDI7XG4gICAgICAgIHRyaWFuZ2xlcy5wdXNoKGksIGkgKyAxLCAxLCBpLCAxLCAwKTtcbiAgICAgICAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHZlcnRpY2VzLCAzKSk7XG4gICAgICAgIGdlb21ldHJ5LnNldEluZGV4KHRyaWFuZ2xlcyk7XG4gICAgICAgIHN1cGVyKGdlb21ldHJ5KTtcbiAgICAgICAgdGhpcy5zaWRlID0gc2lkZTtcbiAgICAgICAgY29uc3QgbWF0ZXJpYWwgPSB0aGlzLm1hdGVyaWFsO1xuICAgICAgICBtYXRlcmlhbC5zaWRlID0gRG91YmxlU2lkZTtcbiAgICAgICAgbWF0ZXJpYWwudHJhbnNwYXJlbnQgPSB0cnVlO1xuICAgICAgICBtYXRlcmlhbC5vcGFjaXR5ID0gMDtcbiAgICAgICAgdGhpcy5nb2FsT3BhY2l0eSA9IDA7XG4gICAgICAgIHRoaXMub3BhY2l0eURhbXBlciA9IG5ldyBEYW1wZXIoKTtcbiAgICAgICAgdGhpcy5oaXRQbGFuZSA9XG4gICAgICAgICAgICBuZXcgTWVzaChuZXcgUGxhbmVHZW9tZXRyeSgyICogKHggKyBSQURJVVMpLCAyICogKHkgKyBSQURJVVMpKSk7XG4gICAgICAgIHRoaXMuaGl0UGxhbmUudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhpdFBsYW5lLm1hdGVyaWFsLnNpZGUgPSBEb3VibGVTaWRlO1xuICAgICAgICB0aGlzLmFkZCh0aGlzLmhpdFBsYW5lKTtcbiAgICAgICAgYm91bmRpbmdCb3guZ2V0Q2VudGVyKHRoaXMucG9zaXRpb24pO1xuICAgICAgICBzd2l0Y2ggKHNpZGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgdGhpcy5yb3RhdGVYKC1NYXRoLlBJIC8gMik7XG4gICAgICAgICAgICAgICAgdGhpcy5zaGFkb3dIZWlnaHQgPSBib3VuZGluZ0JveC5taW4ueTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9uLnkgPSB0aGlzLnNoYWRvd0hlaWdodDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2JhY2snOlxuICAgICAgICAgICAgICAgIHRoaXMuc2hhZG93SGVpZ2h0ID0gYm91bmRpbmdCb3gubWluLno7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvbi56ID0gdGhpcy5zaGFkb3dIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgc2NlbmUudGFyZ2V0LmFkZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vZmZzZXRIZWlnaHQgPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHdvcmxkIGhpdCBwb3NpdGlvbiBpZiB0aGUgdG91Y2ggY29vcmRpbmF0ZXMgaGl0IHRoZSBib3gsIGFuZCBudWxsXG4gICAgICogb3RoZXJ3aXNlLiBQYXNzIHRoZSBzY2VuZSBpbiB0byBnZXQgYWNjZXNzIHRvIGl0cyByYXljYXN0ZXIuXG4gICAgICovXG4gICAgZ2V0SGl0KHNjZW5lLCBzY3JlZW5YLCBzY3JlZW5ZKSB7XG4gICAgICAgIHZlY3RvcjIuc2V0KHNjcmVlblgsIC1zY3JlZW5ZKTtcbiAgICAgICAgdGhpcy5oaXRQbGFuZS52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgaGl0UmVzdWx0ID0gc2NlbmUucG9zaXRpb25BbmROb3JtYWxGcm9tUG9pbnQodmVjdG9yMiwgdGhpcy5oaXRQbGFuZSk7XG4gICAgICAgIHRoaXMuaGl0UGxhbmUudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gaGl0UmVzdWx0ID09IG51bGwgPyBudWxsIDogaGl0UmVzdWx0LnBvc2l0aW9uO1xuICAgIH1cbiAgICBnZXRFeHBhbmRlZEhpdChzY2VuZSwgc2NyZWVuWCwgc2NyZWVuWSkge1xuICAgICAgICB0aGlzLmhpdFBsYW5lLnNjYWxlLnNldCgxMDAwLCAxMDAwLCAxMDAwKTtcbiAgICAgICAgdGhpcy5oaXRQbGFuZS51cGRhdGVNYXRyaXhXb3JsZCgpO1xuICAgICAgICBjb25zdCBoaXRSZXN1bHQgPSB0aGlzLmdldEhpdChzY2VuZSwgc2NyZWVuWCwgc2NyZWVuWSk7XG4gICAgICAgIHRoaXMuaGl0UGxhbmUuc2NhbGUuc2V0KDEsIDEsIDEpO1xuICAgICAgICByZXR1cm4gaGl0UmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPZmZzZXQgdGhlIGhlaWdodCBvZiB0aGUgYm94IHJlbGF0aXZlIHRvIHRoZSBib3R0b20gb2YgdGhlIHNjZW5lLiBQb3NpdGl2ZVxuICAgICAqIGlzIHVwLCBzbyBnZW5lcmFsbHkgb25seSBuZWdhdGl2ZSB2YWx1ZXMgYXJlIHVzZWQuXG4gICAgICovXG4gICAgc2V0IG9mZnNldEhlaWdodChvZmZzZXQpIHtcbiAgICAgICAgb2Zmc2V0IC09IDAuMDAxOyAvLyBwdXNoIDEgbW0gYmVsb3cgc2hhZG93IHRvIGF2b2lkIHotZmlnaHRpbmdcbiAgICAgICAgaWYgKHRoaXMuc2lkZSA9PT0gJ2JhY2snKSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uLnogPSB0aGlzLnNoYWRvd0hlaWdodCArIG9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24ueSA9IHRoaXMuc2hhZG93SGVpZ2h0ICsgb2Zmc2V0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBvZmZzZXRIZWlnaHQoKSB7XG4gICAgICAgIGlmICh0aGlzLnNpZGUgPT09ICdiYWNrJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb24ueiAtIHRoaXMuc2hhZG93SGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb24ueSAtIHRoaXMuc2hhZG93SGVpZ2h0O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgYm94J3MgdmlzaWJpbGl0eTsgaXQgd2lsbCBmYWRlIGluIGFuZCBvdXQuXG4gICAgICovXG4gICAgc2V0IHNob3codmlzaWJsZSkge1xuICAgICAgICB0aGlzLmdvYWxPcGFjaXR5ID0gdmlzaWJsZSA/IE1BWF9PUEFDSVRZIDogMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbCBvbiBlYWNoIGZyYW1lIHdpdGggdGhlIGZyYW1lIGRlbHRhIHRvIGZhZGUgdGhlIGJveC5cbiAgICAgKi9cbiAgICB1cGRhdGVPcGFjaXR5KGRlbHRhKSB7XG4gICAgICAgIGNvbnN0IG1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbDtcbiAgICAgICAgbWF0ZXJpYWwub3BhY2l0eSA9XG4gICAgICAgICAgICB0aGlzLm9wYWNpdHlEYW1wZXIudXBkYXRlKG1hdGVyaWFsLm9wYWNpdHksIHRoaXMuZ29hbE9wYWNpdHksIGRlbHRhLCAxKTtcbiAgICAgICAgdGhpcy52aXNpYmxlID0gbWF0ZXJpYWwub3BhY2l0eSA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGwgdGhpcyB0byBjbGVhbiB1cCBUaHJlZSdzIGNhY2hlIHdoZW4geW91IHJlbW92ZSB0aGUgYm94LlxuICAgICAqL1xuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgeyBnZW9tZXRyeSwgbWF0ZXJpYWwgfSA9IHRoaXMuaGl0UGxhbmU7XG4gICAgICAgIGdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICAgICAgbWF0ZXJpYWwuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgICAgIChfYSA9IHRoaXMucGFyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlKHRoaXMpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBsYWNlbWVudEJveC5qcy5tYXAiLCIvKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAnTGljZW5zZScpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICdBUyBJUycgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBBQ0VTRmlsbWljVG9uZU1hcHBpbmcsIEV2ZW50RGlzcGF0Y2hlciwgc1JHQkVuY29kaW5nLCBWZWN0b3IyLCBXZWJHTFJlbmRlcmVyIH0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgJHVwZGF0ZUVudmlyb25tZW50IH0gZnJvbSAnLi4vZmVhdHVyZXMvZW52aXJvbm1lbnQuanMnO1xuaW1wb3J0IHsgJGNhbnZhcywgJHRpY2ssICR1cGRhdGVTaXplIH0gZnJvbSAnLi4vbW9kZWwtdmlld2VyLWJhc2UuanMnO1xuaW1wb3J0IHsgY2xhbXAsIGlzRGVidWdNb2RlLCByZXNvbHZlRHByIH0gZnJvbSAnLi4vdXRpbGl0aWVzLmpzJztcbmltcG9ydCB7IEFSUmVuZGVyZXIgfSBmcm9tICcuL0FSUmVuZGVyZXIuanMnO1xuaW1wb3J0IHsgQ2FjaGluZ0dMVEZMb2FkZXIgfSBmcm9tICcuL0NhY2hpbmdHTFRGTG9hZGVyLmpzJztcbmltcG9ydCB7IERlYnVnZ2VyIH0gZnJvbSAnLi9EZWJ1Z2dlci5qcyc7XG5pbXBvcnQgeyBNb2RlbFZpZXdlckdMVEZJbnN0YW5jZSB9IGZyb20gJy4vZ2x0Zi1pbnN0YW5jZS9Nb2RlbFZpZXdlckdMVEZJbnN0YW5jZS5qcyc7XG5pbXBvcnQgVGV4dHVyZVV0aWxzIGZyb20gJy4vVGV4dHVyZVV0aWxzLmpzJztcbi8vIEJldHdlZW4gMCBhbmQgMTogbGFyZ2VyIG1lYW5zIHRoZSBhdmVyYWdlIHJlc3BvbmRzIGZhc3RlciBhbmQgaXMgbGVzcyBzbW9vdGguXG5jb25zdCBEVVJBVElPTl9ERUNBWSA9IDAuMjtcbmNvbnN0IExPV19GUkFNRV9EVVJBVElPTl9NUyA9IDQwO1xuY29uc3QgSElHSF9GUkFNRV9EVVJBVElPTl9NUyA9IDYwO1xuY29uc3QgTUFYX0FWR19DSEFOR0VfTVMgPSA1O1xuY29uc3QgU0NBTEVfU1RFUFMgPSBbMSwgMC43OSwgMC42MiwgMC41LCAwLjQsIDAuMzEsIDAuMjVdO1xuY29uc3QgREVGQVVMVF9MQVNUX1NURVAgPSAzO1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfUE9XRVJfUFJFRkVSRU5DRSA9ICdoaWdoLXBlcmZvcm1hbmNlJztcbi8qKlxuICogUmVnaXN0ZXJzIGNhbnZhc2VzIHdpdGggQ2FudmFzMkRSZW5kZXJpbmdDb250ZXh0cyBhbmQgcmVuZGVycyB0aGVtXG4gKiBhbGwgaW4gdGhlIHNhbWUgV2ViR0xSZW5kZXJpbmdDb250ZXh0LCBzcGl0dGluZyBvdXQgdGV4dHVyZXMgdG8gYXBwbHlcbiAqIHRvIHRoZSBjYW52YXNlcy4gQ3JlYXRlcyBhIGZ1bGxzY3JlZW4gV2ViR0wgY2FudmFzIHRoYXQgaXMgbm90IGFkZGVkXG4gKiB0byB0aGUgRE9NLCBhbmQgb24gZWFjaCBmcmFtZSwgcmVuZGVycyBlYWNoIHJlZ2lzdGVyZWQgY2FudmFzIG9uIGEgcG9ydGlvblxuICogb2YgdGhlIFdlYkdMIGNhbnZhcywgYW5kIGFwcGxpZXMgdGhlIHRleHR1cmUgb24gdGhlIHJlZ2lzdGVyZWQgY2FudmFzLlxuICpcbiAqIEluIHRoZSBmdXR1cmUsIGNhbiB1c2UgSW1hZ2VCaXRtYXBSZW5kZXJpbmdDb250ZXh0IGluc3RlYWQgb2ZcbiAqIENhbnZhczJEUmVuZGVyaW5nQ29udGV4dCBpZiBzdXBwb3J0ZWQgZm9yIGNoZWFwZXIgdHJhbnNmZXJyaW5nIG9mXG4gKiB0aGUgdGV4dHVyZS5cbiAqL1xuZXhwb3J0IGNsYXNzIFJlbmRlcmVyIGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubG9hZGVyID0gbmV3IENhY2hpbmdHTFRGTG9hZGVyKE1vZGVsVmlld2VyR0xURkluc3RhbmNlKTtcbiAgICAgICAgdGhpcy53aWR0aCA9IDA7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy5kcHIgPSAxO1xuICAgICAgICB0aGlzLmRlYnVnZ2VyID0gbnVsbDtcbiAgICAgICAgdGhpcy5zY2VuZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMubXVsdGlwbGVTY2VuZXNWaXNpYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGFzdFRpY2sgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlZExhc3RGcmFtZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNjYWxlU3RlcCA9IDA7XG4gICAgICAgIHRoaXMubGFzdFN0ZXAgPSBERUZBVUxUX0xBU1RfU1RFUDtcbiAgICAgICAgdGhpcy5hdmdGcmFtZUR1cmF0aW9uID0gKEhJR0hfRlJBTUVfRFVSQVRJT05fTVMgKyBMT1dfRlJBTUVfRFVSQVRJT05fTVMpIC8gMjtcbiAgICAgICAgdGhpcy5vbldlYkdMQ29udGV4dExvc3QgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh7IHR5cGU6ICdjb250ZXh0bG9zdCcsIHNvdXJjZUV2ZW50OiBldmVudCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbldlYkdMQ29udGV4dFJlc3RvcmVkID0gKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgKF9hID0gdGhpcy50ZXh0dXJlVXRpbHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLnRleHR1cmVVdGlscyA9IG5ldyBUZXh0dXJlVXRpbHModGhpcy50aHJlZVJlbmRlcmVyKTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc2NlbmUgb2YgdGhpcy5zY2VuZXMpIHtcbiAgICAgICAgICAgICAgICBzY2VuZS5lbGVtZW50WyR1cGRhdGVFbnZpcm9ubWVudF0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kcHIgPSByZXNvbHZlRHByKCk7XG4gICAgICAgIHRoaXMuY2FudmFzM0QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgdGhpcy5jYW52YXMzRC5pZCA9ICd3ZWJnbC1jYW52YXMnO1xuICAgICAgICB0aGlzLmNhbnZhczNELmNsYXNzTGlzdC5hZGQoJ3Nob3cnKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMudGhyZWVSZW5kZXJlciA9IG5ldyBXZWJHTFJlbmRlcmVyKHtcbiAgICAgICAgICAgICAgICBjYW52YXM6IHRoaXMuY2FudmFzM0QsXG4gICAgICAgICAgICAgICAgYWxwaGE6IHRydWUsXG4gICAgICAgICAgICAgICAgYW50aWFsaWFzOiB0cnVlLFxuICAgICAgICAgICAgICAgIHBvd2VyUHJlZmVyZW5jZTogb3B0aW9ucy5wb3dlclByZWZlcmVuY2UsXG4gICAgICAgICAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudGhyZWVSZW5kZXJlci5hdXRvQ2xlYXIgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy50aHJlZVJlbmRlcmVyLm91dHB1dEVuY29kaW5nID0gc1JHQkVuY29kaW5nO1xuICAgICAgICAgICAgdGhpcy50aHJlZVJlbmRlcmVyLnVzZUxlZ2FjeUxpZ2h0cyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy50aHJlZVJlbmRlcmVyLnNldFBpeGVsUmF0aW8oMSk7IC8vIGhhbmRsZSBwaXhlbCByYXRpbyBleHRlcm5hbGx5XG4gICAgICAgICAgICB0aGlzLmRlYnVnZ2VyID0gISFvcHRpb25zLmRlYnVnID8gbmV3IERlYnVnZ2VyKHRoaXMpIDogbnVsbDtcbiAgICAgICAgICAgIHRoaXMudGhyZWVSZW5kZXJlci5kZWJ1ZyA9IHsgY2hlY2tTaGFkZXJFcnJvcnM6ICEhdGhpcy5kZWJ1Z2dlciB9O1xuICAgICAgICAgICAgLy8gQUNFU0ZpbG1pY1RvbmVNYXBwaW5nIGFwcGVhcnMgdG8gYmUgdGhlIG1vc3QgXCJzYXR1cmF0ZWRcIixcbiAgICAgICAgICAgIC8vIGFuZCBzaW1pbGFyIHRvIEZpbGFtZW50J3MgZ2x0Zi12aWV3ZXIuXG4gICAgICAgICAgICB0aGlzLnRocmVlUmVuZGVyZXIudG9uZU1hcHBpbmcgPSBBQ0VTRmlsbWljVG9uZU1hcHBpbmc7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXJSZW5kZXJlciA9IG5ldyBBUlJlbmRlcmVyKHRoaXMpO1xuICAgICAgICB0aGlzLnRleHR1cmVVdGlscyA9XG4gICAgICAgICAgICB0aGlzLmNhblJlbmRlciA/IG5ldyBUZXh0dXJlVXRpbHModGhpcy50aHJlZVJlbmRlcmVyKSA6IG51bGw7XG4gICAgICAgIENhY2hpbmdHTFRGTG9hZGVyLmluaXRpYWxpemVLVFgyTG9hZGVyKHRoaXMudGhyZWVSZW5kZXJlcik7XG4gICAgICAgIHRoaXMuY2FudmFzM0QuYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0bG9zdCcsIHRoaXMub25XZWJHTENvbnRleHRMb3N0KTtcbiAgICAgICAgdGhpcy5jYW52YXMzRC5hZGRFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRyZXN0b3JlZCcsIHRoaXMub25XZWJHTENvbnRleHRSZXN0b3JlZCk7XG4gICAgICAgIHRoaXMudXBkYXRlUmVuZGVyZXJTaXplKCk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgc2luZ2xldG9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2luZ2xldG9uO1xuICAgIH1cbiAgICBzdGF0aWMgcmVzZXRTaW5nbGV0b24oKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gdGhpcy5fc2luZ2xldG9uLmRpc3Bvc2UoKTtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgICAgICBlbGVtZW50LmRpc2Nvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2luZ2xldG9uID0gbmV3IFJlbmRlcmVyKHtcbiAgICAgICAgICAgIHBvd2VyUHJlZmVyZW5jZTogKHNlbGYuTW9kZWxWaWV3ZXJFbGVtZW50IHx8IHt9KVxuICAgICAgICAgICAgICAgIC5wb3dlclByZWZlcmVuY2UgfHxcbiAgICAgICAgICAgICAgICBERUZBVUxUX1BPV0VSX1BSRUZFUkVOQ0UsXG4gICAgICAgICAgICBkZWJ1ZzogaXNEZWJ1Z01vZGUoKVxuICAgICAgICB9KTtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgICAgICBlbGVtZW50LmNvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGNhblJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGhyZWVSZW5kZXJlciAhPSBudWxsO1xuICAgIH1cbiAgICBnZXQgc2NhbGVGYWN0b3IoKSB7XG4gICAgICAgIHJldHVybiBTQ0FMRV9TVEVQU1t0aGlzLnNjYWxlU3RlcF07XG4gICAgfVxuICAgIHNldCBtaW5TY2FsZShzY2FsZSkge1xuICAgICAgICBsZXQgaSA9IDE7XG4gICAgICAgIHdoaWxlIChpIDwgU0NBTEVfU1RFUFMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoU0NBTEVfU1RFUFNbaV0gPCBzY2FsZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKytpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdFN0ZXAgPSBpIC0gMTtcbiAgICB9XG4gICAgcmVnaXN0ZXJTY2VuZShzY2VuZSkge1xuICAgICAgICB0aGlzLnNjZW5lcy5hZGQoc2NlbmUpO1xuICAgICAgICBzY2VuZS5mb3JjZVJlc2NhbGUoKTtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IG5ldyBWZWN0b3IyKCk7XG4gICAgICAgIHRoaXMudGhyZWVSZW5kZXJlci5nZXRTaXplKHNpemUpO1xuICAgICAgICBzY2VuZS5jYW52YXMud2lkdGggPSBzaXplLng7XG4gICAgICAgIHNjZW5lLmNhbnZhcy5oZWlnaHQgPSBzaXplLnk7XG4gICAgICAgIGlmICh0aGlzLmNhblJlbmRlciAmJiB0aGlzLnNjZW5lcy5zaXplID4gMCkge1xuICAgICAgICAgICAgdGhpcy50aHJlZVJlbmRlcmVyLnNldEFuaW1hdGlvbkxvb3AoKHRpbWUsIGZyYW1lKSA9PiB0aGlzLnJlbmRlcih0aW1lLCBmcmFtZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRlYnVnZ2VyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZGVidWdnZXIuYWRkU2NlbmUoc2NlbmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVucmVnaXN0ZXJTY2VuZShzY2VuZSkge1xuICAgICAgICB0aGlzLnNjZW5lcy5kZWxldGUoc2NlbmUpO1xuICAgICAgICBpZiAodGhpcy5jYW52YXMzRC5wYXJlbnRFbGVtZW50ID09PSBzY2VuZS5jYW52YXMucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgc2NlbmUuY2FudmFzLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQodGhpcy5jYW52YXMzRCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2FuUmVuZGVyICYmIHRoaXMuc2NlbmVzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMudGhyZWVSZW5kZXJlci5zZXRBbmltYXRpb25Mb29wKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRlYnVnZ2VyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZGVidWdnZXIucmVtb3ZlU2NlbmUoc2NlbmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRpc3BsYXlDYW52YXMoc2NlbmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbGVTY2VuZXNWaXNpYmxlID8gc2NlbmUuZWxlbWVudFskY2FudmFzXSA6IHRoaXMuY2FudmFzM0Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBmdW5jdGlvbiBlbmFibGVzIGFuIG9wdGltaXphdGlvbiwgd2hlcmUgd2hlbiB0aGVyZSBpcyBvbmx5IGEgc2luZ2xlXG4gICAgICogPG1vZGVsLXZpZXdlcj4gZWxlbWVudCwgd2UgY2FuIHVzZSB0aGUgcmVuZGVyZXIncyAzRCBjYW52YXMgZGlyZWN0bHkgZm9yXG4gICAgICogZGlzcGxheS4gT3RoZXJ3aXNlIHdlIG5lZWQgdG8gdXNlIHRoZSBlbGVtZW50J3MgMkQgY2FudmFzIGFuZCBjb3B5IHRoZVxuICAgICAqIHJlbmRlcmVyJ3MgcmVzdWx0IGludG8gaXQuXG4gICAgICovXG4gICAgY291bnRWaXNpYmxlU2NlbmVzKCkge1xuICAgICAgICBjb25zdCB7IGNhbnZhczNEIH0gPSB0aGlzO1xuICAgICAgICBsZXQgdmlzaWJsZVNjZW5lcyA9IDA7XG4gICAgICAgIGxldCBjYW52YXMzRFNjZW5lID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBzY2VuZSBvZiB0aGlzLnNjZW5lcykge1xuICAgICAgICAgICAgY29uc3QgeyBlbGVtZW50IH0gPSBzY2VuZTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50Lm1vZGVsSXNWaXNpYmxlICYmIHNjZW5lLmV4dGVybmFsUmVuZGVyZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICsrdmlzaWJsZVNjZW5lcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYW52YXMzRC5wYXJlbnRFbGVtZW50ID09PSBzY2VuZS5jYW52YXMucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGNhbnZhczNEU2NlbmUgPSBzY2VuZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtdWx0aXBsZVNjZW5lc1Zpc2libGUgPSB2aXNpYmxlU2NlbmVzID4gMTtcbiAgICAgICAgaWYgKGNhbnZhczNEU2NlbmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgbmV3bHlNdWx0aXBsZSA9IG11bHRpcGxlU2NlbmVzVmlzaWJsZSAmJiAhdGhpcy5tdWx0aXBsZVNjZW5lc1Zpc2libGU7XG4gICAgICAgICAgICBjb25zdCBkaXNhcHBlYXJpbmcgPSAhY2FudmFzM0RTY2VuZS5lbGVtZW50Lm1vZGVsSXNWaXNpYmxlO1xuICAgICAgICAgICAgaWYgKG5ld2x5TXVsdGlwbGUgfHwgZGlzYXBwZWFyaW5nKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSB0aGlzLnNjZW5lU2l6ZShjYW52YXMzRFNjZW5lKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvcHlQaXhlbHMoY2FudmFzM0RTY2VuZSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgY2FudmFzM0QucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZChjYW52YXMzRCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tdWx0aXBsZVNjZW5lc1Zpc2libGUgPSBtdWx0aXBsZVNjZW5lc1Zpc2libGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHJlbmRlcmVyJ3Mgc2l6ZSBiYXNlZCBvbiB0aGUgbGFyZ2VzdCBzY2VuZSBhbmQgYW55IGNoYW5nZXMgdG9cbiAgICAgKiBkZXZpY2UgcGl4ZWwgcmF0aW8uXG4gICAgICovXG4gICAgdXBkYXRlUmVuZGVyZXJTaXplKCkge1xuICAgICAgICBjb25zdCBkcHIgPSByZXNvbHZlRHByKCk7XG4gICAgICAgIGlmIChkcHIgIT09IHRoaXMuZHByKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZGV2aWNlIHBpeGVsIHJhdGlvIGhhcyBjaGFuZ2VkIGR1ZSB0byBwYWdlIHpvb20sIGVsZW1lbnRzXG4gICAgICAgICAgICAvLyBzcGVjaWZpZWQgYnkgJSB3aWR0aCBkbyBub3QgZmlyZSBhIHJlc2l6ZSBldmVudCBldmVuIHRob3VnaCB0aGVpciBDU1NcbiAgICAgICAgICAgIC8vIHBpeGVsIGRpbWVuc2lvbnMgY2hhbmdlLCBzbyB3ZSBmb3JjZSB0aGVtIHRvIHVwZGF0ZSB0aGVpciBzaXplIGhlcmUuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNjZW5lIG9mIHRoaXMuc2NlbmVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlbGVtZW50IH0gPSBzY2VuZTtcbiAgICAgICAgICAgICAgICBlbGVtZW50WyR1cGRhdGVTaXplXShlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHRoZSByZW5kZXJlciB0aGUgc2l6ZSBvZiB0aGUgbGFyZ2VzdCBzY2VuZVxuICAgICAgICBsZXQgd2lkdGggPSAwO1xuICAgICAgICBsZXQgaGVpZ2h0ID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBzY2VuZSBvZiB0aGlzLnNjZW5lcykge1xuICAgICAgICAgICAgd2lkdGggPSBNYXRoLm1heCh3aWR0aCwgc2NlbmUud2lkdGgpO1xuICAgICAgICAgICAgaGVpZ2h0ID0gTWF0aC5tYXgoaGVpZ2h0LCBzY2VuZS5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3aWR0aCA9PT0gdGhpcy53aWR0aCAmJiBoZWlnaHQgPT09IHRoaXMuaGVpZ2h0ICYmIGRwciA9PT0gdGhpcy5kcHIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLmRwciA9IGRwcjtcbiAgICAgICAgd2lkdGggPSBNYXRoLmNlaWwod2lkdGggKiBkcHIpO1xuICAgICAgICBoZWlnaHQgPSBNYXRoLmNlaWwoaGVpZ2h0ICogZHByKTtcbiAgICAgICAgaWYgKHRoaXMuY2FuUmVuZGVyKSB7XG4gICAgICAgICAgICB0aGlzLnRocmVlUmVuZGVyZXIuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0LCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRWFjaCBzY2VuZSdzIGNhbnZhcyBtdXN0IG1hdGNoIHRoZSByZW5kZXJlciBzaXplLiBJbiBnZW5lcmFsIHRoZXkgY2FuIGJlXG4gICAgICAgIC8vIGxhcmdlciB0aGFuIHRoZSBlbGVtZW50IHRoYXQgY29udGFpbnMgdGhlbSwgYnV0IHRoZSBvdmVyZmxvdyBpcyBoaWRkZW5cbiAgICAgICAgLy8gYW5kIG9ubHkgdGhlIHBvcnRpb24gdGhhdCBpcyBzaG93biBpcyBjb3BpZWQgb3Zlci5cbiAgICAgICAgZm9yIChjb25zdCBzY2VuZSBvZiB0aGlzLnNjZW5lcykge1xuICAgICAgICAgICAgY29uc3QgeyBjYW52YXMgfSA9IHNjZW5lO1xuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgc2NlbmUuZm9yY2VSZXNjYWxlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlUmVuZGVyZXJTY2FsZShkZWx0YSkge1xuICAgICAgICBjb25zdCBzY2FsZVN0ZXAgPSB0aGlzLnNjYWxlU3RlcDtcbiAgICAgICAgdGhpcy5hdmdGcmFtZUR1cmF0aW9uICs9IGNsYW1wKERVUkFUSU9OX0RFQ0FZICogKGRlbHRhIC0gdGhpcy5hdmdGcmFtZUR1cmF0aW9uKSwgLU1BWF9BVkdfQ0hBTkdFX01TLCBNQVhfQVZHX0NIQU5HRV9NUyk7XG4gICAgICAgIGlmICh0aGlzLmF2Z0ZyYW1lRHVyYXRpb24gPiBISUdIX0ZSQU1FX0RVUkFUSU9OX01TKSB7XG4gICAgICAgICAgICArK3RoaXMuc2NhbGVTdGVwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYXZnRnJhbWVEdXJhdGlvbiA8IExPV19GUkFNRV9EVVJBVElPTl9NUyAmJiB0aGlzLnNjYWxlU3RlcCA+IDApIHtcbiAgICAgICAgICAgIC0tdGhpcy5zY2FsZVN0ZXA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zY2FsZVN0ZXAgPSBNYXRoLm1pbih0aGlzLnNjYWxlU3RlcCwgdGhpcy5sYXN0U3RlcCk7XG4gICAgICAgIGlmIChzY2FsZVN0ZXAgIT09IHRoaXMuc2NhbGVTdGVwKSB7XG4gICAgICAgICAgICB0aGlzLmF2Z0ZyYW1lRHVyYXRpb24gPVxuICAgICAgICAgICAgICAgIChISUdIX0ZSQU1FX0RVUkFUSU9OX01TICsgTE9XX0ZSQU1FX0RVUkFUSU9OX01TKSAvIDI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2hvdWxkUmVuZGVyKHNjZW5lKSB7XG4gICAgICAgIGlmICghc2NlbmUuc2hvdWxkUmVuZGVyKCkpIHtcbiAgICAgICAgICAgIC8vIFRoZSBmaXJzdCBmcmFtZSB3ZSBzdG9wIHJlbmRlcmluZyB0aGUgc2NlbmUgKGJlY2F1c2UgaXQgc3RvcHMgbW92aW5nKSxcbiAgICAgICAgICAgIC8vIHRyaWdnZXIgb25lIGV4dHJhIHJlbmRlciBhdCBmdWxsIHNjYWxlLlxuICAgICAgICAgICAgaWYgKHNjZW5lLnNjYWxlU3RlcCAhPSAwKSB7XG4gICAgICAgICAgICAgICAgc2NlbmUuc2NhbGVTdGVwID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2NhbGVDYW52YXMoc2NlbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNjZW5lLnNjYWxlU3RlcCAhPSB0aGlzLnNjYWxlU3RlcCkge1xuICAgICAgICAgICAgLy8gVXBkYXRlIHJlbmRlciBzY2FsZVxuICAgICAgICAgICAgc2NlbmUuc2NhbGVTdGVwID0gdGhpcy5zY2FsZVN0ZXA7XG4gICAgICAgICAgICB0aGlzLnJlc2NhbGVDYW52YXMoc2NlbmUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXNjYWxlQ2FudmFzKHNjZW5lKSB7XG4gICAgICAgIGNvbnN0IHNjYWxlID0gU0NBTEVfU1RFUFNbc2NlbmUuc2NhbGVTdGVwXTtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBNYXRoLmNlaWwodGhpcy53aWR0aCAvIHNjYWxlKTtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5jZWlsKHRoaXMuaGVpZ2h0IC8gc2NhbGUpO1xuICAgICAgICBjb25zdCB7IHN0eWxlIH0gPSBzY2VuZS5jYW52YXM7XG4gICAgICAgIHN0eWxlLndpZHRoID0gYCR7d2lkdGh9cHhgO1xuICAgICAgICBzdHlsZS5oZWlnaHQgPSBgJHtoZWlnaHR9cHhgO1xuICAgICAgICB0aGlzLmNhbnZhczNELnN0eWxlLndpZHRoID0gYCR7d2lkdGh9cHhgO1xuICAgICAgICB0aGlzLmNhbnZhczNELnN0eWxlLmhlaWdodCA9IGAke2hlaWdodH1weGA7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVkRHByID0gdGhpcy5kcHIgKiBzY2FsZTtcbiAgICAgICAgY29uc3QgcmVhc29uID0gc2NhbGUgPCAxID8gJ0dQVSB0aHJvdHRsaW5nJyA6XG4gICAgICAgICAgICB0aGlzLmRwciAhPT0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gPyAnTm8gbWV0YSB2aWV3cG9ydCB0YWcnIDpcbiAgICAgICAgICAgICAgICAnJztcbiAgICAgICAgc2NlbmUuZWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgncmVuZGVyLXNjYWxlJywge1xuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgcmVwb3J0ZWREcHI6IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvLFxuICAgICAgICAgICAgICAgIHJlbmRlcmVkRHByOiByZW5kZXJlZERwcixcbiAgICAgICAgICAgICAgICBtaW5pbXVtRHByOiB0aGlzLmRwciAqIFNDQUxFX1NURVBTW3RoaXMubGFzdFN0ZXBdLFxuICAgICAgICAgICAgICAgIHBpeGVsV2lkdGg6IE1hdGguY2VpbChzY2VuZS53aWR0aCAqIHJlbmRlcmVkRHByKSxcbiAgICAgICAgICAgICAgICBwaXhlbEhlaWdodDogTWF0aC5jZWlsKHNjZW5lLmhlaWdodCAqIHJlbmRlcmVkRHByKSxcbiAgICAgICAgICAgICAgICByZWFzb246IHJlYXNvblxuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIHNjZW5lU2l6ZShzY2VuZSkge1xuICAgICAgICBjb25zdCB7IGRwciB9ID0gdGhpcztcbiAgICAgICAgY29uc3Qgc2NhbGVGYWN0b3IgPSBTQ0FMRV9TVEVQU1tzY2VuZS5zY2FsZVN0ZXBdO1xuICAgICAgICAvLyBXZSBhdm9pZCB1c2luZyB0aGUgVGhyZWUuanMgUGl4ZWxSYXRpbyBhbmQgaGFuZGxlIGl0IG91cnNlbHZlcyBoZXJlIHNvXG4gICAgICAgIC8vIHRoYXQgd2UgY2FuIGRvIHByb3BlciByb3VuZGluZyBhbmQgYXZvaWQgd2hpdGUgYm91bmRhcnkgcGl4ZWxzLlxuICAgICAgICBjb25zdCB3aWR0aCA9IE1hdGgubWluKE1hdGguY2VpbChzY2VuZS53aWR0aCAqIHNjYWxlRmFjdG9yICogZHByKSwgdGhpcy5jYW52YXMzRC53aWR0aCk7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IE1hdGgubWluKE1hdGguY2VpbChzY2VuZS5oZWlnaHQgKiBzY2FsZUZhY3RvciAqIGRwciksIHRoaXMuY2FudmFzM0QuaGVpZ2h0KTtcbiAgICAgICAgcmV0dXJuIHsgd2lkdGgsIGhlaWdodCB9O1xuICAgIH1cbiAgICBjb3B5UGl4ZWxzKHNjZW5lLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQyRCA9IHNjZW5lLmNvbnRleHQ7XG4gICAgICAgIGlmIChjb250ZXh0MkQgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2NvdWxkIG5vdCBhY3F1aXJlIDJkIGNvbnRleHQnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0MkQuY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBjb250ZXh0MkQuZHJhd0ltYWdlKHRoaXMuY2FudmFzM0QsIDAsIDAsIHdpZHRoLCBoZWlnaHQsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBzY2VuZS5jYW52YXMuY2xhc3NMaXN0LmFkZCgnc2hvdycpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IHZlcnNpb24gb2YgdGhpcy5zY2VuZXMgd2hlcmUgdGhlIG5vbi12aXNpYmxlIG9uZXMgYXJlXG4gICAgICogZmlyc3QuIFRoaXMgYWxsb3dzIGVhZ2VyIHNjZW5lcyB0byBiZSByZW5kZXJlZCBiZWZvcmUgdGhleSBhcmUgdmlzaWJsZSxcbiAgICAgKiB3aXRob3V0IG5lZWRpbmcgdGhlIG11bHRpLWNhbnZhcyByZW5kZXIgcGF0aC5cbiAgICAgKi9cbiAgICBvcmRlcmVkU2NlbmVzKCkge1xuICAgICAgICBjb25zdCBzY2VuZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB2aXNpYmxlIG9mIFtmYWxzZSwgdHJ1ZV0pIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc2NlbmUgb2YgdGhpcy5zY2VuZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2NlbmUuZWxlbWVudC5tb2RlbElzVmlzaWJsZSA9PT0gdmlzaWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBzY2VuZXMucHVzaChzY2VuZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY2VuZXM7XG4gICAgfVxuICAgIGdldCBpc1ByZXNlbnRpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFyUmVuZGVyZXIuaXNQcmVzZW50aW5nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCB0YWtlcyBjYXJlIG9mIHVwZGF0aW5nIHRoZSBlbGVtZW50IGFuZCByZW5kZXJlciBzdGF0ZSBiYXNlZCBvblxuICAgICAqIHRoZSB0aW1lIHRoYXQgaGFzIHBhc3NlZCBzaW5jZSB0aGUgbGFzdCByZW5kZXJlZCBmcmFtZS5cbiAgICAgKi9cbiAgICBwcmVSZW5kZXIoc2NlbmUsIHQsIGRlbHRhKSB7XG4gICAgICAgIGNvbnN0IHsgZWxlbWVudCwgZXhwb3N1cmUgfSA9IHNjZW5lO1xuICAgICAgICBlbGVtZW50WyR0aWNrXSh0LCBkZWx0YSk7XG4gICAgICAgIGNvbnN0IGV4cG9zdXJlSXNOdW1iZXIgPSB0eXBlb2YgZXhwb3N1cmUgPT09ICdudW1iZXInICYmICFOdW1iZXIuaXNOYU4oZXhwb3N1cmUpO1xuICAgICAgICB0aGlzLnRocmVlUmVuZGVyZXIudG9uZU1hcHBpbmdFeHBvc3VyZSA9IGV4cG9zdXJlSXNOdW1iZXIgPyBleHBvc3VyZSA6IDEuMDtcbiAgICB9XG4gICAgcmVuZGVyKHQsIGZyYW1lKSB7XG4gICAgICAgIGlmIChmcmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmFyUmVuZGVyZXIub25XZWJYUkZyYW1lKHQsIGZyYW1lKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWx0YSA9IHQgLSB0aGlzLmxhc3RUaWNrO1xuICAgICAgICB0aGlzLmxhc3RUaWNrID0gdDtcbiAgICAgICAgaWYgKCF0aGlzLmNhblJlbmRlciB8fCB0aGlzLmlzUHJlc2VudGluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY291bnRWaXNpYmxlU2NlbmVzKCk7XG4gICAgICAgIHRoaXMudXBkYXRlUmVuZGVyZXJTaXplKCk7XG4gICAgICAgIGlmICh0aGlzLnJlbmRlcmVkTGFzdEZyYW1lKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVJlbmRlcmVyU2NhbGUoZGVsdGEpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlZExhc3RGcmFtZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgY2FudmFzM0QgfSA9IHRoaXM7XG4gICAgICAgIGZvciAoY29uc3Qgc2NlbmUgb2YgdGhpcy5vcmRlcmVkU2NlbmVzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZWxlbWVudCB9ID0gc2NlbmU7XG4gICAgICAgICAgICBpZiAoIWVsZW1lbnQubG9hZGVkIHx8XG4gICAgICAgICAgICAgICAgKCFlbGVtZW50Lm1vZGVsSXNWaXNpYmxlICYmIHNjZW5lLnJlbmRlckNvdW50ID4gMCkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHJlUmVuZGVyKHNjZW5lLCB0LCBkZWx0YSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2hvdWxkUmVuZGVyKHNjZW5lKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNjZW5lLmV4dGVybmFsUmVuZGVyZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbWVyYSA9IHNjZW5lLmdldENhbWVyYSgpO1xuICAgICAgICAgICAgICAgIGNhbWVyYS51cGRhdGVNYXRyaXgoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IG1hdHJpeCwgcHJvamVjdGlvbk1hdHJpeCB9ID0gY2FtZXJhO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpZXdNYXRyaXggPSBtYXRyaXguZWxlbWVudHMuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBzY2VuZS5nZXRUYXJnZXQoKTtcbiAgICAgICAgICAgICAgICB2aWV3TWF0cml4WzEyXSArPSB0YXJnZXQueDtcbiAgICAgICAgICAgICAgICB2aWV3TWF0cml4WzEzXSArPSB0YXJnZXQueTtcbiAgICAgICAgICAgICAgICB2aWV3TWF0cml4WzE0XSArPSB0YXJnZXQuejtcbiAgICAgICAgICAgICAgICBzY2VuZS5leHRlcm5hbFJlbmRlcmVyLnJlbmRlcih7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdNYXRyaXg6IHZpZXdNYXRyaXgsXG4gICAgICAgICAgICAgICAgICAgIHByb2plY3Rpb25NYXRyaXg6IHByb2plY3Rpb25NYXRyaXguZWxlbWVudHNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZWxlbWVudC5tb2RlbElzVmlzaWJsZSAmJiAhdGhpcy5tdWx0aXBsZVNjZW5lc1Zpc2libGUpIHtcbiAgICAgICAgICAgICAgICAvLyBIZXJlIHdlIGFyZSBwcmUtcmVuZGVyaW5nIG9uIHRoZSB2aXNpYmxlIGNhbnZhcywgc28gd2UgbXVzdCBtYXJrIHRoZVxuICAgICAgICAgICAgICAgIC8vIHZpc2libGUgc2NlbmUgZGlydHkgdG8gZW5zdXJlIGl0IG92ZXJ3cml0ZXMgdXMuXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB2aXNpYmxlU2NlbmUgb2YgdGhpcy5zY2VuZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZpc2libGVTY2VuZS5lbGVtZW50Lm1vZGVsSXNWaXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNpYmxlU2NlbmUucXVldWVSZW5kZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdGhpcy5zY2VuZVNpemUoc2NlbmUpO1xuICAgICAgICAgICAgc2NlbmUucmVuZGVyU2hhZG93KHRoaXMudGhyZWVSZW5kZXJlcik7XG4gICAgICAgICAgICAvLyBOZWVkIHRvIHNldCB0aGUgcmVuZGVyIHRhcmdldCBpbiBvcmRlciB0byBwcmV2ZW50XG4gICAgICAgICAgICAvLyBjbGVhcmluZyB0aGUgZGVwdGggZnJvbSBhIGRpZmZlcmVudCBidWZmZXJcbiAgICAgICAgICAgIHRoaXMudGhyZWVSZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQobnVsbCk7XG4gICAgICAgICAgICB0aGlzLnRocmVlUmVuZGVyZXIuc2V0Vmlld3BvcnQoMCwgTWF0aC5jZWlsKHRoaXMuaGVpZ2h0ICogdGhpcy5kcHIpIC0gaGVpZ2h0LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMudGhyZWVSZW5kZXJlci5yZW5kZXIoc2NlbmUsIHNjZW5lLmNhbWVyYSk7XG4gICAgICAgICAgICBpZiAodGhpcy5tdWx0aXBsZVNjZW5lc1Zpc2libGUgfHxcbiAgICAgICAgICAgICAgICAoIXNjZW5lLmVsZW1lbnQubW9kZWxJc1Zpc2libGUgJiYgc2NlbmUucmVuZGVyQ291bnQgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb3B5UGl4ZWxzKHNjZW5lLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNhbnZhczNELnBhcmVudEVsZW1lbnQgIT09IHNjZW5lLmNhbnZhcy5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgc2NlbmUuY2FudmFzLnBhcmVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoY2FudmFzM0QpO1xuICAgICAgICAgICAgICAgIHNjZW5lLmNhbnZhcy5jbGFzc0xpc3QucmVtb3ZlKCdzaG93Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzY2VuZS5oYXNSZW5kZXJlZCgpO1xuICAgICAgICAgICAgKytzY2VuZS5yZW5kZXJDb3VudDtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZWRMYXN0RnJhbWUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLnRleHR1cmVVdGlscyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnRleHR1cmVVdGlscy5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudGhyZWVSZW5kZXJlciAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnRocmVlUmVuZGVyZXIuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGV4dHVyZVV0aWxzID0gbnVsbDtcbiAgICAgICAgdGhpcy50aHJlZVJlbmRlcmVyID0gbnVsbDtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBzY2VuZSBvZiB0aGlzLnNjZW5lcykge1xuICAgICAgICAgICAgZWxlbWVudHMucHVzaChzY2VuZS5lbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbnZhczNELnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dGxvc3QnLCB0aGlzLm9uV2ViR0xDb250ZXh0TG9zdCk7XG4gICAgICAgIHRoaXMuY2FudmFzM0QucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0cmVzdG9yZWQnLCB0aGlzLm9uV2ViR0xDb250ZXh0UmVzdG9yZWQpO1xuICAgICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgfVxufVxuUmVuZGVyZXIuX3NpbmdsZXRvbiA9IG5ldyBSZW5kZXJlcih7XG4gICAgcG93ZXJQcmVmZXJlbmNlOiAoc2VsZi5Nb2RlbFZpZXdlckVsZW1lbnQgfHwge30pXG4gICAgICAgIC5wb3dlclByZWZlcmVuY2UgfHxcbiAgICAgICAgREVGQVVMVF9QT1dFUl9QUkVGRVJFTkNFLFxuICAgIGRlYnVnOiBpc0RlYnVnTW9kZSgpXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlbmRlcmVyLmpzLm1hcCIsIi8qIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICdMaWNlbnNlJyk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gJ0FTIElTJyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IEJhY2tTaWRlLCBCb3gzLCBNZXNoLCBNZXNoQmFzaWNNYXRlcmlhbCwgTWVzaERlcHRoTWF0ZXJpYWwsIE9iamVjdDNELCBPcnRob2dyYXBoaWNDYW1lcmEsIFBsYW5lR2VvbWV0cnksIFJHQkFGb3JtYXQsIFNoYWRlck1hdGVyaWFsLCBWZWN0b3IzLCBXZWJHTFJlbmRlclRhcmdldCB9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7IEhvcml6b250YWxCbHVyU2hhZGVyIH0gZnJvbSAndGhyZWUvZXhhbXBsZXMvanNtL3NoYWRlcnMvSG9yaXpvbnRhbEJsdXJTaGFkZXIuanMnO1xuaW1wb3J0IHsgVmVydGljYWxCbHVyU2hhZGVyIH0gZnJvbSAndGhyZWUvZXhhbXBsZXMvanNtL3NoYWRlcnMvVmVydGljYWxCbHVyU2hhZGVyLmpzJztcbmltcG9ydCB7IGxlcnAgfSBmcm9tICd0aHJlZS9zcmMvbWF0aC9NYXRoVXRpbHMuanMnO1xuLy8gVGhlIHNvZnRuZXNzIFswLCAxXSBvZiB0aGUgc2hhZG93IGlzIG1hcHBlZCB0byBhIHJlc29sdXRpb24gYmV0d2VlblxuLy8gMl5MT0dfTUFYX1JFU09MVVRJT04gYW5kIDJeTE9HX01JTl9SRVNPTFVUSU9OLlxuY29uc3QgTE9HX01BWF9SRVNPTFVUSU9OID0gOTtcbmNvbnN0IExPR19NSU5fUkVTT0xVVElPTiA9IDY7XG4vLyBBbmltYXRlZCBtb2RlbHMgYXJlIG5vdCBpbiBnZW5lcmFsIGNvbnRhaW5lZCBpbiB0aGVpciBib3VuZGluZyBib3gsIGFzIHRoaXNcbi8vIGlzIGNhbGN1bGF0ZWQgb25seSBmb3IgdGhlaXIgcmVzdGluZyBwb3NlLiBXZSBjcmVhdGUgYSBjdWJpYyBzaGFkb3cgdm9sdW1lXG4vLyBmb3IgYW5pbWF0ZWQgbW9kZWxzIHNpemVkIHRvIHRoZWlyIGxhcmdlc3QgYm91bmRpbmcgYm94IGRpbWVuc2lvbiBtdWx0aXBsaWVkXG4vLyBieSB0aGlzIHNjYWxlIGZhY3Rvci5cbmNvbnN0IEFOSU1BVElPTl9TQ0FMSU5HID0gMjtcbi8vIFNpbmNlIGhhcmQgc2hhZG93cyBhcmUgbm90IGxpZ2h0ZW5lZCBieSBibHVycmluZyBhbmQgZGVwdGgsIHNldCBhIGxvd2VyXG4vLyBkZWZhdWx0IGludGVuc2l0eSB0byBtYWtlIHRoZW0gbW9yZSBwZXJjZXB0dWFsbHkgc2ltaWxhciB0byB0aGUgaW50ZW5zaXR5IG9mXG4vLyB0aGUgc29mdCBzaGFkb3dzLlxuY29uc3QgREVGQVVMVF9IQVJEX0lOVEVOU0lUWSA9IDAuMztcbi8qKlxuICogVGhlIFNoYWRvdyBjbGFzcyBjcmVhdGVzIGEgc2hhZG93IHRoYXQgZml0cyBhIGdpdmVuIHNjZW5lIGFuZCBmb2xsb3dzIGFcbiAqIHRhcmdldC4gVGhpcyBzaGFkb3cgd2lsbCBmb2xsb3cgdGhlIHNjZW5lIHdpdGhvdXQgYW55IHVwZGF0ZXMgbmVlZGVkIHNvIGxvbmdcbiAqIGFzIHRoZSBzaGFkb3cgYW5kIHNjZW5lIGFyZSBib3RoIHBhcmVudGVkIHRvIHRoZSBzYW1lIG9iamVjdCAoY2FsbCBpdCB0aGVcbiAqIHNjZW5lKSBhbmQgdGhpcyBzY2VuZSBpcyBwYXNzZWQgYXMgdGhlIHRhcmdldCBwYXJhbWV0ZXIgdG8gdGhlIHNoYWRvdydzXG4gKiBjb25zdHJ1Y3Rvci4gV2UgYWxzbyBtdXN0IGNvbnN0cmFpbiB0aGUgc2NlbmUgdG8gbW90aW9uIHdpdGhpbiB0aGUgaG9yaXpvbnRhbFxuICogcGxhbmUgYW5kIGNhbGwgdGhlIHNldFJvdGF0aW9uKCkgbWV0aG9kIHdoZW5ldmVyIHRoZSBzY2VuZSdzIFktYXhpcyByb3RhdGlvblxuICogY2hhbmdlcy4gRm9yIG1vdGlvbiBvdXRzaWRlIG9mIHRoZSBob3Jpem9udGFsIHBsYW5lLCB0aGlzLm5lZWRzVXBkYXRlIG11c3QgYmVcbiAqIHNldCB0byB0cnVlLlxuICpcbiAqIFRoZSBzb2Z0bmVzcyBvZiB0aGUgc2hhZG93IGlzIGNvbnRyb2xsZWQgYnkgY2hhbmdpbmcgaXRzIHJlc29sdXRpb24sIG1ha2luZ1xuICogc29mdGVyIHNoYWRvd3MgZmFzdGVyLCBidXQgbGVzcyBwcmVjaXNlLlxuICovXG5leHBvcnQgY2xhc3MgU2hhZG93IGV4dGVuZHMgT2JqZWN0M0Qge1xuICAgIGNvbnN0cnVjdG9yKHNjZW5lLCBzb2Z0bmVzcywgc2lkZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNhbWVyYSA9IG5ldyBPcnRob2dyYXBoaWNDYW1lcmEoKTtcbiAgICAgICAgLy8gcHJpdmF0ZSBjYW1lcmFIZWxwZXIgPSBuZXcgQ2FtZXJhSGVscGVyKHRoaXMuY2FtZXJhKTtcbiAgICAgICAgdGhpcy5yZW5kZXJUYXJnZXQgPSBudWxsO1xuICAgICAgICB0aGlzLnJlbmRlclRhcmdldEJsdXIgPSBudWxsO1xuICAgICAgICB0aGlzLmRlcHRoTWF0ZXJpYWwgPSBuZXcgTWVzaERlcHRoTWF0ZXJpYWwoKTtcbiAgICAgICAgdGhpcy5ob3Jpem9udGFsQmx1ck1hdGVyaWFsID0gbmV3IFNoYWRlck1hdGVyaWFsKEhvcml6b250YWxCbHVyU2hhZGVyKTtcbiAgICAgICAgdGhpcy52ZXJ0aWNhbEJsdXJNYXRlcmlhbCA9IG5ldyBTaGFkZXJNYXRlcmlhbChWZXJ0aWNhbEJsdXJTaGFkZXIpO1xuICAgICAgICB0aGlzLmludGVuc2l0eSA9IDA7XG4gICAgICAgIHRoaXMuc29mdG5lc3MgPSAxO1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94ID0gbmV3IEJveDM7XG4gICAgICAgIHRoaXMuc2l6ZSA9IG5ldyBWZWN0b3IzO1xuICAgICAgICB0aGlzLm1heERpbWVuc2lvbiA9IDA7XG4gICAgICAgIHRoaXMuaXNBbmltYXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHsgY2FtZXJhIH0gPSB0aGlzO1xuICAgICAgICBjYW1lcmEucm90YXRpb24ueCA9IE1hdGguUEkgLyAyO1xuICAgICAgICBjYW1lcmEubGVmdCA9IC0wLjU7XG4gICAgICAgIGNhbWVyYS5yaWdodCA9IDAuNTtcbiAgICAgICAgY2FtZXJhLmJvdHRvbSA9IC0wLjU7XG4gICAgICAgIGNhbWVyYS50b3AgPSAwLjU7XG4gICAgICAgIHRoaXMuYWRkKGNhbWVyYSk7XG4gICAgICAgIC8vIHRoaXMuYWRkKHRoaXMuY2FtZXJhSGVscGVyKTtcbiAgICAgICAgLy8gdGhpcy5jYW1lcmFIZWxwZXIudXBkYXRlTWF0cml4V29ybGQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gICB0aGlzLm1hdHJpeFdvcmxkID0gdGhpcy5jYW1lcmEubWF0cml4V29ybGQ7XG4gICAgICAgIC8vIH07XG4gICAgICAgIGNvbnN0IHBsYW5lID0gbmV3IFBsYW5lR2VvbWV0cnkoKTtcbiAgICAgICAgY29uc3Qgc2hhZG93TWF0ZXJpYWwgPSBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoe1xuICAgICAgICAgICAgLy8gY29sb3I6IG5ldyBDb2xvcigxLCAwLCAwKSxcbiAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICB0cmFuc3BhcmVudDogdHJ1ZSxcbiAgICAgICAgICAgIHNpZGU6IEJhY2tTaWRlLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5mbG9vciA9IG5ldyBNZXNoKHBsYW5lLCBzaGFkb3dNYXRlcmlhbCk7XG4gICAgICAgIHRoaXMuZmxvb3IudXNlckRhdGEuc2hhZG93ID0gdHJ1ZTtcbiAgICAgICAgY2FtZXJhLmFkZCh0aGlzLmZsb29yKTtcbiAgICAgICAgLy8gdGhlIHBsYW5lIG9udG8gd2hpY2ggdG8gYmx1ciB0aGUgdGV4dHVyZVxuICAgICAgICB0aGlzLmJsdXJQbGFuZSA9IG5ldyBNZXNoKHBsYW5lKTtcbiAgICAgICAgdGhpcy5ibHVyUGxhbmUudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICBjYW1lcmEuYWRkKHRoaXMuYmx1clBsYW5lKTtcbiAgICAgICAgc2NlbmUudGFyZ2V0LmFkZCh0aGlzKTtcbiAgICAgICAgLy8gbGlrZSBNZXNoRGVwdGhNYXRlcmlhbCwgYnV0IGdvZXMgZnJvbSBibGFjayB0byB0cmFuc3BhcmVudFxuICAgICAgICB0aGlzLmRlcHRoTWF0ZXJpYWwub25CZWZvcmVDb21waWxlID0gZnVuY3Rpb24gKHNoYWRlcikge1xuICAgICAgICAgICAgc2hhZGVyLmZyYWdtZW50U2hhZGVyID0gc2hhZGVyLmZyYWdtZW50U2hhZGVyLnJlcGxhY2UoJ2dsX0ZyYWdDb2xvciA9IHZlYzQoIHZlYzMoIDEuMCAtIGZyYWdDb29yZFogKSwgb3BhY2l0eSApOycsICdnbF9GcmFnQ29sb3IgPSB2ZWM0KCB2ZWMzKCAwLjAgKSwgKCAxLjAgLSBmcmFnQ29vcmRaICkgKiBvcGFjaXR5ICk7Jyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaG9yaXpvbnRhbEJsdXJNYXRlcmlhbC5kZXB0aFRlc3QgPSBmYWxzZTtcbiAgICAgICAgdGhpcy52ZXJ0aWNhbEJsdXJNYXRlcmlhbC5kZXB0aFRlc3QgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zZXRTY2VuZShzY2VuZSwgc29mdG5lc3MsIHNpZGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHNoYWRvdydzIHNpemUgYW5kIHBvc2l0aW9uIGZvciBhIG5ldyBzY2VuZS4gU29mdG5lc3MgaXMgYWxzb1xuICAgICAqIG5lZWRlZCwgYXMgdGhpcyBjb250cm9scyB0aGUgc2hhZG93J3MgcmVzb2x1dGlvbi5cbiAgICAgKi9cbiAgICBzZXRTY2VuZShzY2VuZSwgc29mdG5lc3MsIHNpZGUpIHtcbiAgICAgICAgY29uc3QgeyBib3VuZGluZ0JveCwgc2l6ZSwgcm90YXRpb24sIHBvc2l0aW9uIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLmlzQW5pbWF0ZWQgPSBzY2VuZS5hbmltYXRpb25OYW1lcy5sZW5ndGggPiAwO1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmNvcHkoc2NlbmUuYm91bmRpbmdCb3gpO1xuICAgICAgICB0aGlzLnNpemUuY29weShzY2VuZS5zaXplKTtcbiAgICAgICAgdGhpcy5tYXhEaW1lbnNpb24gPSBNYXRoLm1heChzaXplLngsIHNpemUueSwgc2l6ZS56KSAqXG4gICAgICAgICAgICAodGhpcy5pc0FuaW1hdGVkID8gQU5JTUFUSU9OX1NDQUxJTkcgOiAxKTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5nZXRDZW50ZXIocG9zaXRpb24pO1xuICAgICAgICBpZiAoc2lkZSA9PT0gJ2JhY2snKSB7XG4gICAgICAgICAgICBjb25zdCB7IG1pbiwgbWF4IH0gPSBib3VuZGluZ0JveDtcbiAgICAgICAgICAgIFttaW4ueSwgbWluLnpdID0gW21pbi56LCBtaW4ueV07XG4gICAgICAgICAgICBbbWF4LnksIG1heC56XSA9IFttYXgueiwgbWF4LnldO1xuICAgICAgICAgICAgW3NpemUueSwgc2l6ZS56XSA9IFtzaXplLnosIHNpemUueV07XG4gICAgICAgICAgICByb3RhdGlvbi54ID0gTWF0aC5QSSAvIDI7XG4gICAgICAgICAgICByb3RhdGlvbi55ID0gTWF0aC5QSTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJvdGF0aW9uLnggPSAwO1xuICAgICAgICAgICAgcm90YXRpb24ueSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNBbmltYXRlZCkge1xuICAgICAgICAgICAgY29uc3QgbWluWSA9IGJvdW5kaW5nQm94Lm1pbi55O1xuICAgICAgICAgICAgY29uc3QgbWF4WSA9IGJvdW5kaW5nQm94Lm1heC55O1xuICAgICAgICAgICAgc2l6ZS55ID0gdGhpcy5tYXhEaW1lbnNpb247XG4gICAgICAgICAgICBib3VuZGluZ0JveC5leHBhbmRCeVZlY3RvcihzaXplLnN1YlNjYWxhcih0aGlzLm1heERpbWVuc2lvbikubXVsdGlwbHlTY2FsYXIoLTAuNSkpO1xuICAgICAgICAgICAgYm91bmRpbmdCb3gubWluLnkgPSBtaW5ZO1xuICAgICAgICAgICAgYm91bmRpbmdCb3gubWF4LnkgPSBtYXhZO1xuICAgICAgICAgICAgc2l6ZS5zZXQodGhpcy5tYXhEaW1lbnNpb24sIG1heFkgLSBtaW5ZLCB0aGlzLm1heERpbWVuc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNpZGUgPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgICBwb3NpdGlvbi55ID0gYm91bmRpbmdCb3gubWluLnk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwb3NpdGlvbi56ID0gYm91bmRpbmdCb3gubWluLnk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRTb2Z0bmVzcyhzb2Z0bmVzcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgc2hhZG93J3MgcmVzb2x1dGlvbiBiYXNlZCBvbiBzb2Z0bmVzcyAoYmV0d2VlbiAwIGFuZCAxKS4gU2hvdWxkXG4gICAgICogbm90IGJlIGNhbGxlZCBmcmVxdWVudGx5LCBhcyB0aGlzIHJlc3VsdHMgaW4gcmVhbGxvY2F0aW9uLlxuICAgICAqL1xuICAgIHNldFNvZnRuZXNzKHNvZnRuZXNzKSB7XG4gICAgICAgIHRoaXMuc29mdG5lc3MgPSBzb2Z0bmVzcztcbiAgICAgICAgY29uc3QgeyBzaXplLCBjYW1lcmEgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHNjYWxlWSA9ICh0aGlzLmlzQW5pbWF0ZWQgPyBBTklNQVRJT05fU0NBTElORyA6IDEpO1xuICAgICAgICBjb25zdCByZXNvbHV0aW9uID0gc2NhbGVZICpcbiAgICAgICAgICAgIE1hdGgucG93KDIsIExPR19NQVhfUkVTT0xVVElPTiAtXG4gICAgICAgICAgICAgICAgc29mdG5lc3MgKiAoTE9HX01BWF9SRVNPTFVUSU9OIC0gTE9HX01JTl9SRVNPTFVUSU9OKSk7XG4gICAgICAgIHRoaXMuc2V0TWFwU2l6ZShyZXNvbHV0aW9uKTtcbiAgICAgICAgY29uc3Qgc29mdEZhciA9IHNpemUueSAvIDI7XG4gICAgICAgIGNvbnN0IGhhcmRGYXIgPSBzaXplLnkgKiBzY2FsZVk7XG4gICAgICAgIGNhbWVyYS5uZWFyID0gMDtcbiAgICAgICAgY2FtZXJhLmZhciA9IGxlcnAoaGFyZEZhciwgc29mdEZhciwgc29mdG5lc3MpO1xuICAgICAgICAvLyB3ZSBoYXZlIGNvLW9wdGVkIG9wYWNpdHkgdG8gc2NhbGUgdGhlIGRlcHRoIHRvIGNsaXBcbiAgICAgICAgdGhpcy5kZXB0aE1hdGVyaWFsLm9wYWNpdHkgPSAxLjAgLyBzb2Z0bmVzcztcbiAgICAgICAgY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICAgICAgLy8gdGhpcy5jYW1lcmFIZWxwZXIudXBkYXRlKCk7XG4gICAgICAgIHRoaXMuc2V0SW50ZW5zaXR5KHRoaXMuaW50ZW5zaXR5KTtcbiAgICAgICAgdGhpcy5zZXRPZmZzZXQoMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvd2VyLWxldmVsIHZlcnNpb24gb2YgdGhlIGFib3ZlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHNldE1hcFNpemUobWF4TWFwU2l6ZSkge1xuICAgICAgICBjb25zdCB7IHNpemUgfSA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmlzQW5pbWF0ZWQpIHtcbiAgICAgICAgICAgIG1heE1hcFNpemUgKj0gQU5JTUFUSU9OX1NDQUxJTkc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmFzZVdpZHRoID0gTWF0aC5mbG9vcihzaXplLnggPiBzaXplLnogPyBtYXhNYXBTaXplIDogbWF4TWFwU2l6ZSAqIHNpemUueCAvIHNpemUueik7XG4gICAgICAgIGNvbnN0IGJhc2VIZWlnaHQgPSBNYXRoLmZsb29yKHNpemUueCA+IHNpemUueiA/IG1heE1hcFNpemUgKiBzaXplLnogLyBzaXplLnggOiBtYXhNYXBTaXplKTtcbiAgICAgICAgLy8gd2lkdGggb2YgYmx1ciBmaWx0ZXIgaW4gcGl4ZWxzIChub3QgYWRqdXN0YWJsZSlcbiAgICAgICAgY29uc3QgVEFQX1dJRFRIID0gMTA7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gVEFQX1dJRFRIICsgYmFzZVdpZHRoO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBUQVBfV0lEVEggKyBiYXNlSGVpZ2h0O1xuICAgICAgICBpZiAodGhpcy5yZW5kZXJUYXJnZXQgIT0gbnVsbCAmJlxuICAgICAgICAgICAgKHRoaXMucmVuZGVyVGFyZ2V0LndpZHRoICE9PSB3aWR0aCB8fFxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyVGFyZ2V0LmhlaWdodCAhPT0gaGVpZ2h0KSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJUYXJnZXQuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJUYXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJUYXJnZXRCbHVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyVGFyZ2V0Qmx1ciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVuZGVyVGFyZ2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHsgZm9ybWF0OiBSR0JBRm9ybWF0IH07XG4gICAgICAgICAgICB0aGlzLnJlbmRlclRhcmdldCA9IG5ldyBXZWJHTFJlbmRlclRhcmdldCh3aWR0aCwgaGVpZ2h0LCBwYXJhbXMpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJUYXJnZXRCbHVyID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0KHdpZHRoLCBoZWlnaHQsIHBhcmFtcyk7XG4gICAgICAgICAgICB0aGlzLmZsb29yLm1hdGVyaWFsLm1hcCA9XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGVzZSBwYWRzIGFjY291bnQgZm9yIHRoZSBzb2Z0ZW5pbmcgcmFkaXVzIGFyb3VuZCB0aGUgc2hhZG93LlxuICAgICAgICB0aGlzLmNhbWVyYS5zY2FsZS5zZXQoc2l6ZS54ICogKDEgKyBUQVBfV0lEVEggLyBiYXNlV2lkdGgpLCBzaXplLnogKiAoMSArIFRBUF9XSURUSCAvIGJhc2VIZWlnaHQpLCAxKTtcbiAgICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgc2hhZG93J3MgaW50ZW5zaXR5ICgwIHRvIDEpLCB3aGljaCBpcyBqdXN0IGl0cyBvcGFjaXR5LiBUdXJucyBvZmZcbiAgICAgKiBzaGFkb3cgcmVuZGVyaW5nIGlmIHplcm8uXG4gICAgICovXG4gICAgc2V0SW50ZW5zaXR5KGludGVuc2l0eSkge1xuICAgICAgICB0aGlzLmludGVuc2l0eSA9IGludGVuc2l0eTtcbiAgICAgICAgaWYgKGludGVuc2l0eSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmZsb29yLnZpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5mbG9vci5tYXRlcmlhbC5vcGFjaXR5ID0gaW50ZW5zaXR5ICpcbiAgICAgICAgICAgICAgICBsZXJwKERFRkFVTFRfSEFSRF9JTlRFTlNJVFksIDEsIHRoaXMuc29mdG5lc3MgKiB0aGlzLnNvZnRuZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5mbG9vci52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0SW50ZW5zaXR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlbnNpdHk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFuIG9mZnNldCBjYW4gYmUgc3BlY2lmaWVkIHRvIG1vdmUgdGhlXG4gICAgICogc2hhZG93IHZlcnRpY2FsbHkgcmVsYXRpdmUgdG8gdGhlIGJvdHRvbSBvZiB0aGUgc2NlbmUuIFBvc2l0aXZlIGlzIHVwLCBzb1xuICAgICAqIHZhbHVlcyBhcmUgZ2VuZXJhbGx5IG5lZ2F0aXZlLiBBIHNtYWxsIG9mZnNldCBrZWVwcyBvdXIgc2hhZG93IGZyb21cbiAgICAgKiB6LWZpZ2h0aW5nIHdpdGggYW55IGJha2VkLWluIHNoYWRvdyBwbGFuZS5cbiAgICAgKi9cbiAgICBzZXRPZmZzZXQob2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuZmxvb3IucG9zaXRpb24ueiA9IC1vZmZzZXQgKyAwLjAwMSAqIHRoaXMubWF4RGltZW5zaW9uO1xuICAgIH1cbiAgICByZW5kZXIocmVuZGVyZXIsIHNjZW5lKSB7XG4gICAgICAgIC8vIHRoaXMuY2FtZXJhSGVscGVyLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgLy8gZm9yY2UgdGhlIGRlcHRoTWF0ZXJpYWwgdG8gZXZlcnl0aGluZ1xuICAgICAgICBzY2VuZS5vdmVycmlkZU1hdGVyaWFsID0gdGhpcy5kZXB0aE1hdGVyaWFsO1xuICAgICAgICAvLyBzZXQgcmVuZGVyZXIgY2xlYXIgYWxwaGFcbiAgICAgICAgY29uc3QgaW5pdGlhbENsZWFyQWxwaGEgPSByZW5kZXJlci5nZXRDbGVhckFscGhhKCk7XG4gICAgICAgIHJlbmRlcmVyLnNldENsZWFyQWxwaGEoMCk7XG4gICAgICAgIHRoaXMuZmxvb3IudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAvLyBkaXNhYmxlIFhSIGZvciBvZmZzY3JlZW4gcmVuZGVyaW5nXG4gICAgICAgIGNvbnN0IHhyRW5hYmxlZCA9IHJlbmRlcmVyLnhyLmVuYWJsZWQ7XG4gICAgICAgIHJlbmRlcmVyLnhyLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gcmVuZGVyIHRvIHRoZSByZW5kZXIgdGFyZ2V0IHRvIGdldCB0aGUgZGVwdGhzXG4gICAgICAgIGNvbnN0IG9sZFJlbmRlclRhcmdldCA9IHJlbmRlcmVyLmdldFJlbmRlclRhcmdldCgpO1xuICAgICAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQodGhpcy5yZW5kZXJUYXJnZXQpO1xuICAgICAgICByZW5kZXJlci5yZW5kZXIoc2NlbmUsIHRoaXMuY2FtZXJhKTtcbiAgICAgICAgLy8gYW5kIHJlc2V0IHRoZSBvdmVycmlkZSBtYXRlcmlhbFxuICAgICAgICBzY2VuZS5vdmVycmlkZU1hdGVyaWFsID0gbnVsbDtcbiAgICAgICAgdGhpcy5mbG9vci52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5ibHVyU2hhZG93KHJlbmRlcmVyKTtcbiAgICAgICAgLy8gcmVzZXQgYW5kIHJlbmRlciB0aGUgbm9ybWFsIHNjZW5lXG4gICAgICAgIHJlbmRlcmVyLnhyLmVuYWJsZWQgPSB4ckVuYWJsZWQ7XG4gICAgICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldChvbGRSZW5kZXJUYXJnZXQpO1xuICAgICAgICByZW5kZXJlci5zZXRDbGVhckFscGhhKGluaXRpYWxDbGVhckFscGhhKTtcbiAgICAgICAgLy8gdGhpcy5jYW1lcmFIZWxwZXIudmlzaWJsZSA9IHRydWU7XG4gICAgfVxuICAgIGJsdXJTaGFkb3cocmVuZGVyZXIpIHtcbiAgICAgICAgY29uc3QgeyBjYW1lcmEsIGhvcml6b250YWxCbHVyTWF0ZXJpYWwsIHZlcnRpY2FsQmx1ck1hdGVyaWFsLCByZW5kZXJUYXJnZXQsIHJlbmRlclRhcmdldEJsdXIsIGJsdXJQbGFuZSB9ID0gdGhpcztcbiAgICAgICAgYmx1clBsYW5lLnZpc2libGUgPSB0cnVlO1xuICAgICAgICAvLyBibHVyIGhvcml6b250YWxseSBhbmQgZHJhdyBpbiB0aGUgcmVuZGVyVGFyZ2V0Qmx1clxuICAgICAgICBibHVyUGxhbmUubWF0ZXJpYWwgPSBob3Jpem9udGFsQmx1ck1hdGVyaWFsO1xuICAgICAgICBob3Jpem9udGFsQmx1ck1hdGVyaWFsLnVuaWZvcm1zLmgudmFsdWUgPSAxIC8gdGhpcy5yZW5kZXJUYXJnZXQud2lkdGg7XG4gICAgICAgIGhvcml6b250YWxCbHVyTWF0ZXJpYWwudW5pZm9ybXMudERpZmZ1c2UudmFsdWUgPSB0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlO1xuICAgICAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQocmVuZGVyVGFyZ2V0Qmx1cik7XG4gICAgICAgIHJlbmRlcmVyLnJlbmRlcihibHVyUGxhbmUsIGNhbWVyYSk7XG4gICAgICAgIC8vIGJsdXIgdmVydGljYWxseSBhbmQgZHJhdyBpbiB0aGUgbWFpbiByZW5kZXJUYXJnZXRcbiAgICAgICAgYmx1clBsYW5lLm1hdGVyaWFsID0gdmVydGljYWxCbHVyTWF0ZXJpYWw7XG4gICAgICAgIHZlcnRpY2FsQmx1ck1hdGVyaWFsLnVuaWZvcm1zLnYudmFsdWUgPSAxIC8gdGhpcy5yZW5kZXJUYXJnZXQuaGVpZ2h0O1xuICAgICAgICB2ZXJ0aWNhbEJsdXJNYXRlcmlhbC51bmlmb3Jtcy50RGlmZnVzZS52YWx1ZSA9XG4gICAgICAgICAgICB0aGlzLnJlbmRlclRhcmdldEJsdXIudGV4dHVyZTtcbiAgICAgICAgcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCk7XG4gICAgICAgIHJlbmRlcmVyLnJlbmRlcihibHVyUGxhbmUsIGNhbWVyYSk7XG4gICAgICAgIGJsdXJQbGFuZS52aXNpYmxlID0gZmFsc2U7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlbmRlclRhcmdldCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlclRhcmdldC5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVuZGVyVGFyZ2V0Qmx1ciAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlclRhcmdldEJsdXIuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVwdGhNYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuaG9yaXpvbnRhbEJsdXJNYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMudmVydGljYWxCbHVyTWF0ZXJpYWwuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmZsb29yLm1hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5mbG9vci5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuYmx1clBsYW5lLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5yZW1vdmVGcm9tUGFyZW50KCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2hhZG93LmpzLm1hcCIsIi8qIEBsaWNlbnNlXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgJ0xpY2Vuc2UnKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAnQVMgSVMnIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgRXVsZXIsIEV2ZW50RGlzcGF0Y2hlciwgTWF0cml4MywgU3BoZXJpY2FsLCBWZWN0b3IyLCBWZWN0b3IzIH0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgJHBhbkVsZW1lbnQgfSBmcm9tICcuLi9mZWF0dXJlcy9jb250cm9scy5qcyc7XG5pbXBvcnQgeyBjbGFtcCB9IGZyb20gJy4uL3V0aWxpdGllcy5qcyc7XG5pbXBvcnQgeyBEYW1wZXIsIFNFVFRMSU5HX1RJTUUgfSBmcm9tICcuL0RhbXBlci5qcyc7XG5jb25zdCBQQU5fU0VOU0lUSVZJVFkgPSAwLjAxODtcbmNvbnN0IFRBUF9ESVNUQU5DRSA9IDI7XG5jb25zdCBUQVBfTVMgPSAzMDA7XG5jb25zdCB2ZWN0b3IyID0gbmV3IFZlY3RvcjIoKTtcbmNvbnN0IHZlY3RvcjMgPSBuZXcgVmVjdG9yMygpO1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfT1BUSU9OUyA9IE9iamVjdC5mcmVlemUoe1xuICAgIG1pbmltdW1SYWRpdXM6IDAsXG4gICAgbWF4aW11bVJhZGl1czogSW5maW5pdHksXG4gICAgbWluaW11bVBvbGFyQW5nbGU6IE1hdGguUEkgLyA4LFxuICAgIG1heGltdW1Qb2xhckFuZ2xlOiBNYXRoLlBJIC0gTWF0aC5QSSAvIDgsXG4gICAgbWluaW11bUF6aW11dGhhbEFuZ2xlOiAtSW5maW5pdHksXG4gICAgbWF4aW11bUF6aW11dGhhbEFuZ2xlOiBJbmZpbml0eSxcbiAgICBtaW5pbXVtRmllbGRPZlZpZXc6IDEwLFxuICAgIG1heGltdW1GaWVsZE9mVmlldzogNDUsXG4gICAgdG91Y2hBY3Rpb246ICdub25lJ1xufSk7XG4vLyBDb25zdGFudHNcbmNvbnN0IEtFWUJPQVJEX09SQklUX0lOQ1JFTUVOVCA9IE1hdGguUEkgLyA4O1xuY29uc3QgWk9PTV9TRU5TSVRJVklUWSA9IDAuMDQ7XG4vLyBUaGUgbW92ZSBzaXplIG9uIHBhbiBrZXkgZXZlbnRcbmNvbnN0IFBBTl9LRVlfSU5DUkVNRU5UID0gMTA7XG5leHBvcnQgY29uc3QgS2V5Q29kZSA9IHtcbiAgICBQQUdFX1VQOiAzMyxcbiAgICBQQUdFX0RPV046IDM0LFxuICAgIExFRlQ6IDM3LFxuICAgIFVQOiAzOCxcbiAgICBSSUdIVDogMzksXG4gICAgRE9XTjogNDBcbn07XG5leHBvcnQgY29uc3QgQ2hhbmdlU291cmNlID0ge1xuICAgIFVTRVJfSU5URVJBQ1RJT046ICd1c2VyLWludGVyYWN0aW9uJyxcbiAgICBOT05FOiAnbm9uZScsXG4gICAgQVVUT01BVElDOiAnYXV0b21hdGljJ1xufTtcbi8qKlxuICogU21vb3RoQ29udHJvbHMgaXMgYSBUaHJlZS5qcyBoZWxwZXIgZm9yIGFkZGluZyBkZWxpZ2h0ZnVsIHBvaW50ZXIgYW5kXG4gKiBrZXlib2FyZC1iYXNlZCBpbnB1dCB0byBhIHN0YWdlZCBUaHJlZS5qcyBzY2VuZS4gSXRzIEFQSSBpcyB2ZXJ5IHNpbWlsYXIgdG9cbiAqIE9yYml0Q29udHJvbHMsIGJ1dCBpdCBvZmZlcnMgbW9yZSBvcGluaW9uYXRlZCAoc3ViamVjdGl2ZWx5IG1vcmUgZGVsaWdodGZ1bClcbiAqIGRlZmF1bHRzLCBlYXN5IGV4dGVuc2liaWxpdHkgYW5kIHN1YmplY3RpdmVseSBiZXR0ZXIgb3V0LW9mLXRoZS1ib3gga2V5Ym9hcmRcbiAqIHN1cHBvcnQuXG4gKlxuICogT25lIGltcG9ydGFudCBjaGFuZ2UgY29tcGFyZWQgdG8gT3JiaXRDb250cm9scyBpcyB0aGF0IHRoZSBgdXBkYXRlYCBtZXRob2RcbiAqIG9mIFNtb290aENvbnRyb2xzIG11c3QgYmUgaW52b2tlZCBvbiBldmVyeSBmcmFtZSwgb3RoZXJ3aXNlIHRoZSBjb250cm9sc1xuICogd2lsbCBub3QgaGF2ZSBhbiBlZmZlY3QuXG4gKlxuICogQW5vdGhlciBub3RhYmxlIGRpZmZlcmVuY2UgY29tcGFyZWQgdG8gT3JiaXRDb250cm9scyBpcyB0aGF0IFNtb290aENvbnRyb2xzXG4gKiBkb2VzIG5vdCBjdXJyZW50bHkgc3VwcG9ydCBwYW5uaW5nIChidXQgcHJvYmFibHkgd2lsbCBpbiBhIGZ1dHVyZSByZXZpc2lvbikuXG4gKlxuICogTGlrZSBPcmJpdENvbnRyb2xzLCBTbW9vdGhDb250cm9scyBhc3N1bWVzIHRoYXQgdGhlIG9yaWVudGF0aW9uIG9mIHRoZSBjYW1lcmFcbiAqIGhhcyBiZWVuIHNldCBpbiB0ZXJtcyBvZiBwb3NpdGlvbiwgcm90YXRpb24gYW5kIHNjYWxlLCBzbyBpdCBpcyBpbXBvcnRhbnQgdG9cbiAqIGVuc3VyZSB0aGF0IHRoZSBjYW1lcmEncyBtYXRyaXhXb3JsZCBpcyBpbiBzeW5jIGJlZm9yZSB1c2luZyBTbW9vdGhDb250cm9scy5cbiAqL1xuZXhwb3J0IGNsYXNzIFNtb290aENvbnRyb2xzIGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3RvcihjYW1lcmEsIGVsZW1lbnQsIHNjZW5lKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLnNjZW5lID0gc2NlbmU7XG4gICAgICAgIHRoaXMub3JiaXRTZW5zaXRpdml0eSA9IDE7XG4gICAgICAgIHRoaXMuaW5wdXRTZW5zaXRpdml0eSA9IDE7XG4gICAgICAgIHRoaXMuY2hhbmdlU291cmNlID0gQ2hhbmdlU291cmNlLk5PTkU7XG4gICAgICAgIHRoaXMuX2ludGVyYWN0aW9uRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9kaXNhYmxlWm9vbSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzVXNlclBvaW50aW5nID0gZmFsc2U7XG4gICAgICAgIC8vIFBhbiBzdGF0ZVxuICAgICAgICB0aGlzLmVuYWJsZVBhbiA9IHRydWU7XG4gICAgICAgIHRoaXMuZW5hYmxlVGFwID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wYW5Qcm9qZWN0aW9uID0gbmV3IE1hdHJpeDMoKTtcbiAgICAgICAgdGhpcy5wYW5QZXJQaXhlbCA9IDA7XG4gICAgICAgIC8vIEludGVybmFsIG9yYml0YWwgcG9zaXRpb24gc3RhdGVcbiAgICAgICAgdGhpcy5zcGhlcmljYWwgPSBuZXcgU3BoZXJpY2FsKCk7XG4gICAgICAgIHRoaXMuZ29hbFNwaGVyaWNhbCA9IG5ldyBTcGhlcmljYWwoKTtcbiAgICAgICAgdGhpcy50aGV0YURhbXBlciA9IG5ldyBEYW1wZXIoKTtcbiAgICAgICAgdGhpcy5waGlEYW1wZXIgPSBuZXcgRGFtcGVyKCk7XG4gICAgICAgIHRoaXMucmFkaXVzRGFtcGVyID0gbmV3IERhbXBlcigpO1xuICAgICAgICB0aGlzLmxvZ0ZvdiA9IE1hdGgubG9nKERFRkFVTFRfT1BUSU9OUy5tYXhpbXVtRmllbGRPZlZpZXcpO1xuICAgICAgICB0aGlzLmdvYWxMb2dGb3YgPSB0aGlzLmxvZ0ZvdjtcbiAgICAgICAgdGhpcy5mb3ZEYW1wZXIgPSBuZXcgRGFtcGVyKCk7XG4gICAgICAgIC8vIFBvaW50ZXIgc3RhdGVcbiAgICAgICAgdGhpcy50b3VjaE1vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLnBvaW50ZXJzID0gW107XG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gMDtcbiAgICAgICAgdGhpcy5zdGFydFBvaW50ZXJQb3NpdGlvbiA9IHsgY2xpZW50WDogMCwgY2xpZW50WTogMCB9O1xuICAgICAgICB0aGlzLmxhc3RTZXBhcmF0aW9uID0gMDtcbiAgICAgICAgdGhpcy50b3VjaERlY2lkZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vbkNvbnRleHQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmVuYWJsZVBhbikge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBvaW50ZXIgb2YgdGhpcy5wb2ludGVycykge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXF1aXJlZCBiZWNhdXNlIG9mIGEgY29tbW9uIGJyb3dzZXIgYnVnIHdoZXJlIHRoZSBjb250ZXh0IG1lbnUgbmV2ZXJcbiAgICAgICAgICAgICAgICAgICAgLy8gZmlyZXMgYSBwb2ludGVyY2FuY2VsIGV2ZW50LlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uUG9pbnRlclVwKG5ldyBQb2ludGVyRXZlbnQoJ3BvaW50ZXJjYW5jZWwnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuc3RhcnRQb2ludGVyUG9zaXRpb24pLCB7IHBvaW50ZXJJZDogcG9pbnRlci5pZCB9KSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50b3VjaE1vZGVab29tID0gKGR4LCBkeSkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9kaXNhYmxlWm9vbSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvdWNoRGlzdGFuY2UgPSB0aGlzLnR3b1RvdWNoRGlzdGFuY2UodGhpcy5wb2ludGVyc1swXSwgdGhpcy5wb2ludGVyc1sxXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVsdGFab29tID0gWk9PTV9TRU5TSVRJVklUWSAqXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLmxhc3RTZXBhcmF0aW9uIC0gdG91Y2hEaXN0YW5jZSkgKiA1MCAvIHRoaXMuc2NlbmUuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdFNlcGFyYXRpb24gPSB0b3VjaERpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRoaXMudXNlckFkanVzdE9yYml0KDAsIDAsIGRlbHRhWm9vbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5wYW5QZXJQaXhlbCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVQYW4oZHgsIGR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gV2UgaW1wbGVtZW50IG91ciBvd24gdmVyc2lvbiBvZiB0aGUgYnJvd3NlcidzIENTUyB0b3VjaC1hY3Rpb24sIGVuZm9yY2VkIGJ5XG4gICAgICAgIC8vIHRoaXMgZnVuY3Rpb24sIGJlY2F1c2UgdGhlIGlPUyBpbXBsZW1lbnRhdGlvbiBvZiBwYW4teSBpcyBiYWQgYW5kIGRvZXNuJ3RcbiAgICAgICAgLy8gbWF0Y2ggQW5kcm9pZC4gU3BlY2lmaWNhbGx5LCBldmVuIGlmIGEgdG91Y2ggZ2VzdHVyZSBiZWdpbnMgYnkgcGFubmluZyBYLFxuICAgICAgICAvLyBpT1Mgd2lsbCBzd2l0Y2ggdG8gc2Nyb2xsaW5nIGFzIHNvb24gYXMgdGhlIGdlc3R1cmUgbW92ZXMgaW4gdGhlIFksIHJhdGhlclxuICAgICAgICAvLyB0aGFuIHN0YXlpbmcgaW4gdGhlIHNhbWUgbW9kZSB1bnRpbCB0aGUgZW5kIG9mIHRoZSBnZXN0dXJlLlxuICAgICAgICB0aGlzLmRpc2FibGVTY3JvbGwgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudG91Y2hNb2RlUm90YXRlID0gKGR4LCBkeSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyB0b3VjaEFjdGlvbiB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICAgICAgICAgIGlmICghdGhpcy50b3VjaERlY2lkZWQgJiYgdG91Y2hBY3Rpb24gIT09ICdub25lJykge1xuICAgICAgICAgICAgICAgIHRoaXMudG91Y2hEZWNpZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBkeE1hZyA9IE1hdGguYWJzKGR4KTtcbiAgICAgICAgICAgICAgICBjb25zdCBkeU1hZyA9IE1hdGguYWJzKGR5KTtcbiAgICAgICAgICAgICAgICAvLyBJZiBtb3Rpb24gaXMgbW9zdGx5IHZlcnRpY2FsLCBhc3N1bWUgc2Nyb2xsaW5nIGlzIHRoZSBpbnRlbnQuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hhbmdlU291cmNlID09PSBDaGFuZ2VTb3VyY2UuVVNFUl9JTlRFUkFDVElPTiAmJlxuICAgICAgICAgICAgICAgICAgICAoKHRvdWNoQWN0aW9uID09PSAncGFuLXknICYmIGR5TWFnID4gZHhNYWcpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAodG91Y2hBY3Rpb24gPT09ICdwYW4teCcgJiYgZHhNYWcgPiBkeU1hZykpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG91Y2hNb2RlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuZGlzYWJsZVNjcm9sbCwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVNpbmdsZVBvaW50ZXJNb3ZlKGR4LCBkeSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25Qb2ludGVyRG93biA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMucG9pbnRlcnMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgZWxlbWVudCB9ID0gdGhpcztcbiAgICAgICAgICAgIGlmICh0aGlzLnBvaW50ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCB0aGlzLm9uUG9pbnRlck1vdmUpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgdGhpcy5vblBvaW50ZXJVcCk7XG4gICAgICAgICAgICAgICAgdGhpcy50b3VjaE1vZGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMudG91Y2hEZWNpZGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFBvaW50ZXJQb3NpdGlvbi5jbGllbnRYID0gZXZlbnQuY2xpZW50WDtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0UG9pbnRlclBvc2l0aW9uLmNsaWVudFkgPSBldmVudC5jbGllbnRZO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc2V0UG9pbnRlckNhcHR1cmUoZXZlbnQucG9pbnRlcklkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wb2ludGVycy5wdXNoKHsgY2xpZW50WDogZXZlbnQuY2xpZW50WCwgY2xpZW50WTogZXZlbnQuY2xpZW50WSwgaWQ6IGV2ZW50LnBvaW50ZXJJZCB9KTtcbiAgICAgICAgICAgIHRoaXMuaXNVc2VyUG9pbnRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChldmVudC5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlU291cmNlID0gZXZlbnQuYWx0S2V5ID8gLy8gc2V0IGJ5IGludGVyYWN0KCkgaW4gY29udHJvbHMudHNcbiAgICAgICAgICAgICAgICAgICAgQ2hhbmdlU291cmNlLkFVVE9NQVRJQyA6XG4gICAgICAgICAgICAgICAgICAgIENoYW5nZVNvdXJjZS5VU0VSX0lOVEVSQUNUSU9OO1xuICAgICAgICAgICAgICAgIHRoaXMub25Ub3VjaENoYW5nZShldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZVNvdXJjZSA9IENoYW5nZVNvdXJjZS5VU0VSX0lOVEVSQUNUSU9OO1xuICAgICAgICAgICAgICAgIHRoaXMub25Nb3VzZURvd24oZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY2hhbmdlU291cmNlID09PSBDaGFuZ2VTb3VyY2UuVVNFUl9JTlRFUkFDVElPTikge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh7IHR5cGU6ICd1c2VyLWludGVyYWN0aW9uJyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vblBvaW50ZXJNb3ZlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwb2ludGVyID0gdGhpcy5wb2ludGVycy5maW5kKChwb2ludGVyKSA9PiBwb2ludGVyLmlkID09PSBldmVudC5wb2ludGVySWQpO1xuICAgICAgICAgICAgaWYgKHBvaW50ZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEluIGNhc2Ugbm8gb25lIGdhdmUgdXMgYSBwb2ludGVydXAgb3IgcG9pbnRlcmNhbmNlbCBldmVudC5cbiAgICAgICAgICAgIGlmIChldmVudC5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJyAmJiBldmVudC5idXR0b25zID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vblBvaW50ZXJVcChldmVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbnVtVG91Y2hlcyA9IHRoaXMucG9pbnRlcnMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgZHggPSAoZXZlbnQuY2xpZW50WCAtIHBvaW50ZXIuY2xpZW50WCkgLyBudW1Ub3VjaGVzO1xuICAgICAgICAgICAgY29uc3QgZHkgPSAoZXZlbnQuY2xpZW50WSAtIHBvaW50ZXIuY2xpZW50WSkgLyBudW1Ub3VjaGVzO1xuICAgICAgICAgICAgaWYgKGR4ID09PSAwICYmIGR5ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9pbnRlci5jbGllbnRYID0gZXZlbnQuY2xpZW50WDtcbiAgICAgICAgICAgIHBvaW50ZXIuY2xpZW50WSA9IGV2ZW50LmNsaWVudFk7XG4gICAgICAgICAgICBpZiAoZXZlbnQucG9pbnRlclR5cGUgPT09ICd0b3VjaCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZVNvdXJjZSA9IGV2ZW50LmFsdEtleSA/IC8vIHNldCBieSBpbnRlcmFjdCgpIGluIGNvbnRyb2xzLnRzXG4gICAgICAgICAgICAgICAgICAgIENoYW5nZVNvdXJjZS5BVVRPTUFUSUMgOlxuICAgICAgICAgICAgICAgICAgICBDaGFuZ2VTb3VyY2UuVVNFUl9JTlRFUkFDVElPTjtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50b3VjaE1vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b3VjaE1vZGUoZHgsIGR5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZVNvdXJjZSA9IENoYW5nZVNvdXJjZS5VU0VSX0lOVEVSQUNUSU9OO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhblBlclBpeGVsID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmVQYW4oZHgsIGR5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlU2luZ2xlUG9pbnRlck1vdmUoZHgsIGR5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25Qb2ludGVyVXAgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZWxlbWVudCB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5wb2ludGVycy5maW5kSW5kZXgoKHBvaW50ZXIpID0+IHBvaW50ZXIuaWQgPT09IGV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb2ludGVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYWx0S2V5IGluZGljYXRlcyBhbiBpbnRlcmFjdGlvbiBwcm9tcHQ7IGRvbid0IHJlc2V0IHJhZGl1cyBpbiB0aGlzIGNhc2VcbiAgICAgICAgICAgIC8vIGFzIGl0IHdpbGwgY2F1c2UgdGhlIGNhbWVyYSB0byBkcmlmdC5cbiAgICAgICAgICAgIGlmICh0aGlzLnBhblBlclBpeGVsID4gMCAmJiAhZXZlbnQuYWx0S2V5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldFJhZGl1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucG9pbnRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIHRoaXMub25Qb2ludGVyTW92ZSk7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCB0aGlzLm9uUG9pbnRlclVwKTtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuZGlzYWJsZVNjcm9sbCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZW5hYmxlUGFuICYmIHRoaXMuZW5hYmxlVGFwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVjZW50ZXIoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMudG91Y2hNb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vblRvdWNoQ2hhbmdlKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2NlbmUuZWxlbWVudFskcGFuRWxlbWVudF0uc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLmN1cnNvciA9ICdncmFiJztcbiAgICAgICAgICAgIHRoaXMucGFuUGVyUGl4ZWwgPSAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNVc2VyUG9pbnRpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoeyB0eXBlOiAncG9pbnRlci1jaGFuZ2UtZW5kJyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbldoZWVsID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZVNvdXJjZSA9IENoYW5nZVNvdXJjZS5VU0VSX0lOVEVSQUNUSU9OO1xuICAgICAgICAgICAgY29uc3QgZGVsdGFab29tID0gZXZlbnQuZGVsdGFZICpcbiAgICAgICAgICAgICAgICAoZXZlbnQuZGVsdGFNb2RlID09IDEgPyAxOCA6IDEpICogWk9PTV9TRU5TSVRJVklUWSAvIDMwO1xuICAgICAgICAgICAgdGhpcy51c2VyQWRqdXN0T3JiaXQoMCwgMCwgZGVsdGFab29tKTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoeyB0eXBlOiAndXNlci1pbnRlcmFjdGlvbicgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25LZXlEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAvLyBXZSB0cmFjayBpZiB0aGUga2V5IGlzIGFjdHVhbGx5IG9uZSB3ZSByZXNwb25kIHRvLCBzbyBhcyBub3QgdG9cbiAgICAgICAgICAgIC8vIGFjY2lkZW50YWxseSBjbG9iYmVyIHVucmVsYXRlZCBrZXkgaW5wdXRzIHdoZW4gdGhlIDxtb2RlbC12aWV3ZXI+IGhhc1xuICAgICAgICAgICAgLy8gZm9jdXMuXG4gICAgICAgICAgICBjb25zdCB7IGNoYW5nZVNvdXJjZSB9ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlU291cmNlID0gQ2hhbmdlU291cmNlLlVTRVJfSU5URVJBQ1RJT047XG4gICAgICAgICAgICBjb25zdCByZWxldmFudEtleSA9IChldmVudC5zaGlmdEtleSAmJiB0aGlzLmVuYWJsZVBhbikgP1xuICAgICAgICAgICAgICAgIHRoaXMucGFuS2V5Q29kZUhhbmRsZXIoZXZlbnQpIDpcbiAgICAgICAgICAgICAgICB0aGlzLm9yYml0Wm9vbUtleUNvZGVIYW5kbGVyKGV2ZW50KTtcbiAgICAgICAgICAgIGlmIChyZWxldmFudEtleSkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHsgdHlwZTogJ3VzZXItaW50ZXJhY3Rpb24nIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VTb3VyY2UgPSBjaGFuZ2VTb3VyY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMpO1xuICAgICAgICB0aGlzLnNldE9yYml0KDAsIE1hdGguUEkgLyAyLCAxKTtcbiAgICAgICAgdGhpcy5zZXRGaWVsZE9mVmlldygxMDApO1xuICAgICAgICB0aGlzLmp1bXBUb0dvYWwoKTtcbiAgICB9XG4gICAgZ2V0IGludGVyYWN0aW9uRW5hYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVyYWN0aW9uRW5hYmxlZDtcbiAgICB9XG4gICAgZW5hYmxlSW50ZXJhY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbnRlcmFjdGlvbkVuYWJsZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBjb25zdCB7IGVsZW1lbnQgfSA9IHRoaXM7XG4gICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgdGhpcy5vblBvaW50ZXJEb3duKTtcbiAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmNhbmNlbCcsIHRoaXMub25Qb2ludGVyVXApO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9kaXNhYmxlWm9vbSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCB0aGlzLm9uV2hlZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5vbktleURvd24pO1xuICAgICAgICAgICAgLy8gVGhpcyBsaXR0bGUgYmVhdXR5IGlzIHRvIHdvcmsgYXJvdW5kIGEgV2ViS2l0IGJ1ZyB0aGF0IG90aGVyd2lzZSBtYWtlc1xuICAgICAgICAgICAgLy8gdG91Y2ggZXZlbnRzIHJhbmRvbWx5IG5vdCBjYW5jZWxhYmxlLlxuICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCAoKSA9PiB7IH0sIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgdGhpcy5vbkNvbnRleHQpO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmN1cnNvciA9ICdncmFiJztcbiAgICAgICAgICAgIHRoaXMuX2ludGVyYWN0aW9uRW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRvdWNoQWN0aW9uU3R5bGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXNhYmxlSW50ZXJhY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbnRlcmFjdGlvbkVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZWxlbWVudCB9ID0gdGhpcztcbiAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCB0aGlzLm9uUG9pbnRlckRvd24pO1xuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIHRoaXMub25Qb2ludGVyTW92ZSk7XG4gICAgICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIHRoaXMub25Qb2ludGVyVXApO1xuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVyY2FuY2VsJywgdGhpcy5vblBvaW50ZXJVcCk7XG4gICAgICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3doZWVsJywgdGhpcy5vbldoZWVsKTtcbiAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMub25LZXlEb3duKTtcbiAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCB0aGlzLm9uQ29udGV4dCk7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLmN1cnNvciA9ICcnO1xuICAgICAgICAgICAgdGhpcy50b3VjaE1vZGUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5faW50ZXJhY3Rpb25FbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRvdWNoQWN0aW9uU3R5bGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgb3B0aW9ucyB0aGF0IGFyZSBjdXJyZW50bHkgY29uZmlndXJlZCBmb3IgdGhlIGNvbnRyb2xzIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3B0aW9ucztcbiAgICB9XG4gICAgc2V0IGRpc2FibGVab29tKGRpc2FibGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Rpc2FibGVab29tICE9IGRpc2FibGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc2FibGVab29tID0gZGlzYWJsZTtcbiAgICAgICAgICAgIGlmIChkaXNhYmxlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3doZWVsJywgdGhpcy5vbldoZWVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIHRoaXMub25XaGVlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRvdWNoQWN0aW9uU3R5bGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb3B5IHRoZSBzcGhlcmljYWwgdmFsdWVzIHRoYXQgcmVwcmVzZW50IHRoZSBjdXJyZW50IGNhbWVyYSBvcmJpdGFsXG4gICAgICogcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIGNvbmZpZ3VyZWQgdGFyZ2V0IGludG8gYSBwcm92aWRlZCBTcGhlcmljYWxcbiAgICAgKiBpbnN0YW5jZS4gSWYgbm8gU3BoZXJpY2FsIGlzIHByb3ZpZGVkLCBhIG5ldyBTcGhlcmljYWwgd2lsbCBiZSBhbGxvY2F0ZWRcbiAgICAgKiB0byBjb3B5IHRoZSB2YWx1ZXMgaW50by4gVGhlIFNwaGVyaWNhbCB0aGF0IHZhbHVlcyBhcmUgY29waWVkIGludG8gaXNcbiAgICAgKiByZXR1cm5lZC5cbiAgICAgKi9cbiAgICBnZXRDYW1lcmFTcGhlcmljYWwodGFyZ2V0ID0gbmV3IFNwaGVyaWNhbCgpKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQuY29weSh0aGlzLnNwaGVyaWNhbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNhbWVyYSdzIGN1cnJlbnQgdmVydGljYWwgZmllbGQgb2YgdmlldyBpbiBkZWdyZWVzLlxuICAgICAqL1xuICAgIGdldEZpZWxkT2ZWaWV3KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYW1lcmEuZm92O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmUgdGhlIF9vcHRpb25zIG9mIHRoZSBjb250cm9scy4gQ29uZmlndXJlZCBfb3B0aW9ucyB3aWxsIGJlXG4gICAgICogbWVyZ2VkIHdpdGggd2hhdGV2ZXIgX29wdGlvbnMgaGF2ZSBhbHJlYWR5IGJlZW4gY29uZmlndXJlZCBmb3IgdGhpc1xuICAgICAqIGNvbnRyb2xzIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGFwcGx5T3B0aW9ucyhfb3B0aW9ucykge1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuX29wdGlvbnMsIF9vcHRpb25zKTtcbiAgICAgICAgLy8gUmUtZXZhbHVhdGVzIGNsYW1waW5nIGJhc2VkIG9uIHBvdGVudGlhbGx5IG5ldyB2YWx1ZXMgZm9yIG1pbi9tYXhcbiAgICAgICAgLy8gcG9sYXIsIGF6aW11dGggYW5kIHJhZGl1czpcbiAgICAgICAgdGhpcy5zZXRPcmJpdCgpO1xuICAgICAgICB0aGlzLnNldEZpZWxkT2ZWaWV3KE1hdGguZXhwKHRoaXMuZ29hbExvZ0ZvdikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBuZWFyIGFuZCBmYXIgcGxhbmVzIG9mIHRoZSBjYW1lcmEuXG4gICAgICovXG4gICAgdXBkYXRlTmVhckZhcihuZWFyUGxhbmUsIGZhclBsYW5lKSB7XG4gICAgICAgIHRoaXMuY2FtZXJhLmZhciA9IGZhclBsYW5lID09PSAwID8gMiA6IGZhclBsYW5lO1xuICAgICAgICB0aGlzLmNhbWVyYS5uZWFyID0gTWF0aC5tYXgobmVhclBsYW5lLCB0aGlzLmNhbWVyYS5mYXIgLyAxMDAwKTtcbiAgICAgICAgdGhpcy5jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBhc3BlY3QgcmF0aW8gb2YgdGhlIGNhbWVyYVxuICAgICAqL1xuICAgIHVwZGF0ZUFzcGVjdChhc3BlY3QpIHtcbiAgICAgICAgdGhpcy5jYW1lcmEuYXNwZWN0ID0gYXNwZWN0O1xuICAgICAgICB0aGlzLmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgYWJzb2x1dGUgb3JiaXRhbCBnb2FsIG9mIHRoZSBjYW1lcmEuIFRoZSBjaGFuZ2Ugd2lsbCBiZVxuICAgICAqIGFwcGxpZWQgb3ZlciBhIG51bWJlciBvZiBmcmFtZXMgZGVwZW5kaW5nIG9uIGNvbmZpZ3VyZWQgYWNjZWxlcmF0aW9uIGFuZFxuICAgICAqIGRhbXBlbmluZyBfb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBpbnZva2luZyB0aGUgbWV0aG9kIHdpbGwgcmVzdWx0IGluIHRoZSBjYW1lcmEgY2hhbmdpbmdcbiAgICAgKiBwb3NpdGlvbiBhbmQvb3Igcm90YXRpb24sIG90aGVyd2lzZSBmYWxzZS5cbiAgICAgKi9cbiAgICBzZXRPcmJpdChnb2FsVGhldGEgPSB0aGlzLmdvYWxTcGhlcmljYWwudGhldGEsIGdvYWxQaGkgPSB0aGlzLmdvYWxTcGhlcmljYWwucGhpLCBnb2FsUmFkaXVzID0gdGhpcy5nb2FsU3BoZXJpY2FsLnJhZGl1cykge1xuICAgICAgICBjb25zdCB7IG1pbmltdW1BemltdXRoYWxBbmdsZSwgbWF4aW11bUF6aW11dGhhbEFuZ2xlLCBtaW5pbXVtUG9sYXJBbmdsZSwgbWF4aW11bVBvbGFyQW5nbGUsIG1pbmltdW1SYWRpdXMsIG1heGltdW1SYWRpdXMgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgICAgIGNvbnN0IHsgdGhldGEsIHBoaSwgcmFkaXVzIH0gPSB0aGlzLmdvYWxTcGhlcmljYWw7XG4gICAgICAgIGNvbnN0IG5leHRUaGV0YSA9IGNsYW1wKGdvYWxUaGV0YSwgbWluaW11bUF6aW11dGhhbEFuZ2xlLCBtYXhpbXVtQXppbXV0aGFsQW5nbGUpO1xuICAgICAgICBpZiAoIWlzRmluaXRlKG1pbmltdW1BemltdXRoYWxBbmdsZSkgJiZcbiAgICAgICAgICAgICFpc0Zpbml0ZShtYXhpbXVtQXppbXV0aGFsQW5nbGUpKSB7XG4gICAgICAgICAgICB0aGlzLnNwaGVyaWNhbC50aGV0YSA9XG4gICAgICAgICAgICAgICAgdGhpcy53cmFwQW5nbGUodGhpcy5zcGhlcmljYWwudGhldGEgLSBuZXh0VGhldGEpICsgbmV4dFRoZXRhO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5leHRQaGkgPSBjbGFtcChnb2FsUGhpLCBtaW5pbXVtUG9sYXJBbmdsZSwgbWF4aW11bVBvbGFyQW5nbGUpO1xuICAgICAgICBjb25zdCBuZXh0UmFkaXVzID0gY2xhbXAoZ29hbFJhZGl1cywgbWluaW11bVJhZGl1cywgbWF4aW11bVJhZGl1cyk7XG4gICAgICAgIGlmIChuZXh0VGhldGEgPT09IHRoZXRhICYmIG5leHRQaGkgPT09IHBoaSAmJiBuZXh0UmFkaXVzID09PSByYWRpdXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzRmluaXRlKG5leHRUaGV0YSkgfHwgIWlzRmluaXRlKG5leHRQaGkpIHx8ICFpc0Zpbml0ZShuZXh0UmFkaXVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ29hbFNwaGVyaWNhbC50aGV0YSA9IG5leHRUaGV0YTtcbiAgICAgICAgdGhpcy5nb2FsU3BoZXJpY2FsLnBoaSA9IG5leHRQaGk7XG4gICAgICAgIHRoaXMuZ29hbFNwaGVyaWNhbC5yYWRpdXMgPSBuZXh0UmFkaXVzO1xuICAgICAgICB0aGlzLmdvYWxTcGhlcmljYWwubWFrZVNhZmUoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1YnNldCBvZiBzZXRPcmJpdCgpIGFib3ZlLCB3aGljaCBvbmx5IHNldHMgdGhlIGNhbWVyYSdzIHJhZGl1cy5cbiAgICAgKi9cbiAgICBzZXRSYWRpdXMocmFkaXVzKSB7XG4gICAgICAgIHRoaXMuZ29hbFNwaGVyaWNhbC5yYWRpdXMgPSByYWRpdXM7XG4gICAgICAgIHRoaXMuc2V0T3JiaXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZ29hbCBmaWVsZCBvZiB2aWV3IGZvciB0aGUgY2FtZXJhXG4gICAgICovXG4gICAgc2V0RmllbGRPZlZpZXcoZm92KSB7XG4gICAgICAgIGNvbnN0IHsgbWluaW11bUZpZWxkT2ZWaWV3LCBtYXhpbXVtRmllbGRPZlZpZXcgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgICAgIGZvdiA9IGNsYW1wKGZvdiwgbWluaW11bUZpZWxkT2ZWaWV3LCBtYXhpbXVtRmllbGRPZlZpZXcpO1xuICAgICAgICB0aGlzLmdvYWxMb2dGb3YgPSBNYXRoLmxvZyhmb3YpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzbW9vdGhpbmcgZGVjYXkgdGltZS5cbiAgICAgKi9cbiAgICBzZXREYW1wZXJEZWNheVRpbWUoZGVjYXlNaWxsaXNlY29uZHMpIHtcbiAgICAgICAgdGhpcy50aGV0YURhbXBlci5zZXREZWNheVRpbWUoZGVjYXlNaWxsaXNlY29uZHMpO1xuICAgICAgICB0aGlzLnBoaURhbXBlci5zZXREZWNheVRpbWUoZGVjYXlNaWxsaXNlY29uZHMpO1xuICAgICAgICB0aGlzLnJhZGl1c0RhbXBlci5zZXREZWNheVRpbWUoZGVjYXlNaWxsaXNlY29uZHMpO1xuICAgICAgICB0aGlzLmZvdkRhbXBlci5zZXREZWNheVRpbWUoZGVjYXlNaWxsaXNlY29uZHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGp1c3QgdGhlIG9yYml0YWwgcG9zaXRpb24gb2YgdGhlIGNhbWVyYSByZWxhdGl2ZSB0byBpdHMgY3VycmVudCBvcmJpdGFsXG4gICAgICogcG9zaXRpb24uIERvZXMgbm90IGxldCB0aGUgdGhldGEgZ29hbCBnZXQgbW9yZSB0aGFuIHBpIGFoZWFkIG9mIHRoZSBjdXJyZW50XG4gICAgICogdGhldGEsIHdoaWNoIGVuc3VyZXMgaW50ZXJwb2xhdGlvbiBjb250aW51ZXMgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgZGVsdGEuXG4gICAgICogVGhlIGRlbHRhWm9vbSBwYXJhbWV0ZXIgYWRqdXN0cyBib3RoIHRoZSBmaWVsZCBvZiB2aWV3IGFuZCB0aGUgb3JiaXQgcmFkaXVzXG4gICAgICogc3VjaCB0aGF0IHRoZXkgcHJvZ3Jlc3MgYWNyb3NzIHRoZWlyIGFsbG93ZWQgcmFuZ2VzIGluIHN5bmMuXG4gICAgICovXG4gICAgYWRqdXN0T3JiaXQoZGVsdGFUaGV0YSwgZGVsdGFQaGksIGRlbHRhWm9vbSkge1xuICAgICAgICBjb25zdCB7IHRoZXRhLCBwaGksIHJhZGl1cyB9ID0gdGhpcy5nb2FsU3BoZXJpY2FsO1xuICAgICAgICBjb25zdCB7IG1pbmltdW1SYWRpdXMsIG1heGltdW1SYWRpdXMsIG1pbmltdW1GaWVsZE9mVmlldywgbWF4aW11bUZpZWxkT2ZWaWV3IH0gPSB0aGlzLl9vcHRpb25zO1xuICAgICAgICBjb25zdCBkVGhldGEgPSB0aGlzLnNwaGVyaWNhbC50aGV0YSAtIHRoZXRhO1xuICAgICAgICBjb25zdCBkVGhldGFMaW1pdCA9IE1hdGguUEkgLSAwLjAwMTtcbiAgICAgICAgY29uc3QgZ29hbFRoZXRhID0gdGhldGEgLSBjbGFtcChkZWx0YVRoZXRhLCAtZFRoZXRhTGltaXQgLSBkVGhldGEsIGRUaGV0YUxpbWl0IC0gZFRoZXRhKTtcbiAgICAgICAgY29uc3QgZ29hbFBoaSA9IHBoaSAtIGRlbHRhUGhpO1xuICAgICAgICBjb25zdCBkZWx0YVJhdGlvID0gZGVsdGFab29tID09PSAwID9cbiAgICAgICAgICAgIDAgOlxuICAgICAgICAgICAgKChkZWx0YVpvb20gPiAwID8gbWF4aW11bVJhZGl1cyA6IG1pbmltdW1SYWRpdXMpIC0gcmFkaXVzKSAvXG4gICAgICAgICAgICAgICAgKE1hdGgubG9nKGRlbHRhWm9vbSA+IDAgPyBtYXhpbXVtRmllbGRPZlZpZXcgOiBtaW5pbXVtRmllbGRPZlZpZXcpIC1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nb2FsTG9nRm92KTtcbiAgICAgICAgY29uc3QgZ29hbFJhZGl1cyA9IHJhZGl1cyArXG4gICAgICAgICAgICBkZWx0YVpvb20gKlxuICAgICAgICAgICAgICAgIChpc0Zpbml0ZShkZWx0YVJhdGlvKSA/IGRlbHRhUmF0aW8gOlxuICAgICAgICAgICAgICAgICAgICAobWF4aW11bVJhZGl1cyAtIG1pbmltdW1SYWRpdXMpICogMik7XG4gICAgICAgIHRoaXMuc2V0T3JiaXQoZ29hbFRoZXRhLCBnb2FsUGhpLCBnb2FsUmFkaXVzKTtcbiAgICAgICAgaWYgKGRlbHRhWm9vbSAhPT0gMCkge1xuICAgICAgICAgICAgY29uc3QgZ29hbExvZ0ZvdiA9IHRoaXMuZ29hbExvZ0ZvdiArIGRlbHRhWm9vbTtcbiAgICAgICAgICAgIHRoaXMuc2V0RmllbGRPZlZpZXcoTWF0aC5leHAoZ29hbExvZ0ZvdikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1vdmUgdGhlIGNhbWVyYSBpbnN0YW50bHkgaW5zdGVhZCBvZiBhY2NlbGVyYXRpbmcgdG93YXJkIHRoZSBnb2FsXG4gICAgICogcGFyYW1ldGVycy5cbiAgICAgKi9cbiAgICBqdW1wVG9Hb2FsKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZSgwLCBTRVRUTElOR19USU1FKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIGNvbnRyb2xzLiBJbiBtb3N0IGNhc2VzLCB0aGlzIHdpbGwgcmVzdWx0IGluIHRoZSBjYW1lcmFcbiAgICAgKiBpbnRlcnBvbGF0aW5nIGl0cyBwb3NpdGlvbiBhbmQgcm90YXRpb24gdW50aWwgaXQgbGluZXMgdXAgd2l0aCB0aGVcbiAgICAgKiBkZXNpZ25hdGVkIGdvYWwgb3JiaXRhbCBwb3NpdGlvbi4gUmV0dXJucyBmYWxzZSBpZiB0aGUgY2FtZXJhIGRpZCBub3QgbW92ZS5cbiAgICAgKlxuICAgICAqIFRpbWUgYW5kIGRlbHRhIGFyZSBtZWFzdXJlZCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICovXG4gICAgdXBkYXRlKF90aW1lLCBkZWx0YSkge1xuICAgICAgICBpZiAodGhpcy5pc1N0YXRpb25hcnkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbWF4aW11bVBvbGFyQW5nbGUsIG1heGltdW1SYWRpdXMgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgICAgIGNvbnN0IGRUaGV0YSA9IHRoaXMuc3BoZXJpY2FsLnRoZXRhIC0gdGhpcy5nb2FsU3BoZXJpY2FsLnRoZXRhO1xuICAgICAgICBpZiAoTWF0aC5hYnMoZFRoZXRhKSA+IE1hdGguUEkgJiZcbiAgICAgICAgICAgICFpc0Zpbml0ZSh0aGlzLl9vcHRpb25zLm1pbmltdW1BemltdXRoYWxBbmdsZSkgJiZcbiAgICAgICAgICAgICFpc0Zpbml0ZSh0aGlzLl9vcHRpb25zLm1heGltdW1BemltdXRoYWxBbmdsZSkpIHtcbiAgICAgICAgICAgIHRoaXMuc3BoZXJpY2FsLnRoZXRhIC09IE1hdGguc2lnbihkVGhldGEpICogMiAqIE1hdGguUEk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zcGhlcmljYWwudGhldGEgPSB0aGlzLnRoZXRhRGFtcGVyLnVwZGF0ZSh0aGlzLnNwaGVyaWNhbC50aGV0YSwgdGhpcy5nb2FsU3BoZXJpY2FsLnRoZXRhLCBkZWx0YSwgTWF0aC5QSSk7XG4gICAgICAgIHRoaXMuc3BoZXJpY2FsLnBoaSA9IHRoaXMucGhpRGFtcGVyLnVwZGF0ZSh0aGlzLnNwaGVyaWNhbC5waGksIHRoaXMuZ29hbFNwaGVyaWNhbC5waGksIGRlbHRhLCBtYXhpbXVtUG9sYXJBbmdsZSk7XG4gICAgICAgIHRoaXMuc3BoZXJpY2FsLnJhZGl1cyA9IHRoaXMucmFkaXVzRGFtcGVyLnVwZGF0ZSh0aGlzLnNwaGVyaWNhbC5yYWRpdXMsIHRoaXMuZ29hbFNwaGVyaWNhbC5yYWRpdXMsIGRlbHRhLCBtYXhpbXVtUmFkaXVzKTtcbiAgICAgICAgdGhpcy5sb2dGb3YgPSB0aGlzLmZvdkRhbXBlci51cGRhdGUodGhpcy5sb2dGb3YsIHRoaXMuZ29hbExvZ0ZvdiwgZGVsdGEsIDEpO1xuICAgICAgICB0aGlzLm1vdmVDYW1lcmEoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHVwZGF0ZVRvdWNoQWN0aW9uU3R5bGUoKSB7XG4gICAgICAgIGNvbnN0IHsgc3R5bGUgfSA9IHRoaXMuZWxlbWVudDtcbiAgICAgICAgaWYgKHRoaXMuX2ludGVyYWN0aW9uRW5hYmxlZCkge1xuICAgICAgICAgICAgY29uc3QgeyB0b3VjaEFjdGlvbiB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICAgICAgICAgIGlmICh0aGlzLl9kaXNhYmxlWm9vbSAmJiB0b3VjaEFjdGlvbiAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUudG91Y2hBY3Rpb24gPSAnbWFuaXB1bGF0aW9uJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0eWxlLnRvdWNoQWN0aW9uID0gdG91Y2hBY3Rpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHlsZS50b3VjaEFjdGlvbiA9ICcnO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzU3RhdGlvbmFyeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ29hbFNwaGVyaWNhbC50aGV0YSA9PT0gdGhpcy5zcGhlcmljYWwudGhldGEgJiZcbiAgICAgICAgICAgIHRoaXMuZ29hbFNwaGVyaWNhbC5waGkgPT09IHRoaXMuc3BoZXJpY2FsLnBoaSAmJlxuICAgICAgICAgICAgdGhpcy5nb2FsU3BoZXJpY2FsLnJhZGl1cyA9PT0gdGhpcy5zcGhlcmljYWwucmFkaXVzICYmXG4gICAgICAgICAgICB0aGlzLmdvYWxMb2dGb3YgPT09IHRoaXMubG9nRm92O1xuICAgIH1cbiAgICBtb3ZlQ2FtZXJhKCkge1xuICAgICAgICAvLyBEZXJpdmUgdGhlIG5ldyBjYW1lcmEgcG9zaXRpb24gZnJvbSB0aGUgdXBkYXRlZCBzcGhlcmljYWw6XG4gICAgICAgIHRoaXMuc3BoZXJpY2FsLm1ha2VTYWZlKCk7XG4gICAgICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLnNldEZyb21TcGhlcmljYWwodGhpcy5zcGhlcmljYWwpO1xuICAgICAgICB0aGlzLmNhbWVyYS5zZXRSb3RhdGlvbkZyb21FdWxlcihuZXcgRXVsZXIodGhpcy5zcGhlcmljYWwucGhpIC0gTWF0aC5QSSAvIDIsIHRoaXMuc3BoZXJpY2FsLnRoZXRhLCAwLCAnWVhaJykpO1xuICAgICAgICBpZiAodGhpcy5jYW1lcmEuZm92ICE9PSBNYXRoLmV4cCh0aGlzLmxvZ0ZvdikpIHtcbiAgICAgICAgICAgIHRoaXMuY2FtZXJhLmZvdiA9IE1hdGguZXhwKHRoaXMubG9nRm92KTtcbiAgICAgICAgICAgIHRoaXMuY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1c2VyQWRqdXN0T3JiaXQoZGVsdGFUaGV0YSwgZGVsdGFQaGksIGRlbHRhWm9vbSkge1xuICAgICAgICB0aGlzLmFkanVzdE9yYml0KGRlbHRhVGhldGEgKiB0aGlzLm9yYml0U2Vuc2l0aXZpdHkgKiB0aGlzLmlucHV0U2Vuc2l0aXZpdHksIGRlbHRhUGhpICogdGhpcy5vcmJpdFNlbnNpdGl2aXR5ICogdGhpcy5pbnB1dFNlbnNpdGl2aXR5LCBkZWx0YVpvb20gKiB0aGlzLmlucHV0U2Vuc2l0aXZpdHkpO1xuICAgIH1cbiAgICAvLyBXcmFwcyB0byBiZXR3ZWVuIC1waSBhbmQgcGlcbiAgICB3cmFwQW5nbGUocmFkaWFucykge1xuICAgICAgICBjb25zdCBub3JtYWxpemVkID0gKHJhZGlhbnMgKyBNYXRoLlBJKSAvICgyICogTWF0aC5QSSk7XG4gICAgICAgIGNvbnN0IHdyYXBwZWQgPSBub3JtYWxpemVkIC0gTWF0aC5mbG9vcihub3JtYWxpemVkKTtcbiAgICAgICAgcmV0dXJuIHdyYXBwZWQgKiAyICogTWF0aC5QSSAtIE1hdGguUEk7XG4gICAgfVxuICAgIHBpeGVsTGVuZ3RoVG9TcGhlcmljYWxBbmdsZShwaXhlbExlbmd0aCkge1xuICAgICAgICByZXR1cm4gMiAqIE1hdGguUEkgKiBwaXhlbExlbmd0aCAvIHRoaXMuc2NlbmUuaGVpZ2h0O1xuICAgIH1cbiAgICB0d29Ub3VjaERpc3RhbmNlKHRvdWNoT25lLCB0b3VjaFR3bykge1xuICAgICAgICBjb25zdCB7IGNsaWVudFg6IHhPbmUsIGNsaWVudFk6IHlPbmUgfSA9IHRvdWNoT25lO1xuICAgICAgICBjb25zdCB7IGNsaWVudFg6IHhUd28sIGNsaWVudFk6IHlUd28gfSA9IHRvdWNoVHdvO1xuICAgICAgICBjb25zdCB4RGVsdGEgPSB4VHdvIC0geE9uZTtcbiAgICAgICAgY29uc3QgeURlbHRhID0geVR3byAtIHlPbmU7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoeERlbHRhICogeERlbHRhICsgeURlbHRhICogeURlbHRhKTtcbiAgICB9XG4gICAgaGFuZGxlU2luZ2xlUG9pbnRlck1vdmUoZHgsIGR5KSB7XG4gICAgICAgIGNvbnN0IGRlbHRhVGhldGEgPSB0aGlzLnBpeGVsTGVuZ3RoVG9TcGhlcmljYWxBbmdsZShkeCk7XG4gICAgICAgIGNvbnN0IGRlbHRhUGhpID0gdGhpcy5waXhlbExlbmd0aFRvU3BoZXJpY2FsQW5nbGUoZHkpO1xuICAgICAgICBpZiAodGhpcy5pc1VzZXJQb2ludGluZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuaXNVc2VyUG9pbnRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHsgdHlwZTogJ3BvaW50ZXItY2hhbmdlLXN0YXJ0JyB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVzZXJBZGp1c3RPcmJpdChkZWx0YVRoZXRhLCBkZWx0YVBoaSwgMCk7XG4gICAgfVxuICAgIGluaXRpYWxpemVQYW4oKSB7XG4gICAgICAgIGNvbnN0IHsgdGhldGEsIHBoaSB9ID0gdGhpcy5zcGhlcmljYWw7XG4gICAgICAgIGNvbnN0IHBzaSA9IHRoZXRhIC0gdGhpcy5zY2VuZS55YXc7XG4gICAgICAgIHRoaXMucGFuUGVyUGl4ZWwgPSBQQU5fU0VOU0lUSVZJVFkgLyB0aGlzLnNjZW5lLmhlaWdodDtcbiAgICAgICAgdGhpcy5wYW5Qcm9qZWN0aW9uLnNldCgtTWF0aC5jb3MocHNpKSwgLU1hdGguY29zKHBoaSkgKiBNYXRoLnNpbihwc2kpLCAwLCAwLCBNYXRoLnNpbihwaGkpLCAwLCBNYXRoLnNpbihwc2kpLCAtTWF0aC5jb3MocGhpKSAqIE1hdGguY29zKHBzaSksIDApO1xuICAgIH1cbiAgICBtb3ZlUGFuKGR4LCBkeSkge1xuICAgICAgICBjb25zdCB7IHNjZW5lIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBkeHkgPSB2ZWN0b3IzLnNldChkeCwgZHksIDApLm11bHRpcGx5U2NhbGFyKHRoaXMuaW5wdXRTZW5zaXRpdml0eSk7XG4gICAgICAgIGNvbnN0IG1ldGVyc1BlclBpeGVsID0gdGhpcy5zcGhlcmljYWwucmFkaXVzICogTWF0aC5leHAodGhpcy5sb2dGb3YpICogdGhpcy5wYW5QZXJQaXhlbDtcbiAgICAgICAgZHh5Lm11bHRpcGx5U2NhbGFyKG1ldGVyc1BlclBpeGVsKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gc2NlbmUuZ2V0VGFyZ2V0KCk7XG4gICAgICAgIHRhcmdldC5hZGQoZHh5LmFwcGx5TWF0cml4Myh0aGlzLnBhblByb2plY3Rpb24pKTtcbiAgICAgICAgc2NlbmUuYm91bmRpbmdTcGhlcmUuY2xhbXBQb2ludCh0YXJnZXQsIHRhcmdldCk7XG4gICAgICAgIHNjZW5lLnNldFRhcmdldCh0YXJnZXQueCwgdGFyZ2V0LnksIHRhcmdldC56KTtcbiAgICB9XG4gICAgcmVjZW50ZXIocG9pbnRlcikge1xuICAgICAgICBpZiAocGVyZm9ybWFuY2Uubm93KCkgPiB0aGlzLnN0YXJ0VGltZSArIFRBUF9NUyB8fFxuICAgICAgICAgICAgTWF0aC5hYnMocG9pbnRlci5jbGllbnRYIC0gdGhpcy5zdGFydFBvaW50ZXJQb3NpdGlvbi5jbGllbnRYKSA+XG4gICAgICAgICAgICAgICAgVEFQX0RJU1RBTkNFIHx8XG4gICAgICAgICAgICBNYXRoLmFicyhwb2ludGVyLmNsaWVudFkgLSB0aGlzLnN0YXJ0UG9pbnRlclBvc2l0aW9uLmNsaWVudFkpID5cbiAgICAgICAgICAgICAgICBUQVBfRElTVEFOQ0UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHNjZW5lIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBoaXQgPSBzY2VuZS5wb3NpdGlvbkFuZE5vcm1hbEZyb21Qb2ludChzY2VuZS5nZXROREMocG9pbnRlci5jbGllbnRYLCBwb2ludGVyLmNsaWVudFkpKTtcbiAgICAgICAgaWYgKGhpdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCB7IGNhbWVyYVRhcmdldCB9ID0gc2NlbmUuZWxlbWVudDtcbiAgICAgICAgICAgIHNjZW5lLmVsZW1lbnQuY2FtZXJhVGFyZ2V0ID0gJyc7XG4gICAgICAgICAgICBzY2VuZS5lbGVtZW50LmNhbWVyYVRhcmdldCA9IGNhbWVyYVRhcmdldDtcbiAgICAgICAgICAgIC8vIFpvb20gYWxsIHRoZSB3YXkgb3V0LlxuICAgICAgICAgICAgdGhpcy51c2VyQWRqdXN0T3JiaXQoMCwgMCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzY2VuZS50YXJnZXQud29ybGRUb0xvY2FsKGhpdC5wb3NpdGlvbik7XG4gICAgICAgICAgICBzY2VuZS5zZXRUYXJnZXQoaGl0LnBvc2l0aW9uLngsIGhpdC5wb3NpdGlvbi55LCBoaXQucG9zaXRpb24ueik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzZXRSYWRpdXMoKSB7XG4gICAgICAgIGNvbnN0IHsgc2NlbmUgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGhpdCA9IHNjZW5lLnBvc2l0aW9uQW5kTm9ybWFsRnJvbVBvaW50KHZlY3RvcjIuc2V0KDAsIDApKTtcbiAgICAgICAgaWYgKGhpdCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2NlbmUudGFyZ2V0LndvcmxkVG9Mb2NhbChoaXQucG9zaXRpb24pO1xuICAgICAgICBjb25zdCBnb2FsVGFyZ2V0ID0gc2NlbmUuZ2V0VGFyZ2V0KCk7XG4gICAgICAgIGNvbnN0IHsgdGhldGEsIHBoaSB9ID0gdGhpcy5zcGhlcmljYWw7XG4gICAgICAgIC8vIFNldCB0YXJnZXQgdG8gc3VyZmFjZSBoaXQgcG9pbnQsIGV4Y2VwdCB0aGUgdGFyZ2V0IGlzIHN0aWxsIHNldHRsaW5nLFxuICAgICAgICAvLyBzbyBvZmZzZXQgdGhlIGdvYWwgYWNjb3JkaW5nbHkgc28gdGhlIHRyYW5zaXRpb24gaXMgc21vb3RoIGV2ZW4gdGhvdWdoXG4gICAgICAgIC8vIHRoaXMgd2lsbCBkcmlmdCB0aGUgdGFyZ2V0IHNsaWdodGx5IGF3YXkgZnJvbSB0aGUgaGl0IHBvaW50LlxuICAgICAgICBjb25zdCBwc2kgPSB0aGV0YSAtIHNjZW5lLnlhdztcbiAgICAgICAgY29uc3QgbiA9IHZlY3RvcjMuc2V0KE1hdGguc2luKHBoaSkgKiBNYXRoLnNpbihwc2kpLCBNYXRoLmNvcyhwaGkpLCBNYXRoLnNpbihwaGkpICogTWF0aC5jb3MocHNpKSk7XG4gICAgICAgIGNvbnN0IGRyID0gbi5kb3QoaGl0LnBvc2l0aW9uLnN1Yihnb2FsVGFyZ2V0KSk7XG4gICAgICAgIGdvYWxUYXJnZXQuYWRkKG4ubXVsdGlwbHlTY2FsYXIoZHIpKTtcbiAgICAgICAgc2NlbmUuc2V0VGFyZ2V0KGdvYWxUYXJnZXQueCwgZ29hbFRhcmdldC55LCBnb2FsVGFyZ2V0LnopO1xuICAgICAgICAvLyBDaGFuZ2UgdGhlIGNhbWVyYSByYWRpdXMgdG8gbWF0Y2ggdGhlIGNoYW5nZSBpbiB0YXJnZXQgc28gdGhhdCB0aGVcbiAgICAgICAgLy8gY2FtZXJhIGl0c2VsZiBkb2VzIG5vdCBtb3ZlLCB1bmxlc3MgaXQgaGl0cyBhIHJhZGl1cyBib3VuZC5cbiAgICAgICAgdGhpcy5zZXRPcmJpdCh1bmRlZmluZWQsIHVuZGVmaW5lZCwgdGhpcy5nb2FsU3BoZXJpY2FsLnJhZGl1cyAtIGRyKTtcbiAgICB9XG4gICAgb25Ub3VjaENoYW5nZShldmVudCkge1xuICAgICAgICBpZiAodGhpcy5wb2ludGVycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMudG91Y2hNb2RlID0gdGhpcy50b3VjaE1vZGVSb3RhdGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZGlzYWJsZVpvb20pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvdWNoTW9kZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuZGlzYWJsZVNjcm9sbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50b3VjaE1vZGUgPSAodGhpcy50b3VjaERlY2lkZWQgJiYgdGhpcy50b3VjaE1vZGUgPT09IG51bGwpID9cbiAgICAgICAgICAgICAgICBudWxsIDpcbiAgICAgICAgICAgICAgICB0aGlzLnRvdWNoTW9kZVpvb207XG4gICAgICAgICAgICB0aGlzLnRvdWNoRGVjaWRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5kaXNhYmxlU2Nyb2xsLCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgdGhpcy5sYXN0U2VwYXJhdGlvbiA9XG4gICAgICAgICAgICAgICAgdGhpcy50d29Ub3VjaERpc3RhbmNlKHRoaXMucG9pbnRlcnNbMF0sIHRoaXMucG9pbnRlcnNbMV0pO1xuICAgICAgICAgICAgaWYgKHRoaXMuZW5hYmxlUGFuICYmIHRoaXMudG91Y2hNb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRpYWxpemVQYW4oKTtcbiAgICAgICAgICAgICAgICBpZiAoIWV2ZW50LmFsdEtleSkgeyAvLyB1c2VyIGludGVyYWN0aW9uLCBub3QgcHJvbXB0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUuZWxlbWVudFskcGFuRWxlbWVudF0uc3R5bGUub3BhY2l0eSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG9uTW91c2VEb3duKGV2ZW50KSB7XG4gICAgICAgIHRoaXMucGFuUGVyUGl4ZWwgPSAwO1xuICAgICAgICBpZiAodGhpcy5lbmFibGVQYW4gJiZcbiAgICAgICAgICAgIChldmVudC5idXR0b24gPT09IDIgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5IHx8XG4gICAgICAgICAgICAgICAgZXZlbnQuc2hpZnRLZXkpKSB7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemVQYW4oKTtcbiAgICAgICAgICAgIHRoaXMuc2NlbmUuZWxlbWVudFskcGFuRWxlbWVudF0uc3R5bGUub3BhY2l0eSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmN1cnNvciA9ICdncmFiYmluZyc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgdGhlIG9yYml0IGFuZCBab29tIGtleSBwcmVzc2VzXG4gICAgICogVXNlcyBjb25zdGFudHMgZm9yIHRoZSBpbmNyZW1lbnQuXG4gICAgICogQHBhcmFtIGV2ZW50IFRoZSBrZXlib2FyZCBldmVudCBmb3IgdGhlIC5rZXkgdmFsdWVcbiAgICAgKiBAcmV0dXJucyBib29sZWFuIHRvIGluZGljYXRlIGlmIHRoZSBrZXkgZXZlbnQgaGFzIGJlZW4gaGFuZGxlZFxuICAgICAqL1xuICAgIG9yYml0Wm9vbUtleUNvZGVIYW5kbGVyKGV2ZW50KSB7XG4gICAgICAgIGxldCByZWxldmFudEtleSA9IHRydWU7XG4gICAgICAgIHN3aXRjaCAoZXZlbnQua2V5KSB7XG4gICAgICAgICAgICBjYXNlICdQYWdlVXAnOlxuICAgICAgICAgICAgICAgIHRoaXMudXNlckFkanVzdE9yYml0KDAsIDAsIFpPT01fU0VOU0lUSVZJVFkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnUGFnZURvd24nOlxuICAgICAgICAgICAgICAgIHRoaXMudXNlckFkanVzdE9yYml0KDAsIDAsIC0xICogWk9PTV9TRU5TSVRJVklUWSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdBcnJvd1VwJzpcbiAgICAgICAgICAgICAgICB0aGlzLnVzZXJBZGp1c3RPcmJpdCgwLCAtS0VZQk9BUkRfT1JCSVRfSU5DUkVNRU5ULCAwKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0Fycm93RG93bic6XG4gICAgICAgICAgICAgICAgdGhpcy51c2VyQWRqdXN0T3JiaXQoMCwgS0VZQk9BUkRfT1JCSVRfSU5DUkVNRU5ULCAwKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0Fycm93TGVmdCc6XG4gICAgICAgICAgICAgICAgdGhpcy51c2VyQWRqdXN0T3JiaXQoLUtFWUJPQVJEX09SQklUX0lOQ1JFTUVOVCwgMCwgMCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdBcnJvd1JpZ2h0JzpcbiAgICAgICAgICAgICAgICB0aGlzLnVzZXJBZGp1c3RPcmJpdChLRVlCT0FSRF9PUkJJVF9JTkNSRU1FTlQsIDAsIDApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZWxldmFudEtleSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWxldmFudEtleTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB0aGUgUGFuIGtleSBwcmVzc2VzXG4gICAgICogVXNlcyBjb25zdGFudHMgZm9yIHRoZSBpbmNyZW1lbnQuXG4gICAgICogQHBhcmFtIGV2ZW50IFRoZSBrZXlib2FyZCBldmVudCBmb3IgdGhlIC5rZXkgdmFsdWVcbiAgICAgKiBAcmV0dXJucyBib29sZWFuIHRvIGluZGljYXRlIGlmIHRoZSBrZXkgZXZlbnQgaGFzIGJlZW4gaGFuZGxlZFxuICAgICAqL1xuICAgIHBhbktleUNvZGVIYW5kbGVyKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZVBhbigpO1xuICAgICAgICBsZXQgcmVsZXZhbnRLZXkgPSB0cnVlO1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LmtleSkge1xuICAgICAgICAgICAgY2FzZSAnQXJyb3dVcCc6XG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlUGFuKDAsIC0xICogUEFOX0tFWV9JTkNSRU1FTlQpOyAvLyBUaGlzIGlzIHRoZSBuZWdhdGl2ZSBvbmUgc28gdGhhdCB0aGVcbiAgICAgICAgICAgICAgICAvLyBtb2RlbCBhcHBlYXJzIHRvIG1vdmUgYXMgdGhlIGFycm93XG4gICAgICAgICAgICAgICAgLy8gZGlyZWN0aW9uIHJhdGhlciB0aGFuIHRoZSB2aWV3IG1vdmluZ1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnQXJyb3dEb3duJzpcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVQYW4oMCwgUEFOX0tFWV9JTkNSRU1FTlQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnQXJyb3dMZWZ0JzpcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVQYW4oLTEgKiBQQU5fS0VZX0lOQ1JFTUVOVCwgMCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdBcnJvd1JpZ2h0JzpcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVQYW4oUEFOX0tFWV9JTkNSRU1FTlQsIDApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZWxldmFudEtleSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWxldmFudEtleTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TbW9vdGhDb250cm9scy5qcy5tYXAiLCIvKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAnTGljZW5zZScpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICdBUyBJUycgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBCYWNrU2lkZSwgQm94R2VvbWV0cnksIEN1YmVDYW1lcmEsIEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nLCBFdmVudERpc3BhdGNoZXIsIEhhbGZGbG9hdFR5cGUsIExpbmVhckVuY29kaW5nLCBNZXNoLCBOb0JsZW5kaW5nLCBOb1RvbmVNYXBwaW5nLCBSR0JBRm9ybWF0LCBTY2VuZSwgU2hhZGVyTWF0ZXJpYWwsIHNSR0JFbmNvZGluZywgVGV4dHVyZUxvYWRlciwgVmVjdG9yMywgV2ViR0xDdWJlUmVuZGVyVGFyZ2V0IH0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgUkdCRUxvYWRlciB9IGZyb20gJ3RocmVlL2V4YW1wbGVzL2pzbS9sb2FkZXJzL1JHQkVMb2FkZXIuanMnO1xuaW1wb3J0IHsgZGVzZXJpYWxpemVVcmwsIHRpbWVQYXNzZXMgfSBmcm9tICcuLi91dGlsaXRpZXMuanMnO1xuaW1wb3J0IEVudmlyb25tZW50U2NlbmUgZnJvbSAnLi9FbnZpcm9ubWVudFNjZW5lLmpzJztcbmltcG9ydCBFbnZpcm9ubWVudFNjZW5lQWx0IGZyb20gJy4vRW52aXJvbm1lbnRTY2VuZUFsdC5qcyc7XG5jb25zdCBHRU5FUkFURURfU0lHTUEgPSAwLjA0O1xuLy8gVGhlIG1heGltdW0gbGVuZ3RoIG9mIHRoZSBibHVyIGZvciBsb29wLiBTbWFsbGVyIHNpZ21hcyB3aWxsIHVzZSBmZXdlclxuLy8gc2FtcGxlcyBhbmQgZXhpdCBlYXJseSwgYnV0IG5vdCByZWNvbXBpbGUgdGhlIHNoYWRlci5cbmNvbnN0IE1BWF9TQU1QTEVTID0gMjA7XG5jb25zdCBIRFJfRklMRV9SRSA9IC9cXC5oZHIoXFwuanMpPyQvO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGV4dHVyZVV0aWxzIGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0aHJlZVJlbmRlcmVyKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudGhyZWVSZW5kZXJlciA9IHRocmVlUmVuZGVyZXI7XG4gICAgICAgIHRoaXMubG90dGllTG9hZGVyVXJsID0gJyc7XG4gICAgICAgIHRoaXMud2l0aENyZWRlbnRpYWxzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2xkckxvYWRlciA9IG51bGw7XG4gICAgICAgIHRoaXMuX2hkckxvYWRlciA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xvdHRpZUxvYWRlciA9IG51bGw7XG4gICAgICAgIHRoaXMuZ2VuZXJhdGVkRW52aXJvbm1lbnRNYXAgPSBudWxsO1xuICAgICAgICB0aGlzLmdlbmVyYXRlZEVudmlyb25tZW50TWFwQWx0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5za3lib3hDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5ibHVyTWF0ZXJpYWwgPSBudWxsO1xuICAgICAgICB0aGlzLmJsdXJTY2VuZSA9IG51bGw7XG4gICAgfVxuICAgIGdldCBsZHJMb2FkZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLl9sZHJMb2FkZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fbGRyTG9hZGVyID0gbmV3IFRleHR1cmVMb2FkZXIoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sZHJMb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKHRoaXMud2l0aENyZWRlbnRpYWxzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xkckxvYWRlcjtcbiAgICB9XG4gICAgZ2V0IGhkckxvYWRlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2hkckxvYWRlciA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9oZHJMb2FkZXIgPSBuZXcgUkdCRUxvYWRlcigpO1xuICAgICAgICAgICAgdGhpcy5faGRyTG9hZGVyLnNldERhdGFUeXBlKEhhbGZGbG9hdFR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2hkckxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHModGhpcy53aXRoQ3JlZGVudGlhbHMpO1xuICAgICAgICByZXR1cm4gdGhpcy5faGRyTG9hZGVyO1xuICAgIH1cbiAgICBhc3luYyBnZXRMb3R0aWVMb2FkZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLl9sb3R0aWVMb2FkZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgeyBMb3R0aWVMb2FkZXIgfSA9IGF3YWl0IGltcG9ydCh0aGlzLmxvdHRpZUxvYWRlclVybCk7XG4gICAgICAgICAgICB0aGlzLl9sb3R0aWVMb2FkZXIgPSBuZXcgTG90dGllTG9hZGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbG90dGllTG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyh0aGlzLndpdGhDcmVkZW50aWFscyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb3R0aWVMb2FkZXI7XG4gICAgfVxuICAgIGFzeW5jIGxvYWRJbWFnZSh1cmwpIHtcbiAgICAgICAgY29uc3QgdGV4dHVyZSA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHRoaXMubGRyTG9hZGVyLmxvYWQodXJsLCByZXNvbHZlLCAoKSA9PiB7IH0sIHJlamVjdCkpO1xuICAgICAgICB0ZXh0dXJlLm5hbWUgPSB1cmw7XG4gICAgICAgIHRleHR1cmUuZmxpcFkgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgfVxuICAgIGFzeW5jIGxvYWRMb3R0aWUodXJsLCBxdWFsaXR5KSB7XG4gICAgICAgIGNvbnN0IGxvYWRlciA9IGF3YWl0IHRoaXMuZ2V0TG90dGllTG9hZGVyKCk7XG4gICAgICAgIGxvYWRlci5zZXRRdWFsaXR5KHF1YWxpdHkpO1xuICAgICAgICBjb25zdCB0ZXh0dXJlID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gbG9hZGVyLmxvYWQodXJsLCByZXNvbHZlLCAoKSA9PiB7IH0sIHJlamVjdCkpO1xuICAgICAgICB0ZXh0dXJlLm5hbWUgPSB1cmw7XG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgIH1cbiAgICBhc3luYyBsb2FkRXF1aXJlY3QodXJsLCBwcm9ncmVzc0NhbGxiYWNrID0gKCkgPT4geyB9KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBpc0hEUiA9IEhEUl9GSUxFX1JFLnRlc3QodXJsKTtcbiAgICAgICAgICAgIGNvbnN0IGxvYWRlciA9IGlzSERSID8gdGhpcy5oZHJMb2FkZXIgOiB0aGlzLmxkckxvYWRlcjtcbiAgICAgICAgICAgIGNvbnN0IHRleHR1cmUgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBsb2FkZXIubG9hZCh1cmwsIHJlc29sdmUsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHByb2dyZXNzQ2FsbGJhY2soZXZlbnQubG9hZGVkIC8gZXZlbnQudG90YWwgKiAwLjkpO1xuICAgICAgICAgICAgfSwgcmVqZWN0KSk7XG4gICAgICAgICAgICBwcm9ncmVzc0NhbGxiYWNrKDEuMCk7XG4gICAgICAgICAgICB0ZXh0dXJlLm5hbWUgPSB1cmw7XG4gICAgICAgICAgICB0ZXh0dXJlLm1hcHBpbmcgPSBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZztcbiAgICAgICAgICAgIGlmICghaXNIRFIpIHtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlLmVuY29kaW5nID0gc1JHQkVuY29kaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBpZiAocHJvZ3Jlc3NDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHByb2dyZXNzQ2FsbGJhY2soMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHsgc2t5Ym94LCBlbnZpcm9ubWVudE1hcCB9IG9iamVjdCB3aXRoIHRoZSB0YXJnZXRzL3RleHR1cmVzXG4gICAgICogYWNjb3JkaW5nbHkuIGBza3lib3hgIGlzIGEgV2ViR0xSZW5kZXJDdWJlVGFyZ2V0LCBhbmQgYGVudmlyb25tZW50TWFwYFxuICAgICAqIGlzIGEgVGV4dHVyZSBmcm9tIGEgV2ViR0xSZW5kZXJDdWJlVGFyZ2V0LlxuICAgICAqL1xuICAgIGFzeW5jIGdlbmVyYXRlRW52aXJvbm1lbnRNYXBBbmRTa3lib3goc2t5Ym94VXJsID0gbnVsbCwgZW52aXJvbm1lbnRNYXBVcmwgPSBudWxsLCBwcm9ncmVzc0NhbGxiYWNrID0gKCkgPT4geyB9KSB7XG4gICAgICAgIGNvbnN0IHVzZUFsdEVudmlyb25tZW50ID0gZW52aXJvbm1lbnRNYXBVcmwgIT09ICdsZWdhY3knO1xuICAgICAgICBpZiAoZW52aXJvbm1lbnRNYXBVcmwgPT09ICdsZWdhY3knIHx8IGVudmlyb25tZW50TWFwVXJsID09PSAnbmV1dHJhbCcpIHtcbiAgICAgICAgICAgIGVudmlyb25tZW50TWFwVXJsID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbnZpcm9ubWVudE1hcFVybCA9IGRlc2VyaWFsaXplVXJsKGVudmlyb25tZW50TWFwVXJsKTtcbiAgICAgICAgbGV0IHNreWJveExvYWRzID0gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgICBsZXQgZW52aXJvbm1lbnRNYXBMb2FkcztcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHNreWJveCBVUkwsIGF0dGVtcHQgdG8gbG9hZCBpdCBhcyBhIGN1YmVtYXBcbiAgICAgICAgaWYgKCEhc2t5Ym94VXJsKSB7XG4gICAgICAgICAgICBza3lib3hMb2FkcyA9IHRoaXMubG9hZEVxdWlyZWN0RnJvbVVybChza3lib3hVcmwsIHByb2dyZXNzQ2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGlmICghIWVudmlyb25tZW50TWFwVXJsKSB7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIGFuIGF2YWlsYWJsZSBlbnZpcm9ubWVudCBtYXAgVVJMXG4gICAgICAgICAgICBlbnZpcm9ubWVudE1hcExvYWRzID1cbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRFcXVpcmVjdEZyb21VcmwoZW52aXJvbm1lbnRNYXBVcmwsIHByb2dyZXNzQ2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCEhc2t5Ym94VXJsKSB7XG4gICAgICAgICAgICAvLyBGYWxsYmFjayB0byBkZXJpdmluZyB0aGUgZW52aXJvbm1lbnQgbWFwIGZyb20gYW4gYXZhaWxhYmxlIHNreWJveFxuICAgICAgICAgICAgZW52aXJvbm1lbnRNYXBMb2FkcyA9XG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkRXF1aXJlY3RGcm9tVXJsKHNreWJveFVybCwgcHJvZ3Jlc3NDYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBGYWxsYmFjayB0byBnZW5lcmF0aW5nIHRoZSBlbnZpcm9ubWVudCBtYXBcbiAgICAgICAgICAgIGVudmlyb25tZW50TWFwTG9hZHMgPSB1c2VBbHRFbnZpcm9ubWVudCA/XG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkR2VuZXJhdGVkRW52aXJvbm1lbnRNYXBBbHQoKSA6XG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkR2VuZXJhdGVkRW52aXJvbm1lbnRNYXAoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbZW52aXJvbm1lbnRNYXAsIHNreWJveF0gPSBhd2FpdCBQcm9taXNlLmFsbChbZW52aXJvbm1lbnRNYXBMb2Fkcywgc2t5Ym94TG9hZHNdKTtcbiAgICAgICAgaWYgKGVudmlyb25tZW50TWFwID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGxvYWQgZW52aXJvbm1lbnQgbWFwLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGVudmlyb25tZW50TWFwLCBza3lib3ggfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9hZHMgYW4gZXF1aXJlY3QgVGV4dHVyZSBmcm9tIGEgZ2l2ZW4gVVJMLCBmb3IgdXNlIGFzIGEgc2t5Ym94LlxuICAgICAqL1xuICAgIGFzeW5jIGxvYWRFcXVpcmVjdEZyb21VcmwodXJsLCBwcm9ncmVzc0NhbGxiYWNrKSB7XG4gICAgICAgIGlmICghdGhpcy5za3lib3hDYWNoZS5oYXModXJsKSkge1xuICAgICAgICAgICAgY29uc3Qgc2t5Ym94TWFwTG9hZHMgPSB0aGlzLmxvYWRFcXVpcmVjdCh1cmwsIHByb2dyZXNzQ2FsbGJhY2spO1xuICAgICAgICAgICAgdGhpcy5za3lib3hDYWNoZS5zZXQodXJsLCBza3lib3hNYXBMb2Fkcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc2t5Ym94Q2FjaGUuZ2V0KHVybCk7XG4gICAgfVxuICAgIGFzeW5jIEdlbmVyYXRlRW52aXJvbm1lbnRNYXAoc2NlbmUsIG5hbWUpIHtcbiAgICAgICAgYXdhaXQgdGltZVBhc3NlcygpO1xuICAgICAgICBjb25zdCByZW5kZXJlciA9IHRoaXMudGhyZWVSZW5kZXJlcjtcbiAgICAgICAgY29uc3QgY3ViZVRhcmdldCA9IG5ldyBXZWJHTEN1YmVSZW5kZXJUYXJnZXQoMjU2LCB7XG4gICAgICAgICAgICBnZW5lcmF0ZU1pcG1hcHM6IGZhbHNlLFxuICAgICAgICAgICAgdHlwZTogSGFsZkZsb2F0VHlwZSxcbiAgICAgICAgICAgIGZvcm1hdDogUkdCQUZvcm1hdCxcbiAgICAgICAgICAgIGVuY29kaW5nOiBMaW5lYXJFbmNvZGluZyxcbiAgICAgICAgICAgIGRlcHRoQnVmZmVyOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjdWJlQ2FtZXJhID0gbmV3IEN1YmVDYW1lcmEoMC4xLCAxMDAsIGN1YmVUYXJnZXQpO1xuICAgICAgICBjb25zdCBnZW5lcmF0ZWRFbnZpcm9ubWVudE1hcCA9IGN1YmVDYW1lcmEucmVuZGVyVGFyZ2V0LnRleHR1cmU7XG4gICAgICAgIGdlbmVyYXRlZEVudmlyb25tZW50TWFwLm5hbWUgPSBuYW1lO1xuICAgICAgICBjb25zdCBvdXRwdXRFbmNvZGluZyA9IHJlbmRlcmVyLm91dHB1dEVuY29kaW5nO1xuICAgICAgICBjb25zdCB0b25lTWFwcGluZyA9IHJlbmRlcmVyLnRvbmVNYXBwaW5nO1xuICAgICAgICByZW5kZXJlci50b25lTWFwcGluZyA9IE5vVG9uZU1hcHBpbmc7XG4gICAgICAgIHJlbmRlcmVyLm91dHB1dEVuY29kaW5nID0gTGluZWFyRW5jb2Rpbmc7XG4gICAgICAgIGN1YmVDYW1lcmEudXBkYXRlKHJlbmRlcmVyLCBzY2VuZSk7XG4gICAgICAgIHRoaXMuYmx1ckN1YmVtYXAoY3ViZVRhcmdldCwgR0VORVJBVEVEX1NJR01BKTtcbiAgICAgICAgcmVuZGVyZXIudG9uZU1hcHBpbmcgPSB0b25lTWFwcGluZztcbiAgICAgICAgcmVuZGVyZXIub3V0cHV0RW5jb2RpbmcgPSBvdXRwdXRFbmNvZGluZztcbiAgICAgICAgcmV0dXJuIGdlbmVyYXRlZEVudmlyb25tZW50TWFwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2FkcyBhIGR5bmFtaWNhbGx5IGdlbmVyYXRlZCBlbnZpcm9ubWVudCBtYXAuXG4gICAgICovXG4gICAgYXN5bmMgbG9hZEdlbmVyYXRlZEVudmlyb25tZW50TWFwKCkge1xuICAgICAgICBpZiAodGhpcy5nZW5lcmF0ZWRFbnZpcm9ubWVudE1hcCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdlbmVyYXRlZEVudmlyb25tZW50TWFwID1cbiAgICAgICAgICAgICAgICB0aGlzLkdlbmVyYXRlRW52aXJvbm1lbnRNYXAobmV3IEVudmlyb25tZW50U2NlbmUoKSwgJ2xlZ2FjeScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlZEVudmlyb25tZW50TWFwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2FkcyBhIGR5bmFtaWNhbGx5IGdlbmVyYXRlZCBlbnZpcm9ubWVudCBtYXAsIGRlc2lnbmVkIHRvIGJlIG5ldXRyYWwgYW5kXG4gICAgICogY29sb3ItcHJlc2VydmluZy4gU2hvd3MgbGVzcyBjb250cmFzdCBhcm91bmQgdGhlIGRpZmZlcmVudCBzaWRlcyBvZiB0aGVcbiAgICAgKiBvYmplY3QuXG4gICAgICovXG4gICAgYXN5bmMgbG9hZEdlbmVyYXRlZEVudmlyb25tZW50TWFwQWx0KCkge1xuICAgICAgICBpZiAodGhpcy5nZW5lcmF0ZWRFbnZpcm9ubWVudE1hcEFsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdlbmVyYXRlZEVudmlyb25tZW50TWFwQWx0ID1cbiAgICAgICAgICAgICAgICB0aGlzLkdlbmVyYXRlRW52aXJvbm1lbnRNYXAobmV3IEVudmlyb25tZW50U2NlbmVBbHQoKSwgJ25ldXRyYWwnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZWRFbnZpcm9ubWVudE1hcEFsdDtcbiAgICB9XG4gICAgYmx1ckN1YmVtYXAoY3ViZVRhcmdldCwgc2lnbWEpIHtcbiAgICAgICAgaWYgKHRoaXMuYmx1ck1hdGVyaWFsID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuYmx1ck1hdGVyaWFsID0gdGhpcy5nZXRCbHVyU2hhZGVyKE1BWF9TQU1QTEVTKTtcbiAgICAgICAgICAgIGNvbnN0IGJveCA9IG5ldyBCb3hHZW9tZXRyeSgpO1xuICAgICAgICAgICAgY29uc3QgYmx1ck1lc2ggPSBuZXcgTWVzaChib3gsIHRoaXMuYmx1ck1hdGVyaWFsKTtcbiAgICAgICAgICAgIHRoaXMuYmx1clNjZW5lID0gbmV3IFNjZW5lKCk7XG4gICAgICAgICAgICB0aGlzLmJsdXJTY2VuZS5hZGQoYmx1ck1lc2gpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRlbXBUYXJnZXQgPSBjdWJlVGFyZ2V0LmNsb25lKCk7XG4gICAgICAgIHRoaXMuaGFsZmJsdXIoY3ViZVRhcmdldCwgdGVtcFRhcmdldCwgc2lnbWEsICdsYXRpdHVkaW5hbCcpO1xuICAgICAgICB0aGlzLmhhbGZibHVyKHRlbXBUYXJnZXQsIGN1YmVUYXJnZXQsIHNpZ21hLCAnbG9uZ2l0dWRpbmFsJyk7XG4gICAgICAgIC8vIERpc3Bvc2luZyB0aGlzIHRhcmdldCBhZnRlciB3ZSdyZSBkb25lIHdpdGggaXQgc29tZWhvdyBjb3JydXB0cyBTYWZhcmknc1xuICAgICAgICAvLyB3aG9sZSBncmFwaGljcyBkcml2ZXIuIEl0J3MgcmFuZG9tLCBidXQgb2NjdXJzIG1vcmUgZnJlcXVlbnRseSBvblxuICAgICAgICAvLyBsb3dlci1wb3dlcmVkIEdQVXMgKG1hY2Jvb2tzIHdpdGggaW50ZWwgZ3JhcGhpY3MsIG9sZGVyIGlQaG9uZXMpLiBJdCBnb2VzXG4gICAgICAgIC8vIGJleW9uZCBqdXN0IG1lc3NpbmcgdXAgdGhlIFBNUkVNLCBhcyBpdCBhbHNvIG9jY2FzaW9uYWxseSBjYXVzZXNcbiAgICAgICAgLy8gdmlzaWJsZSBjb3JydXB0aW9uIG9uIHRoZSBjYW52YXMgYW5kIGV2ZW4gb24gdGhlIHJlc3Qgb2YgdGhlIHBhZ2UuXG4gICAgICAgIC8qKiB0ZW1wVGFyZ2V0LmRpc3Bvc2UoKTsgKi9cbiAgICB9XG4gICAgaGFsZmJsdXIodGFyZ2V0SW4sIHRhcmdldE91dCwgc2lnbWFSYWRpYW5zLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgLy8gTnVtYmVyIG9mIHN0YW5kYXJkIGRldmlhdGlvbnMgYXQgd2hpY2ggdG8gY3V0IG9mZiB0aGUgZGlzY3JldGVcbiAgICAgICAgLy8gYXBwcm94aW1hdGlvbi5cbiAgICAgICAgY29uc3QgU1RBTkRBUkRfREVWSUFUSU9OUyA9IDM7XG4gICAgICAgIGNvbnN0IHBpeGVscyA9IHRhcmdldEluLndpZHRoO1xuICAgICAgICBjb25zdCByYWRpYW5zUGVyUGl4ZWwgPSBpc0Zpbml0ZShzaWdtYVJhZGlhbnMpID9cbiAgICAgICAgICAgIE1hdGguUEkgLyAoMiAqIHBpeGVscykgOlxuICAgICAgICAgICAgMiAqIE1hdGguUEkgLyAoMiAqIE1BWF9TQU1QTEVTIC0gMSk7XG4gICAgICAgIGNvbnN0IHNpZ21hUGl4ZWxzID0gc2lnbWFSYWRpYW5zIC8gcmFkaWFuc1BlclBpeGVsO1xuICAgICAgICBjb25zdCBzYW1wbGVzID0gaXNGaW5pdGUoc2lnbWFSYWRpYW5zKSA/XG4gICAgICAgICAgICAxICsgTWF0aC5mbG9vcihTVEFOREFSRF9ERVZJQVRJT05TICogc2lnbWFQaXhlbHMpIDpcbiAgICAgICAgICAgIE1BWF9TQU1QTEVTO1xuICAgICAgICBpZiAoc2FtcGxlcyA+IE1BWF9TQU1QTEVTKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYHNpZ21hUmFkaWFucywgJHtzaWdtYVJhZGlhbnN9LCBpcyB0b28gbGFyZ2UgYW5kIHdpbGwgY2xpcCwgYXMgaXQgcmVxdWVzdGVkICR7c2FtcGxlc30gc2FtcGxlcyB3aGVuIHRoZSBtYXhpbXVtIGlzIHNldCB0byAke01BWF9TQU1QTEVTfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdlaWdodHMgPSBbXTtcbiAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTUFYX1NBTVBMRVM7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgeCA9IGkgLyBzaWdtYVBpeGVscztcbiAgICAgICAgICAgIGNvbnN0IHdlaWdodCA9IE1hdGguZXhwKC14ICogeCAvIDIpO1xuICAgICAgICAgICAgd2VpZ2h0cy5wdXNoKHdlaWdodCk7XG4gICAgICAgICAgICBpZiAoaSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgc3VtICs9IHdlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGkgPCBzYW1wbGVzKSB7XG4gICAgICAgICAgICAgICAgc3VtICs9IDIgKiB3ZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3ZWlnaHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB3ZWlnaHRzW2ldID0gd2VpZ2h0c1tpXSAvIHN1bTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBibHVyVW5pZm9ybXMgPSB0aGlzLmJsdXJNYXRlcmlhbC51bmlmb3JtcztcbiAgICAgICAgYmx1clVuaWZvcm1zWydlbnZNYXAnXS52YWx1ZSA9IHRhcmdldEluLnRleHR1cmU7XG4gICAgICAgIGJsdXJVbmlmb3Jtc1snc2FtcGxlcyddLnZhbHVlID0gc2FtcGxlcztcbiAgICAgICAgYmx1clVuaWZvcm1zWyd3ZWlnaHRzJ10udmFsdWUgPSB3ZWlnaHRzO1xuICAgICAgICBibHVyVW5pZm9ybXNbJ2xhdGl0dWRpbmFsJ10udmFsdWUgPSBkaXJlY3Rpb24gPT09ICdsYXRpdHVkaW5hbCc7XG4gICAgICAgIGJsdXJVbmlmb3Jtc1snZFRoZXRhJ10udmFsdWUgPSByYWRpYW5zUGVyUGl4ZWw7XG4gICAgICAgIGNvbnN0IGN1YmVDYW1lcmEgPSBuZXcgQ3ViZUNhbWVyYSgwLjEsIDEwMCwgdGFyZ2V0T3V0KTtcbiAgICAgICAgY3ViZUNhbWVyYS51cGRhdGUodGhpcy50aHJlZVJlbmRlcmVyLCB0aGlzLmJsdXJTY2VuZSk7XG4gICAgfVxuICAgIGdldEJsdXJTaGFkZXIobWF4U2FtcGxlcykge1xuICAgICAgICBjb25zdCB3ZWlnaHRzID0gbmV3IEZsb2F0MzJBcnJheShtYXhTYW1wbGVzKTtcbiAgICAgICAgY29uc3QgcG9sZUF4aXMgPSBuZXcgVmVjdG9yMygwLCAxLCAwKTtcbiAgICAgICAgY29uc3Qgc2hhZGVyTWF0ZXJpYWwgPSBuZXcgU2hhZGVyTWF0ZXJpYWwoe1xuICAgICAgICAgICAgbmFtZTogJ1NwaGVyaWNhbEdhdXNzaWFuQmx1cicsXG4gICAgICAgICAgICBkZWZpbmVzOiB7ICduJzogbWF4U2FtcGxlcyB9LFxuICAgICAgICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgICAgICAgICAnZW52TWFwJzogeyB2YWx1ZTogbnVsbCB9LFxuICAgICAgICAgICAgICAgICdzYW1wbGVzJzogeyB2YWx1ZTogMSB9LFxuICAgICAgICAgICAgICAgICd3ZWlnaHRzJzogeyB2YWx1ZTogd2VpZ2h0cyB9LFxuICAgICAgICAgICAgICAgICdsYXRpdHVkaW5hbCc6IHsgdmFsdWU6IGZhbHNlIH0sXG4gICAgICAgICAgICAgICAgJ2RUaGV0YSc6IHsgdmFsdWU6IDAgfSxcbiAgICAgICAgICAgICAgICAncG9sZUF4aXMnOiB7IHZhbHVlOiBwb2xlQXhpcyB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmVydGV4U2hhZGVyOiAvKiBnbHNsICovIGBcbiAgICAgIFxuICAgICAgdmFyeWluZyB2ZWMzIHZPdXRwdXREaXJlY3Rpb247XG4gIFxuICAgICAgdm9pZCBtYWluKCkge1xuICBcbiAgICAgICAgdk91dHB1dERpcmVjdGlvbiA9IHZlYzMoIHBvc2l0aW9uICk7XG4gICAgICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcbiAgXG4gICAgICB9XG4gICAgYCxcbiAgICAgICAgICAgIGZyYWdtZW50U2hhZGVyOiAvKiBnbHNsICovIGBcbiAgICAgICAgdmFyeWluZyB2ZWMzIHZPdXRwdXREaXJlY3Rpb247XG4gIFxuICAgICAgICB1bmlmb3JtIHNhbXBsZXJDdWJlIGVudk1hcDtcbiAgICAgICAgdW5pZm9ybSBpbnQgc2FtcGxlcztcbiAgICAgICAgdW5pZm9ybSBmbG9hdCB3ZWlnaHRzWyBuIF07XG4gICAgICAgIHVuaWZvcm0gYm9vbCBsYXRpdHVkaW5hbDtcbiAgICAgICAgdW5pZm9ybSBmbG9hdCBkVGhldGE7XG4gICAgICAgIHVuaWZvcm0gdmVjMyBwb2xlQXhpcztcbiAgXG4gICAgICAgIHZlYzMgZ2V0U2FtcGxlKCBmbG9hdCB0aGV0YSwgdmVjMyBheGlzICkge1xuICBcbiAgICAgICAgICBmbG9hdCBjb3NUaGV0YSA9IGNvcyggdGhldGEgKTtcbiAgICAgICAgICAvLyBSb2RyaWd1ZXMnIGF4aXMtYW5nbGUgcm90YXRpb25cbiAgICAgICAgICB2ZWMzIHNhbXBsZURpcmVjdGlvbiA9IHZPdXRwdXREaXJlY3Rpb24gKiBjb3NUaGV0YVxuICAgICAgICAgICAgKyBjcm9zcyggYXhpcywgdk91dHB1dERpcmVjdGlvbiApICogc2luKCB0aGV0YSApXG4gICAgICAgICAgICArIGF4aXMgKiBkb3QoIGF4aXMsIHZPdXRwdXREaXJlY3Rpb24gKSAqICggMS4wIC0gY29zVGhldGEgKTtcbiAgXG4gICAgICAgICAgcmV0dXJuIHZlYzMoIHRleHR1cmVDdWJlKCBlbnZNYXAsIHNhbXBsZURpcmVjdGlvbiApICk7XG4gIFxuICAgICAgICB9XG4gIFxuICAgICAgICB2b2lkIG1haW4oKSB7XG4gIFxuICAgICAgICAgIHZlYzMgYXhpcyA9IGxhdGl0dWRpbmFsID8gcG9sZUF4aXMgOiBjcm9zcyggcG9sZUF4aXMsIHZPdXRwdXREaXJlY3Rpb24gKTtcbiAgXG4gICAgICAgICAgaWYgKCBhbGwoIGVxdWFsKCBheGlzLCB2ZWMzKCAwLjAgKSApICkgKSB7XG4gIFxuICAgICAgICAgICAgYXhpcyA9IHZlYzMoIHZPdXRwdXREaXJlY3Rpb24ueiwgMC4wLCAtIHZPdXRwdXREaXJlY3Rpb24ueCApO1xuICBcbiAgICAgICAgICB9XG4gIFxuICAgICAgICAgIGF4aXMgPSBub3JtYWxpemUoIGF4aXMgKTtcbiAgXG4gICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCggMC4wLCAwLjAsIDAuMCwgMS4wICk7XG4gICAgICAgICAgZ2xfRnJhZ0NvbG9yLnJnYiArPSB3ZWlnaHRzWyAwIF0gKiBnZXRTYW1wbGUoIDAuMCwgYXhpcyApO1xuICBcbiAgICAgICAgICBmb3IgKCBpbnQgaSA9IDE7IGkgPCBuOyBpKysgKSB7XG4gIFxuICAgICAgICAgICAgaWYgKCBpID49IHNhbXBsZXMgKSB7XG4gIFxuICAgICAgICAgICAgICBicmVhaztcbiAgXG4gICAgICAgICAgICB9XG4gIFxuICAgICAgICAgICAgZmxvYXQgdGhldGEgPSBkVGhldGEgKiBmbG9hdCggaSApO1xuICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yLnJnYiArPSB3ZWlnaHRzWyBpIF0gKiBnZXRTYW1wbGUoIC0xLjAgKiB0aGV0YSwgYXhpcyApO1xuICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yLnJnYiArPSB3ZWlnaHRzWyBpIF0gKiBnZXRTYW1wbGUoIHRoZXRhLCBheGlzICk7XG4gIFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgYCxcbiAgICAgICAgICAgIGJsZW5kaW5nOiBOb0JsZW5kaW5nLFxuICAgICAgICAgICAgZGVwdGhUZXN0OiBmYWxzZSxcbiAgICAgICAgICAgIGRlcHRoV3JpdGU6IGZhbHNlLFxuICAgICAgICAgICAgc2lkZTogQmFja1NpZGVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzaGFkZXJNYXRlcmlhbDtcbiAgICB9XG4gICAgYXN5bmMgZGlzcG9zZSgpIHtcbiAgICAgICAgZm9yIChjb25zdCBbLCBwcm9taXNlXSBvZiB0aGlzLnNreWJveENhY2hlKSB7XG4gICAgICAgICAgICBjb25zdCBza3lib3ggPSBhd2FpdCBwcm9taXNlO1xuICAgICAgICAgICAgc2t5Ym94LmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5nZW5lcmF0ZWRFbnZpcm9ubWVudE1hcCAhPSBudWxsKSB7XG4gICAgICAgICAgICAoYXdhaXQgdGhpcy5nZW5lcmF0ZWRFbnZpcm9ubWVudE1hcCkuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZWRFbnZpcm9ubWVudE1hcCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZ2VuZXJhdGVkRW52aXJvbm1lbnRNYXBBbHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgKGF3YWl0IHRoaXMuZ2VuZXJhdGVkRW52aXJvbm1lbnRNYXBBbHQpLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVkRW52aXJvbm1lbnRNYXBBbHQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmJsdXJNYXRlcmlhbCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmJsdXJNYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UZXh0dXJlVXRpbHMuanMubWFwIiwiLyogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgJ0xpY2Vuc2UnKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAnQVMgSVMnIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgRnJvbnRTaWRlLCBTcGhlcmUgfSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyAkY2xvbmUsICRwcmVwYXJlLCAkcHJlcGFyZWRHTFRGLCBHTFRGSW5zdGFuY2UgfSBmcm9tICcuLi9HTFRGSW5zdGFuY2UuanMnO1xuaW1wb3J0IHsgQ29ycmVsYXRlZFNjZW5lR3JhcGggfSBmcm9tICcuL2NvcnJlbGF0ZWQtc2NlbmUtZ3JhcGguanMnO1xuY29uc3QgJGNvcnJlbGF0ZWRTY2VuZUdyYXBoID0gU3ltYm9sKCdjb3JyZWxhdGVkU2NlbmVHcmFwaCcpO1xuLyoqXG4gKiBUaGlzIHNwZWNpYWxpemF0aW9uIG9mIEdMVEZJbnN0YW5jZSBjb2xsZWN0cyBhbGwgb2YgdGhlIHByb2Nlc3NpbmcgbmVlZGVkXG4gKiB0byBwcmVwYXJlIGEgbW9kZWwgYW5kIHRvIGNsb25lIGl0IG1ha2luZyBzcGVjaWFsIGNvbnNpZGVyYXRpb25zIGZvclxuICogPG1vZGVsLXZpZXdlcj4gdXNlIGNhc2VzLlxuICovXG5leHBvcnQgY2xhc3MgTW9kZWxWaWV3ZXJHTFRGSW5zdGFuY2UgZXh0ZW5kcyBHTFRGSW5zdGFuY2Uge1xuICAgIC8qKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIHN0YXRpYyBbJHByZXBhcmVdKHNvdXJjZSkge1xuICAgICAgICBjb25zdCBwcmVwYXJlZCA9IHN1cGVyWyRwcmVwYXJlXShzb3VyY2UpO1xuICAgICAgICBpZiAocHJlcGFyZWRbJGNvcnJlbGF0ZWRTY2VuZUdyYXBoXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBwcmVwYXJlZFskY29ycmVsYXRlZFNjZW5lR3JhcGhdID0gQ29ycmVsYXRlZFNjZW5lR3JhcGguZnJvbShwcmVwYXJlZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzY2VuZSB9ID0gcHJlcGFyZWQ7XG4gICAgICAgIGNvbnN0IG51bGxTcGhlcmUgPSBuZXcgU3BoZXJlKHVuZGVmaW5lZCwgSW5maW5pdHkpO1xuICAgICAgICBzY2VuZS50cmF2ZXJzZSgobm9kZSkgPT4ge1xuICAgICAgICAgICAgLy8gU2V0IGEgaGlnaCByZW5kZXJPcmRlciB3aGlsZSB3ZSdyZSBoZXJlIHRvIGVuc3VyZSB0aGUgbW9kZWxcbiAgICAgICAgICAgIC8vIGFsd2F5cyByZW5kZXJzIG9uIHRvcCBvZiB0aGUgc2t5IHNwaGVyZVxuICAgICAgICAgICAgbm9kZS5yZW5kZXJPcmRlciA9IDEwMDA7XG4gICAgICAgICAgICAvLyBUaHJlZS5qcyBzZWVtcyB0byBjdWxsIHNvbWUgYW5pbWF0ZWQgbW9kZWxzIGluY29ycmVjdGx5LiBTaW5jZSB3ZVxuICAgICAgICAgICAgLy8gZXhwZWN0IHRvIHZpZXcgb3VyIHdob2xlIHNjZW5lIGFueXdheSwgd2UgdHVybiBvZmYgdGhlIGZydXN0dW1cbiAgICAgICAgICAgIC8vIGN1bGxpbmcgb3B0aW1pemF0aW9uIGhlcmUuXG4gICAgICAgICAgICBub2RlLmZydXN0dW1DdWxsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIEFuaW1hdGlvbnMgZm9yIG9iamVjdHMgd2l0aG91dCBuYW1lcyB0YXJnZXQgdGhlaXIgVVVJRCBpbnN0ZWFkLiBXaGVuXG4gICAgICAgICAgICAvLyBvYmplY3RzIGFyZSBjbG9uZWQsIHRoZXkgZ2V0IG5ldyBVVUlEcyB3aGljaCB0aGUgYW5pbWF0aW9uIGNhbid0XG4gICAgICAgICAgICAvLyBmaW5kLiBUbyBmaXggdGhpcywgd2UgYXNzaWduIHRoZWlyIFVVSUQgYXMgdGhlaXIgbmFtZS5cbiAgICAgICAgICAgIGlmICghbm9kZS5uYW1lKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5uYW1lID0gbm9kZS51dWlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWVzaCA9IG5vZGU7XG4gICAgICAgICAgICBpZiAobWVzaC5tYXRlcmlhbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZ2VvbWV0cnkgfSA9IG1lc2g7XG4gICAgICAgICAgICAgICAgbWVzaC5jYXN0U2hhZG93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAobWVzaC5pc1NraW5uZWRNZXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFraW4gdG8gZGlzYWJsaW5nIGZydXN0dW0gY3VsbGluZyBhYm92ZSwgd2UgaGF2ZSB0byBhbHNvIG1hbnVhbGx5XG4gICAgICAgICAgICAgICAgICAgIC8vIGRpc2FibGUgdGhlIGJvdW5kcyB0byBtYWtlIHJheWNhc3RpbmcgY29ycmVjdCBmb3Igc2tpbm5lZCBtZXNoZXMuXG4gICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID0gbnVsbFNwaGVyZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGJvdW5kaW5nIGJveCBpcyBzZXQgaW4gR0xURkxvYWRlciBieSB0aGUgYWNjZXNzb3IgYm91bmRzLCB3aGljaFxuICAgICAgICAgICAgICAgICAgICAvLyBhcmUgbm90IHVwZGF0ZWQgd2l0aCBhbmltYXRpb24uXG4gICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5LmJvdW5kaW5nQm94ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0ZXJpYWwgPSBtZXNoLm1hdGVyaWFsO1xuICAgICAgICAgICAgICAgIGlmIChtYXRlcmlhbC5pc01lc2hCYXNpY01hdGVyaWFsID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsLnRvbmVNYXBwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBtYWtlcyBzaGFkb3dzIGJldHRlciBmb3Igbm9uLW1hbmlmb2xkIG1lc2hlc1xuICAgICAgICAgICAgICAgIG1hdGVyaWFsLnNoYWRvd1NpZGUgPSBGcm9udFNpZGU7XG4gICAgICAgICAgICAgICAgLy8gRml4ZXMgYW4gZWRnZSBjYXNlIHdpdGggdW51c2VkIGV4dHJhIFVWLWNvb3JkcyBiZWluZyBpbmNvcnJlY3RseVxuICAgICAgICAgICAgICAgIC8vIHJlZmVyZW5jZWQgYnkgdGhyZWUuanM7IHJlbW92ZSB3aGVuXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9wdWxsLzIzOTc0IGlzIG1lcmdlZC5cbiAgICAgICAgICAgICAgICBpZiAobWF0ZXJpYWwuYW9NYXApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBnbHRmLCB0aHJlZU9iamVjdE1hcCB9ID0gcHJlcGFyZWRbJGNvcnJlbGF0ZWRTY2VuZUdyYXBoXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2x0ZlJlZiA9IHRocmVlT2JqZWN0TWFwLmdldChtYXRlcmlhbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnbHRmLm1hdGVyaWFscyAhPSBudWxsICYmIGdsdGZSZWYgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZ2x0ZlJlZi5tYXRlcmlhbHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2x0Zk1hdGVyaWFsID0gZ2x0Zi5tYXRlcmlhbHNbZ2x0ZlJlZi5tYXRlcmlhbHNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdsdGZNYXRlcmlhbC5vY2NsdXNpb25UZXh0dXJlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2x0Zk1hdGVyaWFsLm9jY2x1c2lvblRleHR1cmUudGV4Q29vcmQgPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS5hdHRyaWJ1dGVzLnV2ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ3V2MicsIGdlb21ldHJ5LmF0dHJpYnV0ZXMudXYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHByZXBhcmVkO1xuICAgIH1cbiAgICBnZXQgY29ycmVsYXRlZFNjZW5lR3JhcGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzWyRwcmVwYXJlZEdMVEZdWyRjb3JyZWxhdGVkU2NlbmVHcmFwaF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIFskY2xvbmVdKCkge1xuICAgICAgICBjb25zdCBjbG9uZSA9IHN1cGVyWyRjbG9uZV0oKTtcbiAgICAgICAgY29uc3Qgc291cmNlVVVJRFRvQ2xvbmVkTWF0ZXJpYWwgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNsb25lLnNjZW5lLnRyYXZlcnNlKChub2RlKSA9PiB7XG4gICAgICAgICAgICAvLyBNYXRlcmlhbHMgYXJlbid0IGNsb25lZCB3aGVuIGNsb25pbmcgbWVzaGVzOyBnZW9tZXRyeVxuICAgICAgICAgICAgLy8gYW5kIG1hdGVyaWFscyBhcmUgY29waWVkIGJ5IHJlZmVyZW5jZS4gVGhpcyBpcyBuZWNlc3NhcnlcbiAgICAgICAgICAgIC8vIGZvciB0aGUgc2FtZSBtb2RlbCB0byBiZSB1c2VkIHR3aWNlIHdpdGggZGlmZmVyZW50XG4gICAgICAgICAgICAvLyBzY2VuZS1ncmFwaCBvcGVyYXRpb25zLlxuICAgICAgICAgICAgY29uc3QgbWVzaCA9IG5vZGU7XG4gICAgICAgICAgICBpZiAobWVzaC5tYXRlcmlhbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGVyaWFsID0gbWVzaC5tYXRlcmlhbDtcbiAgICAgICAgICAgICAgICBpZiAobWF0ZXJpYWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlVVVJRFRvQ2xvbmVkTWF0ZXJpYWwuaGFzKG1hdGVyaWFsLnV1aWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNoLm1hdGVyaWFsID0gc291cmNlVVVJRFRvQ2xvbmVkTWF0ZXJpYWwuZ2V0KG1hdGVyaWFsLnV1aWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc2gubWF0ZXJpYWwgPSBtYXRlcmlhbC5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2VVVUlEVG9DbG9uZWRNYXRlcmlhbC5zZXQobWF0ZXJpYWwudXVpZCwgbWVzaC5tYXRlcmlhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQ3Jvc3MtY29ycmVsYXRlIHRoZSBzY2VuZSBncmFwaCBieSByZWx5aW5nIG9uIGluZm9ybWF0aW9uIGluIHRoZVxuICAgICAgICAvLyBjdXJyZW50IHNjZW5lIGdyYXBoOyB3aXRob3V0IHRoaXMgc3RlcCwgcmVsYXRpb25zaGlwcyBiZXR3ZWVuIHRoZVxuICAgICAgICAvLyBUaHJlZS5qcyBvYmplY3QgZ3JhcGggYW5kIHRoZSBnbFRGIHNjZW5lIGdyYXBoIHdpbGwgYmUgbG9zdC5cbiAgICAgICAgY2xvbmVbJGNvcnJlbGF0ZWRTY2VuZUdyYXBoXSA9XG4gICAgICAgICAgICBDb3JyZWxhdGVkU2NlbmVHcmFwaC5mcm9tKGNsb25lLCB0aGlzLmNvcnJlbGF0ZWRTY2VuZUdyYXBoKTtcbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1vZGVsVmlld2VyR0xURkluc3RhbmNlLmpzLm1hcCIsIi8qIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICdMaWNlbnNlJyk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gJ0FTIElTJyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQHBhcmFtIG9iamVjdCB7VEhSRUUuT2JqZWN0M0R9XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5jb25zdCBjb21wYXRpYmxlT2JqZWN0ID0gKG9iamVjdCkgPT4ge1xuICAgIC8vIEBUT0RPOiBOZWVkIHByb3BlcmVyIHZhcmlhbnRNYXRlcmlhbHMgZm9ybWF0IHZhbGlkYXRpb24/XG4gICAgcmV0dXJuIG9iamVjdC5tYXRlcmlhbCAhPT1cbiAgICAgICAgdW5kZWZpbmVkICYmIC8vIGVhc2llciB0aGFuICghb2JqZWN0LmlzTWVzaCAmJiAhb2JqZWN0LmlzTGluZSAmJlxuICAgICAgICAvLyAhb2JqZWN0LmlzUG9pbnRzKVxuICAgICAgICBvYmplY3QudXNlckRhdGEgJiYgLy8ganVzdCBpbiBjYXNlXG4gICAgICAgIG9iamVjdC51c2VyRGF0YS52YXJpYW50TWF0ZXJpYWxzICYmXG4gICAgICAgIC8vIElzIHRoaXMgbGluZSBjb3N0bHk/XG4gICAgICAgICEhQXJyYXlcbiAgICAgICAgICAgIC5mcm9tKG9iamVjdC51c2VyRGF0YS52YXJpYW50TWF0ZXJpYWxzXG4gICAgICAgICAgICAudmFsdWVzKCkpXG4gICAgICAgICAgICAuZmlsdGVyKG0gPT4gY29tcGF0aWJsZU1hdGVyaWFsKG0ubWF0ZXJpYWwpKTtcbn07XG4vKipcbiAqIEBwYXJhbSBtYXRlcmlhbCB7VEhSRUUuTWF0ZXJpYWx9XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5jb25zdCBjb21wYXRpYmxlTWF0ZXJpYWwgPSAobWF0ZXJpYWwpID0+IHtcbiAgICAvLyBAVE9ETzogc3VwcG9ydCBtdWx0aSBtYXRlcmlhbHM/XG4gICAgcmV0dXJuIG1hdGVyaWFsICYmIG1hdGVyaWFsLmlzTWF0ZXJpYWwgJiYgIUFycmF5LmlzQXJyYXkobWF0ZXJpYWwpO1xufTtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdMVEZFeHBvcnRlck1hdGVyaWFsc1ZhcmlhbnRzRXh0ZW5zaW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih3cml0ZXIpIHtcbiAgICAgICAgdGhpcy53cml0ZXIgPSB3cml0ZXI7XG4gICAgICAgIHRoaXMubmFtZSA9ICdLSFJfbWF0ZXJpYWxzX3ZhcmlhbnRzJztcbiAgICAgICAgdGhpcy52YXJpYW50TmFtZXMgPSBbXTtcbiAgICB9XG4gICAgYmVmb3JlUGFyc2Uob2JqZWN0cykge1xuICAgICAgICAvLyBGaW5kIGFsbCB2YXJpYW50IG5hbWVzIGFuZCBzdG9yZSB0aGVtIHRvIHRoZSB0YWJsZVxuICAgICAgICBjb25zdCB2YXJpYW50TmFtZVNldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgZm9yIChjb25zdCBvYmplY3Qgb2Ygb2JqZWN0cykge1xuICAgICAgICAgICAgb2JqZWN0LnRyYXZlcnNlKG8gPT4ge1xuICAgICAgICAgICAgICAgIGlmICghY29tcGF0aWJsZU9iamVjdChvKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHZhcmlhbnRNYXRlcmlhbHMgPSBvLnVzZXJEYXRhLnZhcmlhbnRNYXRlcmlhbHM7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFyaWFudERhdGFNYXAgPSBvLnVzZXJEYXRhLnZhcmlhbnREYXRhO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW3ZhcmlhbnROYW1lLCB2YXJpYW50RGF0YV0gb2YgdmFyaWFudERhdGFNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFyaWFudE1hdGVyaWFsID0gdmFyaWFudE1hdGVyaWFscy5nZXQodmFyaWFudERhdGEuaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgdW5sb2FkZWQgdmFyaWFudCBtYXRlcmlhbHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhcmlhbnRNYXRlcmlhbCAmJiBjb21wYXRpYmxlTWF0ZXJpYWwodmFyaWFudE1hdGVyaWFsLm1hdGVyaWFsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFudE5hbWVTZXQuYWRkKHZhcmlhbnROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIG1heSB3YW50IHRvIHNvcnQ/XG4gICAgICAgIHZhcmlhbnROYW1lU2V0LmZvckVhY2gobmFtZSA9PiB0aGlzLnZhcmlhbnROYW1lcy5wdXNoKG5hbWUpKTtcbiAgICB9XG4gICAgd3JpdGVNZXNoKG1lc2gsIG1lc2hEZWYpIHtcbiAgICAgICAgaWYgKCFjb21wYXRpYmxlT2JqZWN0KG1lc2gpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXNlckRhdGEgPSBtZXNoLnVzZXJEYXRhO1xuICAgICAgICBjb25zdCB2YXJpYW50TWF0ZXJpYWxzID0gdXNlckRhdGEudmFyaWFudE1hdGVyaWFscztcbiAgICAgICAgY29uc3QgdmFyaWFudERhdGFNYXAgPSB1c2VyRGF0YS52YXJpYW50RGF0YTtcbiAgICAgICAgY29uc3QgbWFwcGluZ1RhYmxlID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBSZW1vdmVzIGdhcHMgaW4gdGhlIHZhcmlhbnQgaW5kaWNlcyBsaXN0IChjYXVzZWQgYnkgZGVsZXRpbmcgdmFyaWFudHMpLlxuICAgICAgICBjb25zdCByZUluZGV4ZWRWYXJpYW50cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgdmFyaWFudHMgPSBBcnJheS5mcm9tKHZhcmlhbnREYXRhTWFwLnZhbHVlcygpKS5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYS5pbmRleCAtIGIuaW5kZXg7XG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKGNvbnN0IFtpLCB2YXJpYW50RGF0YV0gb2YgdmFyaWFudHMuZW50cmllcygpKSB7XG4gICAgICAgICAgICByZUluZGV4ZWRWYXJpYW50cy5zZXQodmFyaWFudERhdGEuaW5kZXgsIGkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgdmFyaWFudERhdGEgb2YgdmFyaWFudERhdGFNYXAudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhcmlhbnRJbnN0YW5jZSA9IHZhcmlhbnRNYXRlcmlhbHMuZ2V0KHZhcmlhbnREYXRhLmluZGV4KTtcbiAgICAgICAgICAgIGlmICghdmFyaWFudEluc3RhbmNlIHx8ICFjb21wYXRpYmxlTWF0ZXJpYWwodmFyaWFudEluc3RhbmNlLm1hdGVyaWFsKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWF0ZXJpYWxJbmRleCA9IHRoaXMud3JpdGVyLnByb2Nlc3NNYXRlcmlhbCh2YXJpYW50SW5zdGFuY2UubWF0ZXJpYWwpO1xuICAgICAgICAgICAgaWYgKCFtYXBwaW5nVGFibGUuaGFzKG1hdGVyaWFsSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgbWFwcGluZ1RhYmxlLnNldChtYXRlcmlhbEluZGV4LCB7IG1hdGVyaWFsOiBtYXRlcmlhbEluZGV4LCB2YXJpYW50czogW10gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXBwaW5nVGFibGUuZ2V0KG1hdGVyaWFsSW5kZXgpLnZhcmlhbnRzLnB1c2gocmVJbmRleGVkVmFyaWFudHMuZ2V0KHZhcmlhbnREYXRhLmluZGV4KSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWFwcGluZ3NEZWYgPSBBcnJheS5mcm9tKG1hcHBpbmdUYWJsZS52YWx1ZXMoKSlcbiAgICAgICAgICAgIC5tYXAoKG0gPT4geyByZXR1cm4gbS52YXJpYW50cy5zb3J0KChhLCBiKSA9PiBhIC0gYikgJiYgbTsgfSkpXG4gICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYS5tYXRlcmlhbCAtIGIubWF0ZXJpYWwpO1xuICAgICAgICBpZiAobWFwcGluZ3NEZWYubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3JpZ2luYWxNYXRlcmlhbEluZGV4ID0gY29tcGF0aWJsZU1hdGVyaWFsKHVzZXJEYXRhLm9yaWdpbmFsTWF0ZXJpYWwpID9cbiAgICAgICAgICAgIHRoaXMud3JpdGVyLnByb2Nlc3NNYXRlcmlhbCh1c2VyRGF0YS5vcmlnaW5hbE1hdGVyaWFsKSA6XG4gICAgICAgICAgICAtMTtcbiAgICAgICAgZm9yIChjb25zdCBwcmltaXRpdmVEZWYgb2YgbWVzaERlZi5wcmltaXRpdmVzKSB7XG4gICAgICAgICAgICAvLyBPdmVycmlkZSBwcmltaXRpdmVEZWYubWF0ZXJpYWwgd2l0aCBvcmlnaW5hbCBtYXRlcmlhbC5cbiAgICAgICAgICAgIGlmIChvcmlnaW5hbE1hdGVyaWFsSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIHByaW1pdGl2ZURlZi5tYXRlcmlhbCA9IG9yaWdpbmFsTWF0ZXJpYWxJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByaW1pdGl2ZURlZi5leHRlbnNpb25zID0gcHJpbWl0aXZlRGVmLmV4dGVuc2lvbnMgfHwge307XG4gICAgICAgICAgICBwcmltaXRpdmVEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdID0geyBtYXBwaW5nczogbWFwcGluZ3NEZWYgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZnRlclBhcnNlKCkge1xuICAgICAgICBpZiAodGhpcy52YXJpYW50TmFtZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm9vdCA9IHRoaXMud3JpdGVyLmpzb247XG4gICAgICAgIHJvb3QuZXh0ZW5zaW9ucyA9IHJvb3QuZXh0ZW5zaW9ucyB8fCB7fTtcbiAgICAgICAgY29uc3QgdmFyaWFudHNEZWYgPSB0aGlzLnZhcmlhbnROYW1lcy5tYXAobiA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyBuYW1lOiBuIH07XG4gICAgICAgIH0pO1xuICAgICAgICByb290LmV4dGVuc2lvbnNbdGhpcy5uYW1lXSA9IHsgdmFyaWFudHM6IHZhcmlhbnRzRGVmIH07XG4gICAgICAgIHRoaXMud3JpdGVyLmV4dGVuc2lvbnNVc2VkW3RoaXMubmFtZV0gPSB0cnVlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZhcmlhbnRNYXRlcmlhbEV4cG9ydGVyUGx1Z2luLmpzLm1hcCIsIi8qIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICdMaWNlbnNlJyk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gJ0FTIElTJyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogS0hSX21hdGVyaWFsc192YXJpYW50cyBzcGVjaWZpY2F0aW9uIGFsbG93cyBkdXBsaWNhdGVkIHZhcmlhbnQgbmFtZXNcbiAqIGJ1dCBpdCBtYWtlcyBoYW5kbGluZyB0aGUgZXh0ZW5zaW9uIGNvbXBsZXguXG4gKiBXZSBlbnN1cmUgdGhhIG5hbWVzIGFuZCBtYWtlIGl0IGVhc2llci5cbiAqIElmIHlvdSB3YW50IHRvIGV4cG9ydCB0aGUgZXh0ZW5zaW9uIHdpdGggdGhlIG9yaWdpbmFsIG5hbWVzXG4gKiB5b3UgYXJlIHJlY29tbWVuZGVkIHRvIHdyaXRlIEdMVEZFeHBvcnRlciBwbHVnaW4gdG8gcmVzdG9yZSB0aGUgbmFtZXMuXG4gKlxuICogQHBhcmFtIHZhcmlhbnROYW1lcyB7QXJyYXk8c3RyaW5nPn1cbiAqIEByZXR1cm4ge0FycmF5PHN0cmluZz59XG4gKi9cbmNvbnN0IGVuc3VyZVVuaXF1ZU5hbWVzID0gKHZhcmlhbnROYW1lcykgPT4ge1xuICAgIGNvbnN0IHVuaXF1ZU5hbWVzID0gW107XG4gICAgY29uc3Qga25vd25OYW1lcyA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgdmFyaWFudE5hbWVzKSB7XG4gICAgICAgIGxldCB1bmlxdWVOYW1lID0gbmFtZTtcbiAgICAgICAgbGV0IHN1ZmZpeCA9IDA7XG4gICAgICAgIC8vIEBUT0RPOiBBbiBlYXN5IHNvbHV0aW9uLlxuICAgICAgICAvLyAgICAgICAgTyhOXjIpIGluIHRoZSB3b3JzdCBzY2VuYXJpbyB3aGVyZSBOIGlzIHZhcmlhbnROYW1lcy5sZW5ndGguXG4gICAgICAgIC8vICAgICAgICBGaXggbWUgaWYgbmVlZGVkLlxuICAgICAgICB3aGlsZSAoa25vd25OYW1lcy5oYXModW5pcXVlTmFtZSkpIHtcbiAgICAgICAgICAgIHVuaXF1ZU5hbWUgPSBuYW1lICsgJy4nICsgKCsrc3VmZml4KTtcbiAgICAgICAgfVxuICAgICAgICBrbm93bk5hbWVzLmFkZCh1bmlxdWVOYW1lKTtcbiAgICAgICAgdW5pcXVlTmFtZXMucHVzaCh1bmlxdWVOYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuaXF1ZU5hbWVzO1xufTtcbi8qKlxuICogQ29udmVydCBtYXBwaW5ncyBhcnJheSB0byB0YWJsZSBvYmplY3QgdG8gbWFrZSBoYW5kbGluZyB0aGUgZXh0ZW5zaW9uIGVhc2llci5cbiAqXG4gKiBAcGFyYW1cbiAqICAgICBleHRlbnNpb25EZWYge2dsVEYubWVzaGVzW25dLnByaW1pdGl2ZS5leHRlbnNpb25zLktIUl9tYXRlcmlhbHNfdmFyaWFudHN9XG4gKiBAcGFyYW0gdmFyaWFudE5hbWVzIHtBcnJheTxzdHJpbmc+fSBSZXF1aXJlZCB0byBiZSB1bmlxdWUgbmFtZXNcbiAqIEByZXR1cm4ge01hcH1cbiAqL1xuY29uc3QgbWFwcGluZ3NBcnJheVRvVGFibGUgPSAoZXh0ZW5zaW9uRGVmKSA9PiB7XG4gICAgY29uc3QgdGFibGUgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBtYXBwaW5nIG9mIGV4dGVuc2lvbkRlZi5tYXBwaW5ncykge1xuICAgICAgICBmb3IgKGNvbnN0IHZhcmlhbnQgb2YgbWFwcGluZy52YXJpYW50cykge1xuICAgICAgICAgICAgdGFibGUuc2V0KHZhcmlhbnQsIHsgbWF0ZXJpYWw6IG51bGwsIGdsdGZNYXRlcmlhbEluZGV4OiBtYXBwaW5nLm1hdGVyaWFsIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YWJsZTtcbn07XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHTFRGTWF0ZXJpYWxzVmFyaWFudHNFeHRlbnNpb24ge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0tIUl9tYXRlcmlhbHNfdmFyaWFudHMnO1xuICAgIH1cbiAgICAvLyBOb3RlIHRoYXQgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIHdpbGwgYmUgb3ZlcnJpZGRlbiBldmVuIGlmIHRoZXkgYXJlXG4gICAgLy8gcHJlLWRlZmluZWRcbiAgICAvLyAtIGdsdGYudXNlckRhdGEudmFyaWFudHNcbiAgICAvLyAtIG1lc2gudXNlckRhdGEudmFyaWFudE1hdGVyaWFsc1xuICAgIGFmdGVyUm9vdChnbHRmKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgICAgICBjb25zdCBqc29uID0gcGFyc2VyLmpzb247XG4gICAgICAgIGlmIChqc29uLmV4dGVuc2lvbnMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAganNvbi5leHRlbnNpb25zW3RoaXMubmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXh0ZW5zaW9uRGVmID0ganNvbi5leHRlbnNpb25zW3RoaXMubmFtZV07XG4gICAgICAgIGNvbnN0IHZhcmlhbnRzRGVmID0gZXh0ZW5zaW9uRGVmLnZhcmlhbnRzIHx8IFtdO1xuICAgICAgICBjb25zdCB2YXJpYW50cyA9IGVuc3VyZVVuaXF1ZU5hbWVzKHZhcmlhbnRzRGVmLm1hcCgodikgPT4gdi5uYW1lKSk7XG4gICAgICAgIGZvciAoY29uc3Qgc2NlbmUgb2YgZ2x0Zi5zY2VuZXMpIHtcbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIHZhcmlhbnRzIGRhdGEgdW5kZXIgYXNzb2NpYXRlZCBtZXNoLnVzZXJEYXRhXG4gICAgICAgICAgICBzY2VuZS50cmF2ZXJzZShvYmplY3QgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc2ggPSBvYmplY3Q7XG4gICAgICAgICAgICAgICAgaWYgKCFtZXNoLm1hdGVyaWFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgYXNzb2NpYXRpb24gPSBwYXJzZXIuYXNzb2NpYXRpb25zLmdldChtZXNoKTtcbiAgICAgICAgICAgICAgICBpZiAoYXNzb2NpYXRpb24gPT0gbnVsbCB8fCBhc3NvY2lhdGlvbi5tZXNoZXMgPT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICAgICBhc3NvY2lhdGlvbi5wcmltaXRpdmVzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBtZXNoRGVmID0ganNvbi5tZXNoZXNbYXNzb2NpYXRpb24ubWVzaGVzXTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmltaXRpdmVzRGVmID0gbWVzaERlZi5wcmltaXRpdmVzO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByaW1pdGl2ZURlZiA9IHByaW1pdGl2ZXNEZWZbYXNzb2NpYXRpb24ucHJpbWl0aXZlc107XG4gICAgICAgICAgICAgICAgY29uc3QgZXh0ZW5zaW9uc0RlZiA9IHByaW1pdGl2ZURlZi5leHRlbnNpb25zO1xuICAgICAgICAgICAgICAgIGlmICghZXh0ZW5zaW9uc0RlZiB8fCAhZXh0ZW5zaW9uc0RlZlt0aGlzLm5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWVzaC51c2VyRGF0YS52YXJpYW50TWF0ZXJpYWxzID1cbiAgICAgICAgICAgICAgICAgICAgbWFwcGluZ3NBcnJheVRvVGFibGUoZXh0ZW5zaW9uc0RlZlt0aGlzLm5hbWVdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGdsdGYudXNlckRhdGEudmFyaWFudHMgPSB2YXJpYW50cztcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZhcmlhbnRNYXRlcmlhbExvYWRlclBsdWdpbi5qcy5tYXAiLCJpbXBvcnQgeyBNYXRlcmlhbCB9IGZyb20gJ3RocmVlJztcbmNvbnN0ICR0aHJlZUdMVEYgPSBTeW1ib2woJ3RocmVlR0xURicpO1xuY29uc3QgJGdsdGYgPSBTeW1ib2woJ2dsdGYnKTtcbmNvbnN0ICRnbHRmRWxlbWVudE1hcCA9IFN5bWJvbCgnZ2x0ZkVsZW1lbnRNYXAnKTtcbmNvbnN0ICR0aHJlZU9iamVjdE1hcCA9IFN5bWJvbCgndGhyZWVPYmplY3RNYXAnKTtcbmNvbnN0ICRwYXJhbGxlbFRyYXZlcnNlVGhyZWVTY2VuZSA9IFN5bWJvbCgncGFyYWxsZWxUcmF2ZXJzZVRocmVlU2NlbmUnKTtcbmNvbnN0ICRjb3JyZWxhdGVPcmlnaW5hbFRocmVlR0xURiA9IFN5bWJvbCgnY29ycmVsYXRlT3JpZ2luYWxUaHJlZUdMVEYnKTtcbmNvbnN0ICRjb3JyZWxhdGVDbG9uZVRocmVlR0xURiA9IFN5bWJvbCgnY29ycmVsYXRlQ2xvbmVUaHJlZUdMVEYnKTtcbi8qKlxuICogVGhlIFRocmVlLmpzIEdMVEZMb2FkZXIgcHJvdmlkZXMgdXMgd2l0aCBhbiBpbi1tZW1vcnkgcmVwcmVzZW50YXRpb25cbiAqIG9mIGEgZ2xURiBpbiB0ZXJtcyBvZiBUaHJlZS5qcyBjb25zdHJ1Y3RzLiBJdCBhbHNvIHByb3ZpZGVzIHVzIHdpdGggYSBjb3B5XG4gKiBvZiB0aGUgZGVzZXJpYWxpemVkIGdsVEYgd2l0aG91dCBhbnkgVGhyZWUuanMgZGVjb3JhdGlvbiwgYW5kIGEgbWFwcGluZyBvZlxuICogZ2xURiBlbGVtZW50cyB0byB0aGVpciBjb3JyZXNwb25kaW5nIFRocmVlLmpzIGNvbnN0cnVjdHMuXG4gKlxuICogQSBDb3JyZWxhdGVkU2NlbmVHcmFwaCBleHBvc2VzIGEgc3luY2hyb25vdXNseSBhdmFpbGFibGUgbWFwcGluZyBvZiBnbFRGXG4gKiBlbGVtZW50IHJlZmVyZW5jZXMgdG8gdGhlaXIgY29ycmVzcG9uZGluZyBUaHJlZS5qcyBjb25zdHJ1Y3RzLlxuICovXG5leHBvcnQgY2xhc3MgQ29ycmVsYXRlZFNjZW5lR3JhcGgge1xuICAgIGNvbnN0cnVjdG9yKHRocmVlR0xURiwgZ2x0ZiwgdGhyZWVPYmplY3RNYXAsIGdsdGZFbGVtZW50TWFwKSB7XG4gICAgICAgIHRoaXNbJHRocmVlR0xURl0gPSB0aHJlZUdMVEY7XG4gICAgICAgIHRoaXNbJGdsdGZdID0gZ2x0ZjtcbiAgICAgICAgdGhpc1skZ2x0ZkVsZW1lbnRNYXBdID0gZ2x0ZkVsZW1lbnRNYXA7XG4gICAgICAgIHRoaXNbJHRocmVlT2JqZWN0TWFwXSA9IHRocmVlT2JqZWN0TWFwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlIGEgQ29ycmVsYXRlZFNjZW5lR3JhcGggZnJvbSBhIG5hdHVyYWxseSBnZW5lcmF0ZWQgVGhyZWUuanMgR0xURi5cbiAgICAgKiBTdWNoIEdMVEZzIGFyZSBwcm9kdWNlZCBieSBUaHJlZS5qcycgR0xURkxvYWRlciwgYW5kIGNvbnRhaW4gY2FjaGVkXG4gICAgICogZGV0YWlscyB0aGF0IGV4cGVkaXRlIHRoZSBjb3JyZWxhdGlvbiBzdGVwLlxuICAgICAqXG4gICAgICogSWYgYSBDb3JyZWxhdGVkU2NlbmVHcmFwaCBpcyBwcm92aWRlZCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LCByZS1jb3JyZWxhdGVzXG4gICAgICogYSBjbG9uZWQgVGhyZWUuanMgR0xURiB3aXRoIGEgY2xvbmUgb2YgdGhlIGdsVEYgaGllcmFyY2h5IHVzZWQgdG8gcHJvZHVjZVxuICAgICAqIHRoZSB1cHN0cmVhbSBUaHJlZS5qcyBHTFRGIHRoYXQgdGhlIGNsb25lIHdhcyBjcmVhdGVkIGZyb20uIFRoZSByZXN1bHRcbiAgICAgKiBDb3JyZWxhdGVkU2NlbmVHcmFwaCBpcyByZXByZXNlbnRhdGl2ZSBvZiB0aGUgY2xvbmVkIGhpZXJhcmNoeS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbSh0aHJlZUdMVEYsIHVwc3RyZWFtQ29ycmVsYXRlZFNjZW5lR3JhcGgpIHtcbiAgICAgICAgaWYgKHVwc3RyZWFtQ29ycmVsYXRlZFNjZW5lR3JhcGggIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbJGNvcnJlbGF0ZUNsb25lVGhyZWVHTFRGXSh0aHJlZUdMVEYsIHVwc3RyZWFtQ29ycmVsYXRlZFNjZW5lR3JhcGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbJGNvcnJlbGF0ZU9yaWdpbmFsVGhyZWVHTFRGXSh0aHJlZUdMVEYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBbJGNvcnJlbGF0ZU9yaWdpbmFsVGhyZWVHTFRGXSh0aHJlZUdMVEYpIHtcbiAgICAgICAgY29uc3QgZ2x0ZiA9IHRocmVlR0xURi5wYXJzZXIuanNvbjtcbiAgICAgICAgY29uc3QgYXNzb2NpYXRpb25zID0gdGhyZWVHTFRGLnBhcnNlci5hc3NvY2lhdGlvbnM7XG4gICAgICAgIGNvbnN0IGdsdGZFbGVtZW50TWFwID0gbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCBkZWZhdWx0TWF0ZXJpYWwgPSB7IG5hbWU6ICdEZWZhdWx0JyB9O1xuICAgICAgICBjb25zdCBkZWZhdWx0UmVmZXJlbmNlID0geyB0eXBlOiAnbWF0ZXJpYWxzJywgaW5kZXg6IC0xIH07XG4gICAgICAgIGZvciAoY29uc3QgdGhyZWVNYXRlcmlhbCBvZiBhc3NvY2lhdGlvbnMua2V5cygpKSB7XG4gICAgICAgICAgICAvLyBOb3RlOiBHTFRGTG9hZGVyIGNyZWF0ZXMgYSBcImRlZmF1bHRcIiBtYXRlcmlhbCB0aGF0IGhhcyBub1xuICAgICAgICAgICAgLy8gY29ycmVzcG9uZGluZyBnbFRGIGVsZW1lbnQgaW4gdGhlIGNhc2UgdGhhdCBubyBtYXRlcmlhbHMgYXJlXG4gICAgICAgICAgICAvLyBzcGVjaWZpZWQgaW4gdGhlIHNvdXJjZSBnbFRGLiBJbiB0aGlzIGNhc2Ugd2UgYXBwZW5kIGEgZGVmYXVsdFxuICAgICAgICAgICAgLy8gbWF0ZXJpYWwgdG8gYWxsb3cgdGhpcyB0byBiZSBvcGVyYXRlZCB1cG9uLlxuICAgICAgICAgICAgaWYgKHRocmVlTWF0ZXJpYWwgaW5zdGFuY2VvZiBNYXRlcmlhbCAmJlxuICAgICAgICAgICAgICAgIGFzc29jaWF0aW9ucy5nZXQodGhyZWVNYXRlcmlhbCkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChkZWZhdWx0UmVmZXJlbmNlLmluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2x0Zi5tYXRlcmlhbHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2x0Zi5tYXRlcmlhbHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0UmVmZXJlbmNlLmluZGV4ID0gZ2x0Zi5tYXRlcmlhbHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBnbHRmLm1hdGVyaWFscy5wdXNoKGRlZmF1bHRNYXRlcmlhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocmVlTWF0ZXJpYWwubmFtZSA9IGRlZmF1bHRNYXRlcmlhbC5uYW1lO1xuICAgICAgICAgICAgICAgIGFzc29jaWF0aW9ucy5zZXQodGhyZWVNYXRlcmlhbCwgeyBtYXRlcmlhbHM6IGRlZmF1bHRSZWZlcmVuY2UuaW5kZXggfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlcyBhIHJldmVyc2UgbG9vayB1cCBtYXAgKGdsdGYtb2JqZWN0IHRvIFRocmVlLW9iamVjdClcbiAgICAgICAgZm9yIChjb25zdCBbdGhyZWVPYmplY3QsIGdsdGZNYXBwaW5nc10gb2YgYXNzb2NpYXRpb25zKSB7XG4gICAgICAgICAgICBpZiAoZ2x0Zk1hcHBpbmdzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqV2l0aFVzZXJEYXRhID0gdGhyZWVPYmplY3Q7XG4gICAgICAgICAgICAgICAgb2JqV2l0aFVzZXJEYXRhLnVzZXJEYXRhID0gb2JqV2l0aFVzZXJEYXRhLnVzZXJEYXRhIHx8IHt9O1xuICAgICAgICAgICAgICAgIG9ialdpdGhVc2VyRGF0YS51c2VyRGF0YS5hc3NvY2lhdGlvbnMgPSBnbHRmTWFwcGluZ3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG1hcHBpbmcgaW4gZ2x0Zk1hcHBpbmdzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hcHBpbmcgIT0gbnVsbCAmJiBtYXBwaW5nICE9PSAncHJpbWl0aXZlcycpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IG1hcHBpbmc7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRBcnJheSA9IGdsdGZbdHlwZV0gfHwgW107XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGdsdGZFbGVtZW50ID0gZWxlbWVudEFycmF5W2dsdGZNYXBwaW5nc1t0eXBlXV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChnbHRmRWxlbWVudCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBNYXliZSB0aHJvdyBoZXJlLi4uXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgdGhyZWVPYmplY3RzID0gZ2x0ZkVsZW1lbnRNYXAuZ2V0KGdsdGZFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRocmVlT2JqZWN0cyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJlZU9iamVjdHMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBnbHRmRWxlbWVudE1hcC5zZXQoZ2x0ZkVsZW1lbnQsIHRocmVlT2JqZWN0cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyZWVPYmplY3RzLmFkZCh0aHJlZU9iamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ29ycmVsYXRlZFNjZW5lR3JhcGgodGhyZWVHTFRGLCBnbHRmLCBhc3NvY2lhdGlvbnMsIGdsdGZFbGVtZW50TWFwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNmZXJzIHRoZSBhc3NvY2lhdGlvbiBiZXR3ZWVuIGEgcmF3IGdsVEYgYW5kIGEgVGhyZWUuanMgc2NlbmUgZ3JhcGhcbiAgICAgKiB0byBhIGNsb25lIG9mIHRoZSBUaHJlZS5qcyBzY2VuZSBncmFwaCwgcmVzb2x2ZWQgYXMgYSBuZXdcbiAgICAgKiBDb3JyZWxhdGVkU2NlbmVHcmFwaCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgWyRjb3JyZWxhdGVDbG9uZVRocmVlR0xURl0oY2xvbmVUaHJlZUdMVEYsIHVwc3RyZWFtQ29ycmVsYXRlZFNjZW5lR3JhcGgpIHtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxUaHJlZUdMVEYgPSB1cHN0cmVhbUNvcnJlbGF0ZWRTY2VuZUdyYXBoLnRocmVlR0xURjtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxHTFRGID0gdXBzdHJlYW1Db3JyZWxhdGVkU2NlbmVHcmFwaC5nbHRmO1xuICAgICAgICBjb25zdCBjbG9uZUdMVEYgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9yaWdpbmFsR0xURikpO1xuICAgICAgICBjb25zdCBjbG9uZVRocmVlT2JqZWN0TWFwID0gbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCBjbG9uZUdMVEZFbGVtZW50TWFwID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9yaWdpbmFsVGhyZWVHTFRGLnNjZW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpc1skcGFyYWxsZWxUcmF2ZXJzZVRocmVlU2NlbmVdKG9yaWdpbmFsVGhyZWVHTFRGLnNjZW5lc1tpXSwgY2xvbmVUaHJlZUdMVEYuc2NlbmVzW2ldLCAob2JqZWN0LCBjbG9uZU9iamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRSZWZlcmVuY2UgPSB1cHN0cmVhbUNvcnJlbGF0ZWRTY2VuZUdyYXBoLnRocmVlT2JqZWN0TWFwLmdldChvYmplY3QpO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50UmVmZXJlbmNlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG1hcHBpbmcgaW4gZWxlbWVudFJlZmVyZW5jZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFwcGluZyAhPSBudWxsICYmIG1hcHBpbmcgIT09ICdwcmltaXRpdmVzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IG1hcHBpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGVsZW1lbnRSZWZlcmVuY2VbdHlwZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjbG9uZUVsZW1lbnQgPSBjbG9uZUdMVEZbdHlwZV1baW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWFwcGluZ3MgPSBjbG9uZVRocmVlT2JqZWN0TWFwLmdldChjbG9uZU9iamVjdCkgfHwge307XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nc1t0eXBlXSA9IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmVUaHJlZU9iamVjdE1hcC5zZXQoY2xvbmVPYmplY3QsIG1hcHBpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsb25lT2JqZWN0cyA9IGNsb25lR0xURkVsZW1lbnRNYXAuZ2V0KGNsb25lRWxlbWVudCkgfHwgbmV3IFNldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmVPYmplY3RzLmFkZChjbG9uZU9iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9uZUdMVEZFbGVtZW50TWFwLnNldChjbG9uZUVsZW1lbnQsIGNsb25lT2JqZWN0cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENvcnJlbGF0ZWRTY2VuZUdyYXBoKGNsb25lVGhyZWVHTFRGLCBjbG9uZUdMVEYsIGNsb25lVGhyZWVPYmplY3RNYXAsIGNsb25lR0xURkVsZW1lbnRNYXApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmF2ZXJzZXMgdHdvIHByZXN1bWFibHkgaWRlbnRpY2FsIFRocmVlLmpzIHNjZW5lcywgYW5kIGludm9rZXMgYVxuICAgICAqIGNhbGxiYWNrIGZvciBlYWNoIE9iamVjdDNEIG9yIE1hdGVyaWFsIGVuY291bnRlcmVkLCBpbmNsdWRpbmcgdGhlIGluaXRpYWxcbiAgICAgKiBzY2VuZS4gQWRhcHRlZCBmcm9tXG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9ibG9iLzdjMTQyNGM1ODE5YWI2MjJhMzQ2ZGQ2MzBlZTRlNjQzMTM4ODAyMWUvZXhhbXBsZXMvanNtL3V0aWxzL1NrZWxldG9uVXRpbHMuanMjTDU4Ni1MNTk2XG4gICAgICovXG4gICAgc3RhdGljIFskcGFyYWxsZWxUcmF2ZXJzZVRocmVlU2NlbmVdKHNjZW5lT25lLCBzY2VuZVR3bywgY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgdHJhdmVyc2UgPSAoYSwgYikgPT4ge1xuICAgICAgICAgICAgY2FsbGJhY2soYSwgYik7XG4gICAgICAgICAgICBpZiAoYS5pc09iamVjdDNEKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVzaEEgPSBhO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc2hCID0gYjtcbiAgICAgICAgICAgICAgICBpZiAobWVzaEEubWF0ZXJpYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWVzaEEubWF0ZXJpYWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lc2hBLm1hdGVyaWFsLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobWVzaEEubWF0ZXJpYWxbaV0sIG1lc2hCLm1hdGVyaWFsW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG1lc2hBLm1hdGVyaWFsLCBtZXNoQi5tYXRlcmlhbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYXZlcnNlKGEuY2hpbGRyZW5baV0sIGIuY2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdHJhdmVyc2Uoc2NlbmVPbmUsIHNjZW5lVHdvKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHNvdXJjZSBUaHJlZS5qcyBHTFRGIHJlc3VsdCBnaXZlbiB0byB1cyBieSBhIFRocmVlLmpzIEdMVEZMb2FkZXIuXG4gICAgICovXG4gICAgZ2V0IHRocmVlR0xURigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbJHRocmVlR0xURl07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBpbi1tZW1vcnkgZGVzZXJpYWxpemVkIHNvdXJjZSBnbFRGLlxuICAgICAqL1xuICAgIGdldCBnbHRmKCkge1xuICAgICAgICByZXR1cm4gdGhpc1skZ2x0Zl07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgTWFwIG9mIGdsVEYgZWxlbWVudCByZWZlcmVuY2VzIHRvIGFycmF5cyBvZiBjb3JyZXNwb25kaW5nIFRocmVlLmpzXG4gICAgICogb2JqZWN0IHJlZmVyZW5jZXMuIFRocmVlLmpzIG9iamVjdHMgYXJlIGtlcHQgaW4gYXJyYXlzIHRvIGFjY291bnQgZm9yXG4gICAgICogY2FzZXMgd2hlcmUgbW9yZSB0aGFuIG9uZSBUaHJlZS5qcyBvYmplY3QgY29ycmVzcG9uZHMgdG8gYSBzaW5nbGUgZ2xURlxuICAgICAqIGVsZW1lbnQuXG4gICAgICovXG4gICAgZ2V0IGdsdGZFbGVtZW50TWFwKCkge1xuICAgICAgICByZXR1cm4gdGhpc1skZ2x0ZkVsZW1lbnRNYXBdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIG1hcCBvZiBpbmRpdmlkdWFsIFRocmVlLmpzIG9iamVjdHMgdG8gY29ycmVzcG9uZGluZyBlbGVtZW50cyBpbiB0aGVcbiAgICAgKiBzb3VyY2UgZ2xURi5cbiAgICAgKi9cbiAgICBnZXQgdGhyZWVPYmplY3RNYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzWyR0aHJlZU9iamVjdE1hcF07XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29ycmVsYXRlZC1zY2VuZS1ncmFwaC5qcy5tYXAiLCJleHBvcnQgdmFyIEZpbHRlcjtcbihmdW5jdGlvbiAoRmlsdGVyKSB7XG4gICAgRmlsdGVyW0ZpbHRlcltcIk5lYXJlc3RcIl0gPSA5NzI4XSA9IFwiTmVhcmVzdFwiO1xuICAgIEZpbHRlcltGaWx0ZXJbXCJMaW5lYXJcIl0gPSA5NzI5XSA9IFwiTGluZWFyXCI7XG4gICAgRmlsdGVyW0ZpbHRlcltcIk5lYXJlc3RNaXBtYXBOZWFyZXN0XCJdID0gOTk4NF0gPSBcIk5lYXJlc3RNaXBtYXBOZWFyZXN0XCI7XG4gICAgRmlsdGVyW0ZpbHRlcltcIkxpbmVhck1pcG1hcE5lYXJlc3RcIl0gPSA5OTg1XSA9IFwiTGluZWFyTWlwbWFwTmVhcmVzdFwiO1xuICAgIEZpbHRlcltGaWx0ZXJbXCJOZWFyZXN0TWlwbWFwTGluZWFyXCJdID0gOTk4Nl0gPSBcIk5lYXJlc3RNaXBtYXBMaW5lYXJcIjtcbiAgICBGaWx0ZXJbRmlsdGVyW1wiTGluZWFyTWlwbWFwTGluZWFyXCJdID0gOTk4N10gPSBcIkxpbmVhck1pcG1hcExpbmVhclwiO1xufSkoRmlsdGVyIHx8IChGaWx0ZXIgPSB7fSkpO1xuZXhwb3J0IHZhciBXcmFwO1xuKGZ1bmN0aW9uIChXcmFwKSB7XG4gICAgV3JhcFtXcmFwW1wiQ2xhbXBUb0VkZ2VcIl0gPSAzMzA3MV0gPSBcIkNsYW1wVG9FZGdlXCI7XG4gICAgV3JhcFtXcmFwW1wiTWlycm9yZWRSZXBlYXRcIl0gPSAzMzY0OF0gPSBcIk1pcnJvcmVkUmVwZWF0XCI7XG4gICAgV3JhcFtXcmFwW1wiUmVwZWF0XCJdID0gMTA0OTddID0gXCJSZXBlYXRcIjtcbn0pKFdyYXAgfHwgKFdyYXAgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2x0Zi0yLjAuanMubWFwIiwiLyogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgJ0xpY2Vuc2UnKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAnQVMgSVMnIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgSEFTX1dFQlhSX0RFVklDRV9BUEksIEhBU19XRUJYUl9ISVRfVEVTVF9BUEksIElTX1dFQlhSX0FSX0NBTkRJREFURSB9IGZyb20gJy4vY29uc3RhbnRzLmpzJztcbmV4cG9ydCBjb25zdCBkZXNlcmlhbGl6ZVVybCA9ICh1cmwpID0+ICghIXVybCAmJiB1cmwgIT09ICdudWxsJykgPyB0b0Z1bGxVcmwodXJsKSA6IG51bGw7XG5leHBvcnQgY29uc3QgYXNzZXJ0SXNBckNhbmRpZGF0ZSA9ICgpID0+IHtcbiAgICBpZiAoSVNfV0VCWFJfQVJfQ0FORElEQVRFKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbWlzc2luZ0FwaXMgPSBbXTtcbiAgICBpZiAoIUhBU19XRUJYUl9ERVZJQ0VfQVBJKSB7XG4gICAgICAgIG1pc3NpbmdBcGlzLnB1c2goJ1dlYlhSIERldmljZSBBUEknKTtcbiAgICB9XG4gICAgaWYgKCFIQVNfV0VCWFJfSElUX1RFU1RfQVBJKSB7XG4gICAgICAgIG1pc3NpbmdBcGlzLnB1c2goJ1dlYlhSIEhpdCBUZXN0IEFQSScpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBmb2xsb3dpbmcgQVBJcyBhcmUgcmVxdWlyZWQgZm9yIEFSLCBidXQgYXJlIG1pc3NpbmcgaW4gdGhpcyBicm93c2VyOiAke21pc3NpbmdBcGlzLmpvaW4oJywgJyl9YCk7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyBhIHBhcnRpYWwgVVJMIHN0cmluZyB0byBhIGZ1bGx5IHF1YWxpZmllZCBVUkwgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IHRvRnVsbFVybCA9IChwYXJ0aWFsVXJsKSA9PiB7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChwYXJ0aWFsVXJsLCB3aW5kb3cubG9jYXRpb24udG9TdHJpbmcoKSk7XG4gICAgcmV0dXJuIHVybC50b1N0cmluZygpO1xufTtcbi8qKlxuICogUmV0dXJucyBhIHRocm90dGxlZCB2ZXJzaW9uIG9mIGEgZ2l2ZW4gZnVuY3Rpb24gdGhhdCBpcyBvbmx5IGludm9rZWQgYXQgbW9zdFxuICogb25jZSB3aXRoaW4gYSBnaXZlbiB0aHJlc2hvbGQgb2YgdGltZSBpbiBtaWxsaXNlY29uZHMuXG4gKlxuICogVGhlIHRocm90dGxlZCB2ZXJzaW9uIG9mIHRoZSBmdW5jdGlvbiBoYXMgYSBcImZsdXNoXCIgcHJvcGVydHkgdGhhdCByZXNldHMgdGhlXG4gKiB0aHJlc2hvbGQgZm9yIGNhc2VzIHdoZW4gaW1tZWRpYXRlIGludm9jYXRpb24gaXMgZGVzaXJlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IHRocm90dGxlID0gKGZuLCBtcykgPT4ge1xuICAgIGxldCB0aW1lciA9IG51bGw7XG4gICAgY29uc3QgdGhyb3R0bGVkID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgaWYgKHRpbWVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmbiguLi5hcmdzKTtcbiAgICAgICAgdGltZXIgPSBzZWxmLnNldFRpbWVvdXQoKCkgPT4gdGltZXIgPSBudWxsLCBtcyk7XG4gICAgfTtcbiAgICB0aHJvdHRsZWQuZmx1c2ggPSAoKSA9PiB7XG4gICAgICAgIGlmICh0aW1lciAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZWxmLmNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB0aHJvdHRsZWQ7XG59O1xuZXhwb3J0IGNvbnN0IGRlYm91bmNlID0gKGZuLCBtcykgPT4ge1xuICAgIGxldCB0aW1lciA9IG51bGw7XG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGlmICh0aW1lciAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZWxmLmNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIH1cbiAgICAgICAgdGltZXIgPSBzZWxmLnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgICAgICAgZm4oLi4uYXJncyk7XG4gICAgICAgIH0sIG1zKTtcbiAgICB9O1xufTtcbi8qKlxuICogQHBhcmFtIHtOdW1iZXJ9IGVkZ2VcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICogQHJldHVybiB7TnVtYmVyfSAwIGlmIHZhbHVlIGlzIGxlc3MgdGhhbiBlZGdlLCBvdGhlcndpc2UgMVxuICovXG5leHBvcnQgY29uc3Qgc3RlcCA9IChlZGdlLCB2YWx1ZSkgPT4ge1xuICAgIHJldHVybiB2YWx1ZSA8IGVkZ2UgPyAwIDogMTtcbn07XG4vKipcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICogQHBhcmFtIHtOdW1iZXJ9IGxvd2VyTGltaXRcbiAqIEBwYXJhbSB7TnVtYmVyfSB1cHBlckxpbWl0XG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHZhbHVlIGNsYW1wZWQgd2l0aGluIGxvd2VyTGltaXQuLnVwcGVyTGltaXRcbiAqL1xuZXhwb3J0IGNvbnN0IGNsYW1wID0gKHZhbHVlLCBsb3dlckxpbWl0LCB1cHBlckxpbWl0KSA9PiBNYXRoLm1heChsb3dlckxpbWl0LCBNYXRoLm1pbih1cHBlckxpbWl0LCB2YWx1ZSkpO1xuLy8gVGhlIERQUiB3ZSB1c2UgZm9yIGEgXCJjYXBwZWRcIiBzY2VuYXJpbyAoc2VlIHJlc29sdmVEcHIgYmVsb3cpOlxuZXhwb3J0IGNvbnN0IENBUFBFRF9ERVZJQ0VfUElYRUxfUkFUSU8gPSAxO1xuLyoqXG4gKiBUaGlzIGhlbHBlciBhbmFseXplcyB0aGUgbGF5b3V0IG9mIHRoZSBjdXJyZW50IHBhZ2UgdG8gZGVjaWRlIGlmIHdlIHNob3VsZFxuICogdXNlIHRoZSBuYXR1cmFsIGRldmljZSBwaXhlbCByYXRpbywgb3IgYSBjYXBwZWQgdmFsdWUuXG4gKlxuICogV2UgY2FwIERQUiBpZiB0aGVyZSBpcyBubyBtZXRhIHZpZXdwb3J0IChzdWdnZXN0aW5nIHRoYXQgdXNlciBpcyBub3RcbiAqIGNvbnNjaW91c2x5IHNwZWNpZnlpbmcgaG93IHRvIHNjYWxlIHRoZSB2aWV3cG9ydCByZWxhdGl2ZSB0byB0aGUgZGV2aWNlXG4gKiBzY3JlZW4gc2l6ZSkuXG4gKlxuICogVGhlIHJhdGlvbmFsZSBpcyB0aGF0IHRoaXMgY29uZGl0aW9uIHR5cGljYWxseSBsZWFkcyB0byBhIHBhdGhvbG9naWNhbFxuICogb3V0Y29tZSBvbiBtb2JpbGUgZGV2aWNlcy4gV2hlbiB0aGUgd2luZG93IGRpbWVuc2lvbnMgYXJlIHNjYWxlZCB1cCBvbiBhXG4gKiBkZXZpY2Ugd2l0aCBhIGhpZ2ggRFBSLCB3ZSBjcmVhdGUgYSBjYW52YXMgdGhhdCBpcyBtdWNoIGxhcmdlciB0aGFuXG4gKiBhcHByb3ByaWF0ZSB0byBhY2NvbW1vZGF0ZSBmb3IgdGhlIHBpeGVsIGRlbnNpdHkgaWYgd2UgbmFpdmVseSB1c2UgdGhlXG4gKiByZXBvcnRlZCBEUFIuXG4gKlxuICogVGhpcyB2YWx1ZSBuZWVkcyB0byBiZSBtZWFzdXJlZCBpbiByZWFsIHRpbWUsIGFzIGRldmljZSBwaXhlbCByYXRpbyBjYW5cbiAqIGNoYW5nZSBvdmVyIHRpbWUgKGUuZy4sIHdoZW4gYSB1c2VyIHpvb21zIHRoZSBwYWdlKS4gQWxzbywgaW4gc29tZSBjYXNlc1xuICogKHN1Y2ggYXMgRmlyZWZveCBvbiBBbmRyb2lkKSwgdGhlIHdpbmRvdydzIGlubmVyV2lkdGggaXMgaW5pdGlhbGx5IHJlcG9ydGVkXG4gKiBhcyB0aGUgc2FtZSBhcyB0aGUgc2NyZWVuJ3MgYXZhaWxXaWR0aCBidXQgY2hhbmdlcyBsYXRlci5cbiAqXG4gKiBBIHVzZXIgd2hvIHNwZWNpZmllcyBhIG1ldGEgdmlld3BvcnQsIHRoZXJlYnkgY29uc2Npb3VzbHkgY3JlYXRpbmcgc2NhbGluZ1xuICogY29uZGl0aW9ucyB3aGVyZSA8bW9kZWwtdmlld2VyPiBpcyBzbG93LCB3aWxsIGJlIGVuY291cmFnZWQgdG8gbGl2ZSB0aGVpclxuICogYmVzdCBsaWZlLlxuICovXG5leHBvcnQgY29uc3QgcmVzb2x2ZURwciA9ICgoKSA9PiB7XG4gICAgLy8gSWYgdHJ1ZSwgaW1wbGllcyB0aGF0IHRoZSB1c2VyIGlzIGNvbnNjaW91cyBvZiB0aGUgdmlld3BvcnQgc2NhbGluZ1xuICAgIC8vIHJlbGF0aXZlIHRvIHRoZSBkZXZpY2Ugc2NyZWVuIHNpemUuXG4gICAgY29uc3QgSEFTX01FVEFfVklFV1BPUlRfVEFHID0gKCgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBTZWFyY2ggcmVzdWx0IHBhZ2VzIHNvbWV0aW1lcyBkbyBub3QgaW5jbHVkZSBhIG1ldGEgdmlld3BvcnQgdGFnIGV2ZW5cbiAgICAgICAgLy8gdGhvdWdoIHRoZXkgYXJlIGNlcnRhaW5seSBtb2Rlcm4gYW5kIHdvcmsgcHJvcGVybHkgd2l0aCBkZXZpY2VQaXhlbFJhdGlvLlxuICAgICAgICBpZiAoKF9hID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmdldEF0dHJpYnV0ZSgnaXRlbXR5cGUnKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmluY2x1ZGVzKCdzY2hlbWEub3JnL1NlYXJjaFJlc3VsdHNQYWdlJykpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGFzID0gZG9jdW1lbnQuaGVhZCAhPSBudWxsID9cbiAgICAgICAgICAgIEFycmF5LmZyb20oZG9jdW1lbnQuaGVhZC5xdWVyeVNlbGVjdG9yQWxsKCdtZXRhJykpIDpcbiAgICAgICAgICAgIFtdO1xuICAgICAgICBmb3IgKGNvbnN0IG1ldGEgb2YgbWV0YXMpIHtcbiAgICAgICAgICAgIGlmIChtZXRhLm5hbWUgPT09ICd2aWV3cG9ydCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSkoKTtcbiAgICBpZiAoIUhBU19NRVRBX1ZJRVdQT1JUX1RBRykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ05vIDxtZXRhIG5hbWU9XCJ2aWV3cG9ydFwiPiBkZXRlY3RlZDsgPG1vZGVsLXZpZXdlcj4gd2lsbCBjYXAgcGl4ZWwgZGVuc2l0eSBhdCAxLicpO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4gSEFTX01FVEFfVklFV1BPUlRfVEFHID8gd2luZG93LmRldmljZVBpeGVsUmF0aW8gOlxuICAgICAgICBDQVBQRURfREVWSUNFX1BJWEVMX1JBVElPO1xufSkoKTtcbi8qKlxuICogRGVidWcgbW9kZSBpcyBlbmFibGVkIHdoZW4gb25lIG9mIHRoZSB0d28gZm9sbG93aW5nIGNvbmRpdGlvbnMgaXMgdHJ1ZTpcbiAqXG4gKiAgMS4gQSAnbW9kZWwtdmlld2VyLWRlYnVnLW1vZGUnIHF1ZXJ5IHBhcmFtZXRlciBpcyBwcmVzZW50IGluIHRoZSBjdXJyZW50XG4gKiAgICAgc2VhcmNoIHN0cmluZ1xuICogIDIuIFRoZXJlIGlzIGEgZ2xvYmFsIG9iamVjdCBNb2RlbFZpZXdlckVsZW1lbnQgd2l0aCBhIGRlYnVnTW9kZSBwcm9wZXJ0eSBzZXRcbiAqICAgICB0byB0cnVlXG4gKi9cbmV4cG9ydCBjb25zdCBpc0RlYnVnTW9kZSA9ICgoKSA9PiB7XG4gICAgY29uc3QgZGVidWdRdWVyeVBhcmFtZXRlck5hbWUgPSAnbW9kZWwtdmlld2VyLWRlYnVnLW1vZGUnO1xuICAgIGNvbnN0IGRlYnVnUXVlcnlQYXJhbWV0ZXIgPSBuZXcgUmVnRXhwKGBbPyZdJHtkZWJ1Z1F1ZXJ5UGFyYW1ldGVyTmFtZX0oJnwkKWApO1xuICAgIHJldHVybiAoKSA9PiAoc2VsZi5Nb2RlbFZpZXdlckVsZW1lbnQgJiZcbiAgICAgICAgc2VsZi5Nb2RlbFZpZXdlckVsZW1lbnQuZGVidWdNb2RlKSB8fFxuICAgICAgICAoc2VsZi5sb2NhdGlvbiAmJiBzZWxmLmxvY2F0aW9uLnNlYXJjaCAmJlxuICAgICAgICAgICAgc2VsZi5sb2NhdGlvbi5zZWFyY2gubWF0Y2goZGVidWdRdWVyeVBhcmFtZXRlcikpO1xufSkoKTtcbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3Qga2V5IGluIGEgTWFwIGluIGl0ZXJhdGlvbiBvcmRlci5cbiAqXG4gKiBOT1RFKGNkYXRhKTogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBJRTExIGRvZXMgbm90IGltcGxlbWVudCBpdGVyYXRvclxuICogbWV0aG9kcyBvZiBNYXAsIGFuZCBwb2x5bWVyLWJ1aWxkIGRvZXMgbm90IHBvbHlmaWxsIHRoZXNlIG1ldGhvZHMgZm9yXG4gKiBjb21wYXRpYmlsaXR5IGFuZCBwZXJmb3JtYW5jZSByZWFzb25zLiBUaGlzIGhlbHBlciBwcm9wb3NlcyB0aGF0IGl0IGlzXG4gKiBhIHJlYXNvbmFibGUgY29tcHJvbWlzZSB0byBzYWNyaWZpY2UgYSB2ZXJ5IHNtYWxsIGFtb3VudCBvZiBydW50aW1lXG4gKiBwZXJmb3JtYW5jZSBpbiBJRTExIGZvciB0aGUgc2FrZSBvZiBjb2RlIGNsYXJpdHkuXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRGaXJzdE1hcEtleSA9IChtYXApID0+IHtcbiAgICBpZiAobWFwLmtleXMgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbWFwLmtleXMoKS5uZXh0KCkudmFsdWUgfHwgbnVsbDtcbiAgICB9XG4gICAgbGV0IGZpcnN0S2V5ID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgICBtYXAuZm9yRWFjaCgoX3ZhbHVlLCBrZXksIF9tYXApID0+IHtcbiAgICAgICAgICAgIGZpcnN0S2V5ID0ga2V5O1xuICAgICAgICAgICAgLy8gU3RvcCBpdGVyYXRpbmcgdGhlIE1hcCB3aXRoIGZvckVhY2g6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoIChfZXJyb3IpIHtcbiAgICB9XG4gICAgcmV0dXJuIGZpcnN0S2V5O1xufTtcbmV4cG9ydCBjb25zdCB0aW1lUGFzc2VzID0gKG1zID0gMCkgPT4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG4vKipcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR8RXZlbnREaXNwYXRjaGVyfSB0YXJnZXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAqIEBwYXJhbSB7P0Z1bmN0aW9ufSBwcmVkaWNhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IHdhaXRGb3JFdmVudCA9ICh0YXJnZXQsIGV2ZW50TmFtZSwgcHJlZGljYXRlID0gbnVsbCkgPT4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgZnVuY3Rpb24gaGFuZGxlcihldmVudCkge1xuICAgICAgICBpZiAoIXByZWRpY2F0ZSB8fCBwcmVkaWNhdGUoZXZlbnQpKSB7XG4gICAgICAgICAgICByZXNvbHZlKGV2ZW50KTtcbiAgICAgICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyKTtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbGl0aWVzLmpzLm1hcCIsIi8qIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICdMaWNlbnNlJyk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gJ0FTIElTJyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IGNsYW1wIH0gZnJvbSAnLi4vdXRpbGl0aWVzJztcbi8vIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9ncmUvMTY1MDI5NFxuZXhwb3J0IGNvbnN0IGVhc2VJbk91dFF1YWQgPSAodCkgPT4gdCA8IC41ID8gMiAqIHQgKiB0IDogLTEgKyAoNCAtIDIgKiB0KSAqIHQ7XG4vKipcbiAqIENyZWF0ZXMgYSBUaW1pbmdGdW5jdGlvbiB0aGF0IHVzZXMgYSBnaXZlbiBlYXNlIHRvIGludGVycG9sYXRlIGJldHdlZW5cbiAqIHR3byBjb25maWd1cmVkIG51bWJlciB2YWx1ZXMuXG4gKi9cbmV4cG9ydCBjb25zdCBpbnRlcnBvbGF0ZSA9IChzdGFydCwgZW5kLCBlYXNlID0gZWFzZUluT3V0UXVhZCkgPT4gKHRpbWUpID0+IHN0YXJ0ICsgKGVuZCAtIHN0YXJ0KSAqIGVhc2UodGltZSk7XG4vKipcbiAqIENyZWF0ZXMgYSBUaW1pbmdGdW5jdGlvbiB0aGF0IGludGVycG9sYXRlcyB0aHJvdWdoIGEgd2VpZ2h0ZWQgbGlzdFxuICogb2Ygb3RoZXIgVGltaW5nRnVuY3Rpb25zIChcInRyYWNrc1wiKS4gVHJhY2tzIGFyZSBpbnRlcnBvbGF0ZWQgaW4gb3JkZXIsIGFuZFxuICogYWxsb2NhdGVkIGEgcGVyY2VudGFnZSBvZiB0aGUgdG90YWwgdGltZSBiYXNlZCBvbiB0aGVpciByZWxhdGl2ZSB3ZWlnaHQuXG4gKi9cbmV4cG9ydCBjb25zdCBzZXF1ZW5jZSA9ICh0cmFja3MsIHdlaWdodHMpID0+IHtcbiAgICBjb25zdCBjdW11bGF0aXZlU3VtID0gKChzdW0pID0+ICh2YWx1ZSkgPT4gc3VtICs9IHZhbHVlKTtcbiAgICBjb25zdCB0aW1lcyA9IHdlaWdodHMubWFwKGN1bXVsYXRpdmVTdW0oMCkpO1xuICAgIHJldHVybiAodGltZSkgPT4ge1xuICAgICAgICB0aW1lID0gY2xhbXAodGltZSwgMCwgMSk7XG4gICAgICAgIHRpbWUgKj0gdGltZXNbdGltZXMubGVuZ3RoIC0gMV07XG4gICAgICAgIGNvbnN0IGkgPSB0aW1lcy5maW5kSW5kZXgoKHZhbCkgPT4gdmFsID49IHRpbWUpO1xuICAgICAgICBjb25zdCBzdGFydCA9IGkgPCAxID8gMCA6IHRpbWVzW2kgLSAxXTtcbiAgICAgICAgY29uc3QgZW5kID0gdGltZXNbaV07XG4gICAgICAgIHJldHVybiB0cmFja3NbaV0oKHRpbWUgLSBzdGFydCkgLyAoZW5kIC0gc3RhcnQpKTtcbiAgICB9O1xufTtcbi8qKlxuICogQ3JlYXRlcyBhIFwidGltZWxpbmVcIiBUaW1pbmdGdW5jdGlvbiBvdXQgb2YgYW4gaW5pdGlhbCB2YWx1ZSBhbmQgYSBzZXJpZXMgb2ZcbiAqIEtleWZyYW1lcy4gVGhlIHRpbWVsaW5lIGZ1bmN0aW9uIGFjY2VwdHMgdmFsdWUgZnJvbSAwLTEgYW5kIHJldHVybnMgdGhlXG4gKiBjdXJyZW50IHZhbHVlIGJhc2VkIG9uIGtleWZyYW1lIGludGVycG9sYXRpb24gYWNyb3NzIHRoZSB0b3RhbCBudW1iZXIgb2ZcbiAqIGZyYW1lcy4gRnJhbWVzIGFyZSBvbmx5IHVzZWQgdG8gaW5kaWNhdGUgdGhlIHJlbGF0aXZlIGxlbmd0aCBvZiBlYWNoIGtleWZyYW1lXG4gKiB0cmFuc2l0aW9uLCBzbyBpbnRlcnBvbGF0ZWQgdmFsdWVzIHdpbGwgYmUgY29tcHV0ZWQgZm9yIGZyYWN0aW9uYWwgZnJhbWVzLlxuICovXG5leHBvcnQgY29uc3QgdGltZWxpbmUgPSAocGF0aCkgPT4ge1xuICAgIGNvbnN0IHRyYWNrcyA9IFtdO1xuICAgIGNvbnN0IHdlaWdodHMgPSBbXTtcbiAgICBsZXQgbGFzdFZhbHVlID0gcGF0aC5pbml0aWFsVmFsdWU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmtleWZyYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBrZXlmcmFtZSA9IHBhdGgua2V5ZnJhbWVzW2ldO1xuICAgICAgICBjb25zdCB7IHZhbHVlLCBmcmFtZXMgfSA9IGtleWZyYW1lO1xuICAgICAgICBjb25zdCBlYXNlID0ga2V5ZnJhbWUuZWFzZSB8fCBlYXNlSW5PdXRRdWFkO1xuICAgICAgICBjb25zdCB0cmFjayA9IGludGVycG9sYXRlKGxhc3RWYWx1ZSwgdmFsdWUsIGVhc2UpO1xuICAgICAgICB0cmFja3MucHVzaCh0cmFjayk7XG4gICAgICAgIHdlaWdodHMucHVzaChmcmFtZXMpO1xuICAgICAgICBsYXN0VmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHNlcXVlbmNlKHRyYWNrcywgd2VpZ2h0cyk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YW5pbWF0aW9uLmpzLm1hcCIsIi8qIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICdMaWNlbnNlJyk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gJ0FTIElTJyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBfYSwgX2I7XG5jb25zdCAkcmV0YWluZXJDb3VudCA9IFN5bWJvbCgncmV0YWluZXJDb3VudCcpO1xuY29uc3QgJHJlY2VudGx5VXNlZCA9IFN5bWJvbCgncmVjZW50bHlVc2VkJyk7XG5jb25zdCAkZXZpY3QgPSBTeW1ib2woJ2V2aWN0Jyk7XG5jb25zdCAkZXZpY3Rpb25UaHJlc2hvbGQgPSBTeW1ib2woJ2V2aWN0aW9uVGhyZXNob2xkJyk7XG5jb25zdCAkY2FjaGUgPSBTeW1ib2woJ2NhY2hlJyk7XG4vKipcbiAqIFRoZSBDYWNoZUV2aWN0aW9uUG9saWN5IG1hbmFnZXMgdGhlIGxpZmVjeWNsZSBmb3IgaXRlbXMgaW4gYSBjYWNoZSxcbiAqIGV2aWN0aW5nIGFueSBpdGVtcyBvdXRzaWRlIHNvbWUgdGhyZXNob2xkIGJvdW5kcyBpbiBcInJlY2VudGx5IHVzZWRcIiBvcmRlcixcbiAqIGlmIHRoZXkgYXJlIGV2aWN0YWJsZS5cbiAqXG4gKiBJdGVtcyBhcmUgY29uc2lkZXJlZCBjYWNoZWQgYXMgdGhleSBhcmUgcmV0YWluZWQuIFdoZW4gYWxsIHJldGFpbmVyc1xuICogb2YgYW4gaXRlbSByZWxlYXNlIGl0LCB0aGF0IGl0ZW0gaXMgY29uc2lkZXJlZCBldmljdGFibGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBDYWNoZUV2aWN0aW9uUG9saWN5IHtcbiAgICBjb25zdHJ1Y3RvcihjYWNoZSwgZXZpY3Rpb25UaHJlc2hvbGQgPSA1KSB7XG4gICAgICAgIHRoaXNbX2FdID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzW19iXSA9IFtdO1xuICAgICAgICB0aGlzWyRjYWNoZV0gPSBjYWNoZTtcbiAgICAgICAgdGhpc1skZXZpY3Rpb25UaHJlc2hvbGRdID0gZXZpY3Rpb25UaHJlc2hvbGQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBldmljdGlvbiB0aHJlc2hvbGQgaXMgdGhlIG1heGltdW0gbnVtYmVyIG9mIGl0ZW1zIHRvIGhvbGRcbiAgICAgKiBpbiBjYWNoZSBpbmRlZmluaXRlbHkuIEl0ZW1zIHdpdGhpbiB0aGUgdGhyZXNob2xkIChpbiByZWNlbnRseVxuICAgICAqIHVzZWQgb3JkZXIpIHdpbGwgY29udGludWUgdG8gYmUgY2FjaGVkIGV2ZW4gaWYgdGhleSBoYXZlIHplcm9cbiAgICAgKiByZXRhaW5lcnMuXG4gICAgICovXG4gICAgc2V0IGV2aWN0aW9uVGhyZXNob2xkKHZhbHVlKSB7XG4gICAgICAgIHRoaXNbJGV2aWN0aW9uVGhyZXNob2xkXSA9IHZhbHVlO1xuICAgICAgICB0aGlzWyRldmljdF0oKTtcbiAgICB9XG4gICAgZ2V0IGV2aWN0aW9uVGhyZXNob2xkKCkge1xuICAgICAgICByZXR1cm4gdGhpc1skZXZpY3Rpb25UaHJlc2hvbGRdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgY2FjaGUgdGhhdCBvcGVyYXRlcyB1bmRlciB0aGlzIHBvbGljeVxuICAgICAqL1xuICAgIGdldCBjYWNoZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbJGNhY2hlXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYW4gaXRlbSBrZXksIHJldHVybnMgdGhlIG51bWJlciBvZiByZXRhaW5lcnMgb2YgdGhhdCBpdGVtXG4gICAgICovXG4gICAgcmV0YWluZXJDb3VudChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbJHJldGFpbmVyQ291bnRdLmdldChrZXkpIHx8IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgaW50ZXJuYWwgdHJhY2tpbmcgb2YgY2FjaGUgaXRlbSByZXRhaW5lcnMuIFVzZSBvbmx5IGluIGNhc2VzXG4gICAgICogd2hlcmUgaXQgaXMgY2VydGFpbiB0aGF0IGFsbCByZXRhaW5lZCBjYWNoZSBpdGVtcyBoYXZlIGJlZW4gYWNjb3VudGVkIGZvciFcbiAgICAgKi9cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpc1skcmV0YWluZXJDb3VudF0uY2xlYXIoKTtcbiAgICAgICAgdGhpc1skcmVjZW50bHlVc2VkXSA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXJrIGEgZ2l2ZW4gY2FjaGUgaXRlbSBhcyByZXRhaW5lZCwgd2hlcmUgdGhlIGl0ZW0gaXMgcmVwcmVzZW50ZWRcbiAgICAgKiBieSBpdHMga2V5LiBBbiBpdGVtIGNhbiBoYXZlIGFueSBudW1iZXIgb2YgcmV0YWluZXJzLlxuICAgICAqL1xuICAgIHJldGFpbihrZXkpIHtcbiAgICAgICAgaWYgKCF0aGlzWyRyZXRhaW5lckNvdW50XS5oYXMoa2V5KSkge1xuICAgICAgICAgICAgdGhpc1skcmV0YWluZXJDb3VudF0uc2V0KGtleSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1skcmV0YWluZXJDb3VudF0uc2V0KGtleSwgdGhpc1skcmV0YWluZXJDb3VudF0uZ2V0KGtleSkgKyAxKTtcbiAgICAgICAgY29uc3QgcmVjZW50bHlVc2VkSW5kZXggPSB0aGlzWyRyZWNlbnRseVVzZWRdLmluZGV4T2Yoa2V5KTtcbiAgICAgICAgaWYgKHJlY2VudGx5VXNlZEluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpc1skcmVjZW50bHlVc2VkXS5zcGxpY2UocmVjZW50bHlVc2VkSW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbJHJlY2VudGx5VXNlZF0udW5zaGlmdChrZXkpO1xuICAgICAgICAvLyBFdmljdCwgaW4gY2FzZSByZXRhaW5pbmcgYSBuZXcgaXRlbSBwdXNoZWQgYW4gZXZpY3RhYmxlIGl0ZW0gYmV5b25kIHRoZVxuICAgICAgICAvLyBldmljdGlvbiB0aHJlc2hvbGRcbiAgICAgICAgdGhpc1skZXZpY3RdKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hcmsgYSBnaXZlbiBjYWNoZSBpdGVtIGFzIHJlbGVhc2VkIGJ5IG9uZSBvZiBpdHMgcmV0YWluZXJzLCB3aGVyZSB0aGUgaXRlbVxuICAgICAqIGlzIHJlcHJlc2VudGVkIGJ5IGl0cyBrZXkuIFdoZW4gYWxsIHJldGFpbmVycyBvZiBhbiBpdGVtIGhhdmUgcmVsZWFzZWQgaXQsXG4gICAgICogdGhlIGl0ZW0gaXMgY29uc2lkZXJlZCBldmljdGFibGUuXG4gICAgICovXG4gICAgcmVsZWFzZShrZXkpIHtcbiAgICAgICAgaWYgKHRoaXNbJHJldGFpbmVyQ291bnRdLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICB0aGlzWyRyZXRhaW5lckNvdW50XS5zZXQoa2V5LCBNYXRoLm1heCh0aGlzWyRyZXRhaW5lckNvdW50XS5nZXQoa2V5KSAtIDEsIDApKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzWyRldmljdF0oKTtcbiAgICB9XG4gICAgWyhfYSA9ICRyZXRhaW5lckNvdW50LCBfYiA9ICRyZWNlbnRseVVzZWQsICRldmljdCldKCkge1xuICAgICAgICBpZiAodGhpc1skcmVjZW50bHlVc2VkXS5sZW5ndGggPCB0aGlzWyRldmljdGlvblRocmVzaG9sZF0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gdGhpc1skcmVjZW50bHlVc2VkXS5sZW5ndGggLSAxOyBpID49IHRoaXNbJGV2aWN0aW9uVGhyZXNob2xkXTsgLS1pKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSB0aGlzWyRyZWNlbnRseVVzZWRdW2ldO1xuICAgICAgICAgICAgY29uc3QgcmV0YWluZXJDb3VudCA9IHRoaXNbJHJldGFpbmVyQ291bnRdLmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKHJldGFpbmVyQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzWyRjYWNoZV0uZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgdGhpc1skcmVjZW50bHlVc2VkXS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYWNoZS1ldmljdGlvbi1wb2xpY3kuanMubWFwIiwiLyogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgJ0xpY2Vuc2UnKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAnQVMgSVMnIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBDb252ZXJ0cyBhIGJhc2U2NCBzdHJpbmcgd2hpY2ggcmVwcmVzZW50cyBhIGRhdGEgdXJsXG4gKiBpbnRvIGEgQmxvYiBvZiB0aGUgc2FtZSBjb250ZW50cy5cbiAqL1xuZXhwb3J0IGNvbnN0IGRhdGFVcmxUb0Jsb2IgPSBhc3luYyAoYmFzZTY0RGF0YVVybCkgPT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHNsaWNlU2l6ZSA9IDUxMjtcbiAgICAgICAgY29uc3QgdHlwZU1hdGNoID0gYmFzZTY0RGF0YVVybC5tYXRjaCgvZGF0YTooLiopOy8pO1xuICAgICAgICBpZiAoIXR5cGVNYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoYCR7YmFzZTY0RGF0YVVybH0gaXMgbm90IGEgdmFsaWQgZGF0YSBVcmxgKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHlwZSA9IHR5cGVNYXRjaFsxXTtcbiAgICAgICAgY29uc3QgYmFzZTY0ID0gYmFzZTY0RGF0YVVybC5yZXBsYWNlKC9kYXRhOmltYWdlXFwvXFx3KztiYXNlNjQsLywgJycpO1xuICAgICAgICBjb25zdCBieXRlQ2hhcmFjdGVycyA9IGF0b2IoYmFzZTY0KTtcbiAgICAgICAgY29uc3QgYnl0ZUFycmF5cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBvZmZzZXQgPSAwOyBvZmZzZXQgPCBieXRlQ2hhcmFjdGVycy5sZW5ndGg7IG9mZnNldCArPSBzbGljZVNpemUpIHtcbiAgICAgICAgICAgIGNvbnN0IHNsaWNlID0gYnl0ZUNoYXJhY3RlcnMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBzbGljZVNpemUpO1xuICAgICAgICAgICAgY29uc3QgYnl0ZU51bWJlcnMgPSBuZXcgQXJyYXkoc2xpY2UubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2xpY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBieXRlTnVtYmVyc1tpXSA9IHNsaWNlLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBieXRlQXJyYXkgPSBuZXcgVWludDhBcnJheShieXRlTnVtYmVycyk7XG4gICAgICAgICAgICBieXRlQXJyYXlzLnB1c2goYnl0ZUFycmF5KTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKG5ldyBCbG9iKGJ5dGVBcnJheXMsIHsgdHlwZSB9KSk7XG4gICAgfSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YS1jb252ZXJzaW9uLmpzLm1hcCIsIi8qIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICdMaWNlbnNlJyk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gJ0FTIElTJyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IGNsYW1wIH0gZnJvbSAnLi4vdXRpbGl0aWVzLmpzJztcbi8qKlxuICogUHJvZ3Jlc3NUcmFja2VyIGlzIGFuIGV2ZW50IGVtaXR0ZXIgdGhhdCBoZWxwcyB0byB0cmFjayB0aGUgb25nb2luZyBwcm9ncmVzc1xuICogb2YgbWFueSBzaW11bHRhbmVvdXMgYWN0aW9ucy5cbiAqXG4gKiBQcm9ncmVzc1RyYWNrZXIgcmVwb3J0cyBwcm9ncmVzcyBhY3Rpdml0eSBpbiB0aGUgZm9ybSBvZiBhIHByb2dyZXNzIGV2ZW50LlxuICogVGhlIGV2ZW50LmRldGFpbC50b3RhbFByb2dyZXNzIHZhbHVlIGluZGljYXRlcyB0aGUgZWxhcHNlZCBwcm9ncmVzcyBvZiBhbGxcbiAqIGFjdGl2aXRpZXMgYmVpbmcgdHJhY2tlZCBieSB0aGUgUHJvZ3Jlc3NUcmFja2VyLlxuICpcbiAqIFRoZSB2YWx1ZSBvZiB0b3RhbFByb2dyZXNzIGlzIGEgbnVtYmVyIHRoYXQgcHJvZ3Jlc3NlcyBmcm9tIDAgdG8gMS4gVGhlXG4gKiBQcm9ncmVzc1RyYWNrZXIgYWxsb3dzIGZvciB0aGUgbGF6eSBhY2N1bXVsYXRpb24gb2YgdHJhY2tlZCBhY3Rpb25zLCBzbyB0aGVcbiAqIHRvdGFsIHByb2dyZXNzIHJlcHJlc2VudHMgYSBhYnN0cmFjdCwgbm9uLWFic29sdXRlIHByb2dyZXNzIHRvd2FyZHMgdGhlXG4gKiBjb21wbGV0aW9uIG9mIGFsbCBjdXJyZW50bHkgdHJhY2tlZCBldmVudHMuXG4gKlxuICogV2hlbiBhbGwgY3VycmVudGx5IHRyYWNrZWQgYWN0aXZpdGllcyBhcmUgZmluaXNoZWQsIHRoZSBQcm9ncmVzc1RyYWNrZXJcbiAqIGVtaXRzIG9uZSBmaW5hbCBwcm9ncmVzcyBldmVudCBhbmQgdGhlbiByZXNldHMgdGhlIGxpc3Qgb2YgaXRzIGN1cnJlbnRseVxuICogdHJhY2tlZCBhY3Rpdml0aWVzLiBUaGlzIG1lYW5zIHRoYXQgZnJvbSBhbiBvYnNlcnZlcidzIHBlcnNwZWN0aXZlLFxuICogb25nb2luZyBhY3Rpdml0aWVzIHdpbGwgYWNjdW11bGF0ZSBhbmQgY29sbGVjdGl2ZWx5IGNvbnRyaWJ1dGUgdG8gdGhlIG5vdGlvblxuICogb2YgdG90YWwgcHJvZ3Jlc3MgdW50aWwgYWxsIGN1cnJlbnRseSB0cmFja2VkIG9uZ29pbmcgYWN0aXZpdGllcyBoYXZlXG4gKiBjb21wbGV0ZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBQcm9ncmVzc1RyYWNrZXIgZXh0ZW5kcyBFdmVudFRhcmdldCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMub25nb2luZ0FjdGl2aXRpZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMudG90YWxQcm9ncmVzcyA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSB0b3RhbCBudW1iZXIgb2YgYWN0aXZpdGllcyBjdXJyZW50bHkgYmVpbmcgdHJhY2tlZC5cbiAgICAgKi9cbiAgICBnZXQgb25nb2luZ0FjdGl2aXR5Q291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9uZ29pbmdBY3Rpdml0aWVzLnNpemU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIG5ldyBhY3Rpdml0eSB0byBiZSB0cmFja2VkIGJ5IHRoZSBwcm9ncmVzcyB0cmFja2VyLiBUaGUgbWV0aG9kXG4gICAgICogcmV0dXJucyBhIHNwZWNpYWwgY2FsbGJhY2sgdGhhdCBzaG91bGQgYmUgaW52b2tlZCB3aGVuZXZlciBuZXcgcHJvZ3Jlc3MgaXNcbiAgICAgKiByZWFkeSB0byBiZSByZXBvcnRlZC4gVGhlIHByb2dyZXNzIHNob3VsZCBiZSByZXBvcnRlZCBhcyBhIHZhbHVlIGJldHdlZW4gMFxuICAgICAqIGFuZCAxLCB3aGVyZSAwIHdvdWxkIHJlcHJlc2VudCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhY3Rpb24gYW5kIDEgd291bGRcbiAgICAgKiByZXByZXNlbnQgaXRzIGNvbXBsZXRpb24uXG4gICAgICpcbiAgICAgKiBUaGVyZSBpcyBubyBidWlsdC1pbiBub3Rpb24gb2YgYSB0aW1lLW91dCBmb3Igb25nb2luZyBhY3Rpdml0aWVzLCBzbyBvbmNlXG4gICAgICogYW4gb25nb2luZyBhY3Rpdml0eSBpcyBiZWd1biwgaXQgaXMgdXAgdG8gdGhlIGNvbnN1bWVyIG9mIHRoaXMgQVBJIHRvXG4gICAgICogdXBkYXRlIHRoZSBwcm9ncmVzcyB1bnRpbCB0aGF0IGFjdGl2aXR5IGlzIG5vIGxvbmdlciBvbmdvaW5nLlxuICAgICAqXG4gICAgICogUHJvZ3Jlc3MgaXMgb25seSBhbGxvd2VkIHRvIG1vdmUgZm9yd2FyZCBmb3IgYW55IGdpdmVuIGFjdGl2aXR5LiBJZiBhIGxvd2VyXG4gICAgICogcHJvZ3Jlc3MgaXMgcmVwb3J0ZWQgdGhhbiB0aGUgcHJldmlvdXNseSByZXBvcnRlZCBwcm9ncmVzcywgaXQgd2lsbCBiZVxuICAgICAqIGlnbm9yZWQuXG4gICAgICovXG4gICAgYmVnaW5BY3Rpdml0eSgpIHtcbiAgICAgICAgY29uc3QgYWN0aXZpdHkgPSB7IHByb2dyZXNzOiAwLCBjb21wbGV0ZWQ6IGZhbHNlIH07XG4gICAgICAgIHRoaXMub25nb2luZ0FjdGl2aXRpZXMuYWRkKGFjdGl2aXR5KTtcbiAgICAgICAgaWYgKHRoaXMub25nb2luZ0FjdGl2aXR5Q291bnQgPT09IDEpIHtcbiAgICAgICAgICAgIC8vIEFubm91bmNlIHRoZSBmaXJzdCBwcm9ncmVzcyBldmVudCAod2hpY2ggc2hvdWxkIGFsd2F5cyBiZSAwIC8gMVxuICAgICAgICAgICAgLy8gdG90YWwgcHJvZ3Jlc3MpOlxuICAgICAgICAgICAgdGhpcy5hbm5vdW5jZVRvdGFsUHJvZ3Jlc3MoYWN0aXZpdHksIDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAocHJvZ3Jlc3MpID0+IHtcbiAgICAgICAgICAgIGxldCBuZXh0UHJvZ3Jlc3M7XG4gICAgICAgICAgICBuZXh0UHJvZ3Jlc3MgPSBNYXRoLm1heChjbGFtcChwcm9ncmVzcywgMCwgMSksIGFjdGl2aXR5LnByb2dyZXNzKTtcbiAgICAgICAgICAgIGlmIChuZXh0UHJvZ3Jlc3MgIT09IGFjdGl2aXR5LnByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbm5vdW5jZVRvdGFsUHJvZ3Jlc3MoYWN0aXZpdHksIG5leHRQcm9ncmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWN0aXZpdHkucHJvZ3Jlc3M7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGFubm91bmNlVG90YWxQcm9ncmVzcyh1cGRhdGVkQWN0aXZpdHksIG5leHRQcm9ncmVzcykge1xuICAgICAgICBsZXQgcHJvZ3Jlc3NMZWZ0ID0gMDtcbiAgICAgICAgbGV0IGNvbXBsZXRlZEFjdGl2aXRpZXMgPSAwO1xuICAgICAgICBpZiAobmV4dFByb2dyZXNzID09IDEuMClcbiAgICAgICAgICAgIHVwZGF0ZWRBY3Rpdml0eS5jb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICBmb3IgKGNvbnN0IGFjdGl2aXR5IG9mIHRoaXMub25nb2luZ0FjdGl2aXRpZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcHJvZ3Jlc3MgfSA9IGFjdGl2aXR5O1xuICAgICAgICAgICAgcHJvZ3Jlc3NMZWZ0ICs9IDEuMCAtIHByb2dyZXNzO1xuICAgICAgICAgICAgaWYgKGFjdGl2aXR5LmNvbXBsZXRlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlZEFjdGl2aXRpZXMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYXN0UHJvZ3Jlc3MgPSB1cGRhdGVkQWN0aXZpdHkucHJvZ3Jlc3M7XG4gICAgICAgIHVwZGF0ZWRBY3Rpdml0eS5wcm9ncmVzcyA9IG5leHRQcm9ncmVzcztcbiAgICAgICAgLy8gQWR2YW5jZSB0aGUgdG90YWwgcHJvZ3Jlc3MgYnkgdGhlIGZyYWN0aW9uIG9mIHRvdGFsIHJlbWFpbmluZyBwcm9ncmVzc1xuICAgICAgICAvLyBkdWUgdG8gdGhpcyBhY3Rpdml0eS5cbiAgICAgICAgdGhpcy50b3RhbFByb2dyZXNzICs9IChuZXh0UHJvZ3Jlc3MgLSBsYXN0UHJvZ3Jlc3MpICpcbiAgICAgICAgICAgICgxLjAgLSB0aGlzLnRvdGFsUHJvZ3Jlc3MpIC8gcHJvZ3Jlc3NMZWZ0O1xuICAgICAgICBjb25zdCB0b3RhbFByb2dyZXNzID0gY29tcGxldGVkQWN0aXZpdGllcyA9PT0gdGhpcy5vbmdvaW5nQWN0aXZpdHlDb3VudCA/XG4gICAgICAgICAgICAxLjAgOlxuICAgICAgICAgICAgdGhpcy50b3RhbFByb2dyZXNzO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdwcm9ncmVzcycsIHsgZGV0YWlsOiB7IHRvdGFsUHJvZ3Jlc3MgfSB9KSk7XG4gICAgICAgIGlmIChjb21wbGV0ZWRBY3Rpdml0aWVzID09PSB0aGlzLm9uZ29pbmdBY3Rpdml0eUNvdW50KSB7XG4gICAgICAgICAgICB0aGlzLnRvdGFsUHJvZ3Jlc3MgPSAwLjA7XG4gICAgICAgICAgICB0aGlzLm9uZ29pbmdBY3Rpdml0aWVzLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9ncmVzcy10cmFja2VyLmpzLm1hcCIsImZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuICAgIGkgJSAyID8gb3duS2V5cyhPYmplY3Qoc291cmNlKSwgITApLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSkgOiBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gIH0gOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgfSwgX3R5cGVvZihvYmopO1xufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG52YXIgdmVuZG9yUHJlZml4O1xudmFyIGpzQ3NzTWFwID0ge1xuICBXZWJraXQ6ICctd2Via2l0LScsXG4gIE1vejogJy1tb3otJyxcbiAgLy8gSUUgZGlkIGl0IHdyb25nIGFnYWluIC4uLlxuICBtczogJy1tcy0nLFxuICBPOiAnLW8tJ1xufTtcbmZ1bmN0aW9uIGdldFZlbmRvclByZWZpeCgpIHtcbiAgaWYgKHZlbmRvclByZWZpeCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHZlbmRvclByZWZpeDtcbiAgfVxuICB2ZW5kb3JQcmVmaXggPSAnJztcbiAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpLnN0eWxlO1xuICB2YXIgdGVzdFByb3AgPSAnVHJhbnNmb3JtJztcbiAgZm9yICh2YXIga2V5IGluIGpzQ3NzTWFwKSB7XG4gICAgaWYgKGtleSArIHRlc3RQcm9wIGluIHN0eWxlKSB7XG4gICAgICB2ZW5kb3JQcmVmaXggPSBrZXk7XG4gICAgfVxuICB9XG4gIHJldHVybiB2ZW5kb3JQcmVmaXg7XG59XG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uTmFtZSgpIHtcbiAgcmV0dXJuIGdldFZlbmRvclByZWZpeCgpID8gXCJcIi5jb25jYXQoZ2V0VmVuZG9yUHJlZml4KCksIFwiVHJhbnNpdGlvblByb3BlcnR5XCIpIDogJ3RyYW5zaXRpb25Qcm9wZXJ0eSc7XG59XG5mdW5jdGlvbiBnZXRUcmFuc2Zvcm1OYW1lKCkge1xuICByZXR1cm4gZ2V0VmVuZG9yUHJlZml4KCkgPyBcIlwiLmNvbmNhdChnZXRWZW5kb3JQcmVmaXgoKSwgXCJUcmFuc2Zvcm1cIikgOiAndHJhbnNmb3JtJztcbn1cbmZ1bmN0aW9uIHNldFRyYW5zaXRpb25Qcm9wZXJ0eShub2RlLCB2YWx1ZSkge1xuICB2YXIgbmFtZSA9IGdldFRyYW5zaXRpb25OYW1lKCk7XG4gIGlmIChuYW1lKSB7XG4gICAgbm9kZS5zdHlsZVtuYW1lXSA9IHZhbHVlO1xuICAgIGlmIChuYW1lICE9PSAndHJhbnNpdGlvblByb3BlcnR5Jykge1xuICAgICAgbm9kZS5zdHlsZS50cmFuc2l0aW9uUHJvcGVydHkgPSB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHNldFRyYW5zZm9ybShub2RlLCB2YWx1ZSkge1xuICB2YXIgbmFtZSA9IGdldFRyYW5zZm9ybU5hbWUoKTtcbiAgaWYgKG5hbWUpIHtcbiAgICBub2RlLnN0eWxlW25hbWVdID0gdmFsdWU7XG4gICAgaWYgKG5hbWUgIT09ICd0cmFuc2Zvcm0nKSB7XG4gICAgICBub2RlLnN0eWxlLnRyYW5zZm9ybSA9IHZhbHVlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvblByb3BlcnR5KG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuc3R5bGUudHJhbnNpdGlvblByb3BlcnR5IHx8IG5vZGUuc3R5bGVbZ2V0VHJhbnNpdGlvbk5hbWUoKV07XG59XG5mdW5jdGlvbiBnZXRUcmFuc2Zvcm1YWShub2RlKSB7XG4gIHZhciBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG5vZGUsIG51bGwpO1xuICB2YXIgdHJhbnNmb3JtID0gc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgndHJhbnNmb3JtJykgfHwgc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShnZXRUcmFuc2Zvcm1OYW1lKCkpO1xuICBpZiAodHJhbnNmb3JtICYmIHRyYW5zZm9ybSAhPT0gJ25vbmUnKSB7XG4gICAgdmFyIG1hdHJpeCA9IHRyYW5zZm9ybS5yZXBsYWNlKC9bXjAtOVxcLS4sXS9nLCAnJykuc3BsaXQoJywnKTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogcGFyc2VGbG9hdChtYXRyaXhbMTJdIHx8IG1hdHJpeFs0XSwgMCksXG4gICAgICB5OiBwYXJzZUZsb2F0KG1hdHJpeFsxM10gfHwgbWF0cml4WzVdLCAwKVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcbn1cbnZhciBtYXRyaXgyZCA9IC9tYXRyaXhcXCgoLiopXFwpLztcbnZhciBtYXRyaXgzZCA9IC9tYXRyaXgzZFxcKCguKilcXCkvO1xuZnVuY3Rpb24gc2V0VHJhbnNmb3JtWFkobm9kZSwgeHkpIHtcbiAgdmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUobm9kZSwgbnVsbCk7XG4gIHZhciB0cmFuc2Zvcm0gPSBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCd0cmFuc2Zvcm0nKSB8fCBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKGdldFRyYW5zZm9ybU5hbWUoKSk7XG4gIGlmICh0cmFuc2Zvcm0gJiYgdHJhbnNmb3JtICE9PSAnbm9uZScpIHtcbiAgICB2YXIgYXJyO1xuICAgIHZhciBtYXRjaDJkID0gdHJhbnNmb3JtLm1hdGNoKG1hdHJpeDJkKTtcbiAgICBpZiAobWF0Y2gyZCkge1xuICAgICAgbWF0Y2gyZCA9IG1hdGNoMmRbMV07XG4gICAgICBhcnIgPSBtYXRjaDJkLnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KGl0ZW0sIDEwKTtcbiAgICAgIH0pO1xuICAgICAgYXJyWzRdID0geHkueDtcbiAgICAgIGFycls1XSA9IHh5Lnk7XG4gICAgICBzZXRUcmFuc2Zvcm0obm9kZSwgXCJtYXRyaXgoXCIuY29uY2F0KGFyci5qb2luKCcsJyksIFwiKVwiKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtYXRjaDNkID0gdHJhbnNmb3JtLm1hdGNoKG1hdHJpeDNkKVsxXTtcbiAgICAgIGFyciA9IG1hdGNoM2Quc3BsaXQoJywnKS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoaXRlbSwgMTApO1xuICAgICAgfSk7XG4gICAgICBhcnJbMTJdID0geHkueDtcbiAgICAgIGFyclsxM10gPSB4eS55O1xuICAgICAgc2V0VHJhbnNmb3JtKG5vZGUsIFwibWF0cml4M2QoXCIuY29uY2F0KGFyci5qb2luKCcsJyksIFwiKVwiKSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNldFRyYW5zZm9ybShub2RlLCBcInRyYW5zbGF0ZVgoXCIuY29uY2F0KHh5LngsIFwicHgpIHRyYW5zbGF0ZVkoXCIpLmNvbmNhdCh4eS55LCBcInB4KSB0cmFuc2xhdGVaKDApXCIpKTtcbiAgfVxufVxuXG52YXIgUkVfTlVNID0gL1tcXC0rXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVtcXC0rXT9cXGQrfCkvLnNvdXJjZTtcbnZhciBnZXRDb21wdXRlZFN0eWxlWDtcblxuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM0ODU2NTQvMzA0MDYwNVxuZnVuY3Rpb24gZm9yY2VSZWxheW91dChlbGVtKSB7XG4gIHZhciBvcmlnaW5hbFN0eWxlID0gZWxlbS5zdHlsZS5kaXNwbGF5O1xuICBlbGVtLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIGVsZW0ub2Zmc2V0SGVpZ2h0OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIGVsZW0uc3R5bGUuZGlzcGxheSA9IG9yaWdpbmFsU3R5bGU7XG59XG5mdW5jdGlvbiBjc3MoZWwsIG5hbWUsIHYpIHtcbiAgdmFyIHZhbHVlID0gdjtcbiAgaWYgKF90eXBlb2YobmFtZSkgPT09ICdvYmplY3QnKSB7XG4gICAgZm9yICh2YXIgaSBpbiBuYW1lKSB7XG4gICAgICBpZiAobmFtZS5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICBjc3MoZWwsIGksIG5hbWVbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHZhbHVlID0gXCJcIi5jb25jYXQodmFsdWUsIFwicHhcIik7XG4gICAgfVxuICAgIGVsLnN0eWxlW25hbWVdID0gdmFsdWU7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZVgoZWwsIG5hbWUpO1xufVxuZnVuY3Rpb24gZ2V0Q2xpZW50UG9zaXRpb24oZWxlbSkge1xuICB2YXIgYm94O1xuICB2YXIgeDtcbiAgdmFyIHk7XG4gIHZhciBkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQ7XG4gIHZhciBib2R5ID0gZG9jLmJvZHk7XG4gIHZhciBkb2NFbGVtID0gZG9jICYmIGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gIC8vIOagueaNriBHQlMg5pyA5paw5pWw5o2u77yMQS1HcmFkZSBCcm93c2VycyDpg73lt7LmlK/mjIEgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IOaWueazle+8jOS4jeeUqOWGjeiAg+iZkeS8oOe7n+eahOWunueOsOaWueW8j1xuICBib3ggPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gIC8vIOazqO+8mmpRdWVyeSDov5jogIPomZHlh4/ljrsgZG9jRWxlbS5jbGllbnRMZWZ0L2NsaWVudFRvcFxuICAvLyDkvYbmtYvor5Xlj5HnjrDvvIzov5nmoLflj43ogIzkvJrlr7zoh7TlvZMgaHRtbCDlkowgYm9keSDmnInovrnot50v6L655qGG5qC35byP5pe277yM6I635Y+W55qE5YC85LiN5q2j56GuXG4gIC8vIOatpOWklu+8jGllNiDkvJrlv73nlaUgaHRtbCDnmoQgbWFyZ2luIOWAvO+8jOW5uOi/kOWcsOaYr+ayoeacieiwgeS8muWOu+iuvue9riBodG1sIOeahCBtYXJnaW5cblxuICB4ID0gTWF0aC5mbG9vcihib3gubGVmdCk7XG4gIHkgPSBNYXRoLmZsb29yKGJveC50b3ApO1xuXG4gIC8vIEluIElFLCBtb3N0IG9mIHRoZSB0aW1lLCAyIGV4dHJhIHBpeGVscyBhcmUgYWRkZWQgdG8gdGhlIHRvcCBhbmQgbGVmdFxuICAvLyBkdWUgdG8gdGhlIGltcGxpY2l0IDItcGl4ZWwgaW5zZXQgYm9yZGVyLiAgSW4gSUU2LzcgcXVpcmtzIG1vZGUgYW5kXG4gIC8vIElFNiBzdGFuZGFyZHMgbW9kZSwgdGhpcyBib3JkZXIgY2FuIGJlIG92ZXJyaWRkZW4gYnkgc2V0dGluZyB0aGVcbiAgLy8gZG9jdW1lbnQgZWxlbWVudCdzIGJvcmRlciB0byB6ZXJvIC0tIHRodXMsIHdlIGNhbm5vdCByZWx5IG9uIHRoZVxuICAvLyBvZmZzZXQgYWx3YXlzIGJlaW5nIDIgcGl4ZWxzLlxuXG4gIC8vIEluIHF1aXJrcyBtb2RlLCB0aGUgb2Zmc2V0IGNhbiBiZSBkZXRlcm1pbmVkIGJ5IHF1ZXJ5aW5nIHRoZSBib2R5J3NcbiAgLy8gY2xpZW50TGVmdC9jbGllbnRUb3AsIGJ1dCBpbiBzdGFuZGFyZHMgbW9kZSwgaXQgaXMgZm91bmQgYnkgcXVlcnlpbmdcbiAgLy8gdGhlIGRvY3VtZW50IGVsZW1lbnQncyBjbGllbnRMZWZ0L2NsaWVudFRvcC4gIFNpbmNlIHdlIGFscmVhZHkgY2FsbGVkXG4gIC8vIGdldENsaWVudEJvdW5kaW5nUmVjdCB3ZSBoYXZlIGFscmVhZHkgZm9yY2VkIGEgcmVmbG93LCBzbyBpdCBpcyBub3RcbiAgLy8gdG9vIGV4cGVuc2l2ZSBqdXN0IHRvIHF1ZXJ5IHRoZW0gYWxsLlxuXG4gIC8vIGllIOS4i+W6lOivpeWHj+WOu+eql+WPo+eahOi+ueahhuWQp++8jOavleern+m7mOiupCBhYnNvbHV0ZSDpg73mmK/nm7jlr7nnqpflj6PlrprkvY3nmoRcbiAgLy8g56qX5Y+j6L655qGG5qCH5YeG5piv6K6+IGRvY3VtZW50RWxlbWVudCAscXVpcmtzIOaXtuiuvue9riBib2R5XG4gIC8vIOacgOWlveemgeatouWcqCBib2R5IOWSjCBodG1sIOS4iui+ueahhiDvvIzkvYYgaWUgPCA5IGh0bWwg6buY6K6k5pyJIDJweCDvvIzlh4/ljrtcbiAgLy8g5L2G5piv6Z2eIGllIOS4jeWPr+iDveiuvue9rueql+WPo+i+ueahhu+8jGJvZHkgaHRtbCDkuZ/kuI3mmK/nqpflj6MgLGllIOWPr+S7pemAmui/hyBodG1sLGJvZHkg6K6+572uXG4gIC8vIOagh+WHhiBpZSDkuIsgZG9jRWxlbS5jbGllbnRUb3Ag5bCx5pivIGJvcmRlci10b3BcbiAgLy8gaWU3IGh0bWwg5Y2z56qX5Y+j6L655qGG5pS55Y+Y5LiN5LqG44CC5rC46L+c5Li6IDJcbiAgLy8g5L2G5qCH5YeGIGZpcmVmb3gvY2hyb21lL2llOSDkuIsgZG9jRWxlbS5jbGllbnRUb3Ag5piv56qX5Y+j6L655qGG77yM5Y2z5L2/6K6+5LqGIGJvcmRlci10b3Ag5Lmf5Li6IDBcblxuICB4IC09IGRvY0VsZW0uY2xpZW50TGVmdCB8fCBib2R5LmNsaWVudExlZnQgfHwgMDtcbiAgeSAtPSBkb2NFbGVtLmNsaWVudFRvcCB8fCBib2R5LmNsaWVudFRvcCB8fCAwO1xuICByZXR1cm4ge1xuICAgIGxlZnQ6IHgsXG4gICAgdG9wOiB5XG4gIH07XG59XG5mdW5jdGlvbiBnZXRTY3JvbGwodywgdG9wKSB7XG4gIHZhciByZXQgPSB3W1wicGFnZVwiLmNvbmNhdCh0b3AgPyAnWScgOiAnWCcsIFwiT2Zmc2V0XCIpXTtcbiAgdmFyIG1ldGhvZCA9IFwic2Nyb2xsXCIuY29uY2F0KHRvcCA/ICdUb3AnIDogJ0xlZnQnKTtcbiAgaWYgKHR5cGVvZiByZXQgIT09ICdudW1iZXInKSB7XG4gICAgdmFyIGQgPSB3LmRvY3VtZW50O1xuICAgIC8vIGllNiw3LDggc3RhbmRhcmQgbW9kZVxuICAgIHJldCA9IGQuZG9jdW1lbnRFbGVtZW50W21ldGhvZF07XG4gICAgaWYgKHR5cGVvZiByZXQgIT09ICdudW1iZXInKSB7XG4gICAgICAvLyBxdWlya3MgbW9kZVxuICAgICAgcmV0ID0gZC5ib2R5W21ldGhvZF07XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiBnZXRTY3JvbGxMZWZ0KHcpIHtcbiAgcmV0dXJuIGdldFNjcm9sbCh3KTtcbn1cbmZ1bmN0aW9uIGdldFNjcm9sbFRvcCh3KSB7XG4gIHJldHVybiBnZXRTY3JvbGwodywgdHJ1ZSk7XG59XG5mdW5jdGlvbiBnZXRPZmZzZXQoZWwpIHtcbiAgdmFyIHBvcyA9IGdldENsaWVudFBvc2l0aW9uKGVsKTtcbiAgdmFyIGRvYyA9IGVsLm93bmVyRG9jdW1lbnQ7XG4gIHZhciB3ID0gZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3c7XG4gIHBvcy5sZWZ0ICs9IGdldFNjcm9sbExlZnQodyk7XG4gIHBvcy50b3AgKz0gZ2V0U2Nyb2xsVG9wKHcpO1xuICByZXR1cm4gcG9zO1xufVxuXG4vKipcbiAqIEEgY3J1ZGUgd2F5IG9mIGRldGVybWluaW5nIGlmIGFuIG9iamVjdCBpcyBhIHdpbmRvd1xuICogQG1lbWJlciB1dGlsXG4gKi9cbmZ1bmN0aW9uIGlzV2luZG93KG9iaikge1xuICAvLyBtdXN0IHVzZSA9PSBmb3IgaWU4XG4gIC8qIGVzbGludCBlcWVxZXE6MCAqL1xuICByZXR1cm4gb2JqICE9PSBudWxsICYmIG9iaiAhPT0gdW5kZWZpbmVkICYmIG9iaiA9PSBvYmoud2luZG93O1xufVxuZnVuY3Rpb24gZ2V0RG9jdW1lbnQobm9kZSkge1xuICBpZiAoaXNXaW5kb3cobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZS5kb2N1bWVudDtcbiAgfVxuICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gOSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIHJldHVybiBub2RlLm93bmVyRG9jdW1lbnQ7XG59XG5mdW5jdGlvbiBfZ2V0Q29tcHV0ZWRTdHlsZShlbGVtLCBuYW1lLCBjcykge1xuICB2YXIgY29tcHV0ZWRTdHlsZSA9IGNzO1xuICB2YXIgdmFsID0gJyc7XG4gIHZhciBkID0gZ2V0RG9jdW1lbnQoZWxlbSk7XG4gIGNvbXB1dGVkU3R5bGUgPSBjb21wdXRlZFN0eWxlIHx8IGQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtLCBudWxsKTtcblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20va2lzc3l0ZWFtL2tpc3N5L2lzc3Vlcy82MVxuICBpZiAoY29tcHV0ZWRTdHlsZSkge1xuICAgIHZhbCA9IGNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKSB8fCBjb21wdXRlZFN0eWxlW25hbWVdO1xuICB9XG4gIHJldHVybiB2YWw7XG59XG52YXIgX1JFX05VTV9OT19QWCA9IG5ldyBSZWdFeHAoXCJeKFwiLmNvbmNhdChSRV9OVU0sIFwiKSg/IXB4KVthLXolXSskXCIpLCAnaScpO1xudmFyIFJFX1BPUyA9IC9eKHRvcHxyaWdodHxib3R0b218bGVmdCkkLztcbnZhciBDVVJSRU5UX1NUWUxFID0gJ2N1cnJlbnRTdHlsZSc7XG52YXIgUlVOVElNRV9TVFlMRSA9ICdydW50aW1lU3R5bGUnO1xudmFyIExFRlQgPSAnbGVmdCc7XG52YXIgUFggPSAncHgnO1xuZnVuY3Rpb24gX2dldENvbXB1dGVkU3R5bGVJRShlbGVtLCBuYW1lKSB7XG4gIC8vIGN1cnJlbnRTdHlsZSBtYXliZSBudWxsXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNTIzMS5hc3B4XG4gIHZhciByZXQgPSBlbGVtW0NVUlJFTlRfU1RZTEVdICYmIGVsZW1bQ1VSUkVOVF9TVFlMRV1bbmFtZV07XG5cbiAgLy8g5b2TIHdpZHRoL2hlaWdodCDorr7nva7kuLrnmb7liIbmr5Tml7bvvIzpgJrov4cgcGl4ZWxMZWZ0IOaWueW8j+i9rOaNoueahCB3aWR0aC9oZWlnaHQg5YC8XG4gIC8vIOS4gOW8gOWni+WwseWkhOeQhuS6hiEgQ1VTVE9NX1NUWUxFLmhlaWdodCxDVVNUT01fU1RZTEUud2lkdGggLGNzc0hvb2sg6Kej5YazQDIwMTEtMDgtMTlcbiAgLy8g5ZyoIGllIOS4i+S4jeWvue+8jOmcgOimgeebtOaOpeeUqCBvZmZzZXQg5pa55byPXG4gIC8vIGJvcmRlcldpZHRoIOetieWAvOS5n+aciemXrumimO+8jOS9huiAg+iZkeWIsCBib3JkZXJXaWR0aCDorr7kuLrnmb7liIbmr5TnmoTmpoLnjoflvojlsI/vvIzov5nph4zlsLHkuI3ogIPomZHkuoZcblxuICAvLyBGcm9tIHRoZSBhd2Vzb21lIGhhY2sgYnkgRGVhbiBFZHdhcmRzXG4gIC8vIGh0dHA6Ly9lcmlrLmVhZS5uZXQvYXJjaGl2ZXMvMjAwNy8wNy8yNy8xOC41NC4xNS8jY29tbWVudC0xMDIyOTFcbiAgLy8gSWYgd2UncmUgbm90IGRlYWxpbmcgd2l0aCBhIHJlZ3VsYXIgcGl4ZWwgbnVtYmVyXG4gIC8vIGJ1dCBhIG51bWJlciB0aGF0IGhhcyBhIHdlaXJkIGVuZGluZywgd2UgbmVlZCB0byBjb252ZXJ0IGl0IHRvIHBpeGVsc1xuICAvLyBleGNsdWRlIGxlZnQgcmlnaHQgZm9yIHJlbGF0aXZpdHlcbiAgaWYgKF9SRV9OVU1fTk9fUFgudGVzdChyZXQpICYmICFSRV9QT1MudGVzdChuYW1lKSkge1xuICAgIC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcbiAgICB2YXIgc3R5bGUgPSBlbGVtLnN0eWxlO1xuICAgIHZhciBsZWZ0ID0gc3R5bGVbTEVGVF07XG4gICAgdmFyIHJzTGVmdCA9IGVsZW1bUlVOVElNRV9TVFlMRV1bTEVGVF07XG5cbiAgICAvLyBwcmV2ZW50IGZsYXNoaW5nIG9mIGNvbnRlbnRcbiAgICBlbGVtW1JVTlRJTUVfU1RZTEVdW0xFRlRdID0gZWxlbVtDVVJSRU5UX1NUWUxFXVtMRUZUXTtcblxuICAgIC8vIFB1dCBpbiB0aGUgbmV3IHZhbHVlcyB0byBnZXQgYSBjb21wdXRlZCB2YWx1ZSBvdXRcbiAgICBzdHlsZVtMRUZUXSA9IG5hbWUgPT09ICdmb250U2l6ZScgPyAnMWVtJyA6IHJldCB8fCAwO1xuICAgIHJldCA9IHN0eWxlLnBpeGVsTGVmdCArIFBYO1xuXG4gICAgLy8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xuICAgIHN0eWxlW0xFRlRdID0gbGVmdDtcbiAgICBlbGVtW1JVTlRJTUVfU1RZTEVdW0xFRlRdID0gcnNMZWZ0O1xuICB9XG4gIHJldHVybiByZXQgPT09ICcnID8gJ2F1dG8nIDogcmV0O1xufVxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIGdldENvbXB1dGVkU3R5bGVYID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUgPyBfZ2V0Q29tcHV0ZWRTdHlsZSA6IF9nZXRDb21wdXRlZFN0eWxlSUU7XG59XG5mdW5jdGlvbiBnZXRPZmZzZXREaXJlY3Rpb24oZGlyLCBvcHRpb24pIHtcbiAgaWYgKGRpciA9PT0gJ2xlZnQnKSB7XG4gICAgcmV0dXJuIG9wdGlvbi51c2VDc3NSaWdodCA/ICdyaWdodCcgOiBkaXI7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbi51c2VDc3NCb3R0b20gPyAnYm90dG9tJyA6IGRpcjtcbn1cbmZ1bmN0aW9uIG9wcG9zaXRlT2Zmc2V0RGlyZWN0aW9uKGRpcikge1xuICBpZiAoZGlyID09PSAnbGVmdCcpIHtcbiAgICByZXR1cm4gJ3JpZ2h0JztcbiAgfSBlbHNlIGlmIChkaXIgPT09ICdyaWdodCcpIHtcbiAgICByZXR1cm4gJ2xlZnQnO1xuICB9IGVsc2UgaWYgKGRpciA9PT0gJ3RvcCcpIHtcbiAgICByZXR1cm4gJ2JvdHRvbSc7XG4gIH0gZWxzZSBpZiAoZGlyID09PSAnYm90dG9tJykge1xuICAgIHJldHVybiAndG9wJztcbiAgfVxufVxuXG4vLyDorr7nva4gZWxlbSDnm7jlr7kgZWxlbS5vd25lckRvY3VtZW50IOeahOWdkOagh1xuZnVuY3Rpb24gc2V0TGVmdFRvcChlbGVtLCBvZmZzZXQsIG9wdGlvbikge1xuICAvLyBzZXQgcG9zaXRpb24gZmlyc3QsIGluLWNhc2UgdG9wL2xlZnQgYXJlIHNldCBldmVuIG9uIHN0YXRpYyBlbGVtXG4gIGlmIChjc3MoZWxlbSwgJ3Bvc2l0aW9uJykgPT09ICdzdGF0aWMnKSB7XG4gICAgZWxlbS5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gIH1cbiAgdmFyIHByZXNldEggPSAtOTk5O1xuICB2YXIgcHJlc2V0ViA9IC05OTk7XG4gIHZhciBob3Jpem9udGFsUHJvcGVydHkgPSBnZXRPZmZzZXREaXJlY3Rpb24oJ2xlZnQnLCBvcHRpb24pO1xuICB2YXIgdmVydGljYWxQcm9wZXJ0eSA9IGdldE9mZnNldERpcmVjdGlvbigndG9wJywgb3B0aW9uKTtcbiAgdmFyIG9wcG9zaXRlSG9yaXpvbnRhbFByb3BlcnR5ID0gb3Bwb3NpdGVPZmZzZXREaXJlY3Rpb24oaG9yaXpvbnRhbFByb3BlcnR5KTtcbiAgdmFyIG9wcG9zaXRlVmVydGljYWxQcm9wZXJ0eSA9IG9wcG9zaXRlT2Zmc2V0RGlyZWN0aW9uKHZlcnRpY2FsUHJvcGVydHkpO1xuICBpZiAoaG9yaXpvbnRhbFByb3BlcnR5ICE9PSAnbGVmdCcpIHtcbiAgICBwcmVzZXRIID0gOTk5O1xuICB9XG4gIGlmICh2ZXJ0aWNhbFByb3BlcnR5ICE9PSAndG9wJykge1xuICAgIHByZXNldFYgPSA5OTk7XG4gIH1cbiAgdmFyIG9yaWdpbmFsVHJhbnNpdGlvbiA9ICcnO1xuICB2YXIgb3JpZ2luYWxPZmZzZXQgPSBnZXRPZmZzZXQoZWxlbSk7XG4gIGlmICgnbGVmdCcgaW4gb2Zmc2V0IHx8ICd0b3AnIGluIG9mZnNldCkge1xuICAgIG9yaWdpbmFsVHJhbnNpdGlvbiA9IGdldFRyYW5zaXRpb25Qcm9wZXJ0eShlbGVtKSB8fCAnJztcbiAgICBzZXRUcmFuc2l0aW9uUHJvcGVydHkoZWxlbSwgJ25vbmUnKTtcbiAgfVxuICBpZiAoJ2xlZnQnIGluIG9mZnNldCkge1xuICAgIGVsZW0uc3R5bGVbb3Bwb3NpdGVIb3Jpem9udGFsUHJvcGVydHldID0gJyc7XG4gICAgZWxlbS5zdHlsZVtob3Jpem9udGFsUHJvcGVydHldID0gXCJcIi5jb25jYXQocHJlc2V0SCwgXCJweFwiKTtcbiAgfVxuICBpZiAoJ3RvcCcgaW4gb2Zmc2V0KSB7XG4gICAgZWxlbS5zdHlsZVtvcHBvc2l0ZVZlcnRpY2FsUHJvcGVydHldID0gJyc7XG4gICAgZWxlbS5zdHlsZVt2ZXJ0aWNhbFByb3BlcnR5XSA9IFwiXCIuY29uY2F0KHByZXNldFYsIFwicHhcIik7XG4gIH1cbiAgLy8gZm9yY2UgcmVsYXlvdXRcbiAgZm9yY2VSZWxheW91dChlbGVtKTtcbiAgdmFyIG9sZCA9IGdldE9mZnNldChlbGVtKTtcbiAgdmFyIG9yaWdpbmFsU3R5bGUgPSB7fTtcbiAgZm9yICh2YXIga2V5IGluIG9mZnNldCkge1xuICAgIGlmIChvZmZzZXQuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgdmFyIGRpciA9IGdldE9mZnNldERpcmVjdGlvbihrZXksIG9wdGlvbik7XG4gICAgICB2YXIgcHJlc2V0ID0ga2V5ID09PSAnbGVmdCcgPyBwcmVzZXRIIDogcHJlc2V0VjtcbiAgICAgIHZhciBvZmYgPSBvcmlnaW5hbE9mZnNldFtrZXldIC0gb2xkW2tleV07XG4gICAgICBpZiAoZGlyID09PSBrZXkpIHtcbiAgICAgICAgb3JpZ2luYWxTdHlsZVtkaXJdID0gcHJlc2V0ICsgb2ZmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3JpZ2luYWxTdHlsZVtkaXJdID0gcHJlc2V0IC0gb2ZmO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjc3MoZWxlbSwgb3JpZ2luYWxTdHlsZSk7XG4gIC8vIGZvcmNlIHJlbGF5b3V0XG4gIGZvcmNlUmVsYXlvdXQoZWxlbSk7XG4gIGlmICgnbGVmdCcgaW4gb2Zmc2V0IHx8ICd0b3AnIGluIG9mZnNldCkge1xuICAgIHNldFRyYW5zaXRpb25Qcm9wZXJ0eShlbGVtLCBvcmlnaW5hbFRyYW5zaXRpb24pO1xuICB9XG4gIHZhciByZXQgPSB7fTtcbiAgZm9yICh2YXIgX2tleSBpbiBvZmZzZXQpIHtcbiAgICBpZiAob2Zmc2V0Lmhhc093blByb3BlcnR5KF9rZXkpKSB7XG4gICAgICB2YXIgX2RpciA9IGdldE9mZnNldERpcmVjdGlvbihfa2V5LCBvcHRpb24pO1xuICAgICAgdmFyIF9vZmYgPSBvZmZzZXRbX2tleV0gLSBvcmlnaW5hbE9mZnNldFtfa2V5XTtcbiAgICAgIGlmIChfa2V5ID09PSBfZGlyKSB7XG4gICAgICAgIHJldFtfZGlyXSA9IG9yaWdpbmFsU3R5bGVbX2Rpcl0gKyBfb2ZmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0W19kaXJdID0gb3JpZ2luYWxTdHlsZVtfZGlyXSAtIF9vZmY7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNzcyhlbGVtLCByZXQpO1xufVxuZnVuY3Rpb24gc2V0VHJhbnNmb3JtJDEoZWxlbSwgb2Zmc2V0KSB7XG4gIHZhciBvcmlnaW5hbE9mZnNldCA9IGdldE9mZnNldChlbGVtKTtcbiAgdmFyIG9yaWdpbmFsWFkgPSBnZXRUcmFuc2Zvcm1YWShlbGVtKTtcbiAgdmFyIHJlc3VsdFhZID0ge1xuICAgIHg6IG9yaWdpbmFsWFkueCxcbiAgICB5OiBvcmlnaW5hbFhZLnlcbiAgfTtcbiAgaWYgKCdsZWZ0JyBpbiBvZmZzZXQpIHtcbiAgICByZXN1bHRYWS54ID0gb3JpZ2luYWxYWS54ICsgb2Zmc2V0LmxlZnQgLSBvcmlnaW5hbE9mZnNldC5sZWZ0O1xuICB9XG4gIGlmICgndG9wJyBpbiBvZmZzZXQpIHtcbiAgICByZXN1bHRYWS55ID0gb3JpZ2luYWxYWS55ICsgb2Zmc2V0LnRvcCAtIG9yaWdpbmFsT2Zmc2V0LnRvcDtcbiAgfVxuICBzZXRUcmFuc2Zvcm1YWShlbGVtLCByZXN1bHRYWSk7XG59XG5mdW5jdGlvbiBzZXRPZmZzZXQoZWxlbSwgb2Zmc2V0LCBvcHRpb24pIHtcbiAgaWYgKG9wdGlvbi5pZ25vcmVTaGFrZSkge1xuICAgIHZhciBvcmlPZmZzZXQgPSBnZXRPZmZzZXQoZWxlbSk7XG4gICAgdmFyIG9MZWZ0ID0gb3JpT2Zmc2V0LmxlZnQudG9GaXhlZCgwKTtcbiAgICB2YXIgb1RvcCA9IG9yaU9mZnNldC50b3AudG9GaXhlZCgwKTtcbiAgICB2YXIgdExlZnQgPSBvZmZzZXQubGVmdC50b0ZpeGVkKDApO1xuICAgIHZhciB0VG9wID0gb2Zmc2V0LnRvcC50b0ZpeGVkKDApO1xuICAgIGlmIChvTGVmdCA9PT0gdExlZnQgJiYgb1RvcCA9PT0gdFRvcCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBpZiAob3B0aW9uLnVzZUNzc1JpZ2h0IHx8IG9wdGlvbi51c2VDc3NCb3R0b20pIHtcbiAgICBzZXRMZWZ0VG9wKGVsZW0sIG9mZnNldCwgb3B0aW9uKTtcbiAgfSBlbHNlIGlmIChvcHRpb24udXNlQ3NzVHJhbnNmb3JtICYmIGdldFRyYW5zZm9ybU5hbWUoKSBpbiBkb2N1bWVudC5ib2R5LnN0eWxlKSB7XG4gICAgc2V0VHJhbnNmb3JtJDEoZWxlbSwgb2Zmc2V0KTtcbiAgfSBlbHNlIHtcbiAgICBzZXRMZWZ0VG9wKGVsZW0sIG9mZnNldCwgb3B0aW9uKTtcbiAgfVxufVxuZnVuY3Rpb24gZWFjaChhcnIsIGZuKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgZm4oYXJyW2ldKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNCb3JkZXJCb3hGbihlbGVtKSB7XG4gIHJldHVybiBnZXRDb21wdXRlZFN0eWxlWChlbGVtLCAnYm94U2l6aW5nJykgPT09ICdib3JkZXItYm94Jztcbn1cbnZhciBCT1hfTU9ERUxTID0gWydtYXJnaW4nLCAnYm9yZGVyJywgJ3BhZGRpbmcnXTtcbnZhciBDT05URU5UX0lOREVYID0gLTE7XG52YXIgUEFERElOR19JTkRFWCA9IDI7XG52YXIgQk9SREVSX0lOREVYID0gMTtcbnZhciBNQVJHSU5fSU5ERVggPSAwO1xuZnVuY3Rpb24gc3dhcChlbGVtLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICB2YXIgb2xkID0ge307XG4gIHZhciBzdHlsZSA9IGVsZW0uc3R5bGU7XG4gIHZhciBuYW1lO1xuXG4gIC8vIFJlbWVtYmVyIHRoZSBvbGQgdmFsdWVzLCBhbmQgaW5zZXJ0IHRoZSBuZXcgb25lc1xuICBmb3IgKG5hbWUgaW4gb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBvbGRbbmFtZV0gPSBzdHlsZVtuYW1lXTtcbiAgICAgIHN0eWxlW25hbWVdID0gb3B0aW9uc1tuYW1lXTtcbiAgICB9XG4gIH1cbiAgY2FsbGJhY2suY2FsbChlbGVtKTtcblxuICAvLyBSZXZlcnQgdGhlIG9sZCB2YWx1ZXNcbiAgZm9yIChuYW1lIGluIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgc3R5bGVbbmFtZV0gPSBvbGRbbmFtZV07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXRQQk1XaWR0aChlbGVtLCBwcm9wcywgd2hpY2gpIHtcbiAgdmFyIHZhbHVlID0gMDtcbiAgdmFyIHByb3A7XG4gIHZhciBqO1xuICB2YXIgaTtcbiAgZm9yIChqID0gMDsgaiA8IHByb3BzLmxlbmd0aDsgaisrKSB7XG4gICAgcHJvcCA9IHByb3BzW2pdO1xuICAgIGlmIChwcm9wKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgd2hpY2gubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNzc1Byb3AgPSB2b2lkIDA7XG4gICAgICAgIGlmIChwcm9wID09PSAnYm9yZGVyJykge1xuICAgICAgICAgIGNzc1Byb3AgPSBcIlwiLmNvbmNhdChwcm9wKS5jb25jYXQod2hpY2hbaV0sIFwiV2lkdGhcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3NzUHJvcCA9IHByb3AgKyB3aGljaFtpXTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSArPSBwYXJzZUZsb2F0KGdldENvbXB1dGVkU3R5bGVYKGVsZW0sIGNzc1Byb3ApKSB8fCAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG52YXIgZG9tVXRpbHMgPSB7XG4gIGdldFBhcmVudDogZnVuY3Rpb24gZ2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgICB2YXIgcGFyZW50ID0gZWxlbWVudDtcbiAgICBkbyB7XG4gICAgICBpZiAocGFyZW50Lm5vZGVUeXBlID09PSAxMSAmJiBwYXJlbnQuaG9zdCkge1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQuaG9zdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgIT09IDEgJiYgcGFyZW50Lm5vZGVUeXBlICE9PSA5KTtcbiAgICByZXR1cm4gcGFyZW50O1xuICB9XG59O1xuZWFjaChbJ1dpZHRoJywgJ0hlaWdodCddLCBmdW5jdGlvbiAobmFtZSkge1xuICBkb21VdGlsc1tcImRvY1wiLmNvbmNhdChuYW1lKV0gPSBmdW5jdGlvbiAocmVmV2luKSB7XG4gICAgdmFyIGQgPSByZWZXaW4uZG9jdW1lbnQ7XG4gICAgcmV0dXJuIE1hdGgubWF4KFxuICAgIC8vIGZpcmVmb3ggY2hyb21lIGRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQ8IGJvZHkuc2Nyb2xsSGVpZ2h0XG4gICAgLy8gaWUgc3RhbmRhcmQgbW9kZSA6IGRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQ+IGJvZHkuc2Nyb2xsSGVpZ2h0XG4gICAgZC5kb2N1bWVudEVsZW1lbnRbXCJzY3JvbGxcIi5jb25jYXQobmFtZSldLFxuICAgIC8vIHF1aXJrcyA6IGRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQg5pyA5aSn562J5LqO5Y+v6KeG56qX5Y+j5aSa5LiA54K577yfXG4gICAgZC5ib2R5W1wic2Nyb2xsXCIuY29uY2F0KG5hbWUpXSwgZG9tVXRpbHNbXCJ2aWV3cG9ydFwiLmNvbmNhdChuYW1lKV0oZCkpO1xuICB9O1xuICBkb21VdGlsc1tcInZpZXdwb3J0XCIuY29uY2F0KG5hbWUpXSA9IGZ1bmN0aW9uICh3aW4pIHtcbiAgICAvLyBwYyBicm93c2VyIGluY2x1ZGVzIHNjcm9sbGJhciBpbiB3aW5kb3cuaW5uZXJXaWR0aFxuICAgIHZhciBwcm9wID0gXCJjbGllbnRcIi5jb25jYXQobmFtZSk7XG4gICAgdmFyIGRvYyA9IHdpbi5kb2N1bWVudDtcbiAgICB2YXIgYm9keSA9IGRvYy5ib2R5O1xuICAgIHZhciBkb2N1bWVudEVsZW1lbnQgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgIHZhciBkb2N1bWVudEVsZW1lbnRQcm9wID0gZG9jdW1lbnRFbGVtZW50W3Byb3BdO1xuICAgIC8vIOagh+WHhuaooeW8j+WPliBkb2N1bWVudEVsZW1lbnRcbiAgICAvLyBiYWNrY29tcGF0IOWPliBib2R5XG4gICAgcmV0dXJuIGRvYy5jb21wYXRNb2RlID09PSAnQ1NTMUNvbXBhdCcgJiYgZG9jdW1lbnRFbGVtZW50UHJvcCB8fCBib2R5ICYmIGJvZHlbcHJvcF0gfHwgZG9jdW1lbnRFbGVtZW50UHJvcDtcbiAgfTtcbn0pO1xuXG4vKlxuIOW+l+WIsOWFg+e0oOeahOWkp+Wwj+S/oeaBr1xuIEBwYXJhbSBlbGVtXG4gQHBhcmFtIG5hbWVcbiBAcGFyYW0ge1N0cmluZ30gW2V4dHJhXSAgJ3BhZGRpbmcnIDogKGNzcyB3aWR0aCkgKyBwYWRkaW5nXG4gJ2JvcmRlcicgOiAoY3NzIHdpZHRoKSArIHBhZGRpbmcgKyBib3JkZXJcbiAnbWFyZ2luJyA6IChjc3Mgd2lkdGgpICsgcGFkZGluZyArIGJvcmRlciArIG1hcmdpblxuICovXG5mdW5jdGlvbiBnZXRXSChlbGVtLCBuYW1lLCBleCkge1xuICB2YXIgZXh0cmEgPSBleDtcbiAgaWYgKGlzV2luZG93KGVsZW0pKSB7XG4gICAgcmV0dXJuIG5hbWUgPT09ICd3aWR0aCcgPyBkb21VdGlscy52aWV3cG9ydFdpZHRoKGVsZW0pIDogZG9tVXRpbHMudmlld3BvcnRIZWlnaHQoZWxlbSk7XG4gIH0gZWxzZSBpZiAoZWxlbS5ub2RlVHlwZSA9PT0gOSkge1xuICAgIHJldHVybiBuYW1lID09PSAnd2lkdGgnID8gZG9tVXRpbHMuZG9jV2lkdGgoZWxlbSkgOiBkb21VdGlscy5kb2NIZWlnaHQoZWxlbSk7XG4gIH1cbiAgdmFyIHdoaWNoID0gbmFtZSA9PT0gJ3dpZHRoJyA/IFsnTGVmdCcsICdSaWdodCddIDogWydUb3AnLCAnQm90dG9tJ107XG4gIHZhciBib3JkZXJCb3hWYWx1ZSA9IG5hbWUgPT09ICd3aWR0aCcgPyBNYXRoLmZsb29yKGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGgpIDogTWF0aC5mbG9vcihlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCk7XG4gIHZhciBpc0JvcmRlckJveCA9IGlzQm9yZGVyQm94Rm4oZWxlbSk7XG4gIHZhciBjc3NCb3hWYWx1ZSA9IDA7XG4gIGlmIChib3JkZXJCb3hWYWx1ZSA9PT0gbnVsbCB8fCBib3JkZXJCb3hWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8IGJvcmRlckJveFZhbHVlIDw9IDApIHtcbiAgICBib3JkZXJCb3hWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAvLyBGYWxsIGJhY2sgdG8gY29tcHV0ZWQgdGhlbiB1biBjb21wdXRlZCBjc3MgaWYgbmVjZXNzYXJ5XG4gICAgY3NzQm94VmFsdWUgPSBnZXRDb21wdXRlZFN0eWxlWChlbGVtLCBuYW1lKTtcbiAgICBpZiAoY3NzQm94VmFsdWUgPT09IG51bGwgfHwgY3NzQm94VmFsdWUgPT09IHVuZGVmaW5lZCB8fCBOdW1iZXIoY3NzQm94VmFsdWUpIDwgMCkge1xuICAgICAgY3NzQm94VmFsdWUgPSBlbGVtLnN0eWxlW25hbWVdIHx8IDA7XG4gICAgfVxuICAgIC8vIE5vcm1hbGl6ZSAnJywgYXV0bywgYW5kIHByZXBhcmUgZm9yIGV4dHJhXG4gICAgY3NzQm94VmFsdWUgPSBNYXRoLmZsb29yKHBhcnNlRmxvYXQoY3NzQm94VmFsdWUpKSB8fCAwO1xuICB9XG4gIGlmIChleHRyYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXh0cmEgPSBpc0JvcmRlckJveCA/IEJPUkRFUl9JTkRFWCA6IENPTlRFTlRfSU5ERVg7XG4gIH1cbiAgdmFyIGJvcmRlckJveFZhbHVlT3JJc0JvcmRlckJveCA9IGJvcmRlckJveFZhbHVlICE9PSB1bmRlZmluZWQgfHwgaXNCb3JkZXJCb3g7XG4gIHZhciB2YWwgPSBib3JkZXJCb3hWYWx1ZSB8fCBjc3NCb3hWYWx1ZTtcbiAgaWYgKGV4dHJhID09PSBDT05URU5UX0lOREVYKSB7XG4gICAgaWYgKGJvcmRlckJveFZhbHVlT3JJc0JvcmRlckJveCkge1xuICAgICAgcmV0dXJuIHZhbCAtIGdldFBCTVdpZHRoKGVsZW0sIFsnYm9yZGVyJywgJ3BhZGRpbmcnXSwgd2hpY2gpO1xuICAgIH1cbiAgICByZXR1cm4gY3NzQm94VmFsdWU7XG4gIH0gZWxzZSBpZiAoYm9yZGVyQm94VmFsdWVPcklzQm9yZGVyQm94KSB7XG4gICAgaWYgKGV4dHJhID09PSBCT1JERVJfSU5ERVgpIHtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIHJldHVybiB2YWwgKyAoZXh0cmEgPT09IFBBRERJTkdfSU5ERVggPyAtZ2V0UEJNV2lkdGgoZWxlbSwgWydib3JkZXInXSwgd2hpY2gpIDogZ2V0UEJNV2lkdGgoZWxlbSwgWydtYXJnaW4nXSwgd2hpY2gpKTtcbiAgfVxuICByZXR1cm4gY3NzQm94VmFsdWUgKyBnZXRQQk1XaWR0aChlbGVtLCBCT1hfTU9ERUxTLnNsaWNlKGV4dHJhKSwgd2hpY2gpO1xufVxudmFyIGNzc1Nob3cgPSB7XG4gIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICB2aXNpYmlsaXR5OiAnaGlkZGVuJyxcbiAgZGlzcGxheTogJ2Jsb2NrJ1xufTtcblxuLy8gZml4ICMxMTkgOiBodHRwczovL2dpdGh1Yi5jb20va2lzc3l0ZWFtL2tpc3N5L2lzc3Vlcy8xMTlcbmZ1bmN0aW9uIGdldFdISWdub3JlRGlzcGxheSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuOyBfa2V5MisrKSB7XG4gICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICB9XG4gIHZhciB2YWw7XG4gIHZhciBlbGVtID0gYXJnc1swXTtcbiAgLy8gaW4gY2FzZSBlbGVtIGlzIHdpbmRvd1xuICAvLyBlbGVtLm9mZnNldFdpZHRoID09PSB1bmRlZmluZWRcbiAgaWYgKGVsZW0ub2Zmc2V0V2lkdGggIT09IDApIHtcbiAgICB2YWwgPSBnZXRXSC5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHN3YXAoZWxlbSwgY3NzU2hvdywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFsID0gZ2V0V0guYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdmFsO1xufVxuZWFjaChbJ3dpZHRoJywgJ2hlaWdodCddLCBmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgZmlyc3QgPSBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKTtcbiAgZG9tVXRpbHNbXCJvdXRlclwiLmNvbmNhdChmaXJzdCldID0gZnVuY3Rpb24gKGVsLCBpbmNsdWRlTWFyZ2luKSB7XG4gICAgcmV0dXJuIGVsICYmIGdldFdISWdub3JlRGlzcGxheShlbCwgbmFtZSwgaW5jbHVkZU1hcmdpbiA/IE1BUkdJTl9JTkRFWCA6IEJPUkRFUl9JTkRFWCk7XG4gIH07XG4gIHZhciB3aGljaCA9IG5hbWUgPT09ICd3aWR0aCcgPyBbJ0xlZnQnLCAnUmlnaHQnXSA6IFsnVG9wJywgJ0JvdHRvbSddO1xuICBkb21VdGlsc1tuYW1lXSA9IGZ1bmN0aW9uIChlbGVtLCB2KSB7XG4gICAgdmFyIHZhbCA9IHY7XG4gICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoZWxlbSkge1xuICAgICAgICB2YXIgaXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveEZuKGVsZW0pO1xuICAgICAgICBpZiAoaXNCb3JkZXJCb3gpIHtcbiAgICAgICAgICB2YWwgKz0gZ2V0UEJNV2lkdGgoZWxlbSwgWydwYWRkaW5nJywgJ2JvcmRlciddLCB3aGljaCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNzcyhlbGVtLCBuYW1lLCB2YWwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW0gJiYgZ2V0V0hJZ25vcmVEaXNwbGF5KGVsZW0sIG5hbWUsIENPTlRFTlRfSU5ERVgpO1xuICB9O1xufSk7XG5mdW5jdGlvbiBtaXgodG8sIGZyb20pIHtcbiAgZm9yICh2YXIgaSBpbiBmcm9tKSB7XG4gICAgaWYgKGZyb20uaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgIHRvW2ldID0gZnJvbVtpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvO1xufVxudmFyIHV0aWxzID0ge1xuICBnZXRXaW5kb3c6IGZ1bmN0aW9uIGdldFdpbmRvdyhub2RlKSB7XG4gICAgaWYgKG5vZGUgJiYgbm9kZS5kb2N1bWVudCAmJiBub2RlLnNldFRpbWVvdXQpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICB2YXIgZG9jID0gbm9kZS5vd25lckRvY3VtZW50IHx8IG5vZGU7XG4gICAgcmV0dXJuIGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93O1xuICB9LFxuICBnZXREb2N1bWVudDogZ2V0RG9jdW1lbnQsXG4gIG9mZnNldDogZnVuY3Rpb24gb2Zmc2V0KGVsLCB2YWx1ZSwgb3B0aW9uKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHNldE9mZnNldChlbCwgdmFsdWUsIG9wdGlvbiB8fCB7fSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBnZXRPZmZzZXQoZWwpO1xuICAgIH1cbiAgfSxcbiAgaXNXaW5kb3c6IGlzV2luZG93LFxuICBlYWNoOiBlYWNoLFxuICBjc3M6IGNzcyxcbiAgY2xvbmU6IGZ1bmN0aW9uIGNsb25lKG9iaikge1xuICAgIHZhciBpO1xuICAgIHZhciByZXQgPSB7fTtcbiAgICBmb3IgKGkgaW4gb2JqKSB7XG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgIHJldFtpXSA9IG9ialtpXTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIG92ZXJmbG93ID0gb2JqLm92ZXJmbG93O1xuICAgIGlmIChvdmVyZmxvdykge1xuICAgICAgZm9yIChpIGluIG9iaikge1xuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgcmV0Lm92ZXJmbG93W2ldID0gb2JqLm92ZXJmbG93W2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH0sXG4gIG1peDogbWl4LFxuICBnZXRXaW5kb3dTY3JvbGxMZWZ0OiBmdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGxMZWZ0KHcpIHtcbiAgICByZXR1cm4gZ2V0U2Nyb2xsTGVmdCh3KTtcbiAgfSxcbiAgZ2V0V2luZG93U2Nyb2xsVG9wOiBmdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGxUb3Aodykge1xuICAgIHJldHVybiBnZXRTY3JvbGxUb3Aodyk7XG4gIH0sXG4gIG1lcmdlOiBmdW5jdGlvbiBtZXJnZSgpIHtcbiAgICB2YXIgcmV0ID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHV0aWxzLm1peChyZXQsIGkgPCAwIHx8IGFyZ3VtZW50cy5sZW5ndGggPD0gaSA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH0sXG4gIHZpZXdwb3J0V2lkdGg6IDAsXG4gIHZpZXdwb3J0SGVpZ2h0OiAwXG59O1xubWl4KHV0aWxzLCBkb21VdGlscyk7XG5cbi8qKlxuICog5b6X5Yiw5Lya5a+86Ie05YWD57Sg5pi+56S65LiN5YWo55qE56WW5YWI5YWD57SgXG4gKi9cbnZhciBnZXRQYXJlbnQgPSB1dGlscy5nZXRQYXJlbnQ7XG5mdW5jdGlvbiBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICBpZiAodXRpbHMuaXNXaW5kb3coZWxlbWVudCkgfHwgZWxlbWVudC5ub2RlVHlwZSA9PT0gOSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8vIGllIOi/meS4quS5n+S4jeaYr+WujOWFqOWPr+ihjFxuICAvKlxuICAgPGRpdiBzdHlsZT1cIndpZHRoOiA1MHB4O2hlaWdodDogMTAwcHg7b3ZlcmZsb3c6IGhpZGRlblwiPlxuICAgPGRpdiBzdHlsZT1cIndpZHRoOiA1MHB4O2hlaWdodDogMTAwcHg7cG9zaXRpb246IHJlbGF0aXZlO1wiIGlkPVwiZDZcIj5cbiAgIOWFg+e0oCA2IOmrmCAxMDBweCDlrr0gNTBweDxici8+XG4gICA8L2Rpdj5cbiAgIDwvZGl2PlxuICAgKi9cbiAgLy8gZWxlbWVudC5vZmZzZXRQYXJlbnQgZG9lcyB0aGUgcmlnaHQgdGhpbmcgaW4gaWU3IGFuZCBiZWxvdy4gUmV0dXJuIHBhcmVudCB3aXRoIGxheW91dCFcbiAgLy8gIEluIG90aGVyIGJyb3dzZXJzIGl0IG9ubHkgaW5jbHVkZXMgZWxlbWVudHMgd2l0aCBwb3NpdGlvbiBhYnNvbHV0ZSwgcmVsYXRpdmUgb3JcbiAgLy8gZml4ZWQsIG5vdCBlbGVtZW50cyB3aXRoIG92ZXJmbG93IHNldCB0byBhdXRvIG9yIHNjcm9sbC5cbiAgLy8gICAgICAgIGlmIChVQS5pZSAmJiBpZU1vZGUgPCA4KSB7XG4gIC8vICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQub2Zmc2V0UGFyZW50O1xuICAvLyAgICAgICAgfVxuICAvLyDnu5/kuIDnmoQgb2Zmc2V0UGFyZW50IOaWueazlVxuICB2YXIgZG9jID0gdXRpbHMuZ2V0RG9jdW1lbnQoZWxlbWVudCk7XG4gIHZhciBib2R5ID0gZG9jLmJvZHk7XG4gIHZhciBwYXJlbnQ7XG4gIHZhciBwb3NpdGlvblN0eWxlID0gdXRpbHMuY3NzKGVsZW1lbnQsICdwb3NpdGlvbicpO1xuICB2YXIgc2tpcFN0YXRpYyA9IHBvc2l0aW9uU3R5bGUgPT09ICdmaXhlZCcgfHwgcG9zaXRpb25TdHlsZSA9PT0gJ2Fic29sdXRlJztcbiAgaWYgKCFza2lwU3RhdGljKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2h0bWwnID8gbnVsbCA6IGdldFBhcmVudChlbGVtZW50KTtcbiAgfVxuICBmb3IgKHBhcmVudCA9IGdldFBhcmVudChlbGVtZW50KTsgcGFyZW50ICYmIHBhcmVudCAhPT0gYm9keSAmJiBwYXJlbnQubm9kZVR5cGUgIT09IDk7IHBhcmVudCA9IGdldFBhcmVudChwYXJlbnQpKSB7XG4gICAgcG9zaXRpb25TdHlsZSA9IHV0aWxzLmNzcyhwYXJlbnQsICdwb3NpdGlvbicpO1xuICAgIGlmIChwb3NpdGlvblN0eWxlICE9PSAnc3RhdGljJykge1xuICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBnZXRQYXJlbnQkMSA9IHV0aWxzLmdldFBhcmVudDtcbmZ1bmN0aW9uIGlzQW5jZXN0b3JGaXhlZChlbGVtZW50KSB7XG4gIGlmICh1dGlscy5pc1dpbmRvdyhlbGVtZW50KSB8fCBlbGVtZW50Lm5vZGVUeXBlID09PSA5KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBkb2MgPSB1dGlscy5nZXREb2N1bWVudChlbGVtZW50KTtcbiAgdmFyIGJvZHkgPSBkb2MuYm9keTtcbiAgdmFyIHBhcmVudCA9IG51bGw7XG4gIGZvciAocGFyZW50ID0gZ2V0UGFyZW50JDEoZWxlbWVudCk7XG4gIC8vIOS/ruWkjeWFg+e0oOS9jeS6jiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQg5LiL5a+86Ie05bSp5rqD6Zeu6aKYXG4gIHBhcmVudCAmJiBwYXJlbnQgIT09IGJvZHkgJiYgcGFyZW50ICE9PSBkb2M7IHBhcmVudCA9IGdldFBhcmVudCQxKHBhcmVudCkpIHtcbiAgICB2YXIgcG9zaXRpb25TdHlsZSA9IHV0aWxzLmNzcyhwYXJlbnQsICdwb3NpdGlvbicpO1xuICAgIGlmIChwb3NpdGlvblN0eWxlID09PSAnZml4ZWQnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIOiOt+W+l+WFg+e0oOeahOaYvuekuumDqOWIhueahOWMuuWfn1xuICovXG5mdW5jdGlvbiBnZXRWaXNpYmxlUmVjdEZvckVsZW1lbnQoZWxlbWVudCwgYWx3YXlzQnlWaWV3cG9ydCkge1xuICB2YXIgdmlzaWJsZVJlY3QgPSB7XG4gICAgbGVmdDogMCxcbiAgICByaWdodDogSW5maW5pdHksXG4gICAgdG9wOiAwLFxuICAgIGJvdHRvbTogSW5maW5pdHlcbiAgfTtcbiAgdmFyIGVsID0gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpO1xuICB2YXIgZG9jID0gdXRpbHMuZ2V0RG9jdW1lbnQoZWxlbWVudCk7XG4gIHZhciB3aW4gPSBkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdztcbiAgdmFyIGJvZHkgPSBkb2MuYm9keTtcbiAgdmFyIGRvY3VtZW50RWxlbWVudCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cbiAgLy8gRGV0ZXJtaW5lIHRoZSBzaXplIG9mIHRoZSB2aXNpYmxlIHJlY3QgYnkgY2xpbWJpbmcgdGhlIGRvbSBhY2NvdW50aW5nIGZvclxuICAvLyBhbGwgc2Nyb2xsYWJsZSBjb250YWluZXJzLlxuICB3aGlsZSAoZWwpIHtcbiAgICAvLyBjbGllbnRXaWR0aCBpcyB6ZXJvIGZvciBpbmxpbmUgYmxvY2sgZWxlbWVudHMgaW4gaWUuXG4gICAgaWYgKChuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ01TSUUnKSA9PT0gLTEgfHwgZWwuY2xpZW50V2lkdGggIT09IDApICYmXG4gICAgLy8gYm9keSBtYXkgaGF2ZSBvdmVyZmxvdyBzZXQgb24gaXQsIHlldCB3ZSBzdGlsbCBnZXQgdGhlIGVudGlyZVxuICAgIC8vIHZpZXdwb3J0LiBJbiBzb21lIGJyb3dzZXJzLCBlbC5vZmZzZXRQYXJlbnQgbWF5IGJlXG4gICAgLy8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBzbyBjaGVjayBmb3IgdGhhdCB0b28uXG4gICAgZWwgIT09IGJvZHkgJiYgZWwgIT09IGRvY3VtZW50RWxlbWVudCAmJiB1dGlscy5jc3MoZWwsICdvdmVyZmxvdycpICE9PSAndmlzaWJsZScpIHtcbiAgICAgIHZhciBwb3MgPSB1dGlscy5vZmZzZXQoZWwpO1xuICAgICAgLy8gYWRkIGJvcmRlclxuICAgICAgcG9zLmxlZnQgKz0gZWwuY2xpZW50TGVmdDtcbiAgICAgIHBvcy50b3AgKz0gZWwuY2xpZW50VG9wO1xuICAgICAgdmlzaWJsZVJlY3QudG9wID0gTWF0aC5tYXgodmlzaWJsZVJlY3QudG9wLCBwb3MudG9wKTtcbiAgICAgIHZpc2libGVSZWN0LnJpZ2h0ID0gTWF0aC5taW4odmlzaWJsZVJlY3QucmlnaHQsXG4gICAgICAvLyBjb25zaWRlciBhcmVhIHdpdGhvdXQgc2Nyb2xsQmFyXG4gICAgICBwb3MubGVmdCArIGVsLmNsaWVudFdpZHRoKTtcbiAgICAgIHZpc2libGVSZWN0LmJvdHRvbSA9IE1hdGgubWluKHZpc2libGVSZWN0LmJvdHRvbSwgcG9zLnRvcCArIGVsLmNsaWVudEhlaWdodCk7XG4gICAgICB2aXNpYmxlUmVjdC5sZWZ0ID0gTWF0aC5tYXgodmlzaWJsZVJlY3QubGVmdCwgcG9zLmxlZnQpO1xuICAgIH0gZWxzZSBpZiAoZWwgPT09IGJvZHkgfHwgZWwgPT09IGRvY3VtZW50RWxlbWVudCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGVsID0gZ2V0T2Zmc2V0UGFyZW50KGVsKTtcbiAgfVxuXG4gIC8vIFNldCBlbGVtZW50IHBvc2l0aW9uIHRvIGZpeGVkXG4gIC8vIG1ha2Ugc3VyZSBhYnNvbHV0ZSBlbGVtZW50IGl0c2VsZiBkb24ndCBhZmZlY3QgaXQncyB2aXNpYmxlIGFyZWFcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FudC1kZXNpZ24vYW50LWRlc2lnbi9pc3N1ZXMvNzYwMVxuICB2YXIgb3JpZ2luYWxQb3NpdGlvbiA9IG51bGw7XG4gIGlmICghdXRpbHMuaXNXaW5kb3coZWxlbWVudCkgJiYgZWxlbWVudC5ub2RlVHlwZSAhPT0gOSkge1xuICAgIG9yaWdpbmFsUG9zaXRpb24gPSBlbGVtZW50LnN0eWxlLnBvc2l0aW9uO1xuICAgIHZhciBwb3NpdGlvbiA9IHV0aWxzLmNzcyhlbGVtZW50LCAncG9zaXRpb24nKTtcbiAgICBpZiAocG9zaXRpb24gPT09ICdhYnNvbHV0ZScpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICAgIH1cbiAgfVxuICB2YXIgc2Nyb2xsWCA9IHV0aWxzLmdldFdpbmRvd1Njcm9sbExlZnQod2luKTtcbiAgdmFyIHNjcm9sbFkgPSB1dGlscy5nZXRXaW5kb3dTY3JvbGxUb3Aod2luKTtcbiAgdmFyIHZpZXdwb3J0V2lkdGggPSB1dGlscy52aWV3cG9ydFdpZHRoKHdpbik7XG4gIHZhciB2aWV3cG9ydEhlaWdodCA9IHV0aWxzLnZpZXdwb3J0SGVpZ2h0KHdpbik7XG4gIHZhciBkb2N1bWVudFdpZHRoID0gZG9jdW1lbnRFbGVtZW50LnNjcm9sbFdpZHRoO1xuICB2YXIgZG9jdW1lbnRIZWlnaHQgPSBkb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0O1xuXG4gIC8vIHNjcm9sbFhYWCBvbiBodG1sIGlzIHN5bmMgd2l0aCBib2R5IHdoaWNoIG1lYW5zIG92ZXJmbG93OiBoaWRkZW4gb24gYm9keSBnZXRzIHdyb25nIHNjcm9sbFhYWC5cbiAgLy8gV2Ugc2hvdWxkIGN1dCB0aGlzIG91cnNlbGYuXG4gIHZhciBib2R5U3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShib2R5KTtcbiAgaWYgKGJvZHlTdHlsZS5vdmVyZmxvd1ggPT09ICdoaWRkZW4nKSB7XG4gICAgZG9jdW1lbnRXaWR0aCA9IHdpbi5pbm5lcldpZHRoO1xuICB9XG4gIGlmIChib2R5U3R5bGUub3ZlcmZsb3dZID09PSAnaGlkZGVuJykge1xuICAgIGRvY3VtZW50SGVpZ2h0ID0gd2luLmlubmVySGVpZ2h0O1xuICB9XG5cbiAgLy8gUmVzZXQgZWxlbWVudCBwb3NpdGlvbiBhZnRlciBjYWxjdWxhdGUgdGhlIHZpc2libGUgYXJlYVxuICBpZiAoZWxlbWVudC5zdHlsZSkge1xuICAgIGVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSBvcmlnaW5hbFBvc2l0aW9uO1xuICB9XG4gIGlmIChhbHdheXNCeVZpZXdwb3J0IHx8IGlzQW5jZXN0b3JGaXhlZChlbGVtZW50KSkge1xuICAgIC8vIENsaXAgYnkgdmlld3BvcnQncyBzaXplLlxuICAgIHZpc2libGVSZWN0LmxlZnQgPSBNYXRoLm1heCh2aXNpYmxlUmVjdC5sZWZ0LCBzY3JvbGxYKTtcbiAgICB2aXNpYmxlUmVjdC50b3AgPSBNYXRoLm1heCh2aXNpYmxlUmVjdC50b3AsIHNjcm9sbFkpO1xuICAgIHZpc2libGVSZWN0LnJpZ2h0ID0gTWF0aC5taW4odmlzaWJsZVJlY3QucmlnaHQsIHNjcm9sbFggKyB2aWV3cG9ydFdpZHRoKTtcbiAgICB2aXNpYmxlUmVjdC5ib3R0b20gPSBNYXRoLm1pbih2aXNpYmxlUmVjdC5ib3R0b20sIHNjcm9sbFkgKyB2aWV3cG9ydEhlaWdodCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ2xpcCBieSBkb2N1bWVudCdzIHNpemUuXG4gICAgdmFyIG1heFZpc2libGVXaWR0aCA9IE1hdGgubWF4KGRvY3VtZW50V2lkdGgsIHNjcm9sbFggKyB2aWV3cG9ydFdpZHRoKTtcbiAgICB2aXNpYmxlUmVjdC5yaWdodCA9IE1hdGgubWluKHZpc2libGVSZWN0LnJpZ2h0LCBtYXhWaXNpYmxlV2lkdGgpO1xuICAgIHZhciBtYXhWaXNpYmxlSGVpZ2h0ID0gTWF0aC5tYXgoZG9jdW1lbnRIZWlnaHQsIHNjcm9sbFkgKyB2aWV3cG9ydEhlaWdodCk7XG4gICAgdmlzaWJsZVJlY3QuYm90dG9tID0gTWF0aC5taW4odmlzaWJsZVJlY3QuYm90dG9tLCBtYXhWaXNpYmxlSGVpZ2h0KTtcbiAgfVxuICByZXR1cm4gdmlzaWJsZVJlY3QudG9wID49IDAgJiYgdmlzaWJsZVJlY3QubGVmdCA+PSAwICYmIHZpc2libGVSZWN0LmJvdHRvbSA+IHZpc2libGVSZWN0LnRvcCAmJiB2aXNpYmxlUmVjdC5yaWdodCA+IHZpc2libGVSZWN0LmxlZnQgPyB2aXNpYmxlUmVjdCA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGFkanVzdEZvclZpZXdwb3J0KGVsRnV0dXJlUG9zLCBlbFJlZ2lvbiwgdmlzaWJsZVJlY3QsIG92ZXJmbG93KSB7XG4gIHZhciBwb3MgPSB1dGlscy5jbG9uZShlbEZ1dHVyZVBvcyk7XG4gIHZhciBzaXplID0ge1xuICAgIHdpZHRoOiBlbFJlZ2lvbi53aWR0aCxcbiAgICBoZWlnaHQ6IGVsUmVnaW9uLmhlaWdodFxuICB9O1xuICBpZiAob3ZlcmZsb3cuYWRqdXN0WCAmJiBwb3MubGVmdCA8IHZpc2libGVSZWN0LmxlZnQpIHtcbiAgICBwb3MubGVmdCA9IHZpc2libGVSZWN0LmxlZnQ7XG4gIH1cblxuICAvLyBMZWZ0IGVkZ2UgaW5zaWRlIGFuZCByaWdodCBlZGdlIG91dHNpZGUgdmlld3BvcnQsIHRyeSB0byByZXNpemUgaXQuXG4gIGlmIChvdmVyZmxvdy5yZXNpemVXaWR0aCAmJiBwb3MubGVmdCA+PSB2aXNpYmxlUmVjdC5sZWZ0ICYmIHBvcy5sZWZ0ICsgc2l6ZS53aWR0aCA+IHZpc2libGVSZWN0LnJpZ2h0KSB7XG4gICAgc2l6ZS53aWR0aCAtPSBwb3MubGVmdCArIHNpemUud2lkdGggLSB2aXNpYmxlUmVjdC5yaWdodDtcbiAgfVxuXG4gIC8vIFJpZ2h0IGVkZ2Ugb3V0c2lkZSB2aWV3cG9ydCwgdHJ5IHRvIG1vdmUgaXQuXG4gIGlmIChvdmVyZmxvdy5hZGp1c3RYICYmIHBvcy5sZWZ0ICsgc2l6ZS53aWR0aCA+IHZpc2libGVSZWN0LnJpZ2h0KSB7XG4gICAgLy8g5L+d6K+B5bem6L6555WM5ZKM5Y+v6KeG5Yy65Z+f5bem6L6555WM5a+56b2QXG4gICAgcG9zLmxlZnQgPSBNYXRoLm1heCh2aXNpYmxlUmVjdC5yaWdodCAtIHNpemUud2lkdGgsIHZpc2libGVSZWN0LmxlZnQpO1xuICB9XG5cbiAgLy8gVG9wIGVkZ2Ugb3V0c2lkZSB2aWV3cG9ydCwgdHJ5IHRvIG1vdmUgaXQuXG4gIGlmIChvdmVyZmxvdy5hZGp1c3RZICYmIHBvcy50b3AgPCB2aXNpYmxlUmVjdC50b3ApIHtcbiAgICBwb3MudG9wID0gdmlzaWJsZVJlY3QudG9wO1xuICB9XG5cbiAgLy8gVG9wIGVkZ2UgaW5zaWRlIGFuZCBib3R0b20gZWRnZSBvdXRzaWRlIHZpZXdwb3J0LCB0cnkgdG8gcmVzaXplIGl0LlxuICBpZiAob3ZlcmZsb3cucmVzaXplSGVpZ2h0ICYmIHBvcy50b3AgPj0gdmlzaWJsZVJlY3QudG9wICYmIHBvcy50b3AgKyBzaXplLmhlaWdodCA+IHZpc2libGVSZWN0LmJvdHRvbSkge1xuICAgIHNpemUuaGVpZ2h0IC09IHBvcy50b3AgKyBzaXplLmhlaWdodCAtIHZpc2libGVSZWN0LmJvdHRvbTtcbiAgfVxuXG4gIC8vIEJvdHRvbSBlZGdlIG91dHNpZGUgdmlld3BvcnQsIHRyeSB0byBtb3ZlIGl0LlxuICBpZiAob3ZlcmZsb3cuYWRqdXN0WSAmJiBwb3MudG9wICsgc2l6ZS5oZWlnaHQgPiB2aXNpYmxlUmVjdC5ib3R0b20pIHtcbiAgICAvLyDkv53or4HkuIrovrnnlYzlkozlj6/op4bljLrln5/kuIrovrnnlYzlr7npvZBcbiAgICBwb3MudG9wID0gTWF0aC5tYXgodmlzaWJsZVJlY3QuYm90dG9tIC0gc2l6ZS5oZWlnaHQsIHZpc2libGVSZWN0LnRvcCk7XG4gIH1cbiAgcmV0dXJuIHV0aWxzLm1peChwb3MsIHNpemUpO1xufVxuXG5mdW5jdGlvbiBnZXRSZWdpb24obm9kZSkge1xuICB2YXIgb2Zmc2V0O1xuICB2YXIgdztcbiAgdmFyIGg7XG4gIGlmICghdXRpbHMuaXNXaW5kb3cobm9kZSkgJiYgbm9kZS5ub2RlVHlwZSAhPT0gOSkge1xuICAgIG9mZnNldCA9IHV0aWxzLm9mZnNldChub2RlKTtcbiAgICB3ID0gdXRpbHMub3V0ZXJXaWR0aChub2RlKTtcbiAgICBoID0gdXRpbHMub3V0ZXJIZWlnaHQobm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHdpbiA9IHV0aWxzLmdldFdpbmRvdyhub2RlKTtcbiAgICBvZmZzZXQgPSB7XG4gICAgICBsZWZ0OiB1dGlscy5nZXRXaW5kb3dTY3JvbGxMZWZ0KHdpbiksXG4gICAgICB0b3A6IHV0aWxzLmdldFdpbmRvd1Njcm9sbFRvcCh3aW4pXG4gICAgfTtcbiAgICB3ID0gdXRpbHMudmlld3BvcnRXaWR0aCh3aW4pO1xuICAgIGggPSB1dGlscy52aWV3cG9ydEhlaWdodCh3aW4pO1xuICB9XG4gIG9mZnNldC53aWR0aCA9IHc7XG4gIG9mZnNldC5oZWlnaHQgPSBoO1xuICByZXR1cm4gb2Zmc2V0O1xufVxuXG4vKipcbiAqIOiOt+WPliBub2RlIOS4iueahCBhbGlnbiDlr7npvZDngrkg55u45a+55LqO6aG16Z2i55qE5Z2Q5qCHXG4gKi9cblxuZnVuY3Rpb24gZ2V0QWxpZ25PZmZzZXQocmVnaW9uLCBhbGlnbikge1xuICB2YXIgViA9IGFsaWduLmNoYXJBdCgwKTtcbiAgdmFyIEggPSBhbGlnbi5jaGFyQXQoMSk7XG4gIHZhciB3ID0gcmVnaW9uLndpZHRoO1xuICB2YXIgaCA9IHJlZ2lvbi5oZWlnaHQ7XG4gIHZhciB4ID0gcmVnaW9uLmxlZnQ7XG4gIHZhciB5ID0gcmVnaW9uLnRvcDtcbiAgaWYgKFYgPT09ICdjJykge1xuICAgIHkgKz0gaCAvIDI7XG4gIH0gZWxzZSBpZiAoViA9PT0gJ2InKSB7XG4gICAgeSArPSBoO1xuICB9XG4gIGlmIChIID09PSAnYycpIHtcbiAgICB4ICs9IHcgLyAyO1xuICB9IGVsc2UgaWYgKEggPT09ICdyJykge1xuICAgIHggKz0gdztcbiAgfVxuICByZXR1cm4ge1xuICAgIGxlZnQ6IHgsXG4gICAgdG9wOiB5XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEVsRnV0dXJlUG9zKGVsUmVnaW9uLCByZWZOb2RlUmVnaW9uLCBwb2ludHMsIG9mZnNldCwgdGFyZ2V0T2Zmc2V0KSB7XG4gIHZhciBwMSA9IGdldEFsaWduT2Zmc2V0KHJlZk5vZGVSZWdpb24sIHBvaW50c1sxXSk7XG4gIHZhciBwMiA9IGdldEFsaWduT2Zmc2V0KGVsUmVnaW9uLCBwb2ludHNbMF0pO1xuICB2YXIgZGlmZiA9IFtwMi5sZWZ0IC0gcDEubGVmdCwgcDIudG9wIC0gcDEudG9wXTtcbiAgcmV0dXJuIHtcbiAgICBsZWZ0OiBNYXRoLnJvdW5kKGVsUmVnaW9uLmxlZnQgLSBkaWZmWzBdICsgb2Zmc2V0WzBdIC0gdGFyZ2V0T2Zmc2V0WzBdKSxcbiAgICB0b3A6IE1hdGgucm91bmQoZWxSZWdpb24udG9wIC0gZGlmZlsxXSArIG9mZnNldFsxXSAtIHRhcmdldE9mZnNldFsxXSlcbiAgfTtcbn1cblxuLyoqXG4gKiBhbGlnbiBkb20gbm9kZSBmbGV4aWJseVxuICogQGF1dGhvciB5aW1pbmdoZUBnbWFpbC5jb21cbiAqL1xuXG4vLyBodHRwOi8veWltaW5naGUuaXRleWUuY29tL2Jsb2cvMTEyNDcyMFxuXG5mdW5jdGlvbiBpc0ZhaWxYKGVsRnV0dXJlUG9zLCBlbFJlZ2lvbiwgdmlzaWJsZVJlY3QpIHtcbiAgcmV0dXJuIGVsRnV0dXJlUG9zLmxlZnQgPCB2aXNpYmxlUmVjdC5sZWZ0IHx8IGVsRnV0dXJlUG9zLmxlZnQgKyBlbFJlZ2lvbi53aWR0aCA+IHZpc2libGVSZWN0LnJpZ2h0O1xufVxuZnVuY3Rpb24gaXNGYWlsWShlbEZ1dHVyZVBvcywgZWxSZWdpb24sIHZpc2libGVSZWN0KSB7XG4gIHJldHVybiBlbEZ1dHVyZVBvcy50b3AgPCB2aXNpYmxlUmVjdC50b3AgfHwgZWxGdXR1cmVQb3MudG9wICsgZWxSZWdpb24uaGVpZ2h0ID4gdmlzaWJsZVJlY3QuYm90dG9tO1xufVxuZnVuY3Rpb24gaXNDb21wbGV0ZUZhaWxYKGVsRnV0dXJlUG9zLCBlbFJlZ2lvbiwgdmlzaWJsZVJlY3QpIHtcbiAgcmV0dXJuIGVsRnV0dXJlUG9zLmxlZnQgPiB2aXNpYmxlUmVjdC5yaWdodCB8fCBlbEZ1dHVyZVBvcy5sZWZ0ICsgZWxSZWdpb24ud2lkdGggPCB2aXNpYmxlUmVjdC5sZWZ0O1xufVxuZnVuY3Rpb24gaXNDb21wbGV0ZUZhaWxZKGVsRnV0dXJlUG9zLCBlbFJlZ2lvbiwgdmlzaWJsZVJlY3QpIHtcbiAgcmV0dXJuIGVsRnV0dXJlUG9zLnRvcCA+IHZpc2libGVSZWN0LmJvdHRvbSB8fCBlbEZ1dHVyZVBvcy50b3AgKyBlbFJlZ2lvbi5oZWlnaHQgPCB2aXNpYmxlUmVjdC50b3A7XG59XG5mdW5jdGlvbiBmbGlwKHBvaW50cywgcmVnLCBtYXApIHtcbiAgdmFyIHJldCA9IFtdO1xuICB1dGlscy5lYWNoKHBvaW50cywgZnVuY3Rpb24gKHApIHtcbiAgICByZXQucHVzaChwLnJlcGxhY2UocmVnLCBmdW5jdGlvbiAobSkge1xuICAgICAgcmV0dXJuIG1hcFttXTtcbiAgICB9KSk7XG4gIH0pO1xuICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gZmxpcE9mZnNldChvZmZzZXQsIGluZGV4KSB7XG4gIG9mZnNldFtpbmRleF0gPSAtb2Zmc2V0W2luZGV4XTtcbiAgcmV0dXJuIG9mZnNldDtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRPZmZzZXQoc3RyLCBvZmZzZXRMZW4pIHtcbiAgdmFyIG47XG4gIGlmICgvJSQvLnRlc3Qoc3RyKSkge1xuICAgIG4gPSBwYXJzZUludChzdHIuc3Vic3RyaW5nKDAsIHN0ci5sZW5ndGggLSAxKSwgMTApIC8gMTAwICogb2Zmc2V0TGVuO1xuICB9IGVsc2Uge1xuICAgIG4gPSBwYXJzZUludChzdHIsIDEwKTtcbiAgfVxuICByZXR1cm4gbiB8fCAwO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplT2Zmc2V0KG9mZnNldCwgZWwpIHtcbiAgb2Zmc2V0WzBdID0gY29udmVydE9mZnNldChvZmZzZXRbMF0sIGVsLndpZHRoKTtcbiAgb2Zmc2V0WzFdID0gY29udmVydE9mZnNldChvZmZzZXRbMV0sIGVsLmhlaWdodCk7XG59XG5cbi8qKlxuICogQHBhcmFtIGVsXG4gKiBAcGFyYW0gdGd0UmVnaW9uIOWPgueFp+iKgueCueaJgOWNoOeahOWMuuWfnzogeyBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQgfVxuICogQHBhcmFtIGFsaWduXG4gKi9cbmZ1bmN0aW9uIGRvQWxpZ24oZWwsIHRndFJlZ2lvbiwgYWxpZ24sIGlzVGd0UmVnaW9uVmlzaWJsZSkge1xuICB2YXIgcG9pbnRzID0gYWxpZ24ucG9pbnRzO1xuICB2YXIgb2Zmc2V0ID0gYWxpZ24ub2Zmc2V0IHx8IFswLCAwXTtcbiAgdmFyIHRhcmdldE9mZnNldCA9IGFsaWduLnRhcmdldE9mZnNldCB8fCBbMCwgMF07XG4gIHZhciBvdmVyZmxvdyA9IGFsaWduLm92ZXJmbG93O1xuICB2YXIgc291cmNlID0gYWxpZ24uc291cmNlIHx8IGVsO1xuICBvZmZzZXQgPSBbXS5jb25jYXQob2Zmc2V0KTtcbiAgdGFyZ2V0T2Zmc2V0ID0gW10uY29uY2F0KHRhcmdldE9mZnNldCk7XG4gIG92ZXJmbG93ID0gb3ZlcmZsb3cgfHwge307XG4gIHZhciBuZXdPdmVyZmxvd0NmZyA9IHt9O1xuICB2YXIgZmFpbCA9IDA7XG4gIHZhciBhbHdheXNCeVZpZXdwb3J0ID0gISEob3ZlcmZsb3cgJiYgb3ZlcmZsb3cuYWx3YXlzQnlWaWV3cG9ydCk7XG4gIC8vIOW9k+WJjeiKgueCueWPr+S7peiiq+aUvue9rueahOaYvuekuuWMuuWfn1xuICB2YXIgdmlzaWJsZVJlY3QgPSBnZXRWaXNpYmxlUmVjdEZvckVsZW1lbnQoc291cmNlLCBhbHdheXNCeVZpZXdwb3J0KTtcbiAgLy8g5b2T5YmN6IqC54K55omA5Y2g55qE5Yy65Z+fLCBsZWZ0L3RvcC93aWR0aC9oZWlnaHRcbiAgdmFyIGVsUmVnaW9uID0gZ2V0UmVnaW9uKHNvdXJjZSk7XG4gIC8vIOWwhiBvZmZzZXQg6L2s5o2i5oiQ5pWw5YC877yM5pSv5oyB55m+5YiG5q+UXG4gIG5vcm1hbGl6ZU9mZnNldChvZmZzZXQsIGVsUmVnaW9uKTtcbiAgbm9ybWFsaXplT2Zmc2V0KHRhcmdldE9mZnNldCwgdGd0UmVnaW9uKTtcbiAgLy8g5b2T5YmN6IqC54K55bCG6KaB6KKr5pS+572u55qE5L2N572uXG4gIHZhciBlbEZ1dHVyZVBvcyA9IGdldEVsRnV0dXJlUG9zKGVsUmVnaW9uLCB0Z3RSZWdpb24sIHBvaW50cywgb2Zmc2V0LCB0YXJnZXRPZmZzZXQpO1xuICAvLyDlvZPliY3oioLngrnlsIbopoHmiYDlpITnmoTljLrln59cbiAgdmFyIG5ld0VsUmVnaW9uID0gdXRpbHMubWVyZ2UoZWxSZWdpb24sIGVsRnV0dXJlUG9zKTtcblxuICAvLyDlpoLmnpzlj6/op4bljLrln5/kuI3og73lrozlhajmlL7nva7lvZPliY3oioLngrnml7blhYHorrjosIPmlbRcbiAgaWYgKHZpc2libGVSZWN0ICYmIChvdmVyZmxvdy5hZGp1c3RYIHx8IG92ZXJmbG93LmFkanVzdFkpICYmIGlzVGd0UmVnaW9uVmlzaWJsZSkge1xuICAgIGlmIChvdmVyZmxvdy5hZGp1c3RYKSB7XG4gICAgICAvLyDlpoLmnpzmqKrlkJHkuI3og73mlL7kuItcbiAgICAgIGlmIChpc0ZhaWxYKGVsRnV0dXJlUG9zLCBlbFJlZ2lvbiwgdmlzaWJsZVJlY3QpKSB7XG4gICAgICAgIC8vIOWvuem9kOS9jee9ruWPjeS4i1xuICAgICAgICB2YXIgbmV3UG9pbnRzID0gZmxpcChwb2ludHMsIC9bbHJdL2dpLCB7XG4gICAgICAgICAgbDogJ3InLFxuICAgICAgICAgIHI6ICdsJ1xuICAgICAgICB9KTtcbiAgICAgICAgLy8g5YGP56e76YeP5Lmf5Y+N5LiLXG4gICAgICAgIHZhciBuZXdPZmZzZXQgPSBmbGlwT2Zmc2V0KG9mZnNldCwgMCk7XG4gICAgICAgIHZhciBuZXdUYXJnZXRPZmZzZXQgPSBmbGlwT2Zmc2V0KHRhcmdldE9mZnNldCwgMCk7XG4gICAgICAgIHZhciBuZXdFbEZ1dHVyZVBvcyA9IGdldEVsRnV0dXJlUG9zKGVsUmVnaW9uLCB0Z3RSZWdpb24sIG5ld1BvaW50cywgbmV3T2Zmc2V0LCBuZXdUYXJnZXRPZmZzZXQpO1xuICAgICAgICBpZiAoIWlzQ29tcGxldGVGYWlsWChuZXdFbEZ1dHVyZVBvcywgZWxSZWdpb24sIHZpc2libGVSZWN0KSkge1xuICAgICAgICAgIGZhaWwgPSAxO1xuICAgICAgICAgIHBvaW50cyA9IG5ld1BvaW50cztcbiAgICAgICAgICBvZmZzZXQgPSBuZXdPZmZzZXQ7XG4gICAgICAgICAgdGFyZ2V0T2Zmc2V0ID0gbmV3VGFyZ2V0T2Zmc2V0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvdmVyZmxvdy5hZGp1c3RZKSB7XG4gICAgICAvLyDlpoLmnpznurXlkJHkuI3og73mlL7kuItcbiAgICAgIGlmIChpc0ZhaWxZKGVsRnV0dXJlUG9zLCBlbFJlZ2lvbiwgdmlzaWJsZVJlY3QpKSB7XG4gICAgICAgIC8vIOWvuem9kOS9jee9ruWPjeS4i1xuICAgICAgICB2YXIgX25ld1BvaW50cyA9IGZsaXAocG9pbnRzLCAvW3RiXS9naSwge1xuICAgICAgICAgIHQ6ICdiJyxcbiAgICAgICAgICBiOiAndCdcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIOWBj+enu+mHj+S5n+WPjeS4i1xuICAgICAgICB2YXIgX25ld09mZnNldCA9IGZsaXBPZmZzZXQob2Zmc2V0LCAxKTtcbiAgICAgICAgdmFyIF9uZXdUYXJnZXRPZmZzZXQgPSBmbGlwT2Zmc2V0KHRhcmdldE9mZnNldCwgMSk7XG4gICAgICAgIHZhciBfbmV3RWxGdXR1cmVQb3MgPSBnZXRFbEZ1dHVyZVBvcyhlbFJlZ2lvbiwgdGd0UmVnaW9uLCBfbmV3UG9pbnRzLCBfbmV3T2Zmc2V0LCBfbmV3VGFyZ2V0T2Zmc2V0KTtcbiAgICAgICAgaWYgKCFpc0NvbXBsZXRlRmFpbFkoX25ld0VsRnV0dXJlUG9zLCBlbFJlZ2lvbiwgdmlzaWJsZVJlY3QpKSB7XG4gICAgICAgICAgZmFpbCA9IDE7XG4gICAgICAgICAgcG9pbnRzID0gX25ld1BvaW50cztcbiAgICAgICAgICBvZmZzZXQgPSBfbmV3T2Zmc2V0O1xuICAgICAgICAgIHRhcmdldE9mZnNldCA9IF9uZXdUYXJnZXRPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyDlpoLmnpzlpLHotKXvvIzph43mlrDorqHnrpflvZPliY3oioLngrnlsIbopoHooqvmlL7nva7nmoTkvY3nva5cbiAgICBpZiAoZmFpbCkge1xuICAgICAgZWxGdXR1cmVQb3MgPSBnZXRFbEZ1dHVyZVBvcyhlbFJlZ2lvbiwgdGd0UmVnaW9uLCBwb2ludHMsIG9mZnNldCwgdGFyZ2V0T2Zmc2V0KTtcbiAgICAgIHV0aWxzLm1peChuZXdFbFJlZ2lvbiwgZWxGdXR1cmVQb3MpO1xuICAgIH1cbiAgICB2YXIgaXNTdGlsbEZhaWxYID0gaXNGYWlsWChlbEZ1dHVyZVBvcywgZWxSZWdpb24sIHZpc2libGVSZWN0KTtcbiAgICB2YXIgaXNTdGlsbEZhaWxZID0gaXNGYWlsWShlbEZ1dHVyZVBvcywgZWxSZWdpb24sIHZpc2libGVSZWN0KTtcbiAgICAvLyDmo4Dmn6Xlj43kuIvlkI7nmoTkvY3nva7mmK/lkKblj6/ku6XmlL7kuIvkuobvvIzlpoLmnpzku43nhLbmlL7kuI3kuIvvvJpcbiAgICAvLyAxLiDlpI3ljp/kv67mlLnov4fnmoTlrprkvY3lj4LmlbBcbiAgICBpZiAoaXNTdGlsbEZhaWxYIHx8IGlzU3RpbGxGYWlsWSkge1xuICAgICAgdmFyIF9uZXdQb2ludHMyID0gcG9pbnRzO1xuXG4gICAgICAvLyDph43nva7lr7nlupTpg6jliIbnmoTnv7vovazpgLvovpFcbiAgICAgIGlmIChpc1N0aWxsRmFpbFgpIHtcbiAgICAgICAgX25ld1BvaW50czIgPSBmbGlwKHBvaW50cywgL1tscl0vZ2ksIHtcbiAgICAgICAgICBsOiAncicsXG4gICAgICAgICAgcjogJ2wnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzU3RpbGxGYWlsWSkge1xuICAgICAgICBfbmV3UG9pbnRzMiA9IGZsaXAocG9pbnRzLCAvW3RiXS9naSwge1xuICAgICAgICAgIHQ6ICdiJyxcbiAgICAgICAgICBiOiAndCdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBwb2ludHMgPSBfbmV3UG9pbnRzMjtcbiAgICAgIG9mZnNldCA9IGFsaWduLm9mZnNldCB8fCBbMCwgMF07XG4gICAgICB0YXJnZXRPZmZzZXQgPSBhbGlnbi50YXJnZXRPZmZzZXQgfHwgWzAsIDBdO1xuICAgIH1cbiAgICAvLyAyLiDlj6rmnInmjIflrprkuoblj6/ku6XosIPmlbTlvZPliY3mlrnlkJHmiY3osIPmlbRcbiAgICBuZXdPdmVyZmxvd0NmZy5hZGp1c3RYID0gb3ZlcmZsb3cuYWRqdXN0WCAmJiBpc1N0aWxsRmFpbFg7XG4gICAgbmV3T3ZlcmZsb3dDZmcuYWRqdXN0WSA9IG92ZXJmbG93LmFkanVzdFkgJiYgaXNTdGlsbEZhaWxZO1xuXG4gICAgLy8g56Gu5a6e6KaB6LCD5pW077yM55Sa6Iez5Y+v6IO95Lya6LCD5pW06auY5bqm5a695bqmXG4gICAgaWYgKG5ld092ZXJmbG93Q2ZnLmFkanVzdFggfHwgbmV3T3ZlcmZsb3dDZmcuYWRqdXN0WSkge1xuICAgICAgbmV3RWxSZWdpb24gPSBhZGp1c3RGb3JWaWV3cG9ydChlbEZ1dHVyZVBvcywgZWxSZWdpb24sIHZpc2libGVSZWN0LCBuZXdPdmVyZmxvd0NmZyk7XG4gICAgfVxuICB9XG5cbiAgLy8gbmVlZCBqdWRnZSB0byBpbiBjYXNlIHNldCBmaXhlZCB3aXRoIGluIGNzcyBvbiBoZWlnaHQgYXV0byBlbGVtZW50XG4gIGlmIChuZXdFbFJlZ2lvbi53aWR0aCAhPT0gZWxSZWdpb24ud2lkdGgpIHtcbiAgICB1dGlscy5jc3Moc291cmNlLCAnd2lkdGgnLCB1dGlscy53aWR0aChzb3VyY2UpICsgbmV3RWxSZWdpb24ud2lkdGggLSBlbFJlZ2lvbi53aWR0aCk7XG4gIH1cbiAgaWYgKG5ld0VsUmVnaW9uLmhlaWdodCAhPT0gZWxSZWdpb24uaGVpZ2h0KSB7XG4gICAgdXRpbHMuY3NzKHNvdXJjZSwgJ2hlaWdodCcsIHV0aWxzLmhlaWdodChzb3VyY2UpICsgbmV3RWxSZWdpb24uaGVpZ2h0IC0gZWxSZWdpb24uaGVpZ2h0KTtcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9raXNzeXRlYW0va2lzc3kvaXNzdWVzLzE5MFxuICAvLyDnm7jlr7nkuo7lsY/luZXkvY3nva7msqHlj5jvvIzogIwgbGVmdC90b3Ag5Y+Y5LqGXG4gIC8vIOS+i+WmgiA8ZGl2ICdyZWxhdGl2ZSc+PGVsIGFic29sdXRlPjwvZGl2PlxuICB1dGlscy5vZmZzZXQoc291cmNlLCB7XG4gICAgbGVmdDogbmV3RWxSZWdpb24ubGVmdCxcbiAgICB0b3A6IG5ld0VsUmVnaW9uLnRvcFxuICB9LCB7XG4gICAgdXNlQ3NzUmlnaHQ6IGFsaWduLnVzZUNzc1JpZ2h0LFxuICAgIHVzZUNzc0JvdHRvbTogYWxpZ24udXNlQ3NzQm90dG9tLFxuICAgIHVzZUNzc1RyYW5zZm9ybTogYWxpZ24udXNlQ3NzVHJhbnNmb3JtLFxuICAgIGlnbm9yZVNoYWtlOiBhbGlnbi5pZ25vcmVTaGFrZVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBwb2ludHM6IHBvaW50cyxcbiAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICB0YXJnZXRPZmZzZXQ6IHRhcmdldE9mZnNldCxcbiAgICBvdmVyZmxvdzogbmV3T3ZlcmZsb3dDZmdcbiAgfTtcbn1cbi8qKlxuICogIDIwMTItMDQtMjYgeWltaW5naGVAZ21haWwuY29tXG4gKiAgIC0g5LyY5YyW5pm66IO95a+56b2Q566X5rOVXG4gKiAgIC0g5oWO55SoIHJlc2l6ZVhYXG4gKlxuICogIDIwMTEtMDctMTMgeWltaW5naGVAZ21haWwuY29tIG5vdGU6XG4gKiAgIC0g5aKe5Yqg5pm66IO95a+56b2Q77yM5Lul5Y+K5aSn5bCP6LCD5pW06YCJ6aG5XG4gKiovXG5cbmZ1bmN0aW9uIGlzT3V0T2ZWaXNpYmxlUmVjdCh0YXJnZXQsIGFsd2F5c0J5Vmlld3BvcnQpIHtcbiAgdmFyIHZpc2libGVSZWN0ID0gZ2V0VmlzaWJsZVJlY3RGb3JFbGVtZW50KHRhcmdldCwgYWx3YXlzQnlWaWV3cG9ydCk7XG4gIHZhciB0YXJnZXRSZWdpb24gPSBnZXRSZWdpb24odGFyZ2V0KTtcbiAgcmV0dXJuICF2aXNpYmxlUmVjdCB8fCB0YXJnZXRSZWdpb24ubGVmdCArIHRhcmdldFJlZ2lvbi53aWR0aCA8PSB2aXNpYmxlUmVjdC5sZWZ0IHx8IHRhcmdldFJlZ2lvbi50b3AgKyB0YXJnZXRSZWdpb24uaGVpZ2h0IDw9IHZpc2libGVSZWN0LnRvcCB8fCB0YXJnZXRSZWdpb24ubGVmdCA+PSB2aXNpYmxlUmVjdC5yaWdodCB8fCB0YXJnZXRSZWdpb24udG9wID49IHZpc2libGVSZWN0LmJvdHRvbTtcbn1cbmZ1bmN0aW9uIGFsaWduRWxlbWVudChlbCwgcmVmTm9kZSwgYWxpZ24pIHtcbiAgdmFyIHRhcmdldCA9IGFsaWduLnRhcmdldCB8fCByZWZOb2RlO1xuICB2YXIgcmVmTm9kZVJlZ2lvbiA9IGdldFJlZ2lvbih0YXJnZXQpO1xuICB2YXIgaXNUYXJnZXROb3RPdXRPZlZpc2libGUgPSAhaXNPdXRPZlZpc2libGVSZWN0KHRhcmdldCwgYWxpZ24ub3ZlcmZsb3cgJiYgYWxpZ24ub3ZlcmZsb3cuYWx3YXlzQnlWaWV3cG9ydCk7XG4gIHJldHVybiBkb0FsaWduKGVsLCByZWZOb2RlUmVnaW9uLCBhbGlnbiwgaXNUYXJnZXROb3RPdXRPZlZpc2libGUpO1xufVxuYWxpZ25FbGVtZW50Ll9fZ2V0T2Zmc2V0UGFyZW50ID0gZ2V0T2Zmc2V0UGFyZW50O1xuYWxpZ25FbGVtZW50Ll9fZ2V0VmlzaWJsZVJlY3RGb3JFbGVtZW50ID0gZ2V0VmlzaWJsZVJlY3RGb3JFbGVtZW50O1xuXG4vKipcbiAqIGB0Z3RQb2ludGA6IHsgcGFnZVgsIHBhZ2VZIH0gb3IgeyBjbGllbnRYLCBjbGllbnRZIH0uXG4gKiBJZiBjbGllbnQgcG9zaXRpb24gcHJvdmlkZWQsIHdpbGwgaW50ZXJuYWwgY29udmVydCB0byBwYWdlIHBvc2l0aW9uLlxuICovXG5cbmZ1bmN0aW9uIGFsaWduUG9pbnQoZWwsIHRndFBvaW50LCBhbGlnbikge1xuICB2YXIgcGFnZVg7XG4gIHZhciBwYWdlWTtcbiAgdmFyIGRvYyA9IHV0aWxzLmdldERvY3VtZW50KGVsKTtcbiAgdmFyIHdpbiA9IGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93O1xuICB2YXIgc2Nyb2xsWCA9IHV0aWxzLmdldFdpbmRvd1Njcm9sbExlZnQod2luKTtcbiAgdmFyIHNjcm9sbFkgPSB1dGlscy5nZXRXaW5kb3dTY3JvbGxUb3Aod2luKTtcbiAgdmFyIHZpZXdwb3J0V2lkdGggPSB1dGlscy52aWV3cG9ydFdpZHRoKHdpbik7XG4gIHZhciB2aWV3cG9ydEhlaWdodCA9IHV0aWxzLnZpZXdwb3J0SGVpZ2h0KHdpbik7XG4gIGlmICgncGFnZVgnIGluIHRndFBvaW50KSB7XG4gICAgcGFnZVggPSB0Z3RQb2ludC5wYWdlWDtcbiAgfSBlbHNlIHtcbiAgICBwYWdlWCA9IHNjcm9sbFggKyB0Z3RQb2ludC5jbGllbnRYO1xuICB9XG4gIGlmICgncGFnZVknIGluIHRndFBvaW50KSB7XG4gICAgcGFnZVkgPSB0Z3RQb2ludC5wYWdlWTtcbiAgfSBlbHNlIHtcbiAgICBwYWdlWSA9IHNjcm9sbFkgKyB0Z3RQb2ludC5jbGllbnRZO1xuICB9XG4gIHZhciB0Z3RSZWdpb24gPSB7XG4gICAgbGVmdDogcGFnZVgsXG4gICAgdG9wOiBwYWdlWSxcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDBcbiAgfTtcbiAgdmFyIHBvaW50SW5WaWV3ID0gcGFnZVggPj0gMCAmJiBwYWdlWCA8PSBzY3JvbGxYICsgdmlld3BvcnRXaWR0aCAmJiBwYWdlWSA+PSAwICYmIHBhZ2VZIDw9IHNjcm9sbFkgKyB2aWV3cG9ydEhlaWdodDtcblxuICAvLyBQcm92aWRlIGRlZmF1bHQgdGFyZ2V0IHBvaW50XG4gIHZhciBwb2ludHMgPSBbYWxpZ24ucG9pbnRzWzBdLCAnY2MnXTtcbiAgcmV0dXJuIGRvQWxpZ24oZWwsIHRndFJlZ2lvbiwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGFsaWduKSwge30sIHtcbiAgICBwb2ludHM6IHBvaW50c1xuICB9KSwgcG9pbnRJblZpZXcpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhbGlnbkVsZW1lbnQ7XG5leHBvcnQgeyBhbGlnbkVsZW1lbnQsIGFsaWduUG9pbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwiaW1wb3J0IGhhc0NsYXNzIGZyb20gJy4vaGFzQ2xhc3MnO1xuLyoqXG4gKiBBZGRzIGEgQ1NTIGNsYXNzIHRvIGEgZ2l2ZW4gZWxlbWVudC5cbiAqIFxuICogQHBhcmFtIGVsZW1lbnQgdGhlIGVsZW1lbnRcbiAqIEBwYXJhbSBjbGFzc05hbWUgdGhlIENTUyBjbGFzcyBuYW1lXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYWRkQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gIGlmIChlbGVtZW50LmNsYXNzTGlzdCkgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7ZWxzZSBpZiAoIWhhc0NsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSkpIGlmICh0eXBlb2YgZWxlbWVudC5jbGFzc05hbWUgPT09ICdzdHJpbmcnKSBlbGVtZW50LmNsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NOYW1lICsgXCIgXCIgKyBjbGFzc05hbWU7ZWxzZSBlbGVtZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoZWxlbWVudC5jbGFzc05hbWUgJiYgZWxlbWVudC5jbGFzc05hbWUuYmFzZVZhbCB8fCAnJykgKyBcIiBcIiArIGNsYXNzTmFtZSk7XG59IiwiLyoqXG4gKiBDaGVja3MgaWYgYSBnaXZlbiBlbGVtZW50IGhhcyBhIENTUyBjbGFzcy5cbiAqIFxuICogQHBhcmFtIGVsZW1lbnQgdGhlIGVsZW1lbnRcbiAqIEBwYXJhbSBjbGFzc05hbWUgdGhlIENTUyBjbGFzcyBuYW1lXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGhhc0NsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIHJldHVybiAhIWNsYXNzTmFtZSAmJiBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpO1xuICByZXR1cm4gKFwiIFwiICsgKGVsZW1lbnQuY2xhc3NOYW1lLmJhc2VWYWwgfHwgZWxlbWVudC5jbGFzc05hbWUpICsgXCIgXCIpLmluZGV4T2YoXCIgXCIgKyBjbGFzc05hbWUgKyBcIiBcIikgIT09IC0xO1xufSIsImZ1bmN0aW9uIHJlcGxhY2VDbGFzc05hbWUob3JpZ0NsYXNzLCBjbGFzc1RvUmVtb3ZlKSB7XG4gIHJldHVybiBvcmlnQ2xhc3MucmVwbGFjZShuZXcgUmVnRXhwKFwiKF58XFxcXHMpXCIgKyBjbGFzc1RvUmVtb3ZlICsgXCIoPzpcXFxcc3wkKVwiLCAnZycpLCAnJDEnKS5yZXBsYWNlKC9cXHMrL2csICcgJykucmVwbGFjZSgvXlxccyp8XFxzKiQvZywgJycpO1xufVxuLyoqXG4gKiBSZW1vdmVzIGEgQ1NTIGNsYXNzIGZyb20gYSBnaXZlbiBlbGVtZW50LlxuICogXG4gKiBAcGFyYW0gZWxlbWVudCB0aGUgZWxlbWVudFxuICogQHBhcmFtIGNsYXNzTmFtZSB0aGUgQ1NTIGNsYXNzIG5hbWVcbiAqL1xuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIHtcbiAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudC5jbGFzc05hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgZWxlbWVudC5jbGFzc05hbWUgPSByZXBsYWNlQ2xhc3NOYW1lKGVsZW1lbnQuY2xhc3NOYW1lLCBjbGFzc05hbWUpO1xuICB9IGVsc2Uge1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdjbGFzcycsIHJlcGxhY2VDbGFzc05hbWUoZWxlbWVudC5jbGFzc05hbWUgJiYgZWxlbWVudC5jbGFzc05hbWUuYmFzZVZhbCB8fCAnJywgY2xhc3NOYW1lKSk7XG4gIH1cbn0iLCIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJldGhlcmV1bS1ibG9ja2llcy1iYXNlNjRcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiZXRoZXJldW0tYmxvY2tpZXMtYmFzZTY0XCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge30sXG4vKioqKioqLyBcdFx0XHRpZDogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4vKioqKioqLyBcdFx0fTtcblxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cblxuXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdGNvbnN0IHBuZ2xpYiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cdGNvbnN0IGhzbDJyZ2IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG5cdC8vIFRoZSByYW5kb20gbnVtYmVyIGlzIGEganMgaW1wbGVtZW50YXRpb24gb2YgdGhlIFhvcnNoaWZ0IFBSTkdcblx0Y29uc3QgcmFuZHNlZWQgPSBuZXcgQXJyYXkoNCk7IC8vIFhvcnNoaWZ0OiBbeCwgeSwgeiwgd10gMzIgYml0IHZhbHVlc1xuXG5cdGZ1bmN0aW9uIHNlZWRyYW5kKHNlZWQpIHtcblx0ICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmRzZWVkLmxlbmd0aDsgaSsrKSB7XG5cdCAgICByYW5kc2VlZFtpXSA9IDA7XG5cdCAgfVxuXHQgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VlZC5sZW5ndGg7IGkrKykge1xuXHQgICAgcmFuZHNlZWRbaSAlIDRdID0gKHJhbmRzZWVkW2kgJSA0XSA8PCA1KSAtIHJhbmRzZWVkW2kgJSA0XSArIHNlZWQuY2hhckNvZGVBdChpKTtcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiByYW5kKCkge1xuXHQgIC8vIGJhc2VkIG9uIEphdmEncyBTdHJpbmcuaGFzaENvZGUoKSwgZXhwYW5kZWQgdG8gNCAzMmJpdCB2YWx1ZXNcblx0ICBjb25zdCB0ID0gcmFuZHNlZWRbMF0gXiAocmFuZHNlZWRbMF0gPDwgMTEpO1xuXG5cdCAgcmFuZHNlZWRbMF0gPSByYW5kc2VlZFsxXTtcblx0ICByYW5kc2VlZFsxXSA9IHJhbmRzZWVkWzJdO1xuXHQgIHJhbmRzZWVkWzJdID0gcmFuZHNlZWRbM107XG5cdCAgcmFuZHNlZWRbM10gPSByYW5kc2VlZFszXSBeIChyYW5kc2VlZFszXSA+PiAxOSkgXiB0IF4gKHQgPj4gOCk7XG5cblx0ICByZXR1cm4gKHJhbmRzZWVkWzNdID4+PiAwKSAvICgxIDw8IDMxID4+PiAwKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZUNvbG9yKCkge1xuXHQgIC8vc2F0dXJhdGlvbiBpcyB0aGUgd2hvbGUgY29sb3Igc3BlY3RydW1cblx0ICBjb25zdCBoID0gTWF0aC5mbG9vcihyYW5kKCkgKiAzNjApO1xuXHQgIC8vc2F0dXJhdGlvbiBnb2VzIGZyb20gNDAgdG8gMTAwLCBpdCBhdm9pZHMgZ3JleWlzaCBjb2xvcnNcblx0ICBjb25zdCBzID0gcmFuZCgpICogNjAgKyA0MDtcblx0ICAvL2xpZ2h0bmVzcyBjYW4gYmUgYW55dGhpbmcgZnJvbSAwIHRvIDEwMCwgYnV0IHByb2JhYmlsaXRpZXMgYXJlIGEgYmVsbCBjdXJ2ZSBhcm91bmQgNTAlXG5cdCAgY29uc3QgbCA9IChyYW5kKCkgKyByYW5kKCkgKyByYW5kKCkgKyByYW5kKCkpICogMjUgO1xuXG5cdCAgcmV0dXJuIFtoIC8gMzYwLCBzIC8gMTAwLCBsIC8gMTAwXTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZUltYWdlRGF0YShzaXplKSB7XG5cdCAgY29uc3Qgd2lkdGggPSBzaXplOyAvLyBPbmx5IHN1cHBvcnQgc3F1YXJlIGljb25zIGZvciBub3dcblx0ICBjb25zdCBoZWlnaHQgPSBzaXplO1xuXG5cdCAgY29uc3QgZGF0YVdpZHRoID0gTWF0aC5jZWlsKHdpZHRoIC8gMik7XG5cdCAgY29uc3QgbWlycm9yV2lkdGggPSB3aWR0aCAtIGRhdGFXaWR0aDtcblxuXHQgIGNvbnN0IGRhdGEgPSBbXTtcblx0ICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG5cdCAgICBsZXQgcm93ID0gW107XG5cdCAgICBmb3IgKGxldCB4ID0gMDsgeCA8IGRhdGFXaWR0aDsgeCsrKSB7XG5cdCAgICAgIC8vIHRoaXMgbWFrZXMgZm9yZWdyb3VuZCBhbmQgYmFja2dyb3VuZCBjb2xvciB0byBoYXZlIGEgNDMlICgxLzIuMykgcHJvYmFiaWxpdHlcblx0ICAgICAgLy8gc3BvdCBjb2xvciBoYXMgMTMlIGNoYW5jZVxuXHQgICAgICByb3dbeF0gPSBNYXRoLmZsb29yKHJhbmQoKSAqIDIuMyk7XG5cdCAgICB9XG5cdCAgICBjb25zdCByID0gcm93LnNsaWNlKDAsIG1pcnJvcldpZHRoKS5yZXZlcnNlKCk7XG5cdCAgICByb3cgPSByb3cuY29uY2F0KHIpO1xuXG5cdCAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvdy5sZW5ndGg7IGkrKykge1xuXHQgICAgICBkYXRhLnB1c2gocm93W2ldKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gZGF0YTtcblx0fVxuXG5cdC8vIE1vZGlmaWVzIHRoZSBwYXNzZWQgUE5HIHRvIGZpbGwgaW4gYSBzcGVjaWZpZWQgcmVjdGFuZ2xlXG5cdGZ1bmN0aW9uIGZpbGxSZWN0KHBuZywgeCwgeSwgdywgaCwgY29sb3IpIHtcblx0ICBmb3IobGV0IGkgPSAwOyBpIDwgdzsgaSsrKSB7XG5cdCAgICBmb3IgKGxldCBqID0gMDsgaiA8IGg7IGorKykge1xuXHQgICAgICBwbmcuYnVmZmVyW3BuZy5pbmRleCh4ICsgaSwgeSArIGopXSA9IGNvbG9yO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIGJ1aWxkT3B0cyhvcHRzKSB7XG5cdCAgaWYgKCFvcHRzLnNlZWQpIHtcblx0ICAgIHRocm93IG5ldyBFcnJvcignTm8gc2VlZCBwcm92aWRlZCcpO1xuXHQgIH1cblxuXHQgIHNlZWRyYW5kKG9wdHMuc2VlZCk7XG5cblx0ICByZXR1cm4gT2JqZWN0LmFzc2lnbih7XG5cdCAgICBzaXplOiA4LFxuXHQgICAgc2NhbGU6IDE2LFxuXHQgICAgY29sb3I6IGNyZWF0ZUNvbG9yKCksXG5cdCAgICBiZ2NvbG9yOiBjcmVhdGVDb2xvcigpLFxuXHQgICAgc3BvdGNvbG9yOiBjcmVhdGVDb2xvcigpLFxuXHQgIH0sIG9wdHMpXG5cdH1cblxuXHRmdW5jdGlvbiBtYWtlQmxvY2tpZShhZGRyZXNzKSB7XG5cdCAgY29uc3Qgb3B0cyA9IGJ1aWxkT3B0cyh7IHNlZWQ6IGFkZHJlc3MudG9Mb3dlckNhc2UoKSB9KTtcblxuXHQgIGNvbnN0IGltYWdlRGF0YSA9IGNyZWF0ZUltYWdlRGF0YShvcHRzLnNpemUpO1xuXHQgIGNvbnN0IHdpZHRoID0gTWF0aC5zcXJ0KGltYWdlRGF0YS5sZW5ndGgpO1xuXG5cdCAgY29uc3QgcCA9IG5ldyBwbmdsaWIob3B0cy5zaXplICogb3B0cy5zY2FsZSwgb3B0cy5zaXplICogb3B0cy5zY2FsZSwgMyk7XG5cdCAgY29uc3QgYmdjb2xvciA9IHAuY29sb3IoLi4uaHNsMnJnYiguLi5vcHRzLmJnY29sb3IpKTtcblx0ICBjb25zdCBjb2xvciA9IHAuY29sb3IoLi4uaHNsMnJnYiguLi5vcHRzLmNvbG9yKSk7XG5cdCAgY29uc3Qgc3BvdGNvbG9yID0gcC5jb2xvciguLi5oc2wycmdiKC4uLm9wdHMuc3BvdGNvbG9yKSk7XG5cblx0ICBmb3IgKGxldCBpID0gMDsgaSA8IGltYWdlRGF0YS5sZW5ndGg7IGkrKykge1xuXHQgICAgY29uc3Qgcm93ID0gTWF0aC5mbG9vcihpIC8gd2lkdGgpO1xuXHQgICAgY29uc3QgY29sID0gaSAlIHdpZHRoO1xuXHQgICAgLy8gaWYgZGF0YSBpcyAwLCBsZWF2ZSB0aGUgYmFja2dyb3VuZFxuXHQgICAgaWYgKGltYWdlRGF0YVtpXSkge1xuXHQgICAgICAvLyBpZiBkYXRhIGlzIDIsIGNob29zZSBzcG90IGNvbG9yLCBpZiAxIGNob29zZSBmb3JlZ3JvdW5kXG5cdCAgICAgIGNvbnN0IHBuZ0NvbG9yID0gaW1hZ2VEYXRhW2ldID09IDEgPyBjb2xvciA6IHNwb3Rjb2xvcjtcblx0ICAgICAgZmlsbFJlY3QocCwgY29sICogb3B0cy5zY2FsZSwgcm93ICogb3B0cy5zY2FsZSwgb3B0cy5zY2FsZSwgb3B0cy5zY2FsZSwgcG5nQ29sb3IpO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gYGRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCwke3AuZ2V0QmFzZTY0KCl9YDtcblx0fVxuXG5cdG1vZHVsZS5leHBvcnRzID0gbWFrZUJsb2NraWU7XG5cblxuLyoqKi8gfSxcbi8qIDEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdC8qKlxuXHQgKiBBIGhhbmR5IGNsYXNzIHRvIGNhbGN1bGF0ZSBjb2xvciB2YWx1ZXMuXG5cdCAqXG5cdCAqIEB2ZXJzaW9uIDEuMFxuXHQgKiBAYXV0aG9yIFJvYmVydCBFaXNlbGUgPHJvYmVydEB4YXJnLm9yZz5cblx0ICogQGNvcHlyaWdodCBDb3B5cmlnaHQgKGMpIDIwMTAsIFJvYmVydCBFaXNlbGVcblx0ICogQGxpbmsgaHR0cDovL3d3dy54YXJnLm9yZy8yMDEwLzAzL2dlbmVyYXRlLWNsaWVudC1zaWRlLXBuZy1maWxlcy11c2luZy1qYXZhc2NyaXB0L1xuXHQgKiBAbGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL2JzZC1saWNlbnNlLnBocCBCU0QgTGljZW5zZVxuXHQgKlxuXHQgKi9cblxuXHQvLyBNb2RpZmllZCBieSBHZW9yZ2UgQ2hhbiA8Z2NoYW5AMjFjbi5jb20+XG5cblx0Ly8gRnVydGhlciBtb2RpZmllZCBieSBXaWxsIE8nQiA8QHdib2JlaXJuZT4gdG8gbWFrZSBpdFxuXHQvLyBVZ2xpZnlKUyBhbmQgXCJ1c2Ugc3RyaWN0XCI7IGZyaWVuZGx5XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih3aWR0aCxoZWlnaHQsZGVwdGgpIHtcblxuXG5cdCAgICAvLyBoZWxwZXIgZnVuY3Rpb25zIGZvciB0aGF0IGN0eFxuXHQgICAgZnVuY3Rpb24gd3JpdGUoYnVmZmVyLCBvZmZzKSB7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhcmd1bWVudHNbaV0ubGVuZ3RoOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgIGJ1ZmZlcltvZmZzKytdID0gYXJndW1lbnRzW2ldLmNoYXJBdChqKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gYnl0ZTIodykge1xuXHQgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKCh3ID4+IDgpICYgMjU1LCB3ICYgMjU1KTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gYnl0ZTQodykge1xuXHQgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKCh3ID4+IDI0KSAmIDI1NSwgKHcgPj4gMTYpICYgMjU1LCAodyA+PiA4KSAmIDI1NSwgdyAmIDI1NSk7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGJ5dGUybHNiKHcpIHtcblx0ICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh3ICYgMjU1LCAodyA+PiA4KSAmIDI1NSk7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMud2lkdGggICA9IHdpZHRoO1xuXHQgICAgdGhpcy5oZWlnaHQgID0gaGVpZ2h0O1xuXHQgICAgdGhpcy5kZXB0aCAgID0gZGVwdGg7XG5cblx0ICAgIC8vIHBpeGVsIGRhdGEgYW5kIHJvdyBmaWx0ZXIgaWRlbnRpZmllciBzaXplXG5cdCAgICB0aGlzLnBpeF9zaXplID0gaGVpZ2h0ICogKHdpZHRoICsgMSk7XG5cblx0ICAgIC8vIGRlZmxhdGUgaGVhZGVyLCBwaXhfc2l6ZSwgYmxvY2sgaGVhZGVycywgYWRsZXIzMiBjaGVja3N1bVxuXHQgICAgdGhpcy5kYXRhX3NpemUgPSAyICsgdGhpcy5waXhfc2l6ZSArIDUgKiBNYXRoLmZsb29yKCgweGZmZmUgKyB0aGlzLnBpeF9zaXplKSAvIDB4ZmZmZikgKyA0O1xuXG5cdCAgICAvLyBvZmZzZXRzIGFuZCBzaXplcyBvZiBQbmcgY2h1bmtzXG5cdCAgICB0aGlzLmloZHJfb2ZmcyA9IDA7IC8vIElIRFIgb2Zmc2V0IGFuZCBzaXplXG5cdCAgICB0aGlzLmloZHJfc2l6ZSA9IDQgKyA0ICsgMTMgKyA0O1xuXHQgICAgdGhpcy5wbHRlX29mZnMgPSB0aGlzLmloZHJfb2ZmcyArIHRoaXMuaWhkcl9zaXplOyAvLyBQTFRFIG9mZnNldCBhbmQgc2l6ZVxuXHQgICAgdGhpcy5wbHRlX3NpemUgPSA0ICsgNCArIDMgKiBkZXB0aCArIDQ7XG5cdCAgICB0aGlzLnRybnNfb2ZmcyA9IHRoaXMucGx0ZV9vZmZzICsgdGhpcy5wbHRlX3NpemU7IC8vIHRSTlMgb2Zmc2V0IGFuZCBzaXplXG5cdCAgICB0aGlzLnRybnNfc2l6ZSA9IDQgKyA0ICsgZGVwdGggKyA0O1xuXHQgICAgdGhpcy5pZGF0X29mZnMgPSB0aGlzLnRybnNfb2ZmcyArIHRoaXMudHJuc19zaXplOyAvLyBJREFUIG9mZnNldCBhbmQgc2l6ZVxuXHQgICAgdGhpcy5pZGF0X3NpemUgPSA0ICsgNCArIHRoaXMuZGF0YV9zaXplICsgNDtcblx0ICAgIHRoaXMuaWVuZF9vZmZzID0gdGhpcy5pZGF0X29mZnMgKyB0aGlzLmlkYXRfc2l6ZTsgLy8gSUVORCBvZmZzZXQgYW5kIHNpemVcblx0ICAgIHRoaXMuaWVuZF9zaXplID0gNCArIDQgKyA0O1xuXHQgICAgdGhpcy5idWZmZXJfc2l6ZSAgPSB0aGlzLmllbmRfb2ZmcyArIHRoaXMuaWVuZF9zaXplOyAvLyB0b3RhbCBQTkcgc2l6ZVxuXG5cdCAgICB0aGlzLmJ1ZmZlciAgPSBuZXcgQXJyYXkoKTtcblx0ICAgIHRoaXMucGFsZXR0ZSA9IG5ldyBPYmplY3QoKTtcblx0ICAgIHRoaXMucGluZGV4ICA9IDA7XG5cblx0ICAgIHZhciBfY3JjMzIgPSBuZXcgQXJyYXkoKTtcblxuXHQgICAgLy8gaW5pdGlhbGl6ZSBidWZmZXIgd2l0aCB6ZXJvIGJ5dGVzXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYnVmZmVyX3NpemU7IGkrKykge1xuXHQgICAgICAgIHRoaXMuYnVmZmVyW2ldID0gXCJcXHgwMFwiO1xuXHQgICAgfVxuXG5cdCAgICAvLyBpbml0aWFsaXplIG5vbi16ZXJvIGVsZW1lbnRzXG5cdCAgICB3cml0ZSh0aGlzLmJ1ZmZlciwgdGhpcy5paGRyX29mZnMsIGJ5dGU0KHRoaXMuaWhkcl9zaXplIC0gMTIpLCAnSUhEUicsIGJ5dGU0KHdpZHRoKSwgYnl0ZTQoaGVpZ2h0KSwgXCJcXHgwOFxceDAzXCIpO1xuXHQgICAgd3JpdGUodGhpcy5idWZmZXIsIHRoaXMucGx0ZV9vZmZzLCBieXRlNCh0aGlzLnBsdGVfc2l6ZSAtIDEyKSwgJ1BMVEUnKTtcblx0ICAgIHdyaXRlKHRoaXMuYnVmZmVyLCB0aGlzLnRybnNfb2ZmcywgYnl0ZTQodGhpcy50cm5zX3NpemUgLSAxMiksICd0Uk5TJyk7XG5cdCAgICB3cml0ZSh0aGlzLmJ1ZmZlciwgdGhpcy5pZGF0X29mZnMsIGJ5dGU0KHRoaXMuaWRhdF9zaXplIC0gMTIpLCAnSURBVCcpO1xuXHQgICAgd3JpdGUodGhpcy5idWZmZXIsIHRoaXMuaWVuZF9vZmZzLCBieXRlNCh0aGlzLmllbmRfc2l6ZSAtIDEyKSwgJ0lFTkQnKTtcblxuXHQgICAgLy8gaW5pdGlhbGl6ZSBkZWZsYXRlIGhlYWRlclxuXHQgICAgdmFyIGhlYWRlciA9ICgoOCArICg3IDw8IDQpKSA8PCA4KSB8ICgzIDw8IDYpO1xuXHQgICAgaGVhZGVyKz0gMzEgLSAoaGVhZGVyICUgMzEpO1xuXG5cdCAgICB3cml0ZSh0aGlzLmJ1ZmZlciwgdGhpcy5pZGF0X29mZnMgKyA4LCBieXRlMihoZWFkZXIpKTtcblxuXHQgICAgLy8gaW5pdGlhbGl6ZSBkZWZsYXRlIGJsb2NrIGhlYWRlcnNcblx0ICAgIGZvciAodmFyIGkgPSAwOyAoaSA8PCAxNikgLSAxIDwgdGhpcy5waXhfc2l6ZTsgaSsrKSB7XG5cdCAgICAgICAgdmFyIHNpemUsIGJpdHM7XG5cdCAgICAgICAgaWYgKGkgKyAweGZmZmYgPCB0aGlzLnBpeF9zaXplKSB7XG5cdCAgICAgICAgICAgIHNpemUgPSAweGZmZmY7XG5cdCAgICAgICAgICAgIGJpdHMgPSBcIlxceDAwXCI7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgc2l6ZSA9IHRoaXMucGl4X3NpemUgLSAoaSA8PCAxNikgLSBpO1xuXHQgICAgICAgICAgICBiaXRzID0gXCJcXHgwMVwiO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB3cml0ZSh0aGlzLmJ1ZmZlciwgdGhpcy5pZGF0X29mZnMgKyA4ICsgMiArIChpIDw8IDE2KSArIChpIDw8IDIpLCBiaXRzLCBieXRlMmxzYihzaXplKSwgYnl0ZTJsc2IofnNpemUpKTtcblx0ICAgIH1cblxuXHQgICAgLyogQ3JlYXRlIGNyYzMyIGxvb2t1cCB0YWJsZSAqL1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuXHQgICAgICAgIHZhciBjID0gaTtcblx0ICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykge1xuXHQgICAgICAgICAgICBpZiAoYyAmIDEpIHtcblx0ICAgICAgICAgICAgICAgIGMgPSAtMzA2Njc0OTEyIF4gKChjID4+IDEpICYgMHg3ZmZmZmZmZik7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBjID0gKGMgPj4gMSkgJiAweDdmZmZmZmZmO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIF9jcmMzMltpXSA9IGM7XG5cdCAgICB9XG5cblx0ICAgIC8vIGNvbXB1dGUgdGhlIGluZGV4IGludG8gYSBwbmcgZm9yIGEgZ2l2ZW4gcGl4ZWxcblx0ICAgIHRoaXMuaW5kZXggPSBmdW5jdGlvbih4LHkpIHtcblx0ICAgICAgICB2YXIgaSA9IHkgKiAodGhpcy53aWR0aCArIDEpICsgeCArIDE7XG5cdCAgICAgICAgdmFyIGogPSB0aGlzLmlkYXRfb2ZmcyArIDggKyAyICsgNSAqIE1hdGguZmxvb3IoKGkgLyAweGZmZmYpICsgMSkgKyBpO1xuXHQgICAgICAgIHJldHVybiBqO1xuXHQgICAgfVxuXG5cdCAgICAvLyBjb252ZXJ0IGEgY29sb3IgYW5kIGJ1aWxkIHVwIHRoZSBwYWxldHRlXG5cdCAgICB0aGlzLmNvbG9yID0gZnVuY3Rpb24ocmVkLCBncmVlbiwgYmx1ZSwgYWxwaGEpIHtcblxuXHQgICAgICAgIGFscGhhID0gYWxwaGEgPj0gMCA/IGFscGhhIDogMjU1O1xuXHQgICAgICAgIHZhciBjb2xvciA9ICgoKCgoYWxwaGEgPDwgOCkgfCByZWQpIDw8IDgpIHwgZ3JlZW4pIDw8IDgpIHwgYmx1ZTtcblxuXHQgICAgICAgIGlmICh0eXBlb2YgdGhpcy5wYWxldHRlW2NvbG9yXSA9PSBcInVuZGVmaW5lZFwiKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLnBpbmRleCA9PSB0aGlzLmRlcHRoKSByZXR1cm4gXCJcXHgwMFwiO1xuXG5cdCAgICAgICAgICAgIHZhciBuZHggPSB0aGlzLnBsdGVfb2ZmcyArIDggKyAzICogdGhpcy5waW5kZXg7XG5cblx0ICAgICAgICAgICAgdGhpcy5idWZmZXJbbmR4ICsgMF0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHJlZCk7XG5cdCAgICAgICAgICAgIHRoaXMuYnVmZmVyW25keCArIDFdID0gU3RyaW5nLmZyb21DaGFyQ29kZShncmVlbik7XG5cdCAgICAgICAgICAgIHRoaXMuYnVmZmVyW25keCArIDJdID0gU3RyaW5nLmZyb21DaGFyQ29kZShibHVlKTtcblx0ICAgICAgICAgICAgdGhpcy5idWZmZXJbdGhpcy50cm5zX29mZnMrOCt0aGlzLnBpbmRleF0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGFscGhhKTtcblxuXHQgICAgICAgICAgICB0aGlzLnBhbGV0dGVbY29sb3JdID0gU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLnBpbmRleCsrKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXMucGFsZXR0ZVtjb2xvcl07XG5cdCAgICB9XG5cblx0ICAgIC8vIG91dHB1dCBhIFBORyBzdHJpbmcsIEJhc2U2NCBlbmNvZGVkXG5cdCAgICB0aGlzLmdldEJhc2U2NCA9IGZ1bmN0aW9uKCkge1xuXG5cdCAgICAgICAgdmFyIHMgPSB0aGlzLmdldER1bXAoKTtcblxuXHQgICAgICAgIHZhciBjaCA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz1cIjtcblx0ICAgICAgICB2YXIgYzEsIGMyLCBjMywgZTEsIGUyLCBlMywgZTQ7XG5cdCAgICAgICAgdmFyIGwgPSBzLmxlbmd0aDtcblx0ICAgICAgICB2YXIgaSA9IDA7XG5cdCAgICAgICAgdmFyIHIgPSBcIlwiO1xuXG5cdCAgICAgICAgZG8ge1xuXHQgICAgICAgICAgICBjMSA9IHMuY2hhckNvZGVBdChpKTtcblx0ICAgICAgICAgICAgZTEgPSBjMSA+PiAyO1xuXHQgICAgICAgICAgICBjMiA9IHMuY2hhckNvZGVBdChpKzEpO1xuXHQgICAgICAgICAgICBlMiA9ICgoYzEgJiAzKSA8PCA0KSB8IChjMiA+PiA0KTtcblx0ICAgICAgICAgICAgYzMgPSBzLmNoYXJDb2RlQXQoaSsyKTtcblx0ICAgICAgICAgICAgaWYgKGwgPCBpKzIpIHsgZTMgPSA2NDsgfSBlbHNlIHsgZTMgPSAoKGMyICYgMHhmKSA8PCAyKSB8IChjMyA+PiA2KTsgfVxuXHQgICAgICAgICAgICBpZiAobCA8IGkrMykgeyBlNCA9IDY0OyB9IGVsc2UgeyBlNCA9IGMzICYgMHgzZjsgfVxuXHQgICAgICAgICAgICByKz0gY2guY2hhckF0KGUxKSArIGNoLmNoYXJBdChlMikgKyBjaC5jaGFyQXQoZTMpICsgY2guY2hhckF0KGU0KTtcblx0ICAgICAgICB9IHdoaWxlICgoaSs9IDMpIDwgbCk7XG5cdCAgICAgICAgcmV0dXJuIHI7XG5cdCAgICB9XG5cblx0ICAgIC8vIG91dHB1dCBhIFBORyBzdHJpbmdcblx0ICAgIHRoaXMuZ2V0RHVtcCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgIC8vIGNvbXB1dGUgYWRsZXIzMiBvZiBvdXRwdXQgcGl4ZWxzICsgcm93IGZpbHRlciBieXRlc1xuXHQgICAgICAgIHZhciBCQVNFID0gNjU1MjE7IC8qIGxhcmdlc3QgcHJpbWUgc21hbGxlciB0aGFuIDY1NTM2ICovXG5cdCAgICAgICAgdmFyIE5NQVggPSA1NTUyOyAvKiBOTUFYIGlzIHRoZSBsYXJnZXN0IG4gc3VjaCB0aGF0IDI1NW4obisxKS8yICsgKG4rMSkoQkFTRS0xKSA8PSAyXjMyLTEgKi9cblx0ICAgICAgICB2YXIgczEgPSAxO1xuXHQgICAgICAgIHZhciBzMiA9IDA7XG5cdCAgICAgICAgdmFyIG4gPSBOTUFYO1xuXG5cdCAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCB0aGlzLmhlaWdodDsgeSsrKSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIHggPSAtMTsgeCA8IHRoaXMud2lkdGg7IHgrKykge1xuXHQgICAgICAgICAgICAgICAgczErPSB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4KHgsIHkpXS5jaGFyQ29kZUF0KDApO1xuXHQgICAgICAgICAgICAgICAgczIrPSBzMTtcblx0ICAgICAgICAgICAgICAgIGlmICgobi09IDEpID09IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICBzMSU9IEJBU0U7XG5cdCAgICAgICAgICAgICAgICAgICAgczIlPSBCQVNFO1xuXHQgICAgICAgICAgICAgICAgICAgIG4gPSBOTUFYO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHMxJT0gQkFTRTtcblx0ICAgICAgICBzMiU9IEJBU0U7XG5cdCAgICAgICAgd3JpdGUodGhpcy5idWZmZXIsIHRoaXMuaWRhdF9vZmZzICsgdGhpcy5pZGF0X3NpemUgLSA4LCBieXRlNCgoczIgPDwgMTYpIHwgczEpKTtcblxuXHQgICAgICAgIC8vIGNvbXB1dGUgY3JjMzIgb2YgdGhlIFBORyBjaHVua3Ncblx0ICAgICAgICBmdW5jdGlvbiBjcmMzMihwbmcsIG9mZnMsIHNpemUpIHtcblx0ICAgICAgICAgICAgdmFyIGNyYyA9IC0xO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gNDsgaSA8IHNpemUtNDsgaSArPSAxKSB7XG5cdCAgICAgICAgICAgICAgICBjcmMgPSBfY3JjMzJbKGNyYyBeIHBuZ1tvZmZzK2ldLmNoYXJDb2RlQXQoMCkpICYgMHhmZl0gXiAoKGNyYyA+PiA4KSAmIDB4MDBmZmZmZmYpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHdyaXRlKHBuZywgb2ZmcytzaXplLTQsIGJ5dGU0KGNyYyBeIC0xKSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgY3JjMzIodGhpcy5idWZmZXIsIHRoaXMuaWhkcl9vZmZzLCB0aGlzLmloZHJfc2l6ZSk7XG5cdCAgICAgICAgY3JjMzIodGhpcy5idWZmZXIsIHRoaXMucGx0ZV9vZmZzLCB0aGlzLnBsdGVfc2l6ZSk7XG5cdCAgICAgICAgY3JjMzIodGhpcy5idWZmZXIsIHRoaXMudHJuc19vZmZzLCB0aGlzLnRybnNfc2l6ZSk7XG5cdCAgICAgICAgY3JjMzIodGhpcy5idWZmZXIsIHRoaXMuaWRhdF9vZmZzLCB0aGlzLmlkYXRfc2l6ZSk7XG5cdCAgICAgICAgY3JjMzIodGhpcy5idWZmZXIsIHRoaXMuaWVuZF9vZmZzLCB0aGlzLmllbmRfc2l6ZSk7XG5cblx0ICAgICAgICAvLyBjb252ZXJ0IFBORyB0byBzdHJpbmdcblx0ICAgICAgICByZXR1cm4gXCJcXHg4OVBOR1xcclxcblxceDFhXFxuXCIgKyB0aGlzLmJ1ZmZlci5qb2luKCcnKTtcblx0ICAgIH1cblx0fTtcblxuXG4vKioqLyB9LFxuLyogMiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0Ly8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjM1MzIxMS9oc2wtdG8tcmdiLWNvbG9yLWNvbnZlcnNpb25cblx0LyoqXG5cdCAqIENvbnZlcnRzIGFuIEhTTCBjb2xvciB2YWx1ZSB0byBSR0IuIENvbnZlcnNpb24gZm9ybXVsYVxuXHQgKiBhZGFwdGVkIGZyb20gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IU0xfY29sb3Jfc3BhY2UuXG5cdCAqIEFzc3VtZXMgaCwgcywgYW5kIGwgYXJlIGNvbnRhaW5lZCBpbiB0aGUgc2V0IFswLCAxXSBhbmRcblx0ICogcmV0dXJucyByLCBnLCBhbmQgYiBpbiB0aGUgc2V0IFswLCAyNTVdLlxuXHQgKlxuXHQgKiBAcGFyYW0gICB7bnVtYmVyfSAgaCAgICAgICBUaGUgaHVlXG5cdCAqIEBwYXJhbSAgIHtudW1iZXJ9ICBzICAgICAgIFRoZSBzYXR1cmF0aW9uXG5cdCAqIEBwYXJhbSAgIHtudW1iZXJ9ICBsICAgICAgIFRoZSBsaWdodG5lc3Ncblx0ICogQHJldHVybiAge0FycmF5fSAgICAgICAgICAgVGhlIFJHQiByZXByZXNlbnRhdGlvblxuXHQgKi9cblxuXHQgZnVuY3Rpb24gaHVlMnJnYihwLCBxLCB0KSB7XG5cdCAgIGlmKHQgPCAwKSB0ICs9IDE7XG5cdCAgIGlmKHQgPiAxKSB0IC09IDE7XG5cdCAgIGlmKHQgPCAxLzYpIHJldHVybiBwICsgKHEgLSBwKSAqIDYgKiB0O1xuXHQgICBpZih0IDwgMS8yKSByZXR1cm4gcTtcblx0ICAgaWYodCA8IDIvMykgcmV0dXJuIHAgKyAocSAtIHApICogKDIvMyAtIHQpICogNjtcblx0ICAgcmV0dXJuIHA7XG5cdCB9XG5cblx0ZnVuY3Rpb24gaHNsMnJnYihoLCBzLCBsKXtcblx0ICBsZXQgciwgZywgYjtcblxuXHQgIGlmIChzID09IDApIHtcblx0ICAgIHIgPSBnID0gYiA9IGw7IC8vIGFjaHJvbWF0aWNcblx0ICB9IGVsc2Uge1xuXHQgICAgY29uc3QgcSA9IGwgPCAwLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHM7XG5cdCAgICBjb25zdCBwID0gMiAqIGwgLSBxO1xuXHQgICAgciA9IGh1ZTJyZ2IocCwgcSwgaCArIDEvMyk7XG5cdCAgICBnID0gaHVlMnJnYihwLCBxLCBoKTtcblx0ICAgIGIgPSBodWUycmdiKHAsIHEsIGggLSAxLzMpO1xuXHQgIH1cblxuXHQgIHJldHVybiBbTWF0aC5yb3VuZChyICogMjU1KSwgTWF0aC5yb3VuZChnICogMjU1KSwgTWF0aC5yb3VuZChiICogMjU1KSwgMjU1XTtcblx0fVxuXG5cdG1vZHVsZS5leHBvcnRzID0gaHNsMnJnYjtcblxuXG4vKioqLyB9XG4vKioqKioqLyBdKVxufSk7XG47IiwiKGZ1bmN0aW9uKGEsYil7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kKWRlZmluZShbXSxiKTtlbHNlIGlmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBleHBvcnRzKWIoKTtlbHNle2IoKSxhLkZpbGVTYXZlcj17ZXhwb3J0czp7fX0uZXhwb3J0c319KSh0aGlzLGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYihhLGIpe3JldHVyblwidW5kZWZpbmVkXCI9PXR5cGVvZiBiP2I9e2F1dG9Cb206ITF9Olwib2JqZWN0XCIhPXR5cGVvZiBiJiYoY29uc29sZS53YXJuKFwiRGVwcmVjYXRlZDogRXhwZWN0ZWQgdGhpcmQgYXJndW1lbnQgdG8gYmUgYSBvYmplY3RcIiksYj17YXV0b0JvbTohYn0pLGIuYXV0b0JvbSYmL15cXHMqKD86dGV4dFxcL1xcUyp8YXBwbGljYXRpb25cXC94bWx8XFxTKlxcL1xcUypcXCt4bWwpXFxzKjsuKmNoYXJzZXRcXHMqPVxccyp1dGYtOC9pLnRlc3QoYS50eXBlKT9uZXcgQmxvYihbXCJcXHVGRUZGXCIsYV0se3R5cGU6YS50eXBlfSk6YX1mdW5jdGlvbiBjKGEsYixjKXt2YXIgZD1uZXcgWE1MSHR0cFJlcXVlc3Q7ZC5vcGVuKFwiR0VUXCIsYSksZC5yZXNwb25zZVR5cGU9XCJibG9iXCIsZC5vbmxvYWQ9ZnVuY3Rpb24oKXtnKGQucmVzcG9uc2UsYixjKX0sZC5vbmVycm9yPWZ1bmN0aW9uKCl7Y29uc29sZS5lcnJvcihcImNvdWxkIG5vdCBkb3dubG9hZCBmaWxlXCIpfSxkLnNlbmQoKX1mdW5jdGlvbiBkKGEpe3ZhciBiPW5ldyBYTUxIdHRwUmVxdWVzdDtiLm9wZW4oXCJIRUFEXCIsYSwhMSk7dHJ5e2Iuc2VuZCgpfWNhdGNoKGEpe31yZXR1cm4gMjAwPD1iLnN0YXR1cyYmMjk5Pj1iLnN0YXR1c31mdW5jdGlvbiBlKGEpe3RyeXthLmRpc3BhdGNoRXZlbnQobmV3IE1vdXNlRXZlbnQoXCJjbGlja1wiKSl9Y2F0Y2goYyl7dmFyIGI9ZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJNb3VzZUV2ZW50c1wiKTtiLmluaXRNb3VzZUV2ZW50KFwiY2xpY2tcIiwhMCwhMCx3aW5kb3csMCwwLDAsODAsMjAsITEsITEsITEsITEsMCxudWxsKSxhLmRpc3BhdGNoRXZlbnQoYil9fXZhciBmPVwib2JqZWN0XCI9PXR5cGVvZiB3aW5kb3cmJndpbmRvdy53aW5kb3c9PT13aW5kb3c/d2luZG93Olwib2JqZWN0XCI9PXR5cGVvZiBzZWxmJiZzZWxmLnNlbGY9PT1zZWxmP3NlbGY6XCJvYmplY3RcIj09dHlwZW9mIGdsb2JhbCYmZ2xvYmFsLmdsb2JhbD09PWdsb2JhbD9nbG9iYWw6dm9pZCAwLGE9Zi5uYXZpZ2F0b3ImJi9NYWNpbnRvc2gvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkmJi9BcHBsZVdlYktpdC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSYmIS9TYWZhcmkvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCksZz1mLnNhdmVBc3x8KFwib2JqZWN0XCIhPXR5cGVvZiB3aW5kb3d8fHdpbmRvdyE9PWY/ZnVuY3Rpb24oKXt9OlwiZG93bmxvYWRcImluIEhUTUxBbmNob3JFbGVtZW50LnByb3RvdHlwZSYmIWE/ZnVuY3Rpb24oYixnLGgpe3ZhciBpPWYuVVJMfHxmLndlYmtpdFVSTCxqPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO2c9Z3x8Yi5uYW1lfHxcImRvd25sb2FkXCIsai5kb3dubG9hZD1nLGoucmVsPVwibm9vcGVuZXJcIixcInN0cmluZ1wiPT10eXBlb2YgYj8oai5ocmVmPWIsai5vcmlnaW49PT1sb2NhdGlvbi5vcmlnaW4/ZShqKTpkKGouaHJlZik/YyhiLGcsaCk6ZShqLGoudGFyZ2V0PVwiX2JsYW5rXCIpKTooai5ocmVmPWkuY3JlYXRlT2JqZWN0VVJMKGIpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtpLnJldm9rZU9iamVjdFVSTChqLmhyZWYpfSw0RTQpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtlKGopfSwwKSl9OlwibXNTYXZlT3JPcGVuQmxvYlwiaW4gbmF2aWdhdG9yP2Z1bmN0aW9uKGYsZyxoKXtpZihnPWd8fGYubmFtZXx8XCJkb3dubG9hZFwiLFwic3RyaW5nXCIhPXR5cGVvZiBmKW5hdmlnYXRvci5tc1NhdmVPck9wZW5CbG9iKGIoZixoKSxnKTtlbHNlIGlmKGQoZikpYyhmLGcsaCk7ZWxzZXt2YXIgaT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtpLmhyZWY9ZixpLnRhcmdldD1cIl9ibGFua1wiLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtlKGkpfSl9fTpmdW5jdGlvbihiLGQsZSxnKXtpZihnPWd8fG9wZW4oXCJcIixcIl9ibGFua1wiKSxnJiYoZy5kb2N1bWVudC50aXRsZT1nLmRvY3VtZW50LmJvZHkuaW5uZXJUZXh0PVwiZG93bmxvYWRpbmcuLi5cIiksXCJzdHJpbmdcIj09dHlwZW9mIGIpcmV0dXJuIGMoYixkLGUpO3ZhciBoPVwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCI9PT1iLnR5cGUsaT0vY29uc3RydWN0b3IvaS50ZXN0KGYuSFRNTEVsZW1lbnQpfHxmLnNhZmFyaSxqPS9DcmlPU1xcL1tcXGRdKy8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtpZigoanx8aCYmaXx8YSkmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBGaWxlUmVhZGVyKXt2YXIgaz1uZXcgRmlsZVJlYWRlcjtrLm9ubG9hZGVuZD1mdW5jdGlvbigpe3ZhciBhPWsucmVzdWx0O2E9aj9hOmEucmVwbGFjZSgvXmRhdGE6W147XSo7LyxcImRhdGE6YXR0YWNobWVudC9maWxlO1wiKSxnP2cubG9jYXRpb24uaHJlZj1hOmxvY2F0aW9uPWEsZz1udWxsfSxrLnJlYWRBc0RhdGFVUkwoYil9ZWxzZXt2YXIgbD1mLlVSTHx8Zi53ZWJraXRVUkwsbT1sLmNyZWF0ZU9iamVjdFVSTChiKTtnP2cubG9jYXRpb249bTpsb2NhdGlvbi5ocmVmPW0sZz1udWxsLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtsLnJldm9rZU9iamVjdFVSTChtKX0sNEU0KX19KTtmLnNhdmVBcz1nLnNhdmVBcz1nLFwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGUmJihtb2R1bGUuZXhwb3J0cz1nKX0pO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1GaWxlU2F2ZXIubWluLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHJlYWN0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbmZ1bmN0aW9uIERlZmF1bHRCbGFuaygpIHtcbiAgICByZXR1cm4gcmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJwXCIsIG51bGwsIFwiTGlzdCBpcyBlbXB0eS4uLlwiKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IERlZmF1bHRCbGFuaztcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHJlYWN0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbmZ1bmN0aW9uIERlZmF1bHRMb2FkaW5nSW5kaWNhdG9yKCkge1xuICAgIHJldHVybiByZWFjdF8xLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJsb2FkaW5nLWluZGljYXRvclwiIH0sIFwibG9hZGluZy4uLlwiKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IERlZmF1bHRMb2FkaW5nSW5kaWNhdG9yO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgcmVhY3RfMSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIGRlZmF1bHRQcm9wcyA9IHtcbiAgICBkaXNwbGF5OiB7XG4gICAgICAgIGdyaWQ6IGZhbHNlLFxuICAgICAgICBncmlkR2FwOiBcIjIwcHhcIixcbiAgICAgICAgZ3JpZE1pbkNvbHVtbldpZHRoOiBcIjIwMHB4XCIsXG4gICAgICAgIHJvdzogZmFsc2UsXG4gICAgICAgIHJvd0dhcDogXCIyMHB4XCIsXG4gICAgfSxcbiAgICBkaXNwbGF5R3JpZDogZmFsc2UsXG4gICAgZGlzcGxheVJvdzogZmFsc2UsXG4gICAgZ3JpZEdhcDogXCIyMHB4XCIsXG4gICAgbWluQ29sdW1uV2lkdGg6IFwiMjAwcHhcIixcbiAgICByb3dHYXA6IFwiMjBweFwiLFxufTtcbmZ1bmN0aW9uIERpc3BsYXlIYW5kbGVyKHByb3BzKSB7XG4gICAgdmFyIF9hID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGRlZmF1bHRQcm9wcyksIHByb3BzKSwgZGlzcGxheUdyaWQgPSBfYS5kaXNwbGF5R3JpZCwgZGlzcGxheVJvdyA9IF9hLmRpc3BsYXlSb3csIGRpc3BsYXkgPSBfYS5kaXNwbGF5LCBncmlkR2FwID0gX2EuZ3JpZEdhcCwgbWluQ29sdW1uV2lkdGggPSBfYS5taW5Db2x1bW5XaWR0aCwgcm93R2FwID0gX2Eucm93R2FwO1xuICAgIHZhciBjaGlsZFNwYW5SZWYgPSAoMCwgcmVhY3RfMS5jcmVhdGVSZWYpKCk7XG4gICAgdmFyIF9iID0gKDAsIHJlYWN0XzEudXNlU3RhdGUpKCksIGNvbWJvID0gX2JbMF0sIHNldFBhcmVudENvbXBvbmVudCA9IF9iWzFdO1xuICAgIHZhciBzdHlsZVBhcmVudEdyaWQgPSBmdW5jdGlvbiAoc3R5bGVUYWcsIGNvbnRhaW5lcikge1xuICAgICAgICBpZiAoZGlzcGxheUdyaWQgfHwgZGlzcGxheS5ncmlkKSB7XG4gICAgICAgICAgICB2YXIgZ2FwID0gZGlzcGxheS5ncmlkR2FwIHx8IGdyaWRHYXAgfHwgZGVmYXVsdFByb3BzLmRpc3BsYXkuZ3JpZEdhcDtcbiAgICAgICAgICAgIHZhciBjb2x1bW4gPSBkaXNwbGF5LmdyaWRNaW5Db2x1bW5XaWR0aCB8fFxuICAgICAgICAgICAgICAgIG1pbkNvbHVtbldpZHRoIHx8XG4gICAgICAgICAgICAgICAgZGVmYXVsdFByb3BzLmRpc3BsYXkuZ3JpZE1pbkNvbHVtbldpZHRoO1xuICAgICAgICAgICAgc3R5bGVUYWcuaW5uZXJIVE1MID0gXCJcXG4gICAgICAgICAgW2RhdGEtY29udD1cXFwiXCIuY29uY2F0KGNvbnRhaW5lci5kYXRhc2V0LmNvbnQsIFwiXFxcIl0ge1xcbiAgICAgICAgICAgICAgZGlzcGxheTogZ3JpZDtcXG4gICAgICAgICAgICAgIGdyaWQtZ2FwOiBcIikuY29uY2F0KGdhcCwgXCI7XFxuICAgICAgICAgICAgICBnYXA6IFwiKS5jb25jYXQoZ2FwLCBcIjtcXG4gICAgICAgICAgICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KGF1dG8tZmlsbCwgbWlubWF4KFwiKS5jb25jYXQoY29sdW1uLCBcIiwgMWZyKSk7XFxuICAgICAgICAgICAgICBncmlkLXRlbXBsYXRlLXJvd3M6IGF1dG87XFxuICAgICAgICAgICAgICBhbGlnbi1pdGVtczogc3RyZXRjaDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBcXG4gICAgICAgICAgW2RhdGEtY29udD1cXFwiXCIpLmNvbmNhdChjb250YWluZXIuZGF0YXNldC5jb250LCBcIlxcXCJdIC5fX2luZmluaXRlLWxvYWRlcixcXG4gICAgICAgICAgW2RhdGEtY29udD1cXFwiXCIpLmNvbmNhdChjb250YWluZXIuZGF0YXNldC5jb250LCBcIlxcXCJdIC5fX19zY3JvbGwtcmVuZGVyZXItYW5jaG9yLFxcbiAgICAgICAgICBbZGF0YS1jb250PVxcXCJcIikuY29uY2F0KGNvbnRhaW5lci5kYXRhc2V0LmNvbnQsIFwiXFxcIl0gLl9fX2xpc3Qtc2VwYXJhdG9yIHtcXG4gICAgICAgICAgICAgIGdyaWQtY29sdW1uOiAxLy0xO1xcbiAgICAgICAgICB9XFxuICAgICAgXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3R5bGVUYWcuaW5uZXJIVE1MID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIHN0eWxlUGFyZW50Um93ID0gZnVuY3Rpb24gKHN0eWxlVGFnLCBjb250YWluZXIpIHtcbiAgICAgICAgaWYgKGRpc3BsYXlSb3cgfHwgZGlzcGxheS5yb3cpIHtcbiAgICAgICAgICAgIHZhciBnYXAgPSBkaXNwbGF5LnJvd0dhcCB8fCByb3dHYXAgfHwgZGVmYXVsdFByb3BzLmRpc3BsYXkucm93R2FwO1xuICAgICAgICAgICAgc3R5bGVUYWcuaW5uZXJIVE1MID0gXCJcXG4gICAgICAgICAgW2RhdGEtY29udD1cXFwiXCIuY29uY2F0KGNvbnRhaW5lci5kYXRhc2V0LmNvbnQsIFwiXFxcIl0ge1xcbiAgICAgICAgICAgICAgZGlzcGxheTogZmxleDtcXG4gICAgICAgICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgXFxuICAgICAgICAgIFtkYXRhLWNvbnQ9XFxcIlwiKS5jb25jYXQoY29udGFpbmVyLmRhdGFzZXQuY29udCwgXCJcXFwiXSA+ICo6bm90KC5fX2luZmluaXRlLWxvYWRlcikge1xcbiAgICAgICAgICAgICAgZGlzcGxheTogYmxvY2s7XFxuICAgICAgICAgICAgICBmbGV4OiAxO1xcbiAgICAgICAgICAgICAgd2lkdGg6IDEwMCU7XFxuICAgICAgICAgICAgICBtYXJnaW4tYm90dG9tOiBcIikuY29uY2F0KGdhcCwgXCI7XFxuICAgICAgICAgIH1cXG4gICAgICBcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHlsZVRhZy5pbm5lckhUTUwgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgaGFuZGxlRGlzcGxheUhhbmRsZXJQcm9wcyA9IGZ1bmN0aW9uIChjb250YWluZXIsIHN0eWxlKSB7XG4gICAgICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgICAgICAgIGlmIChkaXNwbGF5LmdyaWQgfHwgZGlzcGxheUdyaWQpIHtcbiAgICAgICAgICAgICAgICBzdHlsZVBhcmVudEdyaWQoc3R5bGUsIGNvbnRhaW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkaXNwbGF5LnJvdyB8fCBkaXNwbGF5Um93KSB7XG4gICAgICAgICAgICAgICAgc3R5bGVQYXJlbnRSb3coc3R5bGUsIGNvbnRhaW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgICgwLCByZWFjdF8xLnVzZUVmZmVjdCkoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoY29tYm8pIHtcbiAgICAgICAgICAgIGhhbmRsZURpc3BsYXlIYW5kbGVyUHJvcHMoY29tYm9bMF0sIGNvbWJvWzFdKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgICgwLCByZWFjdF8xLnVzZUVmZmVjdCkoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3VycmVudCA9IGNoaWxkU3BhblJlZi5jdXJyZW50O1xuICAgICAgICB2YXIgY29udGFpbmVyO1xuICAgICAgICB2YXIgc3R5bGU7XG4gICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgICB2YXIgaWQgPSBcIl9fY29udGFpbmVyLVwiLmNvbmNhdChuZXcgRGF0ZSgpLmdldFRpbWUoKSk7XG4gICAgICAgICAgICBjb250YWluZXIgPSBjdXJyZW50LnBhcmVudE5vZGU7XG4gICAgICAgICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImRhdGEtY29udFwiLCBpZCk7XG4gICAgICAgICAgICAgICAgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiU1RZTEVcIik7XG4gICAgICAgICAgICAgICAgc3R5bGUuaWQgPSBpZDtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICAgICAgICAgICAgICBzZXRQYXJlbnRDb21wb25lbnQoW2NvbnRhaW5lciwgc3R5bGVdKTtcbiAgICAgICAgICAgICAgICBoYW5kbGVEaXNwbGF5SGFuZGxlclByb3BzKGNvbnRhaW5lciwgc3R5bGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRmxhdExpc3Q6IGl0IHdhcyBub3QgcG9zc2libGUgdG8gZ2V0IGNvbnRhaW5lcidzIHJlZi4gU3R5bGluZyB3aWxsIG5vdCBiZSBwb3NzaWJsZVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHN0eWxlKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHJldHVybiAocmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQocmVhY3RfMS5kZWZhdWx0LkZyYWdtZW50LCBudWxsLCAhY29tYm8gJiYgcmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgcmVmOiBjaGlsZFNwYW5SZWYsIHN0eWxlOiB7IGRpc3BsYXk6IFwibm9uZVwiIH0gfSkpKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IERpc3BsYXlIYW5kbGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgcmVhY3RfMSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIGlzVHlwZV8xID0gcmVxdWlyZShcIi4uL19fX3V0aWxzL2lzVHlwZVwiKTtcbnZhciBEZWZhdWx0TG9hZEluZGljYXRvcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL0RlZmF1bHRMb2FkSW5kaWNhdG9yXCIpKTtcbnZhciBJbmZpbml0ZUxvYWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSW5maW5pdGVMb2FkZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW5maW5pdGVMb2FkZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHByZXZJdGVtc0NvdW50OiBfdGhpcy5wcm9wcy5pdGVtc0NvdW50LFxuICAgICAgICAgICAgbG9hZEluZGljYXRvckNvbnRhaW5lcjogbnVsbCxcbiAgICAgICAgICAgIGxvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgc2Nyb2xsaW5nQ29udGFpbmVyOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5sb2FkZXJDb250YWluZXJSZWYgPSAoMCwgcmVhY3RfMS5jcmVhdGVSZWYpKCk7XG4gICAgICAgIC8vIHRyYWNrIHRoZSBsYXN0IHNjcm9sbCBwb3NpdGlvbiBzbyB3aGVuIG5ldyBkb20gZWxlbWVudHMgYXJlIGluc2VydGVkIHRvIGF2b2lkIHNjcm9sbCBqdW1wXG4gICAgICAgIF90aGlzLmxhc3RTY3JvbGxUb3AgPSAwO1xuICAgICAgICBfdGhpcy5tb3VudGVkID0gZmFsc2U7XG4gICAgICAgIC8vIGtlZXAgdHJhY2sgb2YgdGhlIGRvbSBpdGVtcyBpbiB0aGUgbGlzdFxuICAgICAgICBfdGhpcy5jdXJyZW50SXRlbXNDb3VudCA9IDA7XG4gICAgICAgIF90aGlzLmdldFNjcm9sbGluZ0NvbnRhaW5lckNoaWxkcmVuQ291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc2Nyb2xsaW5nQ29udGFpbmVyID0gX3RoaXMuc3RhdGUuc2Nyb2xsaW5nQ29udGFpbmVyO1xuICAgICAgICAgICAgaWYgKHNjcm9sbGluZ0NvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1heCgwLCBzY3JvbGxpbmdDb250YWluZXIuY2hpbGRyZW4ubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5zZXR1cFNjcm9sbGluZ0NvbnRhaW5lckV2ZW50c0xpc3RlbmVyID0gZnVuY3Rpb24gKHJlbW92ZUV2ZW50KSB7XG4gICAgICAgICAgICBpZiAocmVtb3ZlRXZlbnQgPT09IHZvaWQgMCkgeyByZW1vdmVFdmVudCA9IGZhbHNlOyB9XG4gICAgICAgICAgICB2YXIgc2Nyb2xsaW5nQ29udGFpbmVyID0gX3RoaXMuc3RhdGUuc2Nyb2xsaW5nQ29udGFpbmVyO1xuICAgICAgICAgICAgaWYgKHNjcm9sbGluZ0NvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIFtcInNjcm9sbFwiLCBcIm1vdXNld2hlZWxcIiwgXCJ0b3VjaG1vdmVcIl0uZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsaW5nQ29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIF90aGlzLmNoZWNrSWZMb2FkaW5nSXNOZWVkZWQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlbW92ZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxpbmdDb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgX3RoaXMuY2hlY2tJZkxvYWRpbmdJc05lZWRlZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gc2hvdyBvciBoaWRlIGxvYWRpbmcgaW5kaWNhdG9ycyBiYXNlZCBvbiBzY3JvbGwgcG9zaXRpb25cbiAgICAgICAgLy8gY2FsbHMgdGhlIFwibG9hZE1vcmVcIiBmdW5jdGlvbiB3aGVuIGlzIG5lZWRlZFxuICAgICAgICBfdGhpcy5jaGVja0lmTG9hZGluZ0lzTmVlZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5tb3VudGVkIHx8ICFfdGhpcy5wcm9wcy5oYXNNb3JlIHx8IF90aGlzLnN0YXRlLmxvYWRpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5zdGF0ZSwgc2Nyb2xsaW5nQ29udGFpbmVyID0gX2Euc2Nyb2xsaW5nQ29udGFpbmVyLCBsb2FkSW5kaWNhdG9yQ29udGFpbmVyID0gX2EubG9hZEluZGljYXRvckNvbnRhaW5lcjtcbiAgICAgICAgICAgIGlmIChzY3JvbGxpbmdDb250YWluZXIgJiYgbG9hZEluZGljYXRvckNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIHZhciBzY3JvbGxUb3AgPSBzY3JvbGxpbmdDb250YWluZXIuc2Nyb2xsVG9wLCBvZmZzZXRUb3AgPSBzY3JvbGxpbmdDb250YWluZXIub2Zmc2V0VG9wLCBvZmZzZXRIZWlnaHQgPSBzY3JvbGxpbmdDb250YWluZXIub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgICAgIF90aGlzLmxhc3RTY3JvbGxUb3AgPSBzY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgdmFyIGxvYWRlclBvc2l0aW9uID0gbG9hZEluZGljYXRvckNvbnRhaW5lci5vZmZzZXRUb3AgLSBzY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0aW5nUG9pbnQgPSBvZmZzZXRUb3AgKyBvZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKGxvYWRlclBvc2l0aW9uIDw9IHN0YXJ0aW5nUG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBwcmV2SXRlbXNDb3VudDogX3RoaXMucHJvcHMuaXRlbXNDb3VudCwgbG9hZGluZzogdHJ1ZSB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5sb2FkTW9yZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgSW5maW5pdGVMb2FkZXIucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLm1vdW50ZWQgPSB0cnVlO1xuICAgICAgICB2YXIgbG9hZEluZGljYXRvckNvbnRhaW5lciA9IHRoaXMubG9hZGVyQ29udGFpbmVyUmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmIChsb2FkSW5kaWNhdG9yQ29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBsb2FkSW5kaWNhdG9yQ29udGFpbmVyOiBsb2FkSW5kaWNhdG9yQ29udGFpbmVyLFxuICAgICAgICAgICAgICAgIHNjcm9sbGluZ0NvbnRhaW5lcjogbG9hZEluZGljYXRvckNvbnRhaW5lci5wYXJlbnROb2RlLFxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmN1cnJlbnRJdGVtc0NvdW50ID0gX3RoaXMuZ2V0U2Nyb2xsaW5nQ29udGFpbmVyQ2hpbGRyZW5Db3VudCgpO1xuICAgICAgICAgICAgICAgIF90aGlzLnNldHVwU2Nyb2xsaW5nQ29udGFpbmVyRXZlbnRzTGlzdGVuZXIoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRmxhdExpc3Q6IGl0IHdhcyBub3QgcG9zc2libGUgdG8gZ2V0IGNvbnRhaW5lcidzIHJlZi4gXCIgK1xuICAgICAgICAgICAgICAgIFwiSW5maW5pdGUgc2Nyb2xsaW5nIHBhZ2luYXRpb24gd2lsbCBub3QgYmUgcG9zc2libGVcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEluZmluaXRlTG9hZGVyLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAocHJldlByb3BzLCBwcmV2U3RhdGUpIHtcbiAgICAgICAgLy8gcmVzZXQgc2Nyb2xsIHBvc2l0aW9uIHRvIHdoZXJlIGxhc3Qgd2FzXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnNjcm9sbGluZ0NvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5zY3JvbGxpbmdDb250YWluZXIuc2Nyb2xsVG9wID0gdGhpcy5sYXN0U2Nyb2xsVG9wO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlc2V0IGxvYWRpbmcgc3RhdGUgd2hlbiB0aGUgbGlzdCBzaXplIGNoYW5nZXNcbiAgICAgICAgaWYgKHByZXZQcm9wcy5pdGVtc0NvdW50ICE9PSB0aGlzLnByb3BzLml0ZW1zQ291bnQpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoZWNrSWZMb2FkaW5nSXNOZWVkZWQoKTtcbiAgICB9O1xuICAgIEluZmluaXRlTG9hZGVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZXR1cFNjcm9sbGluZ0NvbnRhaW5lckV2ZW50c0xpc3RlbmVyKHRydWUpO1xuICAgICAgICB0aGlzLm1vdW50ZWQgPSBmYWxzZTtcbiAgICB9O1xuICAgIC8vIHVwZGF0ZSB0aGUgbG9hZGluZyBmbGFncyBhbmQgaXRlbXMgY291bnQgd2hldGhlciBcImhhc01vcmVcIiBpcyBmYWxzZSBvciBsaXN0IGNoYW5nZWRcbiAgICBJbmZpbml0ZUxvYWRlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBsb2FkaW5nOiBmYWxzZSB9KTtcbiAgICB9O1xuICAgIEluZmluaXRlTG9hZGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsb2FkaW5nID0gdGhpcy5zdGF0ZS5sb2FkaW5nO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCBoYXNNb3JlID0gX2EuaGFzTW9yZSwgX2IgPSBfYS5sb2FkaW5nSW5kaWNhdG9yLCBsb2FkaW5nSW5kaWNhdG9yID0gX2IgPT09IHZvaWQgMCA/IERlZmF1bHRMb2FkSW5kaWNhdG9yXzEuZGVmYXVsdCA6IF9iLCBfYyA9IF9hLmxvYWRpbmdJbmRpY2F0b3JQb3NpdGlvbiwgbG9hZGluZ0luZGljYXRvclBvc2l0aW9uID0gX2MgPT09IHZvaWQgMCA/IFwibGVmdFwiIDogX2M7XG4gICAgICAgIHZhciBzcGlubmluZyA9IGhhc01vcmUgJiYgbG9hZGluZztcbiAgICAgICAgLy8gZG8gbm90IHJlbW92ZSB0aGUgZWxlbWVudCBmcm9tIHRoZSBkb20gc28gdGhlIHJlZiBpcyBub3QgYnJva2VuIGJ1dCBzZXQgaXQgaW52aXNpYmxlIGVub3VnaFxuICAgICAgICB2YXIgc3R5bGVzID0ge1xuICAgICAgICAgICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgICAgICAgICBoZWlnaHQ6IHNwaW5uaW5nID8gXCJhdXRvXCIgOiAwLFxuICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6IGxvYWRpbmdJbmRpY2F0b3JQb3NpdGlvbiA9PT0gXCJjZW50ZXJcIlxuICAgICAgICAgICAgICAgID8gbG9hZGluZ0luZGljYXRvclBvc2l0aW9uXG4gICAgICAgICAgICAgICAgOiBsb2FkaW5nSW5kaWNhdG9yUG9zaXRpb24gPT09IFwicmlnaHRcIlxuICAgICAgICAgICAgICAgICAgICA/IFwiZmxleC1lbmRcIlxuICAgICAgICAgICAgICAgICAgICA6IFwiZmxleC1zdGFydFwiLFxuICAgICAgICAgICAgcGFkZGluZzogc3Bpbm5pbmcgPyBcIjVweCAwXCIgOiAwLFxuICAgICAgICAgICAgdmlzaWJpbGl0eTogc3Bpbm5pbmcgPyBcInZpc2libGVcIiA6IFwiaGlkZGVuXCIsXG4gICAgICAgIH07XG4gICAgICAgIHZhciBsb2FkaW5nRWwgPSAoMCwgaXNUeXBlXzEuaXNGdW5jdGlvbikobG9hZGluZ0luZGljYXRvcilcbiAgICAgICAgICAgID8gbG9hZGluZ0luZGljYXRvcigpXG4gICAgICAgICAgICA6IGxvYWRpbmdJbmRpY2F0b3I7XG4gICAgICAgIHJldHVybiAocmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IHRoaXMubG9hZGVyQ29udGFpbmVyUmVmLCBjbGFzc05hbWU6IFwiX19pbmZpbml0ZS1sb2FkZXJcIiwgc3R5bGU6IHN0eWxlcyB9LCBzcGlubmluZyAmJiAobG9hZGluZ0luZGljYXRvciA/IGxvYWRpbmdFbCA6IHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KERlZmF1bHRMb2FkSW5kaWNhdG9yXzEuZGVmYXVsdCwgbnVsbCkpKSk7XG4gICAgfTtcbiAgICByZXR1cm4gSW5maW5pdGVMb2FkZXI7XG59KHJlYWN0XzEuQ29tcG9uZW50KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBJbmZpbml0ZUxvYWRlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9fcmVzdCA9ICh0aGlzICYmIHRoaXMuX19yZXN0KSB8fCBmdW5jdGlvbiAocywgZSkge1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHJlYWN0XzEgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBjb252ZXJ0TGlzdFRvQXJyYXlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vX19fdXRpbHMvY29udmVydExpc3RUb0FycmF5XCIpKTtcbnZhciBpc1R5cGVfMSA9IHJlcXVpcmUoXCIuLi9fX191dGlscy9pc1R5cGVcIik7XG52YXIgU2Nyb2xsUmVuZGVyZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9TY3JvbGxSZW5kZXJlclwiKSk7XG52YXIgdWlGdW5jdGlvbnNfMSA9IHJlcXVpcmUoXCIuL3VpRnVuY3Rpb25zXCIpO1xuZnVuY3Rpb24gUGxhaW5MaXN0KHByb3BzKSB7XG4gICAgdmFyIGxpc3QgPSBwcm9wcy5saXN0LCByZW5kZXJJdGVtID0gcHJvcHMucmVuZGVySXRlbSwgcmVuZGVyV2hlbkVtcHR5ID0gcHJvcHMucmVuZGVyV2hlbkVtcHR5LCByZW5kZXJPblNjcm9sbCA9IHByb3BzLnJlbmRlck9uU2Nyb2xsLCB3cmFwcGVySHRtbFRhZyA9IHByb3BzLndyYXBwZXJIdG1sVGFnLCBfX2ZvcndhcmVkZWRSZWYgPSBwcm9wcy5fX2ZvcndhcmVkZWRSZWYsIHRhZ1Byb3BzID0gX19yZXN0KHByb3BzLCBbXCJsaXN0XCIsIFwicmVuZGVySXRlbVwiLCBcInJlbmRlcldoZW5FbXB0eVwiLCBcInJlbmRlck9uU2Nyb2xsXCIsIFwid3JhcHBlckh0bWxUYWdcIiwgXCJfX2ZvcndhcmVkZWRSZWZcIl0pO1xuICAgIHZhciBkYXRhTGlzdCA9ICgwLCBjb252ZXJ0TGlzdFRvQXJyYXlfMS5kZWZhdWx0KShsaXN0KTtcbiAgICB2YXIgcmVuZGVyVGhpc0l0ZW0gPSAoMCwgcmVhY3RfMS51c2VNZW1vKShmdW5jdGlvbiAoKSB7IHJldHVybiAoMCwgdWlGdW5jdGlvbnNfMS5oYW5kbGVSZW5kZXJJdGVtKShyZW5kZXJJdGVtLCBudWxsKTsgfSwgW3JlbmRlckl0ZW1dKTtcbiAgICBpZiAoZGF0YUxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiAoMCwgdWlGdW5jdGlvbnNfMS5yZW5kZXJCbGFuaykocmVuZGVyV2hlbkVtcHR5KTtcbiAgICB9XG4gICAgdmFyIFdyYXBwZXJFbGVtZW50ID0gXCJcIi5jb25jYXQoKDAsIGlzVHlwZV8xLmlzU3RyaW5nKSh3cmFwcGVySHRtbFRhZykgJiYgd3JhcHBlckh0bWxUYWcgPyB3cmFwcGVySHRtbFRhZyA6IFwiXCIpO1xuICAgIHZhciBjb250ZW50ID0gKHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KHJlYWN0XzEuZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgcmVuZGVyT25TY3JvbGwgPyAocmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoU2Nyb2xsUmVuZGVyZXJfMS5kZWZhdWx0LCB7IGxpc3Q6IGRhdGFMaXN0LCByZW5kZXJJdGVtOiByZW5kZXJJdGVtIH0pKSA6IChkYXRhTGlzdC5tYXAocmVuZGVyVGhpc0l0ZW0pKSkpO1xuICAgIHJldHVybiAocmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQocmVhY3RfMS5kZWZhdWx0LkZyYWdtZW50LCBudWxsLCBXcmFwcGVyRWxlbWVudCA/IChcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoV3JhcHBlckVsZW1lbnQsIF9fYXNzaWduKHt9LCB0YWdQcm9wcywgeyByZWY6IF9fZm9yd2FyZWRlZFJlZiB9KSwgY29udGVudCkpIDogKGNvbnRlbnQpKSk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSAoMCwgcmVhY3RfMS5mb3J3YXJkUmVmKShmdW5jdGlvbiAocHJvcHMsIHJlZikge1xuICAgIHJlZiA9IHJlZiB8fCAoMCwgcmVhY3RfMS5jcmVhdGVSZWYpKCk7XG4gICAgcmV0dXJuIHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFBsYWluTGlzdCwgX19hc3NpZ24oeyBfX2ZvcndhcmVkZWRSZWY6IHJlZiB9LCBwcm9wcykpO1xufSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHJlYWN0XzEgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciB1aUZ1bmN0aW9uc18xID0gcmVxdWlyZShcIi4vdWlGdW5jdGlvbnNcIik7XG5mdW5jdGlvbiBTY3JvbGxSZW5kZXJlcihwcm9wcykge1xuICAgIHZhciBfYSA9IHByb3BzLmxpc3QsIGxpc3QgPSBfYSA9PT0gdm9pZCAwID8gW10gOiBfYSwgX2IgPSBwcm9wcy5yZW5kZXJJdGVtLCByZW5kZXJJdGVtID0gX2IgPT09IHZvaWQgMCA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH0gOiBfYiwgX2MgPSBwcm9wcy5ncm91cFNlcGFyYXRvciwgZ3JvdXBTZXBhcmF0b3IgPSBfYyA9PT0gdm9pZCAwID8gbnVsbCA6IF9jO1xuICAgIHZhciBfZCA9ICgwLCByZWFjdF8xLnVzZVN0YXRlKSh7IHJlbmRlckxpc3Q6IFtdLCBpbmRleDogMCB9KSwgcmVuZGVyID0gX2RbMF0sIHNldFJlbmRlciA9IF9kWzFdO1xuICAgIHZhciBfZSA9ICgwLCByZWFjdF8xLnVzZVN0YXRlKShmYWxzZSksIG1vdW50ZWQgPSBfZVswXSwgc2V0TW91bnRlZCA9IF9lWzFdO1xuICAgIHZhciBfZiA9ICgwLCByZWFjdF8xLnVzZVN0YXRlKSgtMSksIHNldHVwQ291bnQgPSBfZlswXSwgc2V0U2V0dXBDb3VudCA9IF9mWzFdO1xuICAgIHZhciBjb250YWluZXJSZWYgPSAoMCwgcmVhY3RfMS5jcmVhdGVSZWYpKCk7XG4gICAgdmFyIHJlbmRlclRoaXNJdGVtID0gKDAsIHJlYWN0XzEudXNlTWVtbykoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKDAsIHVpRnVuY3Rpb25zXzEuaGFuZGxlUmVuZGVySXRlbSkocmVuZGVySXRlbSwgKDAsIHVpRnVuY3Rpb25zXzEuaGFuZGxlUmVuZGVyR3JvdXBTZXBhcmF0b3IpKGdyb3VwU2VwYXJhdG9yKSk7XG4gICAgfSwgW3JlbmRlckl0ZW0sIGdyb3VwU2VwYXJhdG9yXSk7XG4gICAgdmFyIHVwZGF0ZVJlbmRlckluZm8gPSBmdW5jdGlvbiAoY291bnQpIHtcbiAgICAgICAgaWYgKGNvdW50ID09PSB2b2lkIDApIHsgY291bnQgPSAxMDsgfVxuICAgICAgICBpZiAocmVuZGVyLmluZGV4IDwgbGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHJlbmRlci5pbmRleCArIGNvdW50O1xuICAgICAgICAgICAgc2V0UmVuZGVyKHtcbiAgICAgICAgICAgICAgICByZW5kZXJMaXN0OiBsaXN0LnNsaWNlKDAsIGluZGV4KSxcbiAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIG9uU2Nyb2xsID0gZnVuY3Rpb24gKHNwYW4pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChzcGFuKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudF8xID0gc3Bhbi5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydGluZ1BvaW50ID0gcGFyZW50XzEub2Zmc2V0VG9wICsgcGFyZW50XzEub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgICAgIHZhciBhbmNob3JQb3MgPSBzcGFuLm9mZnNldFRvcCAtIHBhcmVudF8xLnNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICBpZiAoYW5jaG9yUG9zIDw9IHN0YXJ0aW5nUG9pbnQgKyBwYXJlbnRfMS5vZmZzZXRIZWlnaHQgKiAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVJlbmRlckluZm8oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07IH07XG4gICAgKDAsIHJlYWN0XzEudXNlRWZmZWN0KShmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHdoZW4gbW91bnRlZFxuICAgICAgICBzZXRNb3VudGVkKHRydWUpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gd2hlbiB1bm1vdW50ZWRcbiAgICAgICAgICAgIHNldE1vdW50ZWQoZmFsc2UpO1xuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICAoMCwgcmVhY3RfMS51c2VMYXlvdXRFZmZlY3QpKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG1vdW50ZWQpIHtcbiAgICAgICAgICAgIC8vIHJlc2V0IGxpc3Qgb24gbGlzdCBjaGFuZ2VcbiAgICAgICAgICAgIHZhciBzcGFuXzEgPSBjb250YWluZXJSZWYuY3VycmVudDtcbiAgICAgICAgICAgIHZhciBwb3NfMSA9IHNwYW5fMS5wYXJlbnROb2RlLnNjcm9sbFRvcDtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IE1hdGgubWF4KHJlbmRlci5yZW5kZXJMaXN0Lmxlbmd0aCwgc2V0dXBDb3VudCk7XG4gICAgICAgICAgICBzZXRSZW5kZXIoe1xuICAgICAgICAgICAgICAgIHJlbmRlckxpc3Q6IGxpc3Quc2xpY2UoMCwgaW5kZXgpLFxuICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3Bhbl8xICYmIHNwYW5fMS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNwYW5fMS5wYXJlbnROb2RlLnNjcm9sbFRvcCA9IHBvc18xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwgW2xpc3RdKTtcbiAgICAoMCwgcmVhY3RfMS51c2VMYXlvdXRFZmZlY3QpKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNwYW4gPSBjb250YWluZXJSZWYuY3VycmVudDtcbiAgICAgICAgdmFyIGhhbmRsZVNjcm9sbCA9IG9uU2Nyb2xsKHNwYW4pO1xuICAgICAgICB2YXIgY29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgaWYgKHNwYW4pIHtcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IHNwYW4ucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gcG9wdWxhdGUgZG91YmxlIHRoZSBjb250YWluZXIgaGVpZ2h0IG9mIGl0ZW1zXG4gICAgICAgICAgICAgICAgaWYgKHJlbmRlci5pbmRleCA9PT0gMCB8fFxuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIuc2Nyb2xsSGVpZ2h0IDw9IGNvbnRhaW5lci5vZmZzZXRIZWlnaHQgKiAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVJlbmRlckluZm8oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2V0dXBDb3VudCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0U2V0dXBDb3VudChyZW5kZXIuaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgaGFuZGxlU2Nyb2xsLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIHdoZW4gdW5tb3VudGVkXG4gICAgICAgICAgICBpZiAoc3Bhbikge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGhhbmRsZVNjcm9sbCwge1xuICAgICAgICAgICAgICAgICAgICBwYXNzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sIFtyZW5kZXIuaW5kZXgsIGxpc3QubGVuZ3RoXSk7XG4gICAgcmV0dXJuIChyZWFjdF8xLmRlZmF1bHQuY3JlYXRlRWxlbWVudChyZWFjdF8xLmRlZmF1bHQuRnJhZ21lbnQsIG51bGwsXG4gICAgICAgIHJlbmRlci5yZW5kZXJMaXN0Lm1hcChmdW5jdGlvbiAoaXRlbSwgaWR4KSB7IHJldHVybiByZW5kZXJUaGlzSXRlbShpdGVtLCBcIlwiLmNvbmNhdChpZHgpKTsgfSksXG4gICAgICAgIHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7IHJlZjogY29udGFpbmVyUmVmLCBzdHlsZTogeyB2aXNpYmlsaXR5OiBcImhpZGRlblwiLCBoZWlnaHQ6IDEgfSwgY2xhc3NOYW1lOiBcIl9fX3Njcm9sbC1yZW5kZXJlci1hbmNob3JcIiB9KSkpO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gU2Nyb2xsUmVuZGVyZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHJlYWN0XzEgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBpc1R5cGVfMSA9IHJlcXVpcmUoXCIuLi9fX191dGlscy9pc1R5cGVcIik7XG52YXIgdWlGdW5jdGlvbnNfMSA9IHJlcXVpcmUoXCIuL3VpRnVuY3Rpb25zXCIpO1xuZnVuY3Rpb24gU2Nyb2xsVG9Ub3BCdXR0b24ocHJvcHMpIHtcbiAgICB2YXIgYW5jaG9yID0gKDAsIHJlYWN0XzEuY3JlYXRlUmVmKSgpO1xuICAgIHZhciBfYSA9IHByb3BzLmJ1dHRvbiwgYnV0dG9uID0gX2EgPT09IHZvaWQgMCA/IG51bGwgOiBfYSwgX2IgPSBwcm9wcy5wb3NpdGlvbiwgcG9zaXRpb24gPSBfYiA9PT0gdm9pZCAwID8gXCJib3R0b20gcmlnaHRcIiA6IF9iLCBfYyA9IHByb3BzLnBhZGRpbmcsIHBhZGRpbmcgPSBfYyA9PT0gdm9pZCAwID8gMjAgOiBfYywgX2QgPSBwcm9wcy5vZmZzZXQsIG9mZnNldCA9IF9kID09PSB2b2lkIDAgPyA1MCA6IF9kLCBzY3JvbGxpbmdDb250YWluZXIgPSBwcm9wcy5zY3JvbGxpbmdDb250YWluZXI7XG4gICAgdmFyIGJ0biA9ICgwLCBpc1R5cGVfMS5pc0Z1bmN0aW9uKShidXR0b24pID8gYnV0dG9uKCkgOiBidXR0b247XG4gICAgdmFyIF9lID0gKDAsIHJlYWN0XzEudXNlU3RhdGUpKGZhbHNlKSwgbW91bnRlZCA9IF9lWzBdLCBzZXRNb3VudGVkID0gX2VbMV07XG4gICAgKDAsIHJlYWN0XzEudXNlRWZmZWN0KShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBidXR0b25FbGVtZW50ID0gYW5jaG9yLmN1cnJlbnQubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgICB2YXIgY29udGFpbmVyID0gYW5jaG9yLmN1cnJlbnQucGFyZW50Tm9kZTtcbiAgICAgICAgdmFyIHNjcm9sbENvbnRhaW5lciA9IHNjcm9sbGluZ0NvbnRhaW5lci5jdXJyZW50O1xuICAgICAgICB2YXIgY29udGFpbmVyU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGNvbnRhaW5lcik7XG4gICAgICAgIHZhciBvZ1BvcyA9IGNvbnRhaW5lclN0eWxlLnBvc2l0aW9uO1xuICAgICAgICBjb250YWluZXIuc3R5bGUucG9zaXRpb24gPSBbXCJhYnNvbHV0ZVwiLCBcImZpeGVkXCIsIFwicmVsYXRpdmVcIl0uaW5jbHVkZXMob2dQb3MpXG4gICAgICAgICAgICA/IG9nUG9zXG4gICAgICAgICAgICA6IFwicmVsYXRpdmVcIjtcbiAgICAgICAgdmFyIHBvc2l0aW9uQnRuID0gKDAsIHVpRnVuY3Rpb25zXzEuYnRuUG9zaXRpb24pKHNjcm9sbENvbnRhaW5lciwgYnV0dG9uRWxlbWVudCk7XG4gICAgICAgIHZhciBwb3MgPSBwb3NpdGlvbi5zcGxpdChcIiBcIik7XG4gICAgICAgIHZhciB1cGRhdGVCdG5Qb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBwb3NpdGlvbkJ0bihwb3NbMF0sIHBvc1sxXSwgcGFkZGluZywgb2Zmc2V0KTtcbiAgICAgICAgfTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdXBkYXRlQnRuUG9zaXRpb24pO1xuICAgICAgICBzY3JvbGxDb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB1cGRhdGVCdG5Qb3NpdGlvbik7XG4gICAgICAgIGJ1dHRvbkVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNjcm9sbENvbnRhaW5lci5zY3JvbGxUbyh7XG4gICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgIGJlaGF2aW9yOiBcInNtb290aFwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVwZGF0ZUJ0blBvc2l0aW9uKCk7IH0sIDI1MCk7XG4gICAgICAgIHNldE1vdW50ZWQodHJ1ZSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb250YWluZXIuc3R5bGUucG9zaXRpb24gPSBvZ1BvcztcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHVwZGF0ZUJ0blBvc2l0aW9uKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIChyZWFjdF8xLmRlZmF1bHQuY3JlYXRlRWxlbWVudChyZWFjdF8xLmRlZmF1bHQuRnJhZ21lbnQsIG51bGwsXG4gICAgICAgICFtb3VudGVkICYmIHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7IHJlZjogYW5jaG9yLCBzdHlsZTogeyBkaXNwbGF5OiBcIm5vbmVcIiB9IH0pLFxuICAgICAgICBidXR0b24gPyBidG4gOiByZWFjdF8xLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7IHR5cGU6IFwiYnV0dG9uXCIgfSwgXCJUbyBUb3BcIikpKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFNjcm9sbFRvVG9wQnV0dG9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJ0blBvc2l0aW9uID0gZXhwb3J0cy5oYW5kbGVSZW5kZXJJdGVtID0gZXhwb3J0cy5oYW5kbGVSZW5kZXJHcm91cFNlcGFyYXRvciA9IGV4cG9ydHMucmVuZGVyQmxhbmsgPSB2b2lkIDA7XG52YXIgcmVhY3RfMSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIGlzVHlwZV8xID0gcmVxdWlyZShcIi4uL19fX3V0aWxzL2lzVHlwZVwiKTtcbnZhciBEZWZhdWx0QmxhbmtfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9EZWZhdWx0QmxhbmtcIikpO1xudmFyIHJlbmRlckJsYW5rID0gZnVuY3Rpb24gKHJlbmRlcldoZW5FbXB0eSkge1xuICAgIGlmIChyZW5kZXJXaGVuRW1wdHkgPT09IHZvaWQgMCkgeyByZW5kZXJXaGVuRW1wdHkgPSBudWxsOyB9XG4gICAgcmV0dXJuIHJlbmRlcldoZW5FbXB0eSAmJiAoMCwgaXNUeXBlXzEuaXNGdW5jdGlvbikocmVuZGVyV2hlbkVtcHR5KVxuICAgICAgICA/IHJlbmRlcldoZW5FbXB0eSgpXG4gICAgICAgIDogKDAsIERlZmF1bHRCbGFua18xLmRlZmF1bHQpKCk7XG59O1xuZXhwb3J0cy5yZW5kZXJCbGFuayA9IHJlbmRlckJsYW5rO1xudmFyIGhhbmRsZVJlbmRlckdyb3VwU2VwYXJhdG9yID0gZnVuY3Rpb24gKEN1c3RvbVNlcGFyYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc2VwLCBpZHgpIHtcbiAgICAgICAgdmFyIGNscyA9IHNlcFswXSwgZ3JvdXBMYWJlbCA9IHNlcFsxXSwgZ3JvdXAgPSBzZXBbMl07XG4gICAgICAgIHZhciBzZXBhcmF0b3JLZXkgPSBcInNlcGFyYXRvci1cIi5jb25jYXQoaWR4KTtcbiAgICAgICAgaWYgKEN1c3RvbVNlcGFyYXRvcikge1xuICAgICAgICAgICAgaWYgKCgwLCBpc1R5cGVfMS5pc0Z1bmN0aW9uKShDdXN0b21TZXBhcmF0b3IpKSB7XG4gICAgICAgICAgICAgICAgdmFyIFNlcCA9IEN1c3RvbVNlcGFyYXRvcihncm91cCwgaWR4LCBncm91cExhYmVsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsga2V5OiBzZXBhcmF0b3JLZXksIGNsYXNzTmFtZTogY2xzIH0sXG4gICAgICAgICAgICAgICAgICAgIHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFNlcC50eXBlLCBfX2Fzc2lnbih7fSwgU2VwLnByb3BzKSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAocmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBrZXk6IHNlcGFyYXRvcktleSwgY2xhc3NOYW1lOiBjbHMgfSwgKDAsIHJlYWN0XzEuY2xvbmVFbGVtZW50KShDdXN0b21TZXBhcmF0b3IsIHsgZ3JvdXBMYWJlbDogZ3JvdXBMYWJlbCwgZ3JvdXA6IGdyb3VwIH0pKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaHJcIiwgeyBrZXk6IHNlcGFyYXRvcktleSwgY2xhc3NOYW1lOiBjbHMgfSk7XG4gICAgfTtcbn07XG5leHBvcnRzLmhhbmRsZVJlbmRlckdyb3VwU2VwYXJhdG9yID0gaGFuZGxlUmVuZGVyR3JvdXBTZXBhcmF0b3I7XG52YXIgaGFuZGxlUmVuZGVySXRlbSA9IGZ1bmN0aW9uIChyZW5kZXJJdGVtLCByZW5kZXJTZXBhcmF0b3IpIHtcbiAgICBpZiAocmVuZGVyU2VwYXJhdG9yID09PSB2b2lkIDApIHsgcmVuZGVyU2VwYXJhdG9yID0gbnVsbDsgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoaXRlbSwga2V5KSB7XG4gICAgICAgIGlmICghcmVuZGVySXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGl0ZW1JZCA9IChcIlwiLmNvbmNhdChpdGVtKSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIiAmJlxuICAgICAgICAgICAgaXRlbS5pZCkgfHxcbiAgICAgICAgICAgIGtleTtcbiAgICAgICAgaWYgKCgwLCBpc1R5cGVfMS5pc0FycmF5KShpdGVtKSAmJiBpdGVtWzBdID09PSBcIl9fX2xpc3Qtc2VwYXJhdG9yXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgcmVuZGVyU2VwYXJhdG9yID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgICAgICA/IHJlbmRlclNlcGFyYXRvcihpdGVtLCBpdGVtSWQpXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcmVuZGVySXRlbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVuZGVySXRlbShpdGVtLCBcIlwiLmNvbmNhdChpdGVtSWQpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29tcCA9IHJlbmRlckl0ZW07XG4gICAgICAgIHJldHVybiByZWFjdF8xLmRlZmF1bHQuY3JlYXRlRWxlbWVudChjb21wLnR5cGUsIF9fYXNzaWduKHt9LCBjb21wLnByb3BzLCB7IGtleTogaXRlbUlkLCBpdGVtOiBpdGVtIH0pKTtcbiAgICB9O1xufTtcbmV4cG9ydHMuaGFuZGxlUmVuZGVySXRlbSA9IGhhbmRsZVJlbmRlckl0ZW07XG52YXIgYnRuUG9zaXRpb24gPSBmdW5jdGlvbiAoc2Nyb2xsQ29udGFpbmVyLCBidG4pIHtcbiAgICB2YXIgeiA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHNjcm9sbENvbnRhaW5lcikuekluZGV4O1xuICAgIGJ0bi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICBidG4uc3R5bGUuekluZGV4ID0gXCJcIi5jb25jYXQoeiA9PT0gXCJhdXRvXCIgPyAxIDogTnVtYmVyKHopICsgMSk7XG4gICAgYnRuLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgIHJldHVybiBmdW5jdGlvbiAodmVydGljYWwsIGhvcml6b250YWwsIHBhZGRpbmcsIG9mZnNldCkge1xuICAgICAgICBpZiAocGFkZGluZyA9PT0gdm9pZCAwKSB7IHBhZGRpbmcgPSAyMDsgfVxuICAgICAgICBpZiAob2Zmc2V0ID09PSB2b2lkIDApIHsgb2Zmc2V0ID0gNTA7IH1cbiAgICAgICAgdmFyIHggPSBcIjBweFwiO1xuICAgICAgICB2YXIgeSA9IFwiMHB4XCI7XG4gICAgICAgIGlmICh2ZXJ0aWNhbCA9PT0gXCJ0b3BcIikge1xuICAgICAgICAgICAgeSA9IFwiXCIuY29uY2F0KHBhcnNlRmxvYXQoXCJcIi5jb25jYXQocGFkZGluZykpLCBcInB4XCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZlcnRpY2FsID09PSBcImJvdHRvbVwiKSB7XG4gICAgICAgICAgICB5ID0gXCJjYWxjKDEwMCUgLSBcIi5jb25jYXQocGFyc2VGbG9hdChcIlwiLmNvbmNhdChwYWRkaW5nKSkgKyBidG4ub2Zmc2V0SGVpZ2h0LCBcInB4KVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG9yaXpvbnRhbCA9PT0gXCJsZWZ0XCIpIHtcbiAgICAgICAgICAgIHggPSBcIlwiLmNvbmNhdChwYXJzZUZsb2F0KFwiXCIuY29uY2F0KHBhZGRpbmcpKSwgXCJweFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChob3Jpem9udGFsID09PSBcInJpZ2h0XCIpIHtcbiAgICAgICAgICAgIHggPSBcImNhbGMoMTAwJSAtIFwiLmNvbmNhdChwYXJzZUZsb2F0KFwiXCIuY29uY2F0KHBhZGRpbmcpKSArIGJ0bi5vZmZzZXRXaWR0aCwgXCJweClcIik7XG4gICAgICAgIH1cbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGlzdCA9IE51bWJlcigoc2Nyb2xsQ29udGFpbmVyLnNjcm9sbEhlaWdodCAtIHNjcm9sbENvbnRhaW5lci5vZmZzZXRIZWlnaHQpLnRvRml4ZWQoMCkpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gTWF0aC5taW4ob2Zmc2V0LCBkaXN0KTtcbiAgICAgICAgICAgIGJ0bi5zdHlsZS50b3AgPSB5O1xuICAgICAgICAgICAgYnRuLnN0eWxlLmxlZnQgPSB4O1xuICAgICAgICAgICAgYnRuLnN0eWxlLnZpc2liaWxpdHkgPVxuICAgICAgICAgICAgICAgIGRpc3QgIT09IDAgJiYgLy8gZ290IHNjcm9sbGVkXG4gICAgICAgICAgICAgICAgICAgIE51bWJlcihzY3JvbGxDb250YWluZXIuc2Nyb2xsVG9wLnRvRml4ZWQoMCkpID49IG9mZnNldCAvLyBwb3NpdGlvbiBtZWV0cyB0aGUgb2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgID8gXCJ2aXNpYmxlXCJcbiAgICAgICAgICAgICAgICAgICAgOiBcImhpZGRlblwiO1xuICAgICAgICB9KTtcbiAgICB9O1xufTtcbmV4cG9ydHMuYnRuUG9zaXRpb24gPSBidG5Qb3NpdGlvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZ2V0VHlwZV8xID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2dldFR5cGVcIikpO1xuZXhwb3J0cy5kZWZhdWx0ID0gKGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgdmFyIGxpc3RUeXBlID0gKDAsIGdldFR5cGVfMS5kZWZhdWx0KShsaXN0KTtcbiAgICBzd2l0Y2ggKGxpc3RUeXBlKSB7XG4gICAgICAgIGNhc2UgZ2V0VHlwZV8xLnR5cGVzLkFSUkFZOlxuICAgICAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgICAgIGNhc2UgZ2V0VHlwZV8xLnR5cGVzLk9CSkVDVDpcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKGxpc3QpO1xuICAgICAgICBjYXNlIGdldFR5cGVfMS50eXBlcy5TRVQ6XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShsaXN0KTtcbiAgICAgICAgY2FzZSBnZXRUeXBlXzEudHlwZXMuTUFQOlxuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20obGlzdC52YWx1ZXMoKSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgfVxufSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IChmdW5jdGlvbiAobWFwKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20obWFwKS5yZWR1Y2UoZnVuY3Rpb24gKG9iaiwgX2EpIHtcbiAgICAgICAgdmFyIF9iO1xuICAgICAgICB2YXIga2V5ID0gX2FbMF0sIHZhbHVlID0gX2FbMV07XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKG9iaiwgKF9iID0ge30sIF9iW2tleV0gPSB2YWx1ZSwgX2IpKTtcbiAgICB9LCB7fSk7XG59KTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGdldE9iamVjdERlZXBLZXlWYWx1ZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2dldE9iamVjdERlZXBLZXlWYWx1ZVwiKSk7XG52YXIgaXNUeXBlXzEgPSByZXF1aXJlKFwiLi9pc1R5cGVcIik7XG52YXIgZmlsdGVyTGlzdCA9IGZ1bmN0aW9uIChsaXN0LCBieSkge1xuICAgIGlmIChieSA9PT0gdm9pZCAwKSB7IGJ5ID0gXCJcIjsgfVxuICAgIHJldHVybiBsaXN0LmZpbHRlcihmdW5jdGlvbiAoaXRlbSwgaWR4KSB7XG4gICAgICAgIGlmICgoMCwgaXNUeXBlXzEuaXNTdHJpbmcpKGJ5KSAmJiAoKDAsIGlzVHlwZV8xLmlzT2JqZWN0KShpdGVtKSB8fCAoMCwgaXNUeXBlXzEuaXNBcnJheSkoaXRlbSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGdldE9iamVjdERlZXBLZXlWYWx1ZV8xLmRlZmF1bHQpKGl0ZW0sIGJ5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKDAsIGlzVHlwZV8xLmlzRnVuY3Rpb24pKGJ5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGJ5KGl0ZW0sIGlkeCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZmlsdGVyTGlzdDtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZ2V0VHlwZV8xID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2dldFR5cGVcIikpO1xudmFyIGlzVHlwZV8xID0gcmVxdWlyZShcIi4vaXNUeXBlXCIpO1xudmFyIGNvbnZlcnRNYXBUb09iamVjdF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2NvbnZlcnRNYXBUb09iamVjdFwiKSk7XG52YXIgY29udmVydEFueXRoaW5nVG9BcnJheU9yT2JqZWN0ID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiAoMCwgZ2V0VHlwZV8xLmRlZmF1bHQpKG9iaikgPT09IGdldFR5cGVfMS50eXBlcy5TRVRcbiAgICAgICAgPyBBcnJheS5mcm9tKG9iailcbiAgICAgICAgOiAoMCwgZ2V0VHlwZV8xLmRlZmF1bHQpKG9iaikgPT09IGdldFR5cGVfMS50eXBlcy5NQVBcbiAgICAgICAgICAgID8gKDAsIGNvbnZlcnRNYXBUb09iamVjdF8xLmRlZmF1bHQpKG9iailcbiAgICAgICAgICAgIDogKDAsIGlzVHlwZV8xLmlzT2JqZWN0KShvYmopIHx8ICgwLCBpc1R5cGVfMS5pc0FycmF5KShvYmopXG4gICAgICAgICAgICAgICAgPyBvYmpcbiAgICAgICAgICAgICAgICA6IHt9O1xufTtcbnZhciBnZXRPYmplY3REZWVwS2V5VmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIGRvdFNlcGFyYXRlZEtleXMpIHtcbiAgICB2YXIgY29udmVydGVkVmFsdWUgPSBjb252ZXJ0QW55dGhpbmdUb0FycmF5T3JPYmplY3QodmFsdWUpO1xuICAgIHZhciBjb252ZXJ0ZWRWYWx1ZVR5cGUgPSBcIlwiO1xuICAgIGlmICgoMCwgaXNUeXBlXzEuaXNTdHJpbmcpKGRvdFNlcGFyYXRlZEtleXMpKSB7XG4gICAgICAgIHZhciBrZXlzID0gZG90U2VwYXJhdGVkS2V5cy5zcGxpdChcIi5cIik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBpZiAoY29udmVydGVkVmFsdWVba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIktleSBcXFwiXCIuY29uY2F0KGtleSwgXCJcXFwiIHdhcyBub3QgZm91bmQgaW5cIiksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBjb252ZXJ0ZWRWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKDAsIGdldFR5cGVfMS5kZWZhdWx0KShjb252ZXJ0ZWRWYWx1ZVtrZXldKSA9PT0gZ2V0VHlwZV8xLnR5cGVzLlNFVCkge1xuICAgICAgICAgICAgICAgIGNvbnZlcnRlZFZhbHVlID0gQXJyYXkuZnJvbShjb252ZXJ0ZWRWYWx1ZVtrZXldKTtcbiAgICAgICAgICAgICAgICBjb252ZXJ0ZWRWYWx1ZVR5cGUgPSBnZXRUeXBlXzEudHlwZXMuU0VUO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKDAsIGdldFR5cGVfMS5kZWZhdWx0KShjb252ZXJ0ZWRWYWx1ZVtrZXldKSA9PT0gZ2V0VHlwZV8xLnR5cGVzLk1BUCkge1xuICAgICAgICAgICAgICAgIGNvbnZlcnRlZFZhbHVlID0gKDAsIGNvbnZlcnRNYXBUb09iamVjdF8xLmRlZmF1bHQpKGNvbnZlcnRlZFZhbHVlW2tleV0pO1xuICAgICAgICAgICAgICAgIGNvbnZlcnRlZFZhbHVlVHlwZSA9IGdldFR5cGVfMS50eXBlcy5NQVA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb252ZXJ0ZWRWYWx1ZSA9IGNvbnZlcnRlZFZhbHVlW2tleV07XG4gICAgICAgICAgICAgICAgY29udmVydGVkVmFsdWVUeXBlID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBjb252ZXJ0IGNvbnZlcnRlZFZhbHVlIHRvIGl0cyBvcmlnaW5hbCBmb3JtXG4gICAgICAgIHJldHVybiBjb252ZXJ0ZWRWYWx1ZVR5cGUgPT09IGdldFR5cGVfMS50eXBlcy5TRVRcbiAgICAgICAgICAgID8gbmV3IFNldChjb252ZXJ0ZWRWYWx1ZSlcbiAgICAgICAgICAgIDogY29udmVydGVkVmFsdWVUeXBlID09PSBnZXRUeXBlXzEudHlwZXMuTUFQXG4gICAgICAgICAgICAgICAgPyBuZXcgTWFwKE9iamVjdC5lbnRyaWVzKGNvbnZlcnRlZFZhbHVlKSlcbiAgICAgICAgICAgICAgICA6IGNvbnZlcnRlZFZhbHVlO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2dldE9iamVjdERlZXBLZXlWYWx1ZTogXCJkb3RTZXBhcmF0ZWRLZXlzXCIgaXMgbm90IGEgZG90IHNlcGFyYXRlZCB2YWx1ZXMgc3RyaW5nJyk7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZ2V0T2JqZWN0RGVlcEtleVZhbHVlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnR5cGVzID0gdm9pZCAwO1xudmFyIHR5cGVzTWFwID0ge1xuICAgIGFycmF5OiBcIkFSUkFZXCIsXG4gICAgYm9vbGVhbjogXCJCT09MRUFOXCIsXG4gICAgZnVuY3Rpb246IFwiRlVOQ1RJT05cIixcbiAgICBtYXA6IFwiTUFQXCIsXG4gICAgbnVsbDogXCJOVUxMXCIsXG4gICAgbnVtYmVyOiBcIk5VTUJFUlwiLFxuICAgIG9iamVjdDogXCJPQkpFQ1RcIixcbiAgICBzZXQ6IFwiU0VUXCIsXG4gICAgc3RyaW5nOiBcIlNUUklOR1wiLFxuICAgIHN5bWJvbDogXCJTWU1CT0xcIixcbiAgICB1bmRlZmluZWQ6IFwiVU5ERUZJTkVEXCIsXG4gICAgd2Vha01hcDogXCJXRUFLX01BUFwiLFxuICAgIHdlYWtTZXQ6IFwiV0VBS19TRVRcIixcbn07XG5leHBvcnRzLnR5cGVzID0gT2JqZWN0LnZhbHVlcyh0eXBlc01hcCkucmVkdWNlKGZ1bmN0aW9uIChvYmosIHR5cGUpIHtcbiAgICBvYmpbdHlwZV0gPSB0eXBlO1xuICAgIHJldHVybiBvYmo7XG59LCB7fSk7XG52YXIgZ2V0VHlwZSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgeDtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgIHJldHVybiB0eXBlc01hcFt0eXBlXTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB4ID09PSBudWxsXG4gICAgICAgICAgICAgICAgPyB0eXBlc01hcC5udWxsXG4gICAgICAgICAgICAgICAgOiB4IGluc3RhbmNlb2YgU2V0XG4gICAgICAgICAgICAgICAgICAgID8gdHlwZXNNYXAuc2V0XG4gICAgICAgICAgICAgICAgICAgIDogeCBpbnN0YW5jZW9mIFdlYWtTZXRcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdHlwZXNNYXAud2Vha1NldFxuICAgICAgICAgICAgICAgICAgICAgICAgOiB4IGluc3RhbmNlb2YgTWFwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0eXBlc01hcC5tYXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHggaW5zdGFuY2VvZiBXZWFrTWFwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdHlwZXNNYXAud2Vha01hcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IEFycmF5LmlzQXJyYXkoeClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdHlwZXNNYXAuYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdHlwZXNNYXAub2JqZWN0OyAvLyBvdGhlcndpc2UgaXQgaXMgYW4gb2JqZWN0XG4gICAgfVxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGdldFR5cGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBnZXRPYmplY3REZWVwS2V5VmFsdWVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9nZXRPYmplY3REZWVwS2V5VmFsdWVcIikpO1xudmFyIGlzVHlwZV8xID0gcmVxdWlyZShcIi4vaXNUeXBlXCIpO1xudmFyIHJldmVyc2VMaXN0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcmV2ZXJzZUxpc3RcIikpO1xudmFyIGRlZmF1bHRHcm91cE9wdGlvbnMgPSB7XG4gICAgYnk6IFwiXCIsXG4gICAgbGltaXQ6IDAsXG4gICAgcmV2ZXJzZWQ6IGZhbHNlLFxufTtcbnZhciBoYW5kbGVHcm91cFJldmVyc2UgPSBmdW5jdGlvbiAoZ3JvdXBlZExpc3RzLCByZXZlcnNlKSB7XG4gICAgaWYgKHJldmVyc2UgPT09IHZvaWQgMCkgeyByZXZlcnNlID0gZmFsc2U7IH1cbiAgICBpZiAocmV2ZXJzZSAmJiAoMCwgaXNUeXBlXzEuaXNCb29sZWFuKShyZXZlcnNlKSkge1xuICAgICAgICByZXR1cm4gZ3JvdXBlZExpc3RzLm1hcChmdW5jdGlvbiAoZ3JvdXApIHsgcmV0dXJuICgwLCByZXZlcnNlTGlzdF8xLmRlZmF1bHQpKGdyb3VwKTsgfSk7XG4gICAgfVxuICAgIHJldHVybiBncm91cGVkTGlzdHM7XG59O1xudmFyIGdyb3VwTGlzdCA9IGZ1bmN0aW9uIChsaXN0LCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0gZGVmYXVsdEdyb3VwT3B0aW9uczsgfVxuICAgIHZhciBncm91cExhYmVscyA9IFtdO1xuICAgIGlmICgoMCwgaXNUeXBlXzEuaXNOaWxPckVtcHR5KShvcHRpb25zKSkge1xuICAgICAgICBvcHRpb25zID0gZGVmYXVsdEdyb3VwT3B0aW9ucztcbiAgICB9XG4gICAgdmFyIGdyb3VwQnkgPSBvcHRpb25zLmJ5LCBsaW1pdCA9IG9wdGlvbnMubGltaXQ7XG4gICAgaWYgKGdyb3VwQnkgJiYgKCgwLCBpc1R5cGVfMS5pc0Z1bmN0aW9uKShncm91cEJ5KSB8fCAoMCwgaXNUeXBlXzEuaXNTdHJpbmcpKGdyb3VwQnkpKSkge1xuICAgICAgICB2YXIgZ3JvdXBlZExpc3QgPSBsaXN0LnJlZHVjZShmdW5jdGlvbiAocHJldkxpc3QsIGl0ZW0sIGlkeCkge1xuICAgICAgICAgICAgdmFyIGdyb3VwTGFiZWwgPSAoMCwgaXNUeXBlXzEuaXNGdW5jdGlvbikoZ3JvdXBCeSlcbiAgICAgICAgICAgICAgICA/IGdyb3VwQnkoaXRlbSwgaWR4KVxuICAgICAgICAgICAgICAgIDogKDAsIGdldE9iamVjdERlZXBLZXlWYWx1ZV8xLmRlZmF1bHQpKGl0ZW0sIGdyb3VwQnkpO1xuICAgICAgICAgICAgaWYgKCFwcmV2TGlzdFtncm91cExhYmVsXSkge1xuICAgICAgICAgICAgICAgIHByZXZMaXN0W2dyb3VwTGFiZWxdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWxpbWl0IHx8IChsaW1pdCA+IDAgJiYgcHJldkxpc3RbZ3JvdXBMYWJlbF0ubGVuZ3RoIDwgbGltaXQpKSB7XG4gICAgICAgICAgICAgICAgcHJldkxpc3RbZ3JvdXBMYWJlbF0ucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcmV2TGlzdDtcbiAgICAgICAgfSwge30pO1xuICAgICAgICAvLyB1c2luZyBTZXQgaGVyZSBzbyB0aGUgb3JkZXIgaXMgcHJlc2VydmVkIGFuZCBwcmV2ZW50IGR1cGxpY2F0ZXNcbiAgICAgICAgZ3JvdXBMYWJlbHMgPSBBcnJheS5mcm9tKG5ldyBTZXQoT2JqZWN0LmtleXMoZ3JvdXBlZExpc3QpKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBncm91cExhYmVsczogZ3JvdXBMYWJlbHMsXG4gICAgICAgICAgICBncm91cExpc3RzOiBoYW5kbGVHcm91cFJldmVyc2UoT2JqZWN0LnZhbHVlcyhncm91cGVkTGlzdCksIG9wdGlvbnMucmV2ZXJzZWQpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAobGltaXQgJiYgKDAsIGlzVHlwZV8xLmlzTnVtYmVyKShsaW1pdCkgJiYgbGltaXQgPiAwKSB7XG4gICAgICAgIHZhciBncm91cExhYmVsXzEgPSAxO1xuICAgICAgICB2YXIgZ3JvdXBMaXN0cyA9IGxpc3QucmVkdWNlKGZ1bmN0aW9uIChwcmV2TGlzdCwgaXRlbSkge1xuICAgICAgICAgICAgaWYgKCFwcmV2TGlzdFtncm91cExhYmVsXzFdKSB7XG4gICAgICAgICAgICAgICAgcHJldkxpc3RbZ3JvdXBMYWJlbF8xXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldkxpc3RbZ3JvdXBMYWJlbF8xXS5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgaWYgKHByZXZMaXN0W2dyb3VwTGFiZWxfMV0ubGVuZ3RoID09PSBsaW1pdCkge1xuICAgICAgICAgICAgICAgIGdyb3VwTGFiZWxfMSArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByZXZMaXN0O1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIGdyb3VwTGFiZWxzID0gQXJyYXkuZnJvbShuZXcgU2V0KE9iamVjdC5rZXlzKGdyb3VwTGlzdHMpKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBncm91cExhYmVsczogZ3JvdXBMYWJlbHMsXG4gICAgICAgICAgICBncm91cExpc3RzOiBoYW5kbGVHcm91cFJldmVyc2UoT2JqZWN0LnZhbHVlcyhncm91cExpc3RzKSwgb3B0aW9ucy5yZXZlcnNlZCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGdyb3VwTGFiZWxzOiBncm91cExhYmVscyxcbiAgICAgICAgZ3JvdXBMaXN0czogaGFuZGxlR3JvdXBSZXZlcnNlKFtsaXN0XSwgb3B0aW9ucy5yZXZlcnNlZCksXG4gICAgfTtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBncm91cExpc3Q7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc0Z1bmN0aW9uID0gZXhwb3J0cy5pc05pbE9yRW1wdHkgPSBleHBvcnRzLmlzRW1wdHkgPSBleHBvcnRzLmlzTmlsID0gZXhwb3J0cy5pc01hcCA9IGV4cG9ydHMuaXNTZXQgPSBleHBvcnRzLmlzQXJyYXkgPSBleHBvcnRzLmlzU3RyaW5nID0gZXhwb3J0cy5pc09iamVjdExpdGVyYWwgPSBleHBvcnRzLmlzT2JqZWN0ID0gZXhwb3J0cy5pc051bWVyaWMgPSBleHBvcnRzLmlzTnVtYmVyID0gZXhwb3J0cy5pc0Jvb2xlYW4gPSB2b2lkIDA7XG52YXIgZ2V0VHlwZV8xID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2dldFR5cGVcIikpO1xudmFyIGlzQm9vbGVhbiA9IGZ1bmN0aW9uICh4KSB7IHJldHVybiAoMCwgZ2V0VHlwZV8xLmRlZmF1bHQpKHgpID09PSBnZXRUeXBlXzEudHlwZXMuQk9PTEVBTjsgfTtcbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xudmFyIGlzTnVtYmVyID0gZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4gKDAsIGdldFR5cGVfMS5kZWZhdWx0KShOdW1iZXIoeCkpID09PSBnZXRUeXBlXzEudHlwZXMuTlVNQkVSICYmICFpc05hTihOdW1iZXIoeCkpO1xufTtcbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcbnZhciBpc051bWVyaWMgPSBmdW5jdGlvbiAoeCkgeyByZXR1cm4gaXNGaW5pdGUoeCkgJiYgKDAsIGV4cG9ydHMuaXNOdW1iZXIpKHgpOyB9O1xuZXhwb3J0cy5pc051bWVyaWMgPSBpc051bWVyaWM7XG52YXIgaXNPYmplY3QgPSBmdW5jdGlvbiAoeCkgeyByZXR1cm4gKDAsIGdldFR5cGVfMS5kZWZhdWx0KSh4KSA9PT0gZ2V0VHlwZV8xLnR5cGVzLk9CSkVDVDsgfTtcbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcbnZhciBpc09iamVjdExpdGVyYWwgPSBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiAoMCwgZXhwb3J0cy5pc09iamVjdCkoeCkgJiYgeC5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xufTtcbmV4cG9ydHMuaXNPYmplY3RMaXRlcmFsID0gaXNPYmplY3RMaXRlcmFsO1xudmFyIGlzU3RyaW5nID0gZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4gKDAsIGdldFR5cGVfMS5kZWZhdWx0KSh4KSA9PT0gZ2V0VHlwZV8xLnR5cGVzLlNUUklORyB8fCB4IGluc3RhbmNlb2YgU3RyaW5nO1xufTtcbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcbnZhciBpc0FycmF5ID0gZnVuY3Rpb24gKHgpIHsgcmV0dXJuICgwLCBnZXRUeXBlXzEuZGVmYXVsdCkoeCkgPT09IGdldFR5cGVfMS50eXBlcy5BUlJBWTsgfTtcbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG52YXIgaXNTZXQgPSBmdW5jdGlvbiAoeCkgeyByZXR1cm4gKDAsIGdldFR5cGVfMS5kZWZhdWx0KSh4KSA9PT0gZ2V0VHlwZV8xLnR5cGVzLlNFVDsgfTtcbmV4cG9ydHMuaXNTZXQgPSBpc1NldDtcbnZhciBpc01hcCA9IGZ1bmN0aW9uICh4KSB7IHJldHVybiAoMCwgZ2V0VHlwZV8xLmRlZmF1bHQpKHgpID09PSBnZXRUeXBlXzEudHlwZXMuTUFQOyB9O1xuZXhwb3J0cy5pc01hcCA9IGlzTWFwO1xudmFyIGlzTmlsID0gZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4geCA9PT0gbnVsbCB8fCAoMCwgZ2V0VHlwZV8xLmRlZmF1bHQpKHgpID09PSBnZXRUeXBlXzEudHlwZXMuVU5ERUZJTkVEO1xufTtcbmV4cG9ydHMuaXNOaWwgPSBpc05pbDtcbnZhciBpc0VtcHR5ID0gZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4gKCgoMCwgZXhwb3J0cy5pc1N0cmluZykoeCkgfHwgKDAsIGV4cG9ydHMuaXNBcnJheSkoeCkpICYmIHgubGVuZ3RoID09PSAwKSB8fFxuICAgICAgICAoKDAsIGV4cG9ydHMuaXNPYmplY3QpKHgpICYmIE9iamVjdC5rZXlzKHgpLmxlbmd0aCA9PT0gMCkgfHxcbiAgICAgICAgKCgwLCBnZXRUeXBlXzEuZGVmYXVsdCkoeCkgPT09IGdldFR5cGVfMS50eXBlcy5NQVAgJiYgeC5zaXplID09PSAwKSB8fFxuICAgICAgICAoKDAsIGdldFR5cGVfMS5kZWZhdWx0KSh4KSA9PT0gZ2V0VHlwZV8xLnR5cGVzLlNFVCAmJiB4LnNpemUgPT09IDApIHx8XG4gICAgICAgICgoMCwgZ2V0VHlwZV8xLmRlZmF1bHQpKHgpID09PSBnZXRUeXBlXzEudHlwZXMuTlVNQkVSICYmIGlzTmFOKHgpKTtcbn07XG5leHBvcnRzLmlzRW1wdHkgPSBpc0VtcHR5O1xudmFyIGlzTmlsT3JFbXB0eSA9IGZ1bmN0aW9uICh4KSB7IHJldHVybiAoMCwgZXhwb3J0cy5pc05pbCkoeCkgfHwgKDAsIGV4cG9ydHMuaXNFbXB0eSkoeCk7IH07XG5leHBvcnRzLmlzTmlsT3JFbXB0eSA9IGlzTmlsT3JFbXB0eTtcbnZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gKHgpIHsgcmV0dXJuICgwLCBnZXRUeXBlXzEuZGVmYXVsdCkoeCkgPT09IGdldFR5cGVfMS50eXBlcy5GVU5DVElPTjsgfTtcbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gICAgaXNBcnJheTogZXhwb3J0cy5pc0FycmF5LFxuICAgIGlzRnVuY3Rpb246IGV4cG9ydHMuaXNGdW5jdGlvbixcbiAgICBpc05pbDogZXhwb3J0cy5pc05pbCxcbiAgICBpc0VtcHR5OiBleHBvcnRzLmlzRW1wdHksXG4gICAgaXNOaWxPckVtcHR5OiBleHBvcnRzLmlzTmlsT3JFbXB0eSxcbiAgICBpc051bWJlcjogZXhwb3J0cy5pc051bWJlcixcbiAgICBpc09iamVjdDogZXhwb3J0cy5pc09iamVjdCxcbiAgICBpc1N0cmluZzogZXhwb3J0cy5pc1N0cmluZyxcbiAgICBpc1NldDogZXhwb3J0cy5pc1NldCxcbiAgICBpc01hcDogZXhwb3J0cy5pc01hcCxcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBpc1R5cGVfMSA9IHJlcXVpcmUoXCIuL2lzVHlwZVwiKTtcbnZhciBsaW1pdExpc3QgPSBmdW5jdGlvbiAobGlzdCwgbGltaXQsIHRvKSB7XG4gICAgaWYgKGxpbWl0ID09PSB2b2lkIDApIHsgbGltaXQgPSAwOyB9XG4gICAgaWYgKHRvID09PSB2b2lkIDApIHsgdG8gPSB1bmRlZmluZWQ7IH1cbiAgICBpZiAoIWxpbWl0IHx8IE51bWJlcihsaW1pdCkgPD0gMCB8fCBOdW1iZXIobGltaXQpID49IGxpc3QubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cbiAgICBpZiAodG8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbGlzdC5zbGljZSgwLCBOdW1iZXIobGltaXQpKTtcbiAgICB9XG4gICAgcmV0dXJuICF0byB8fCAhKDAsIGlzVHlwZV8xLmlzTnVtYmVyKSh0bykgfHwgTnVtYmVyKHRvKSA9PT0gMFxuICAgICAgICA/IGxpc3Quc2xpY2UoTnVtYmVyKGxpbWl0KSlcbiAgICAgICAgOiBsaXN0LnNsaWNlKE51bWJlcihsaW1pdCksIE51bWJlcih0bykpO1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGxpbWl0TGlzdDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8gYXZvaWQgXCJyZXZlcnNlXCIgYXJyYXkgbWV0aG9kIGFzIGl0IGNoYW5nZXMgaW4gcGxhY2Vcbi8vIHdlIG5lZWQgdG8gY3JlYXRlIGEgbmV3IHJldmVyc2VkIGxpc3QgaW5zdGVhZFxudmFyIHJldmVyc2VMaXN0ID0gZnVuY3Rpb24gKGxpc3QpIHtcbiAgICByZXR1cm4gbGlzdC5tYXAoZnVuY3Rpb24gKGl0ZW0sIGksIGwpIHsgcmV0dXJuIGxbbC5sZW5ndGggLSAoaSArIDEpXTsgfSk7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gcmV2ZXJzZUxpc3Q7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBmaWx0ZXJMaXN0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vZmlsdGVyTGlzdFwiKSk7XG52YXIgZ2V0T2JqZWN0RGVlcEtleVZhbHVlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vZ2V0T2JqZWN0RGVlcEtleVZhbHVlXCIpKTtcbnZhciBpc1R5cGVfMSA9IHJlcXVpcmUoXCIuL2lzVHlwZVwiKTtcbnZhciBkZWZhdWx0U2VhcmNoT3B0aW9ucyA9IHtcbiAgICBieTogXCIwXCIsXG4gICAgY2FzZUluc2Vuc2l0aXZlOiBmYWxzZSxcbiAgICBldmVyeVdvcmQ6IGZhbHNlLFxuICAgIG1pbkNoYXJhY3RlcnNDb3VudDogMyxcbiAgICB0ZXJtOiBcIlwiLFxufTtcbnZhciBkZWZhdWx0RmlsdGVyQnlGbiA9IGZ1bmN0aW9uIChpdGVtLCB0ZXJtLCBjYXNlSW5zZW5zaXRpdmUsIGJ5KSB7XG4gICAgaWYgKGNhc2VJbnNlbnNpdGl2ZSA9PT0gdm9pZCAwKSB7IGNhc2VJbnNlbnNpdGl2ZSA9IGZhbHNlOyB9XG4gICAgaWYgKGJ5ID09PSB2b2lkIDApIHsgYnkgPSBcIjBcIjsgfVxuICAgIHZhciBrZXlWYWx1ZSA9ICgwLCBpc1R5cGVfMS5pc09iamVjdCkoaXRlbSkgfHwgKDAsIGlzVHlwZV8xLmlzQXJyYXkpKGl0ZW0pXG4gICAgICAgID8gKDAsIGdldE9iamVjdERlZXBLZXlWYWx1ZV8xLmRlZmF1bHQpKGl0ZW0sIGJ5KVxuICAgICAgICA6IGl0ZW07XG4gICAgdmFyIHZhbHVlID0gY2FzZUluc2Vuc2l0aXZlID8gXCJcIi5jb25jYXQoa2V5VmFsdWUpLnRvTG93ZXJDYXNlKCkgOiBcIlwiLmNvbmNhdChrZXlWYWx1ZSk7XG4gICAgaWYgKCgwLCBpc1R5cGVfMS5pc0FycmF5KSh0ZXJtKSkge1xuICAgICAgICByZXR1cm4gdGVybS5zb21lKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICB0ID0gY2FzZUluc2Vuc2l0aXZlID8gdC50b0xvd2VyQ2FzZSgpIDogdC50cmltKCk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuc2VhcmNoKHQudHJpbSgpKSA+PSAwO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdGVybSA9IGNhc2VJbnNlbnNpdGl2ZSA/IHRlcm0udG9Mb3dlckNhc2UoKSA6IHRlcm07XG4gICAgcmV0dXJuIHZhbHVlLnNlYXJjaCh0ZXJtLnRyaW0oKSkgPj0gMDtcbn07XG52YXIgZ2V0RmlsdGVyQnlGbiA9IGZ1bmN0aW9uICh0ZXJtLCBieSwgY2FzZUluc2Vuc2l0aXZlKSB7XG4gICAgaWYgKGNhc2VJbnNlbnNpdGl2ZSA9PT0gdm9pZCAwKSB7IGNhc2VJbnNlbnNpdGl2ZSA9IGZhbHNlOyB9XG4gICAgaWYgKCgwLCBpc1R5cGVfMS5pc0Z1bmN0aW9uKShieSkpIHtcbiAgICAgICAgaWYgKCgwLCBpc1R5cGVfMS5pc0FycmF5KSh0ZXJtKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChpdGVtLCBpZHgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGVybS5zb21lKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHQgPSBjYXNlSW5zZW5zaXRpdmUgPyB0LnRvTG93ZXJDYXNlKCkgOiB0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnkoaXRlbSwgdC50cmltKCksIGlkeCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRlcm0gPSBjYXNlSW5zZW5zaXRpdmUgPyB0ZXJtLnRvTG93ZXJDYXNlKCkgOiB0ZXJtO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGl0ZW0sIGlkeCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ5KGl0ZW0sIHRlcm0udHJpbSgpLCBpZHgpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoKDAsIGlzVHlwZV8xLmlzQXJyYXkpKGJ5KSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBieS5zb21lKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5Q2FzZUluc2Vuc2l0aXZlID0gKDAsIGlzVHlwZV8xLmlzT2JqZWN0KShrZXkpICYmIGtleS5jYXNlSW5zZW5zaXRpdmUgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA/IGtleS5jYXNlSW5zZW5zaXRpdmVcbiAgICAgICAgICAgICAgICAgICAgOiBjYXNlSW5zZW5zaXRpdmU7XG4gICAgICAgICAgICAgICAgdmFyIGtleUJ5ID0gKCgwLCBpc1R5cGVfMS5pc09iamVjdCkoa2V5KSA/IGtleS5rZXkgOiBrZXkpIHx8IFwiMFwiO1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0RmlsdGVyQnlGbihpdGVtLCB0ZXJtLCBrZXlDYXNlSW5zZW5zaXRpdmUsIGtleUJ5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRGaWx0ZXJCeUZuKGl0ZW0sIHRlcm0sIGNhc2VJbnNlbnNpdGl2ZSwgYnkgfHwgXCIwXCIpO1xuICAgIH07XG59O1xudmFyIHNlYXJjaExpc3QgPSBmdW5jdGlvbiAobGlzdCwgb3B0aW9ucykge1xuICAgIGlmICgoMCwgaXNUeXBlXzEuaXNOaWxPckVtcHR5KShvcHRpb25zKSkge1xuICAgICAgICBvcHRpb25zID0gZGVmYXVsdFNlYXJjaE9wdGlvbnM7XG4gICAgfVxuICAgIGlmIChsaXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHRlcm0gPSBvcHRpb25zLnRlcm0sIF9hID0gb3B0aW9ucy5ieSwgYnkgPSBfYSA9PT0gdm9pZCAwID8gXCIwXCIgOiBfYSwgX2IgPSBvcHRpb25zLm1pbkNoYXJhY3RlcnNDb3VudCwgbWluQ2hhcmFjdGVyc0NvdW50XzEgPSBfYiA9PT0gdm9pZCAwID8gMCA6IF9iO1xuICAgICAgICBpZiAodGVybSAmJiBieSAmJiB0ZXJtLmxlbmd0aCA+PSBtaW5DaGFyYWN0ZXJzQ291bnRfMSkge1xuICAgICAgICAgICAgdmFyIGV2ZXJ5V29yZCA9IG9wdGlvbnMuZXZlcnlXb3JkLCBjYXNlSW5zZW5zaXRpdmUgPSBvcHRpb25zLmNhc2VJbnNlbnNpdGl2ZTtcbiAgICAgICAgICAgIGlmIChldmVyeVdvcmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGVybVdvcmRzID0gdGVybVxuICAgICAgICAgICAgICAgICAgICAudHJpbSgpXG4gICAgICAgICAgICAgICAgICAgIC5zcGxpdCgvXFxzKy8pXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHdvcmQpIHsgcmV0dXJuIHdvcmQubGVuZ3RoID49IG1pbkNoYXJhY3RlcnNDb3VudF8xOyB9KTtcbiAgICAgICAgICAgICAgICBpZiAodGVybVdvcmRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpbHRlckJ5Rm4gPSBnZXRGaWx0ZXJCeUZuKEFycmF5LmZyb20obmV3IFNldCh0ZXJtV29yZHMpKSwgYnksIGNhc2VJbnNlbnNpdGl2ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgZmlsdGVyTGlzdF8xLmRlZmF1bHQpKGxpc3QsIGZpbHRlckJ5Rm4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBmaWx0ZXJCeUZuID0gZ2V0RmlsdGVyQnlGbih0ZXJtLCBieSwgY2FzZUluc2Vuc2l0aXZlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGZpbHRlckxpc3RfMS5kZWZhdWx0KShsaXN0LCBmaWx0ZXJCeUZuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGlzdDtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBzZWFyY2hMaXN0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSwgcGFjaykge1xuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGdldE9iamVjdERlZXBLZXlWYWx1ZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2dldE9iamVjdERlZXBLZXlWYWx1ZVwiKSk7XG52YXIgaXNUeXBlXzEgPSByZXF1aXJlKFwiLi9pc1R5cGVcIik7XG52YXIgZGVmYXVsdFNvcnRPcHRpb25zID0ge1xuICAgIGNhc2VJbnNlbnNpdGl2ZTogZmFsc2UsXG4gICAgZGVzY2VuZGluZzogZmFsc2UsXG4gICAgYnk6IFwiXCIsXG59O1xudmFyIGNvbXBhcmVLZXlzID0gZnVuY3Rpb24gKGZpcnN0LCBzZWNvbmQsIF9hKSB7XG4gICAgdmFyIF9iID0gX2Eua2V5LCBrZXkgPSBfYiA9PT0gdm9pZCAwID8gXCJcIiA6IF9iLCBfYyA9IF9hLmNhc2VJbnNlbnNpdGl2ZSwgY2FzZUluc2Vuc2l0aXZlID0gX2MgPT09IHZvaWQgMCA/IGZhbHNlIDogX2MsIF9kID0gX2EuZGVzY2VuZGluZywgZGVzY2VuZGluZyA9IF9kID09PSB2b2lkIDAgPyBmYWxzZSA6IF9kO1xuICAgIGlmIChrZXkpIHtcbiAgICAgICAgZmlyc3QgPVxuICAgICAgICAgICAgKDAsIGlzVHlwZV8xLmlzT2JqZWN0KShmaXJzdCkgfHwgKDAsIGlzVHlwZV8xLmlzQXJyYXkpKGZpcnN0KVxuICAgICAgICAgICAgICAgID8gKDAsIGdldE9iamVjdERlZXBLZXlWYWx1ZV8xLmRlZmF1bHQpKGZpcnN0LCBrZXkpXG4gICAgICAgICAgICAgICAgOiBmaXJzdDtcbiAgICAgICAgc2Vjb25kID1cbiAgICAgICAgICAgICgwLCBpc1R5cGVfMS5pc09iamVjdCkoc2Vjb25kKSB8fCAoMCwgaXNUeXBlXzEuaXNBcnJheSkoc2Vjb25kKVxuICAgICAgICAgICAgICAgID8gKDAsIGdldE9iamVjdERlZXBLZXlWYWx1ZV8xLmRlZmF1bHQpKHNlY29uZCwga2V5KVxuICAgICAgICAgICAgICAgIDogc2Vjb25kO1xuICAgIH1cbiAgICBpZiAoY2FzZUluc2Vuc2l0aXZlKSB7XG4gICAgICAgIGZpcnN0ID0gKDAsIGlzVHlwZV8xLmlzU3RyaW5nKShmaXJzdCkgPyBmaXJzdC50b0xvd2VyQ2FzZSgpIDogZmlyc3Q7XG4gICAgICAgIHNlY29uZCA9ICgwLCBpc1R5cGVfMS5pc1N0cmluZykoc2Vjb25kKSA/IHNlY29uZC50b0xvd2VyQ2FzZSgpIDogc2Vjb25kO1xuICAgIH1cbiAgICByZXR1cm4gZmlyc3QgPiBzZWNvbmRcbiAgICAgICAgPyBkZXNjZW5kaW5nXG4gICAgICAgICAgICA/IC0xXG4gICAgICAgICAgICA6IDFcbiAgICAgICAgOiBmaXJzdCA8IHNlY29uZFxuICAgICAgICAgICAgPyBkZXNjZW5kaW5nXG4gICAgICAgICAgICAgICAgPyAxXG4gICAgICAgICAgICAgICAgOiAtMVxuICAgICAgICAgICAgOiAwO1xufTtcbnZhciBzb3J0TGlzdCA9IGZ1bmN0aW9uIChsaXN0LCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0gZGVmYXVsdFNvcnRPcHRpb25zOyB9XG4gICAgdmFyIGxpc3RDb3B5ID0gX19zcHJlYWRBcnJheShbXSwgbGlzdCwgdHJ1ZSk7XG4gICAgaWYgKCgwLCBpc1R5cGVfMS5pc05pbE9yRW1wdHkpKG9wdGlvbnMpKSB7XG4gICAgICAgIG9wdGlvbnMgPSBkZWZhdWx0U29ydE9wdGlvbnM7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZGVmYXVsdFNvcnRPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgbGlzdENvcHkuc29ydChmdW5jdGlvbiAoZmlyc3QsIHNlY29uZCkge1xuICAgICAgICBpZiAoKDAsIGlzVHlwZV8xLmlzQXJyYXkpKG9wdGlvbnMuYnkpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdGlvbnMuYnkubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gb3B0aW9ucy5ieVtpXTtcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9uID0gKDAsIGlzVHlwZV8xLmlzT2JqZWN0KShrZXkpID8ga2V5IDogX19hc3NpZ24oX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7IGtleToga2V5IH0pO1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSBjb21wYXJlS2V5cyhmaXJzdCwgc2Vjb25kLCBvcHRpb24pO1xuICAgICAgICAgICAgICAgIGlmIChyZXMgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcGFyZUtleXMoZmlyc3QsIHNlY29uZCwgX19hc3NpZ24oX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7IGtleTogb3B0aW9ucy5ieSB9KSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGxpc3RDb3B5O1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IHNvcnRMaXN0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHRQcm9wcyA9IHZvaWQgMDtcbmV4cG9ydHMuZGVmYXVsdFByb3BzID0ge1xuICAgIF9fZm9yd2FyZWRlZFJlZjogeyBjdXJyZW50OiBudWxsIH0sXG4gICAgLy8gUkVOREVSXG4gICAgbGlzdDogW10sXG4gICAgcmVuZGVySXRlbTogZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICBsaW1pdDogMCxcbiAgICByZW5kZXJXaGVuRW1wdHk6IG51bGwsXG4gICAgcmV2ZXJzZWQ6IGZhbHNlLFxuICAgIHJlbmRlck9uU2Nyb2xsOiBmYWxzZSxcbiAgICB3cmFwcGVySHRtbFRhZzogXCJcIixcbiAgICAvLyBESVNQTEFZXG4gICAgZGlzcGxheToge1xuICAgICAgICBncmlkOiBmYWxzZSxcbiAgICAgICAgZ3JpZEdhcDogXCJcIixcbiAgICAgICAgZ3JpZE1pbkNvbHVtbldpZHRoOiBcIlwiLFxuICAgICAgICByb3c6IGZhbHNlLFxuICAgICAgICByb3dHYXA6IFwiXCIsXG4gICAgfSxcbiAgICBkaXNwbGF5R3JpZDogZmFsc2UsXG4gICAgZGlzcGxheVJvdzogZmFsc2UsXG4gICAgZ3JpZEdhcDogXCJcIixcbiAgICByb3dHYXA6IFwiXCIsXG4gICAgbWluQ29sdW1uV2lkdGg6IFwiXCIsXG4gICAgLy8gRklMVEVSXG4gICAgZmlsdGVyQnk6IFwiXCIsXG4gICAgLy8gR1JPVVBTXG4gICAgZ3JvdXA6IHtcbiAgICAgICAgYnk6IFwiXCIsXG4gICAgICAgIGxpbWl0OiAwLFxuICAgICAgICBvZjogMCxcbiAgICAgICAgcmV2ZXJzZWQ6IGZhbHNlLFxuICAgICAgICBzZXBhcmF0b3I6IG51bGwsXG4gICAgICAgIHNlcGFyYXRvckF0VGhlQm90dG9tOiBmYWxzZSxcbiAgICAgICAgc29ydGVkQnk6IFwiXCIsXG4gICAgICAgIHNvcnRCeTogXCJcIixcbiAgICAgICAgc29ydGVkQ2FzZUluc2Vuc2l0aXZlOiBmYWxzZSxcbiAgICAgICAgc29ydENhc2VJbnNlbnNpdGl2ZTogZmFsc2UsXG4gICAgICAgIHNvcnRlZERlc2NlbmRpbmc6IGZhbHNlLFxuICAgICAgICBzb3J0RGVzY2VuZGluZzogZmFsc2UsIC8vIGRlcHJlY2F0ZWRcbiAgICB9LFxuICAgIGdyb3VwQnk6IFwiXCIsXG4gICAgZ3JvdXBPZjogMCxcbiAgICBncm91cFJldmVyc2VkOiBmYWxzZSxcbiAgICBncm91cFNlcGFyYXRvcjogbnVsbCxcbiAgICBncm91cFNlcGFyYXRvckF0VGhlQm90dG9tOiBmYWxzZSxcbiAgICBncm91cFNvcnRlZDogZmFsc2UsXG4gICAgZ3JvdXBTb3J0ZWRCeTogXCJcIixcbiAgICBncm91cFNvcnRlZERlc2NlbmRpbmc6IGZhbHNlLFxuICAgIGdyb3VwU29ydGVkQ2FzZUluc2Vuc2l0aXZlOiBmYWxzZSxcbiAgICBzaG93R3JvdXBTZXBhcmF0b3JBdFRoZUJvdHRvbTogZmFsc2UsXG4gICAgLy8gUEFHSU5BVElPTlxuICAgIHBhZ2luYXRpb246IHtcbiAgICAgICAgaGFzTW9yZTogZmFsc2UsXG4gICAgICAgIGxvYWRNb3JlOiBudWxsLFxuICAgICAgICBsb2FkaW5nSW5kaWNhdG9yOiBudWxsLFxuICAgICAgICBsb2FkaW5nSW5kaWNhdG9yUG9zaXRpb246IFwiXCIsXG4gICAgfSxcbiAgICBoYXNNb3JlSXRlbXM6IGZhbHNlLFxuICAgIGxvYWRNb3JlSXRlbXM6IG51bGwsXG4gICAgcGFnaW5hdGlvbkxvYWRpbmdJbmRpY2F0b3I6IG51bGwsXG4gICAgcGFnaW5hdGlvbkxvYWRpbmdJbmRpY2F0b3JQb3NpdGlvbjogXCJcIixcbiAgICAvLyBTQ1JPTEwgVE8gVE9QXG4gICAgc2Nyb2xsVG9Ub3A6IHtcbiAgICAgICAgYnV0dG9uOiBudWxsLFxuICAgICAgICBvZmZzZXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgcGFkZGluZzogdW5kZWZpbmVkLFxuICAgICAgICBwb3NpdGlvbjogdW5kZWZpbmVkLFxuICAgIH0sXG4gICAgc2Nyb2xsVG9Ub3BCdXR0b246IG51bGwsXG4gICAgc2Nyb2xsVG9Ub3BPZmZzZXQ6IHVuZGVmaW5lZCxcbiAgICBzY3JvbGxUb1RvcFBhZGRpbmc6IHVuZGVmaW5lZCxcbiAgICBzY3JvbGxUb1RvcFBvc2l0aW9uOiB1bmRlZmluZWQsXG4gICAgLy8gU0VBUkNIXG4gICAgc2VhcmNoOiB7XG4gICAgICAgIGJ5OiBcIlwiLFxuICAgICAgICBjYXNlSW5zZW5zaXRpdmU6IGZhbHNlLFxuICAgICAgICBldmVyeVdvcmQ6IGZhbHNlLFxuICAgICAgICBvbkV2ZXJ5V29yZDogZmFsc2UsXG4gICAgICAgIG1pbkNoYXJhY3RlcnNDb3VudDogMCxcbiAgICAgICAgdGVybTogXCJcIixcbiAgICB9LFxuICAgIHNlYXJjaEJ5OiBcIlwiLFxuICAgIHNlYXJjaENhc2VJbnNlbnNpdGl2ZTogZmFsc2UsXG4gICAgc2VhcmNoT25FdmVyeVdvcmQ6IGZhbHNlLFxuICAgIHNlYXJjaFRlcm06IFwiXCIsXG4gICAgc2VhcmNoTWluQ2hhcmFjdGVyc0NvdW50OiAwLFxuICAgIHNlYXJjaGFibGVNaW5DaGFyYWN0ZXJzQ291bnQ6IDAsXG4gICAgLy8gU09SVFxuICAgIHNvcnQ6IHtcbiAgICAgICAgYnk6IFwiXCIsXG4gICAgICAgIGNhc2VJbnNlbnNpdGl2ZTogZmFsc2UsXG4gICAgICAgIGRlc2NlbmRpbmc6IGZhbHNlLFxuICAgICAgICBncm91cEJ5OiBcIlwiLFxuICAgICAgICBncm91cENhc2VJbnNlbnNpdGl2ZTogZmFsc2UsXG4gICAgICAgIGdyb3VwRGVzY2VuZGluZzogZmFsc2UsIC8vIGRlcHJlY2F0ZWRcbiAgICB9LFxuICAgIHNvcnRCeTogXCJcIixcbiAgICBzb3J0Q2FzZUluc2Vuc2l0aXZlOiBmYWxzZSxcbiAgICBzb3J0RGVzYzogZmFsc2UsXG4gICAgc29ydERlc2NlbmRpbmc6IGZhbHNlLFxuICAgIHNvcnRHcm91cEJ5OiBcIlwiLFxuICAgIHNvcnRHcm91cERlc2M6IGZhbHNlLFxuICAgIHNvcnRHcm91cENhc2VJbnNlbnNpdGl2ZTogZmFsc2UsIC8vIGRlcHJlY2F0ZWRcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX3Jlc3QgPSAodGhpcyAmJiB0aGlzLl9fcmVzdCkgfHwgZnVuY3Rpb24gKHMsIGUpIHtcbiAgICB2YXIgdCA9IHt9O1xuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxuICAgICAgICB0W3BdID0gc1twXTtcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcbiAgICAgICAgfVxuICAgIHJldHVybiB0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciByZWFjdF8xID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgRGlzcGxheUhhbmRsZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9fX19zdWJDb21wb25lbnRzL0Rpc3BsYXlIYW5kbGVyXCIpKTtcbnZhciBJbmZpbml0ZUxvYWRlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL19fX3N1YkNvbXBvbmVudHMvSW5maW5pdGVMb2FkZXJcIikpO1xudmFyIFNjcm9sbFJlbmRlcmVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vX19fc3ViQ29tcG9uZW50cy9TY3JvbGxSZW5kZXJlclwiKSk7XG52YXIgU2Nyb2xsVG9Ub3BCdXR0b25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9fX19zdWJDb21wb25lbnRzL1Njcm9sbFRvVG9wQnV0dG9uXCIpKTtcbnZhciB1aUZ1bmN0aW9uc18xID0gcmVxdWlyZShcIi4vX19fc3ViQ29tcG9uZW50cy91aUZ1bmN0aW9uc1wiKTtcbnZhciBpc1R5cGVfMSA9IHJlcXVpcmUoXCIuL19fX3V0aWxzL2lzVHlwZVwiKTtcbnZhciBmbGF0TGlzdFByb3BzXzEgPSByZXF1aXJlKFwiLi9mbGF0TGlzdFByb3BzXCIpO1xudmFyIHVzZV9saXN0XzEgPSByZXF1aXJlKFwiLi9ob29rcy91c2UtbGlzdFwiKTtcbmZ1bmN0aW9uIEZsYXRMaXN0KHByb3BzKSB7XG4gICAgdmFyIF9hID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGZsYXRMaXN0UHJvcHNfMS5kZWZhdWx0UHJvcHMpLCBwcm9wcyksIGxpc3QgPSBfYS5saXN0LCBfYiA9IF9hLnJlbmRlcldoZW5FbXB0eSwgcmVuZGVyV2hlbkVtcHR5ID0gX2IgPT09IHZvaWQgMCA/IG51bGwgOiBfYiwgd3JhcHBlckh0bWxUYWcgPSBfYS53cmFwcGVySHRtbFRhZywgcmVuZGVySXRlbSA9IF9hLnJlbmRlckl0ZW0sIHJlbmRlck9uU2Nyb2xsID0gX2EucmVuZGVyT25TY3JvbGwsIC8vIHJlbmRlci9saXN0IHJlbGF0ZWQgcHJvcHNcbiAgICBfYyA9IF9hLmdyb3VwLCAvLyByZW5kZXIvbGlzdCByZWxhdGVkIHByb3BzXG4gICAgZ3JvdXAgPSBfYyA9PT0gdm9pZCAwID8ge30gOiBfYywgZ3JvdXBTZXBhcmF0b3IgPSBfYS5ncm91cFNlcGFyYXRvciwgLy8gZ3JvdXAgcHJvcHNcbiAgICBfZCA9IF9hLmRpc3BsYXksIC8vIGdyb3VwIHByb3BzXG4gICAgZGlzcGxheSA9IF9kID09PSB2b2lkIDAgPyB7fSA6IF9kLCBkaXNwbGF5Um93ID0gX2EuZGlzcGxheVJvdywgcm93R2FwID0gX2Eucm93R2FwLCBkaXNwbGF5R3JpZCA9IF9hLmRpc3BsYXlHcmlkLCBncmlkR2FwID0gX2EuZ3JpZEdhcCwgbWluQ29sdW1uV2lkdGggPSBfYS5taW5Db2x1bW5XaWR0aCwgLy8gZGlzcGxheSBwcm9wcyxcbiAgICBoYXNNb3JlSXRlbXMgPSBfYS5oYXNNb3JlSXRlbXMsIGxvYWRNb3JlSXRlbXMgPSBfYS5sb2FkTW9yZUl0ZW1zLCBwYWdpbmF0aW9uTG9hZGluZ0luZGljYXRvciA9IF9hLnBhZ2luYXRpb25Mb2FkaW5nSW5kaWNhdG9yLCBwYWdpbmF0aW9uTG9hZGluZ0luZGljYXRvclBvc2l0aW9uID0gX2EucGFnaW5hdGlvbkxvYWRpbmdJbmRpY2F0b3JQb3NpdGlvbiwgc2Nyb2xsVG9Ub3AgPSBfYS5zY3JvbGxUb1RvcCwgX2UgPSBfYS5zY3JvbGxUb1RvcEJ1dHRvbiwgc2Nyb2xsVG9Ub3BCdXR0b24gPSBfZSA9PT0gdm9pZCAwID8gbnVsbCA6IF9lLCBzY3JvbGxUb1RvcFBhZGRpbmcgPSBfYS5zY3JvbGxUb1RvcFBhZGRpbmcsIHNjcm9sbFRvVG9wT2Zmc2V0ID0gX2Euc2Nyb2xsVG9Ub3BPZmZzZXQsIHNjcm9sbFRvVG9wUG9zaXRpb24gPSBfYS5zY3JvbGxUb1RvcFBvc2l0aW9uLCBfZiA9IF9hLnBhZ2luYXRpb24sIHBhZ2luYXRpb24gPSBfZiA9PT0gdm9pZCAwID8ge30gOiBfZiwgLy8gcGFnaW5hdGlvbiBwcm9wc1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgX19mb3J3YXJlZGVkUmVmID0gX2EuX19mb3J3YXJlZGVkUmVmLCBvdGhlclByb3BzID0gX19yZXN0KF9hLCBbXCJsaXN0XCIsIFwicmVuZGVyV2hlbkVtcHR5XCIsIFwid3JhcHBlckh0bWxUYWdcIiwgXCJyZW5kZXJJdGVtXCIsIFwicmVuZGVyT25TY3JvbGxcIiwgXCJncm91cFwiLCBcImdyb3VwU2VwYXJhdG9yXCIsIFwiZGlzcGxheVwiLCBcImRpc3BsYXlSb3dcIiwgXCJyb3dHYXBcIiwgXCJkaXNwbGF5R3JpZFwiLCBcImdyaWRHYXBcIiwgXCJtaW5Db2x1bW5XaWR0aFwiLCBcImhhc01vcmVJdGVtc1wiLCBcImxvYWRNb3JlSXRlbXNcIiwgXCJwYWdpbmF0aW9uTG9hZGluZ0luZGljYXRvclwiLCBcInBhZ2luYXRpb25Mb2FkaW5nSW5kaWNhdG9yUG9zaXRpb25cIiwgXCJzY3JvbGxUb1RvcFwiLCBcInNjcm9sbFRvVG9wQnV0dG9uXCIsIFwic2Nyb2xsVG9Ub3BQYWRkaW5nXCIsIFwic2Nyb2xsVG9Ub3BPZmZzZXRcIiwgXCJzY3JvbGxUb1RvcFBvc2l0aW9uXCIsIFwicGFnaW5hdGlvblwiLCBcIl9fZm9yd2FyZWRlZFJlZlwiXSk7XG4gICAgdmFyIHJlbmRlckxpc3QgPSAoMCwgdXNlX2xpc3RfMS51c2VMaXN0KShwcm9wcyk7XG4gICAgdmFyIHRhZ1Byb3BzID0gKDAsIHJlYWN0XzEudXNlTWVtbykoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMob3RoZXJQcm9wcylcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChrKSB7IHJldHVybiBmbGF0TGlzdFByb3BzXzEuZGVmYXVsdFByb3BzW2tdID09PSB1bmRlZmluZWQ7IH0pXG4gICAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChwLCBrKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICByZXR1cm4gKF9fYXNzaWduKF9fYXNzaWduKHt9LCBwKSwgKF9hID0ge30sIF9hW2tdID0gb3RoZXJQcm9wc1trXSwgX2EpKSk7XG4gICAgICAgIH0sIHt9KTtcbiAgICB9LCBbb3RoZXJQcm9wc10pO1xuICAgIHZhciByZW5kZXJUaGlzSXRlbSA9ICgwLCByZWFjdF8xLnVzZU1lbW8pKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICgwLCB1aUZ1bmN0aW9uc18xLmhhbmRsZVJlbmRlckl0ZW0pKHJlbmRlckl0ZW0sICgwLCB1aUZ1bmN0aW9uc18xLmhhbmRsZVJlbmRlckdyb3VwU2VwYXJhdG9yKShncm91cC5zZXBhcmF0b3IgfHwgZ3JvdXBTZXBhcmF0b3IpKTtcbiAgICB9LCBbcmVuZGVySXRlbSwgZ3JvdXAuc2VwYXJhdG9yLCBncm91cFNlcGFyYXRvcl0pO1xuICAgIGlmIChyZW5kZXJMaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gKDAsIHVpRnVuY3Rpb25zXzEucmVuZGVyQmxhbmspKHJlbmRlcldoZW5FbXB0eSk7XG4gICAgfVxuICAgIHZhciBjb250ZW50ID0gKHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KHJlYWN0XzEuZGVmYXVsdC5GcmFnbWVudCwgbnVsbCxcbiAgICAgICAgcmVuZGVyT25TY3JvbGwgJiYgIShsb2FkTW9yZUl0ZW1zIHx8IHBhZ2luYXRpb24ubG9hZE1vcmUpID8gKHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFNjcm9sbFJlbmRlcmVyXzEuZGVmYXVsdCwgeyBsaXN0OiByZW5kZXJMaXN0LCByZW5kZXJJdGVtOiByZW5kZXJJdGVtLCBncm91cFNlcGFyYXRvcjogZ3JvdXAuc2VwYXJhdG9yIHx8IGdyb3VwU2VwYXJhdG9yIH0pKSA6IChyZW5kZXJMaXN0Lm1hcChyZW5kZXJUaGlzSXRlbSkpLFxuICAgICAgICAoZGlzcGxheVJvdyB8fCBkaXNwbGF5R3JpZCB8fCBkaXNwbGF5LmdyaWQgfHwgZGlzcGxheS5yb3cpICYmIChyZWFjdF8xLmRlZmF1bHQuY3JlYXRlRWxlbWVudChEaXNwbGF5SGFuZGxlcl8xLmRlZmF1bHQsIF9fYXNzaWduKHt9LCB7XG4gICAgICAgICAgICBkaXNwbGF5OiBkaXNwbGF5LFxuICAgICAgICAgICAgZGlzcGxheVJvdzogZGlzcGxheVJvdyxcbiAgICAgICAgICAgIHJvd0dhcDogcm93R2FwLFxuICAgICAgICAgICAgZGlzcGxheUdyaWQ6IGRpc3BsYXlHcmlkLFxuICAgICAgICAgICAgZ3JpZEdhcDogZ3JpZEdhcCxcbiAgICAgICAgICAgIG1pbkNvbHVtbldpZHRoOiBtaW5Db2x1bW5XaWR0aCxcbiAgICAgICAgfSkpKSxcbiAgICAgICAgKGxvYWRNb3JlSXRlbXMgfHwgcGFnaW5hdGlvbi5sb2FkTW9yZSkgJiYgIXJlbmRlck9uU2Nyb2xsICYmIChyZWFjdF8xLmRlZmF1bHQuY3JlYXRlRWxlbWVudChJbmZpbml0ZUxvYWRlcl8xLmRlZmF1bHQsIHsgaXRlbXNDb3VudDogcmVuZGVyTGlzdC5sZW5ndGgsIGhhc01vcmU6IGhhc01vcmVJdGVtcyB8fCBwYWdpbmF0aW9uLmhhc01vcmUsIGxvYWRNb3JlOiBsb2FkTW9yZUl0ZW1zIHx8IHBhZ2luYXRpb24ubG9hZE1vcmUsIGxvYWRpbmdJbmRpY2F0b3I6IHBhZ2luYXRpb25Mb2FkaW5nSW5kaWNhdG9yIHx8IHBhZ2luYXRpb24ubG9hZGluZ0luZGljYXRvciwgbG9hZGluZ0luZGljYXRvclBvc2l0aW9uOiBwYWdpbmF0aW9uTG9hZGluZ0luZGljYXRvclBvc2l0aW9uIHx8XG4gICAgICAgICAgICAgICAgcGFnaW5hdGlvbi5sb2FkaW5nSW5kaWNhdG9yUG9zaXRpb24gfSkpKSk7XG4gICAgdmFyIHNob3dTY3JvbGxUb1RvcEJ1dHRvbiA9IHNjcm9sbFRvVG9wID09PSB0cnVlIHx8XG4gICAgICAgIHNjcm9sbFRvVG9wLmJ1dHRvbiB8fFxuICAgICAgICBzY3JvbGxUb1RvcEJ1dHRvbjtcbiAgICB2YXIgV3JhcHBlckVsZW1lbnQgPSBcIlwiO1xuICAgIGlmICgoKDAsIGlzVHlwZV8xLmlzU3RyaW5nKSh3cmFwcGVySHRtbFRhZykgJiYgd3JhcHBlckh0bWxUYWcpIHx8IHNob3dTY3JvbGxUb1RvcEJ1dHRvbikge1xuICAgICAgICBXcmFwcGVyRWxlbWVudCA9IHdyYXBwZXJIdG1sVGFnIHx8IFwiZGl2XCI7XG4gICAgfVxuICAgIHJldHVybiAocmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQocmVhY3RfMS5kZWZhdWx0LkZyYWdtZW50LCBudWxsLFxuICAgICAgICBXcmFwcGVyRWxlbWVudCA/IChcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZWFjdF8xLmRlZmF1bHQuY3JlYXRlRWxlbWVudChXcmFwcGVyRWxlbWVudCwgX19hc3NpZ24oeyByZWY6IF9fZm9yd2FyZWRlZFJlZiB9LCB0YWdQcm9wcyksIGNvbnRlbnQpKSA6IChjb250ZW50KSxcbiAgICAgICAgc2hvd1Njcm9sbFRvVG9wQnV0dG9uICYmIChyZWFjdF8xLmRlZmF1bHQuY3JlYXRlRWxlbWVudChTY3JvbGxUb1RvcEJ1dHRvbl8xLmRlZmF1bHQsIHsgYnV0dG9uOiBzY3JvbGxUb1RvcEJ1dHRvbiAhPT0gbnVsbCAmJiBzY3JvbGxUb1RvcEJ1dHRvbiAhPT0gdm9pZCAwID8gc2Nyb2xsVG9Ub3BCdXR0b24gOiBzY3JvbGxUb1RvcC5idXR0b24sIHBhZGRpbmc6IHNjcm9sbFRvVG9wUGFkZGluZyAhPT0gbnVsbCAmJiBzY3JvbGxUb1RvcFBhZGRpbmcgIT09IHZvaWQgMCA/IHNjcm9sbFRvVG9wUGFkZGluZyA6IHNjcm9sbFRvVG9wLnBhZGRpbmcsIG9mZnNldDogc2Nyb2xsVG9Ub3BPZmZzZXQgIT09IG51bGwgJiYgc2Nyb2xsVG9Ub3BPZmZzZXQgIT09IHZvaWQgMCA/IHNjcm9sbFRvVG9wT2Zmc2V0IDogc2Nyb2xsVG9Ub3Aub2Zmc2V0LCBwb3NpdGlvbjogc2Nyb2xsVG9Ub3BQb3NpdGlvbiAhPT0gbnVsbCAmJiBzY3JvbGxUb1RvcFBvc2l0aW9uICE9PSB2b2lkIDAgPyBzY3JvbGxUb1RvcFBvc2l0aW9uIDogc2Nyb2xsVG9Ub3AucG9zaXRpb24sIHNjcm9sbGluZ0NvbnRhaW5lcjogX19mb3J3YXJlZGVkUmVmIH0pKSkpO1xufVxuLy8gZXhwb3J0IGRlZmF1bHQgRmxhdExpc3Q7XG5leHBvcnRzLmRlZmF1bHQgPSAoMCwgcmVhY3RfMS5mb3J3YXJkUmVmKShmdW5jdGlvbiAocHJvcHMsIHJlZikge1xuICAgIHJlZiA9IHJlZiB8fCAoMCwgcmVhY3RfMS5jcmVhdGVSZWYpKCk7XG4gICAgcmV0dXJuIHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEZsYXRMaXN0LCBfX2Fzc2lnbih7IF9fZm9yd2FyZWRlZFJlZjogcmVmIH0sIHByb3BzKSk7XG59KTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20sIHBhY2spIHtcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudXNlTGlzdCA9IHZvaWQgMDtcbnZhciByZWFjdF8xID0gcmVxdWlyZShcInJlYWN0XCIpO1xudmFyIGNvbnZlcnRMaXN0VG9BcnJheV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9fX191dGlscy9jb252ZXJ0TGlzdFRvQXJyYXlcIikpO1xudmFyIGZpbHRlckxpc3RfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vX19fdXRpbHMvZmlsdGVyTGlzdFwiKSk7XG52YXIgZ3JvdXBMaXN0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL19fX3V0aWxzL2dyb3VwTGlzdFwiKSk7XG52YXIgaXNUeXBlXzEgPSByZXF1aXJlKFwiLi4vX19fdXRpbHMvaXNUeXBlXCIpO1xudmFyIGxpbWl0TGlzdF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9fX191dGlscy9saW1pdExpc3RcIikpO1xudmFyIHJldmVyc2VMaXN0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL19fX3V0aWxzL3JldmVyc2VMaXN0XCIpKTtcbnZhciBzZWFyY2hMaXN0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL19fX3V0aWxzL3NlYXJjaExpc3RcIikpO1xudmFyIHNvcnRMaXN0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL19fX3V0aWxzL3NvcnRMaXN0XCIpKTtcbnZhciBmbGF0TGlzdFByb3BzXzEgPSByZXF1aXJlKFwiLi4vZmxhdExpc3RQcm9wc1wiKTtcbnZhciB1c2VMaXN0ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGxpc3QgPSBfYS5saXN0LCBsaW1pdCA9IF9hLmxpbWl0LCByZXZlcnNlZCA9IF9hLnJldmVyc2VkLCBmaWx0ZXJCeSA9IF9hLmZpbHRlckJ5LCBncm91cCA9IF9hLmdyb3VwLCBncm91cEJ5ID0gX2EuZ3JvdXBCeSwgZ3JvdXBPZiA9IF9hLmdyb3VwT2YsIHNob3dHcm91cFNlcGFyYXRvckF0VGhlQm90dG9tID0gX2Euc2hvd0dyb3VwU2VwYXJhdG9yQXRUaGVCb3R0b20sIGdyb3VwUmV2ZXJzZWQgPSBfYS5ncm91cFJldmVyc2VkLCBncm91cFNlcGFyYXRvckF0VGhlQm90dG9tID0gX2EuZ3JvdXBTZXBhcmF0b3JBdFRoZUJvdHRvbSwgZ3JvdXBTb3J0ZWRDYXNlSW5zZW5zaXRpdmUgPSBfYS5ncm91cFNvcnRlZENhc2VJbnNlbnNpdGl2ZSwgZ3JvdXBTb3J0ZWREZXNjZW5kaW5nID0gX2EuZ3JvdXBTb3J0ZWREZXNjZW5kaW5nLCBncm91cFNvcnRlZCA9IF9hLmdyb3VwU29ydGVkLCBncm91cFNvcnRlZEJ5ID0gX2EuZ3JvdXBTb3J0ZWRCeSwgc29ydEJ5ID0gX2Euc29ydEJ5LCBzb3J0RGVzYyA9IF9hLnNvcnREZXNjLCBzb3J0ID0gX2Euc29ydCwgc29ydENhc2VJbnNlbnNpdGl2ZSA9IF9hLnNvcnRDYXNlSW5zZW5zaXRpdmUsIHNvcnRHcm91cEJ5ID0gX2Euc29ydEdyb3VwQnksIHNvcnRHcm91cERlc2MgPSBfYS5zb3J0R3JvdXBEZXNjLCBzb3J0R3JvdXBDYXNlSW5zZW5zaXRpdmUgPSBfYS5zb3J0R3JvdXBDYXNlSW5zZW5zaXRpdmUsIHNvcnREZXNjZW5kaW5nID0gX2Euc29ydERlc2NlbmRpbmcsIHNlYXJjaCA9IF9hLnNlYXJjaCwgc2VhcmNoQnkgPSBfYS5zZWFyY2hCeSwgc2VhcmNoT25FdmVyeVdvcmQgPSBfYS5zZWFyY2hPbkV2ZXJ5V29yZCwgc2VhcmNoVGVybSA9IF9hLnNlYXJjaFRlcm0sIHNlYXJjaENhc2VJbnNlbnNpdGl2ZSA9IF9hLnNlYXJjaENhc2VJbnNlbnNpdGl2ZSwgc2VhcmNoYWJsZU1pbkNoYXJhY3RlcnNDb3VudCA9IF9hLnNlYXJjaGFibGVNaW5DaGFyYWN0ZXJzQ291bnQsIHNlYXJjaE1pbkNoYXJhY3RlcnNDb3VudCA9IF9hLnNlYXJjaE1pbkNoYXJhY3RlcnNDb3VudDtcbiAgICAvLyBjb252ZXJ0IGxpc3QgdG8gYXJyYXlcbiAgICB2YXIgcmVuZGVyTGlzdCA9ICgwLCByZWFjdF8xLnVzZU1lbW8pKGZ1bmN0aW9uICgpIHsgcmV0dXJuICgwLCBjb252ZXJ0TGlzdFRvQXJyYXlfMS5kZWZhdWx0KShsaXN0KTsgfSwgW2xpc3RdKTtcbiAgICAvLyByZXZlcnNlIGxpc3RcbiAgICByZW5kZXJMaXN0ID0gKDAsIHJlYWN0XzEudXNlTWVtbykoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHJldmVyc2VkID09PSBcImJvb2xlYW5cIiAmJiByZXZlcnNlZFxuICAgICAgICAgICAgPyAoMCwgcmV2ZXJzZUxpc3RfMS5kZWZhdWx0KShyZW5kZXJMaXN0KVxuICAgICAgICAgICAgOiByZW5kZXJMaXN0O1xuICAgIH0sIFtyZW5kZXJMaXN0LCByZXZlcnNlZF0pO1xuICAgIC8vIGxpbWl0IGxpc3RcbiAgICByZW5kZXJMaXN0ID0gKDAsIHJlYWN0XzEudXNlTWVtbykoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoISgwLCBpc1R5cGVfMS5pc05pbCkobGltaXQpKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBcIlwiLmNvbmNhdChsaW1pdCkuc3BsaXQoXCIsXCIpLCBmcm9tID0gX2FbMF0sIHRvID0gX2FbMV07XG4gICAgICAgICAgICByZXR1cm4gKDAsIGxpbWl0TGlzdF8xLmRlZmF1bHQpKHJlbmRlckxpc3QsIGZyb20sIHRvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVuZGVyTGlzdDtcbiAgICB9LCBbcmVuZGVyTGlzdCwgbGltaXRdKTtcbiAgICAvLyBmaWx0ZXIgbGlzdFxuICAgIHJlbmRlckxpc3QgPSAoMCwgcmVhY3RfMS51c2VNZW1vKShmdW5jdGlvbiAoKSB7IHJldHVybiAoZmlsdGVyQnkgPyAoMCwgZmlsdGVyTGlzdF8xLmRlZmF1bHQpKHJlbmRlckxpc3QsIGZpbHRlckJ5KSA6IHJlbmRlckxpc3QpOyB9LCBbcmVuZGVyTGlzdCwgZmlsdGVyQnldKTtcbiAgICAvLyBzZWFyY2ggbGlzdFxuICAgIHJlbmRlckxpc3QgPSAoMCwgcmVhY3RfMS51c2VNZW1vKShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChzZWFyY2hUZXJtIHx8IChzZWFyY2ggJiYgc2VhcmNoLnRlcm0pKSB7XG4gICAgICAgICAgICB2YXIgc2VhcmNoT3B0aW9ucyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBmbGF0TGlzdFByb3BzXzEuZGVmYXVsdFByb3BzLnNlYXJjaCksIHNlYXJjaCk7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHNlYXJjaExpc3RfMS5kZWZhdWx0KShyZW5kZXJMaXN0LCB7XG4gICAgICAgICAgICAgICAgYnk6IHNlYXJjaE9wdGlvbnMuYnkgfHwgc2VhcmNoQnkgfHwgXCIwXCIsXG4gICAgICAgICAgICAgICAgY2FzZUluc2Vuc2l0aXZlOiBzZWFyY2hPcHRpb25zLmNhc2VJbnNlbnNpdGl2ZSB8fCBzZWFyY2hDYXNlSW5zZW5zaXRpdmUsXG4gICAgICAgICAgICAgICAgZXZlcnlXb3JkOiBzZWFyY2hPcHRpb25zLm9uRXZlcnlXb3JkIHx8XG4gICAgICAgICAgICAgICAgICAgIHNlYXJjaE9wdGlvbnMuZXZlcnlXb3JkIHx8IC8vIGRlcHJlY2F0ZWRcbiAgICAgICAgICAgICAgICAgICAgc2VhcmNoT25FdmVyeVdvcmQsXG4gICAgICAgICAgICAgICAgdGVybTogc2VhcmNoT3B0aW9ucy50ZXJtIHx8IHNlYXJjaFRlcm0sXG4gICAgICAgICAgICAgICAgbWluQ2hhcmFjdGVyc0NvdW50OiBcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgc2VhcmNoT3B0aW9ucy5zZWFyY2hhYmxlTWluQ2hhcmFjdGVyc0NvdW50IHx8IC8vIGRlcHJlY2F0ZWRcbiAgICAgICAgICAgICAgICAgICAgc2VhcmNoT3B0aW9ucy5taW5DaGFyYWN0ZXJzQ291bnQgfHxcbiAgICAgICAgICAgICAgICAgICAgc2VhcmNoTWluQ2hhcmFjdGVyc0NvdW50IHx8XG4gICAgICAgICAgICAgICAgICAgIHNlYXJjaGFibGVNaW5DaGFyYWN0ZXJzQ291bnQgfHwgLy8gZGVwcmVjYXRlZFxuICAgICAgICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlbmRlckxpc3Q7XG4gICAgfSwgW1xuICAgICAgICByZW5kZXJMaXN0LFxuICAgICAgICBzZWFyY2gsXG4gICAgICAgIHNlYXJjaEJ5LFxuICAgICAgICBzZWFyY2hPbkV2ZXJ5V29yZCxcbiAgICAgICAgc2VhcmNoVGVybSxcbiAgICAgICAgc2VhcmNoQ2FzZUluc2Vuc2l0aXZlLFxuICAgICAgICBzZWFyY2hhYmxlTWluQ2hhcmFjdGVyc0NvdW50LFxuICAgICAgICBzZWFyY2hNaW5DaGFyYWN0ZXJzQ291bnQsXG4gICAgXSk7XG4gICAgdmFyIHNvcnRPcHRpb25zID0gKDAsIHJlYWN0XzEudXNlTWVtbykoZnVuY3Rpb24gKCkgeyByZXR1cm4gKF9fYXNzaWduKF9fYXNzaWduKHt9LCBmbGF0TGlzdFByb3BzXzEuZGVmYXVsdFByb3BzLnNvcnQpLCBzb3J0KSk7IH0sIFtyZW5kZXJMaXN0LCBzb3J0XSk7XG4gICAgLy8gc29ydCBsaXN0XG4gICAgcmVuZGVyTGlzdCA9ICgwLCByZWFjdF8xLnVzZU1lbW8pKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHNvcnRPcHRpb25zLmJ5IHx8IHNvcnRCeSB8fCAoKDAsIGlzVHlwZV8xLmlzQm9vbGVhbikoc29ydCkgJiYgc29ydCkpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgc29ydExpc3RfMS5kZWZhdWx0KShyZW5kZXJMaXN0LCB7XG4gICAgICAgICAgICAgICAgY2FzZUluc2Vuc2l0aXZlOiBzb3J0T3B0aW9ucy5jYXNlSW5zZW5zaXRpdmUgfHwgc29ydENhc2VJbnNlbnNpdGl2ZSB8fCBmYWxzZSxcbiAgICAgICAgICAgICAgICBkZXNjZW5kaW5nOiBzb3J0T3B0aW9ucy5kZXNjZW5kaW5nIHx8IHNvcnREZXNjZW5kaW5nIHx8IHNvcnREZXNjIHx8IGZhbHNlLFxuICAgICAgICAgICAgICAgIGJ5OiBzb3J0T3B0aW9ucy5ieSB8fCBzb3J0QnksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVuZGVyTGlzdDtcbiAgICB9LCBbXG4gICAgICAgIHJlbmRlckxpc3QsXG4gICAgICAgIHNvcnRPcHRpb25zLFxuICAgICAgICBzb3J0QnksXG4gICAgICAgIHNvcnREZXNjLFxuICAgICAgICBzb3J0LFxuICAgICAgICBzb3J0Q2FzZUluc2Vuc2l0aXZlLFxuICAgICAgICBzb3J0RGVzY2VuZGluZyxcbiAgICBdKTtcbiAgICAvLyBncm91cCBsaXN0XG4gICAgcmVuZGVyTGlzdCA9ICgwLCByZWFjdF8xLnVzZU1lbW8pKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGdyb3VwT3B0aW9ucyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBmbGF0TGlzdFByb3BzXzEuZGVmYXVsdFByb3BzLmdyb3VwKSwgZ3JvdXApO1xuICAgICAgICBpZiAoZ3JvdXBPcHRpb25zLmJ5IHx8XG4gICAgICAgICAgICBncm91cEJ5IHx8XG4gICAgICAgICAgICBncm91cE9mIHx8XG4gICAgICAgICAgICBncm91cE9wdGlvbnMub2YgfHxcbiAgICAgICAgICAgIGdyb3VwT3B0aW9ucy5saW1pdCkge1xuICAgICAgICAgICAgdmFyIGdyb3VwaW5nT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBieTogZ3JvdXBPcHRpb25zLmJ5IHx8IGdyb3VwQnksXG4gICAgICAgICAgICAgICAgbGltaXQ6IGdyb3VwT3B0aW9ucy5vZiB8fCBncm91cE9mIHx8IGdyb3VwT3B0aW9ucy5saW1pdCxcbiAgICAgICAgICAgICAgICByZXZlcnNlZDogZ3JvdXBPcHRpb25zLnJldmVyc2VkIHx8IGdyb3VwUmV2ZXJzZWQsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGdMaXN0XzEgPSAoMCwgZ3JvdXBMaXN0XzEuZGVmYXVsdCkocmVuZGVyTGlzdCwgZ3JvdXBpbmdPcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiBnTGlzdF8xLmdyb3VwTGlzdHMucmVkdWNlKGZ1bmN0aW9uIChuZXdHTGlzdCwgYUdyb3VwLCBpZHgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXBTb3J0ZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICBncm91cE9wdGlvbnMuc29ydGVkIHx8XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwU29ydGVkQnkgfHxcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICBncm91cE9wdGlvbnMuc29ydGVkQnkgfHxcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBPcHRpb25zLnNvcnRCeSB8fFxuICAgICAgICAgICAgICAgICAgICBzb3J0R3JvdXBCeSB8fFxuICAgICAgICAgICAgICAgICAgICBzb3J0T3B0aW9ucy5ncm91cEJ5IC8vIGRlcHJlY2F0ZWRcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgYUdyb3VwID0gKDAsIHNvcnRMaXN0XzEuZGVmYXVsdCkoYUdyb3VwLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlSW5zZW5zaXRpdmU6IGdyb3VwU29ydGVkQ2FzZUluc2Vuc2l0aXZlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwT3B0aW9ucy5zb3J0ZWRDYXNlSW5zZW5zaXRpdmUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cE9wdGlvbnMuc29ydENhc2VJbnNlbnNpdGl2ZSB8fCAvLyBkZXByZWNhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc29ydEdyb3VwQ2FzZUluc2Vuc2l0aXZlIHx8IC8vIGRlcHJlY2F0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3J0T3B0aW9ucy5ncm91cENhc2VJbnNlbnNpdGl2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NlbmRpbmc6IGdyb3VwU29ydGVkRGVzY2VuZGluZyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cE9wdGlvbnMuc29ydGVkRGVzY2VuZGluZyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwT3B0aW9ucy5zb3J0RGVzY2VuZGluZyB8fCAvLyBkZXByZWNhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc29ydEdyb3VwRGVzYyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ5OiBncm91cFNvcnRlZEJ5IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwT3B0aW9ucy5zb3J0ZWRCeSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwT3B0aW9ucy5zb3J0QnkgfHwgLy8gZGVwcmVjYXRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRHcm91cEJ5LCAvLyBkZXByZWNhdGVkXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgc2VwYXJhdG9yID0gW1wiX19fbGlzdC1zZXBhcmF0b3JcIiwgZ0xpc3RfMS5ncm91cExhYmVsc1tpZHhdLCBhR3JvdXBdO1xuICAgICAgICAgICAgICAgIGlmIChncm91cE9wdGlvbnMuc2VwYXJhdG9yQXRUaGVCb3R0b20gfHxcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBTZXBhcmF0b3JBdFRoZUJvdHRvbSB8fFxuICAgICAgICAgICAgICAgICAgICBzaG93R3JvdXBTZXBhcmF0b3JBdFRoZUJvdHRvbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIG5ld0dMaXN0LCB0cnVlKSwgYUdyb3VwLCB0cnVlKSwgW3NlcGFyYXRvcl0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBuZXdHTGlzdCwgdHJ1ZSksIFtzZXBhcmF0b3JdLCBmYWxzZSksIGFHcm91cCwgdHJ1ZSk7XG4gICAgICAgICAgICB9LCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlbmRlckxpc3Q7XG4gICAgfSwgW1xuICAgICAgICByZW5kZXJMaXN0LFxuICAgICAgICBncm91cCxcbiAgICAgICAgZ3JvdXBSZXZlcnNlZCxcbiAgICAgICAgZ3JvdXBTZXBhcmF0b3JBdFRoZUJvdHRvbSxcbiAgICAgICAgZ3JvdXBTb3J0ZWRDYXNlSW5zZW5zaXRpdmUsXG4gICAgICAgIGdyb3VwU29ydGVkRGVzY2VuZGluZyxcbiAgICAgICAgZ3JvdXBTb3J0ZWQsXG4gICAgICAgIGdyb3VwU29ydGVkQnksXG4gICAgICAgIHNvcnRHcm91cEJ5LFxuICAgICAgICBzb3J0R3JvdXBEZXNjLFxuICAgICAgICBzb3J0R3JvdXBDYXNlSW5zZW5zaXRpdmUsXG4gICAgXSk7XG4gICAgcmV0dXJuIHJlbmRlckxpc3Q7XG59O1xuZXhwb3J0cy51c2VMaXN0ID0gdXNlTGlzdDtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QbGFpbkxpc3QgPSBleHBvcnRzLmxpbWl0TGlzdCA9IGV4cG9ydHMuZ3JvdXBMaXN0ID0gZXhwb3J0cy5maWx0ZXJMaXN0ID0gZXhwb3J0cy5zZWFyY2hMaXN0ID0gZXhwb3J0cy5zb3J0TGlzdCA9IHZvaWQgMDtcbnZhciBmbGF0bGlzdF9yZWFjdF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2ZsYXRsaXN0LXJlYWN0XCIpKTtcbnZhciBzb3J0TGlzdF8xID0gcmVxdWlyZShcIi4vX19fdXRpbHMvc29ydExpc3RcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzb3J0TGlzdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gX19pbXBvcnREZWZhdWx0KHNvcnRMaXN0XzEpLmRlZmF1bHQ7IH0gfSk7XG52YXIgc2VhcmNoTGlzdF8xID0gcmVxdWlyZShcIi4vX19fdXRpbHMvc2VhcmNoTGlzdFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNlYXJjaExpc3RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9faW1wb3J0RGVmYXVsdChzZWFyY2hMaXN0XzEpLmRlZmF1bHQ7IH0gfSk7XG52YXIgZmlsdGVyTGlzdF8xID0gcmVxdWlyZShcIi4vX19fdXRpbHMvZmlsdGVyTGlzdFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImZpbHRlckxpc3RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9faW1wb3J0RGVmYXVsdChmaWx0ZXJMaXN0XzEpLmRlZmF1bHQ7IH0gfSk7XG52YXIgZ3JvdXBMaXN0XzEgPSByZXF1aXJlKFwiLi9fX191dGlscy9ncm91cExpc3RcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJncm91cExpc3RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9faW1wb3J0RGVmYXVsdChncm91cExpc3RfMSkuZGVmYXVsdDsgfSB9KTtcbnZhciBsaW1pdExpc3RfMSA9IHJlcXVpcmUoXCIuL19fX3V0aWxzL2xpbWl0TGlzdFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImxpbWl0TGlzdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gX19pbXBvcnREZWZhdWx0KGxpbWl0TGlzdF8xKS5kZWZhdWx0OyB9IH0pO1xudmFyIFBsYWluTGlzdF8xID0gcmVxdWlyZShcIi4vX19fc3ViQ29tcG9uZW50cy9QbGFpbkxpc3RcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQbGFpbkxpc3RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9faW1wb3J0RGVmYXVsdChQbGFpbkxpc3RfMSkuZGVmYXVsdDsgfSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGZsYXRsaXN0X3JlYWN0XzEuZGVmYXVsdDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlYWN0SXMgPSByZXF1aXJlKCdyZWFjdC1pcycpO1xuXG4vKipcbiAqIENvcHlyaWdodCAyMDE1LCBZYWhvbyEgSW5jLlxuICogQ29weXJpZ2h0cyBsaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBMaWNlbnNlLiBTZWUgdGhlIGFjY29tcGFueWluZyBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zLlxuICovXG52YXIgUkVBQ1RfU1RBVElDUyA9IHtcbiAgY2hpbGRDb250ZXh0VHlwZXM6IHRydWUsXG4gIGNvbnRleHRUeXBlOiB0cnVlLFxuICBjb250ZXh0VHlwZXM6IHRydWUsXG4gIGRlZmF1bHRQcm9wczogdHJ1ZSxcbiAgZGlzcGxheU5hbWU6IHRydWUsXG4gIGdldERlZmF1bHRQcm9wczogdHJ1ZSxcbiAgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yOiB0cnVlLFxuICBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM6IHRydWUsXG4gIG1peGluczogdHJ1ZSxcbiAgcHJvcFR5cGVzOiB0cnVlLFxuICB0eXBlOiB0cnVlXG59O1xudmFyIEtOT1dOX1NUQVRJQ1MgPSB7XG4gIG5hbWU6IHRydWUsXG4gIGxlbmd0aDogdHJ1ZSxcbiAgcHJvdG90eXBlOiB0cnVlLFxuICBjYWxsZXI6IHRydWUsXG4gIGNhbGxlZTogdHJ1ZSxcbiAgYXJndW1lbnRzOiB0cnVlLFxuICBhcml0eTogdHJ1ZVxufTtcbnZhciBGT1JXQVJEX1JFRl9TVEFUSUNTID0ge1xuICAnJCR0eXBlb2YnOiB0cnVlLFxuICByZW5kZXI6IHRydWUsXG4gIGRlZmF1bHRQcm9wczogdHJ1ZSxcbiAgZGlzcGxheU5hbWU6IHRydWUsXG4gIHByb3BUeXBlczogdHJ1ZVxufTtcbnZhciBNRU1PX1NUQVRJQ1MgPSB7XG4gICckJHR5cGVvZic6IHRydWUsXG4gIGNvbXBhcmU6IHRydWUsXG4gIGRlZmF1bHRQcm9wczogdHJ1ZSxcbiAgZGlzcGxheU5hbWU6IHRydWUsXG4gIHByb3BUeXBlczogdHJ1ZSxcbiAgdHlwZTogdHJ1ZVxufTtcbnZhciBUWVBFX1NUQVRJQ1MgPSB7fTtcblRZUEVfU1RBVElDU1tyZWFjdElzLkZvcndhcmRSZWZdID0gRk9SV0FSRF9SRUZfU1RBVElDUztcblRZUEVfU1RBVElDU1tyZWFjdElzLk1lbW9dID0gTUVNT19TVEFUSUNTO1xuXG5mdW5jdGlvbiBnZXRTdGF0aWNzKGNvbXBvbmVudCkge1xuICAvLyBSZWFjdCB2MTYuMTEgYW5kIGJlbG93XG4gIGlmIChyZWFjdElzLmlzTWVtbyhjb21wb25lbnQpKSB7XG4gICAgcmV0dXJuIE1FTU9fU1RBVElDUztcbiAgfSAvLyBSZWFjdCB2MTYuMTIgYW5kIGFib3ZlXG5cblxuICByZXR1cm4gVFlQRV9TVEFUSUNTW2NvbXBvbmVudFsnJCR0eXBlb2YnXV0gfHwgUkVBQ1RfU1RBVElDUztcbn1cblxudmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIGdldE93blByb3BlcnR5TmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgb2JqZWN0UHJvdG90eXBlID0gT2JqZWN0LnByb3RvdHlwZTtcbmZ1bmN0aW9uIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKHRhcmdldENvbXBvbmVudCwgc291cmNlQ29tcG9uZW50LCBibGFja2xpc3QpIHtcbiAgaWYgKHR5cGVvZiBzb3VyY2VDb21wb25lbnQgIT09ICdzdHJpbmcnKSB7XG4gICAgLy8gZG9uJ3QgaG9pc3Qgb3ZlciBzdHJpbmcgKGh0bWwpIGNvbXBvbmVudHNcbiAgICBpZiAob2JqZWN0UHJvdG90eXBlKSB7XG4gICAgICB2YXIgaW5oZXJpdGVkQ29tcG9uZW50ID0gZ2V0UHJvdG90eXBlT2Yoc291cmNlQ29tcG9uZW50KTtcblxuICAgICAgaWYgKGluaGVyaXRlZENvbXBvbmVudCAmJiBpbmhlcml0ZWRDb21wb25lbnQgIT09IG9iamVjdFByb3RvdHlwZSkge1xuICAgICAgICBob2lzdE5vblJlYWN0U3RhdGljcyh0YXJnZXRDb21wb25lbnQsIGluaGVyaXRlZENvbXBvbmVudCwgYmxhY2tsaXN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIga2V5cyA9IGdldE93blByb3BlcnR5TmFtZXMoc291cmNlQ29tcG9uZW50KTtcblxuICAgIGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICAgIGtleXMgPSBrZXlzLmNvbmNhdChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlQ29tcG9uZW50KSk7XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldFN0YXRpY3MgPSBnZXRTdGF0aWNzKHRhcmdldENvbXBvbmVudCk7XG4gICAgdmFyIHNvdXJjZVN0YXRpY3MgPSBnZXRTdGF0aWNzKHNvdXJjZUNvbXBvbmVudCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoIUtOT1dOX1NUQVRJQ1Nba2V5XSAmJiAhKGJsYWNrbGlzdCAmJiBibGFja2xpc3Rba2V5XSkgJiYgIShzb3VyY2VTdGF0aWNzICYmIHNvdXJjZVN0YXRpY3Nba2V5XSkgJiYgISh0YXJnZXRTdGF0aWNzICYmIHRhcmdldFN0YXRpY3Nba2V5XSkpIHtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlQ29tcG9uZW50LCBrZXkpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gQXZvaWQgZmFpbHVyZXMgZnJvbSByZWFkLW9ubHkgcHJvcGVydGllc1xuICAgICAgICAgIGRlZmluZVByb3BlcnR5KHRhcmdldENvbXBvbmVudCwga2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0Q29tcG9uZW50O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhvaXN0Tm9uUmVhY3RTdGF0aWNzO1xuIiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi4xMy4xXG4gKiByZWFjdC1pcy5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcjtcbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgOiAweGVhYzc7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKSA6IDB4ZWFjYTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKSA6IDB4ZWFjYjtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKSA6IDB4ZWFjYztcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKSA6IDB4ZWFkMjtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKSA6IDB4ZWFjZDtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0JykgOiAweGVhY2U7IC8vIFRPRE86IFdlIGRvbid0IHVzZSBBc3luY01vZGUgb3IgQ29uY3VycmVudE1vZGUgYW55bW9yZS4gVGhleSB3ZXJlIHRlbXBvcmFyeVxuLy8gKHVuc3RhYmxlKSBBUElzIHRoYXQgaGF2ZSBiZWVuIHJlbW92ZWQuIENhbiB3ZSByZW1vdmUgdGhlIHN5bWJvbHM/XG5cbnZhciBSRUFDVF9BU1lOQ19NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5hc3luY19tb2RlJykgOiAweGVhY2Y7XG52YXIgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5jb25jdXJyZW50X21vZGUnKSA6IDB4ZWFjZjtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKSA6IDB4ZWFkMDtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKSA6IDB4ZWFkMTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0JykgOiAweGVhZDg7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QubWVtbycpIDogMHhlYWQzO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKSA6IDB4ZWFkNDtcbnZhciBSRUFDVF9CTE9DS19UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuYmxvY2snKSA6IDB4ZWFkOTtcbnZhciBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZnVuZGFtZW50YWwnKSA6IDB4ZWFkNTtcbnZhciBSRUFDVF9SRVNQT05ERVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnJlc3BvbmRlcicpIDogMHhlYWQ2O1xudmFyIFJFQUNUX1NDT1BFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zY29wZScpIDogMHhlYWQ3O1xuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nIHx8IC8vIE5vdGU6IGl0cyB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyBpZiBpdCdzIGEgcG9seWZpbGwuXG4gIHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9SRVNQT05ERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9TQ09QRV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0JMT0NLX1RZUEUpO1xufVxuXG5mdW5jdGlvbiB0eXBlT2Yob2JqZWN0KSB7XG4gIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwpIHtcbiAgICB2YXIgJCR0eXBlb2YgPSBvYmplY3QuJCR0eXBlb2Y7XG5cbiAgICBzd2l0Y2ggKCQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgdmFyIHR5cGUgPSBvYmplY3QudHlwZTtcblxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0FTWU5DX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHZhciAkJHR5cGVvZlR5cGUgPSB0eXBlICYmIHR5cGUuJCR0eXBlb2Y7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoJCR0eXBlb2ZUeXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZlR5cGU7XG5cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn0gLy8gQXN5bmNNb2RlIGlzIGRlcHJlY2F0ZWQgYWxvbmcgd2l0aCBpc0FzeW5jTW9kZVxuXG52YXIgQXN5bmNNb2RlID0gUkVBQ1RfQVNZTkNfTU9ERV9UWVBFO1xudmFyIENvbmN1cnJlbnRNb2RlID0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU7XG52YXIgQ29udGV4dENvbnN1bWVyID0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xudmFyIENvbnRleHRQcm92aWRlciA9IFJFQUNUX1BST1ZJREVSX1RZUEU7XG52YXIgRWxlbWVudCA9IFJFQUNUX0VMRU1FTlRfVFlQRTtcbnZhciBGb3J3YXJkUmVmID0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbnZhciBGcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG52YXIgTGF6eSA9IFJFQUNUX0xBWllfVFlQRTtcbnZhciBNZW1vID0gUkVBQ1RfTUVNT19UWVBFO1xudmFyIFBvcnRhbCA9IFJFQUNUX1BPUlRBTF9UWVBFO1xudmFyIFByb2ZpbGVyID0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbnZhciBTdHJpY3RNb2RlID0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbnZhciBTdXNwZW5zZSA9IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG52YXIgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUgPSBmYWxzZTsgLy8gQXN5bmNNb2RlIHNob3VsZCBiZSBkZXByZWNhdGVkXG5cbmZ1bmN0aW9uIGlzQXN5bmNNb2RlKG9iamVjdCkge1xuICB7XG4gICAgaWYgKCFoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSkge1xuICAgICAgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUgPSB0cnVlOyAvLyBVc2luZyBjb25zb2xlWyd3YXJuJ10gdG8gZXZhZGUgQmFiZWwgYW5kIEVTTGludFxuXG4gICAgICBjb25zb2xlWyd3YXJuJ10oJ1RoZSBSZWFjdElzLmlzQXN5bmNNb2RlKCkgYWxpYXMgaGFzIGJlZW4gZGVwcmVjYXRlZCwgJyArICdhbmQgd2lsbCBiZSByZW1vdmVkIGluIFJlYWN0IDE3Ky4gVXBkYXRlIHlvdXIgY29kZSB0byB1c2UgJyArICdSZWFjdElzLmlzQ29uY3VycmVudE1vZGUoKSBpbnN0ZWFkLiBJdCBoYXMgdGhlIGV4YWN0IHNhbWUgQVBJLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpc0NvbmN1cnJlbnRNb2RlKG9iamVjdCkgfHwgdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0FTWU5DX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29uY3VycmVudE1vZGUob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU7XG59XG5mdW5jdGlvbiBpc0NvbnRleHRDb25zdW1lcihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9DT05URVhUX1RZUEU7XG59XG5mdW5jdGlvbiBpc0NvbnRleHRQcm92aWRlcihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QUk9WSURFUl9UWVBFO1xufVxuZnVuY3Rpb24gaXNFbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNGb3J3YXJkUmVmKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU7XG59XG5mdW5jdGlvbiBpc0ZyYWdtZW50KG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG59XG5mdW5jdGlvbiBpc0xhenkob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfTEFaWV9UWVBFO1xufVxuZnVuY3Rpb24gaXNNZW1vKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX01FTU9fVFlQRTtcbn1cbmZ1bmN0aW9uIGlzUG9ydGFsKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BPUlRBTF9UWVBFO1xufVxuZnVuY3Rpb24gaXNQcm9maWxlcihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xufVxuZnVuY3Rpb24gaXNTdHJpY3RNb2RlKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEU7XG59XG5mdW5jdGlvbiBpc1N1c3BlbnNlKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG59XG5cbmV4cG9ydHMuQXN5bmNNb2RlID0gQXN5bmNNb2RlO1xuZXhwb3J0cy5Db25jdXJyZW50TW9kZSA9IENvbmN1cnJlbnRNb2RlO1xuZXhwb3J0cy5Db250ZXh0Q29uc3VtZXIgPSBDb250ZXh0Q29uc3VtZXI7XG5leHBvcnRzLkNvbnRleHRQcm92aWRlciA9IENvbnRleHRQcm92aWRlcjtcbmV4cG9ydHMuRWxlbWVudCA9IEVsZW1lbnQ7XG5leHBvcnRzLkZvcndhcmRSZWYgPSBGb3J3YXJkUmVmO1xuZXhwb3J0cy5GcmFnbWVudCA9IEZyYWdtZW50O1xuZXhwb3J0cy5MYXp5ID0gTGF6eTtcbmV4cG9ydHMuTWVtbyA9IE1lbW87XG5leHBvcnRzLlBvcnRhbCA9IFBvcnRhbDtcbmV4cG9ydHMuUHJvZmlsZXIgPSBQcm9maWxlcjtcbmV4cG9ydHMuU3RyaWN0TW9kZSA9IFN0cmljdE1vZGU7XG5leHBvcnRzLlN1c3BlbnNlID0gU3VzcGVuc2U7XG5leHBvcnRzLmlzQXN5bmNNb2RlID0gaXNBc3luY01vZGU7XG5leHBvcnRzLmlzQ29uY3VycmVudE1vZGUgPSBpc0NvbmN1cnJlbnRNb2RlO1xuZXhwb3J0cy5pc0NvbnRleHRDb25zdW1lciA9IGlzQ29udGV4dENvbnN1bWVyO1xuZXhwb3J0cy5pc0NvbnRleHRQcm92aWRlciA9IGlzQ29udGV4dFByb3ZpZGVyO1xuZXhwb3J0cy5pc0VsZW1lbnQgPSBpc0VsZW1lbnQ7XG5leHBvcnRzLmlzRm9yd2FyZFJlZiA9IGlzRm9yd2FyZFJlZjtcbmV4cG9ydHMuaXNGcmFnbWVudCA9IGlzRnJhZ21lbnQ7XG5leHBvcnRzLmlzTGF6eSA9IGlzTGF6eTtcbmV4cG9ydHMuaXNNZW1vID0gaXNNZW1vO1xuZXhwb3J0cy5pc1BvcnRhbCA9IGlzUG9ydGFsO1xuZXhwb3J0cy5pc1Byb2ZpbGVyID0gaXNQcm9maWxlcjtcbmV4cG9ydHMuaXNTdHJpY3RNb2RlID0gaXNTdHJpY3RNb2RlO1xuZXhwb3J0cy5pc1N1c3BlbnNlID0gaXNTdXNwZW5zZTtcbmV4cG9ydHMuaXNWYWxpZEVsZW1lbnRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlO1xuZXhwb3J0cy50eXBlT2YgPSB0eXBlT2Y7XG4gIH0pKCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiIsImltcG9ydCBlIGZyb21cInZvaWQtZWxlbWVudHNcIjt2YXIgdD0vXFxzKFteJ1wiL1xccz48XSs/KVtcXHMvPl18KFteXFxzPV0rKT1cXHM/KFwiLio/XCJ8Jy4qPycpL2c7ZnVuY3Rpb24gbihuKXt2YXIgcj17dHlwZTpcInRhZ1wiLG5hbWU6XCJcIix2b2lkRWxlbWVudDohMSxhdHRyczp7fSxjaGlsZHJlbjpbXX0saT1uLm1hdGNoKC88XFwvPyhbXlxcc10rPylbL1xccz5dLyk7aWYoaSYmKHIubmFtZT1pWzFdLChlW2lbMV1dfHxcIi9cIj09PW4uY2hhckF0KG4ubGVuZ3RoLTIpKSYmKHIudm9pZEVsZW1lbnQ9ITApLHIubmFtZS5zdGFydHNXaXRoKFwiIS0tXCIpKSl7dmFyIHM9bi5pbmRleE9mKFwiLS1cXHgzZVwiKTtyZXR1cm57dHlwZTpcImNvbW1lbnRcIixjb21tZW50Oi0xIT09cz9uLnNsaWNlKDQscyk6XCJcIn19Zm9yKHZhciBhPW5ldyBSZWdFeHAodCksYz1udWxsO251bGwhPT0oYz1hLmV4ZWMobikpOylpZihjWzBdLnRyaW0oKSlpZihjWzFdKXt2YXIgbz1jWzFdLnRyaW0oKSxsPVtvLFwiXCJdO28uaW5kZXhPZihcIj1cIik+LTEmJihsPW8uc3BsaXQoXCI9XCIpKSxyLmF0dHJzW2xbMF1dPWxbMV0sYS5sYXN0SW5kZXgtLX1lbHNlIGNbMl0mJihyLmF0dHJzW2NbMl1dPWNbM10udHJpbSgpLnN1YnN0cmluZygxLGNbM10ubGVuZ3RoLTEpKTtyZXR1cm4gcn12YXIgcj0vPFthLXpBLVowLTlcXC1cXCFcXC9dKD86XCJbXlwiXSpcInwnW14nXSonfFteJ1wiPl0pKj4vZyxpPS9eXFxzKiQvLHM9T2JqZWN0LmNyZWF0ZShudWxsKTtmdW5jdGlvbiBhKGUsdCl7c3dpdGNoKHQudHlwZSl7Y2FzZVwidGV4dFwiOnJldHVybiBlK3QuY29udGVudDtjYXNlXCJ0YWdcIjpyZXR1cm4gZSs9XCI8XCIrdC5uYW1lKyh0LmF0dHJzP2Z1bmN0aW9uKGUpe3ZhciB0PVtdO2Zvcih2YXIgbiBpbiBlKXQucHVzaChuKyc9XCInK2Vbbl0rJ1wiJyk7cmV0dXJuIHQubGVuZ3RoP1wiIFwiK3Quam9pbihcIiBcIik6XCJcIn0odC5hdHRycyk6XCJcIikrKHQudm9pZEVsZW1lbnQ/XCIvPlwiOlwiPlwiKSx0LnZvaWRFbGVtZW50P2U6ZSt0LmNoaWxkcmVuLnJlZHVjZShhLFwiXCIpK1wiPC9cIit0Lm5hbWUrXCI+XCI7Y2FzZVwiY29tbWVudFwiOnJldHVybiBlK1wiXFx4M2MhLS1cIit0LmNvbW1lbnQrXCItLVxceDNlXCJ9fXZhciBjPXtwYXJzZTpmdW5jdGlvbihlLHQpe3R8fCh0PXt9KSx0LmNvbXBvbmVudHN8fCh0LmNvbXBvbmVudHM9cyk7dmFyIGEsYz1bXSxvPVtdLGw9LTEsbT0hMTtpZigwIT09ZS5pbmRleE9mKFwiPFwiKSl7dmFyIHU9ZS5pbmRleE9mKFwiPFwiKTtjLnB1c2goe3R5cGU6XCJ0ZXh0XCIsY29udGVudDotMT09PXU/ZTplLnN1YnN0cmluZygwLHUpfSl9cmV0dXJuIGUucmVwbGFjZShyLGZ1bmN0aW9uKHIscyl7aWYobSl7aWYociE9PVwiPC9cIithLm5hbWUrXCI+XCIpcmV0dXJuO209ITF9dmFyIHUsZj1cIi9cIiE9PXIuY2hhckF0KDEpLGg9ci5zdGFydHNXaXRoKFwiXFx4M2MhLS1cIikscD1zK3IubGVuZ3RoLGQ9ZS5jaGFyQXQocCk7aWYoaCl7dmFyIHY9bihyKTtyZXR1cm4gbDwwPyhjLnB1c2godiksYyk6KCh1PW9bbF0pLmNoaWxkcmVuLnB1c2godiksYyl9aWYoZiYmKGwrKyxcInRhZ1wiPT09KGE9bihyKSkudHlwZSYmdC5jb21wb25lbnRzW2EubmFtZV0mJihhLnR5cGU9XCJjb21wb25lbnRcIixtPSEwKSxhLnZvaWRFbGVtZW50fHxtfHwhZHx8XCI8XCI9PT1kfHxhLmNoaWxkcmVuLnB1c2goe3R5cGU6XCJ0ZXh0XCIsY29udGVudDplLnNsaWNlKHAsZS5pbmRleE9mKFwiPFwiLHApKX0pLDA9PT1sJiZjLnB1c2goYSksKHU9b1tsLTFdKSYmdS5jaGlsZHJlbi5wdXNoKGEpLG9bbF09YSksKCFmfHxhLnZvaWRFbGVtZW50KSYmKGw+LTEmJihhLnZvaWRFbGVtZW50fHxhLm5hbWU9PT1yLnNsaWNlKDIsLTEpKSYmKGwtLSxhPS0xPT09bD9jOm9bbF0pLCFtJiZcIjxcIiE9PWQmJmQpKXt1PS0xPT09bD9jOm9bbF0uY2hpbGRyZW47dmFyIHg9ZS5pbmRleE9mKFwiPFwiLHApLGc9ZS5zbGljZShwLC0xPT09eD92b2lkIDA6eCk7aS50ZXN0KGcpJiYoZz1cIiBcIiksKHg+LTEmJmwrdS5sZW5ndGg+PTB8fFwiIFwiIT09ZykmJnUucHVzaCh7dHlwZTpcInRleHRcIixjb250ZW50Omd9KX19KSxjfSxzdHJpbmdpZnk6ZnVuY3Rpb24oZSl7cmV0dXJuIGUucmVkdWNlKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUrYShcIlwiLHQpfSxcIlwiKX19O2V4cG9ydCBkZWZhdWx0IGM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1odG1sLXBhcnNlLXN0cmluZ2lmeS5tb2R1bGUuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBfcmVmO1xuXG4vLyBTaG91bGQgYmUgbm8gaW1wb3J0cyBoZXJlIVxuLy8gU29tZSB0aGluZ3MgdGhhdCBzaG91bGQgYmUgZXZhbHVhdGVkIGJlZm9yZSBhbGwgZWxzZS4uLlxuLy8gV2Ugb25seSB3YW50IHRvIGtub3cgaWYgbm9uLXBvbHlmaWxsZWQgc3ltYm9scyBhcmUgYXZhaWxhYmxlXG52YXIgaGFzU3ltYm9sID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Zcbi8qI19fUFVSRV9fKi9cblN5bWJvbChcInhcIikgPT09IFwic3ltYm9sXCI7XG52YXIgaGFzTWFwID0gdHlwZW9mIE1hcCAhPT0gXCJ1bmRlZmluZWRcIjtcbnZhciBoYXNTZXQgPSB0eXBlb2YgU2V0ICE9PSBcInVuZGVmaW5lZFwiO1xudmFyIGhhc1Byb3hpZXMgPSB0eXBlb2YgUHJveHkgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIFByb3h5LnJldm9jYWJsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIjtcbi8qKlxyXG4gKiBUaGUgc2VudGluZWwgdmFsdWUgcmV0dXJuZWQgYnkgcHJvZHVjZXJzIHRvIHJlcGxhY2UgdGhlIGRyYWZ0IHdpdGggdW5kZWZpbmVkLlxyXG4gKi9cblxudmFyIE5PVEhJTkcgPSBoYXNTeW1ib2wgP1xuLyojX19QVVJFX18qL1xuU3ltYm9sLmZvcihcImltbWVyLW5vdGhpbmdcIikgOiAoX3JlZiA9IHt9LCBfcmVmW1wiaW1tZXItbm90aGluZ1wiXSA9IHRydWUsIF9yZWYpO1xuLyoqXHJcbiAqIFRvIGxldCBJbW1lciB0cmVhdCB5b3VyIGNsYXNzIGluc3RhbmNlcyBhcyBwbGFpbiBpbW11dGFibGUgb2JqZWN0c1xyXG4gKiAoYWxiZWl0IHdpdGggYSBjdXN0b20gcHJvdG90eXBlKSwgeW91IG11c3QgZGVmaW5lIGVpdGhlciBhbiBpbnN0YW5jZSBwcm9wZXJ0eVxyXG4gKiBvciBhIHN0YXRpYyBwcm9wZXJ0eSBvbiBlYWNoIG9mIHlvdXIgY3VzdG9tIGNsYXNzZXMuXHJcbiAqXHJcbiAqIE90aGVyd2lzZSwgeW91ciBjbGFzcyBpbnN0YW5jZSB3aWxsIG5ldmVyIGJlIGRyYWZ0ZWQsIHdoaWNoIG1lYW5zIGl0IHdvbid0IGJlXHJcbiAqIHNhZmUgdG8gbXV0YXRlIGluIGEgcHJvZHVjZSBjYWxsYmFjay5cclxuICovXG5cbnZhciBEUkFGVEFCTEUgPSBoYXNTeW1ib2wgP1xuLyojX19QVVJFX18qL1xuU3ltYm9sLmZvcihcImltbWVyLWRyYWZ0YWJsZVwiKSA6IFwiX18kaW1tZXJfZHJhZnRhYmxlXCI7XG52YXIgRFJBRlRfU1RBVEUgPSBoYXNTeW1ib2wgP1xuLyojX19QVVJFX18qL1xuU3ltYm9sLmZvcihcImltbWVyLXN0YXRlXCIpIDogXCJfXyRpbW1lcl9zdGF0ZVwiOyAvLyBFdmVuIGEgcG9seWZpbGxlZCBTeW1ib2wgbWlnaHQgcHJvdmlkZSBTeW1ib2wuaXRlcmF0b3JcblxudmFyIGl0ZXJhdG9yU3ltYm9sID0gdHlwZW9mIFN5bWJvbCAhPSBcInVuZGVmaW5lZFwiICYmIFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcblxudmFyIGVycm9ycyA9IHtcbiAgMDogXCJJbGxlZ2FsIHN0YXRlXCIsXG4gIDE6IFwiSW1tZXIgZHJhZnRzIGNhbm5vdCBoYXZlIGNvbXB1dGVkIHByb3BlcnRpZXNcIixcbiAgMjogXCJUaGlzIG9iamVjdCBoYXMgYmVlbiBmcm96ZW4gYW5kIHNob3VsZCBub3QgYmUgbXV0YXRlZFwiLFxuICAzOiBmdW5jdGlvbiBfKGRhdGEpIHtcbiAgICByZXR1cm4gXCJDYW5ub3QgdXNlIGEgcHJveHkgdGhhdCBoYXMgYmVlbiByZXZva2VkLiBEaWQgeW91IHBhc3MgYW4gb2JqZWN0IGZyb20gaW5zaWRlIGFuIGltbWVyIGZ1bmN0aW9uIHRvIGFuIGFzeW5jIHByb2Nlc3M/IFwiICsgZGF0YTtcbiAgfSxcbiAgNDogXCJBbiBpbW1lciBwcm9kdWNlciByZXR1cm5lZCBhIG5ldyB2YWx1ZSAqYW5kKiBtb2RpZmllZCBpdHMgZHJhZnQuIEVpdGhlciByZXR1cm4gYSBuZXcgdmFsdWUgKm9yKiBtb2RpZnkgdGhlIGRyYWZ0LlwiLFxuICA1OiBcIkltbWVyIGZvcmJpZHMgY2lyY3VsYXIgcmVmZXJlbmNlc1wiLFxuICA2OiBcIlRoZSBmaXJzdCBvciBzZWNvbmQgYXJndW1lbnQgdG8gYHByb2R1Y2VgIG11c3QgYmUgYSBmdW5jdGlvblwiLFxuICA3OiBcIlRoZSB0aGlyZCBhcmd1bWVudCB0byBgcHJvZHVjZWAgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIHVuZGVmaW5lZFwiLFxuICA4OiBcIkZpcnN0IGFyZ3VtZW50IHRvIGBjcmVhdGVEcmFmdGAgbXVzdCBiZSBhIHBsYWluIG9iamVjdCwgYW4gYXJyYXksIG9yIGFuIGltbWVyYWJsZSBvYmplY3RcIixcbiAgOTogXCJGaXJzdCBhcmd1bWVudCB0byBgZmluaXNoRHJhZnRgIG11c3QgYmUgYSBkcmFmdCByZXR1cm5lZCBieSBgY3JlYXRlRHJhZnRgXCIsXG4gIDEwOiBcIlRoZSBnaXZlbiBkcmFmdCBpcyBhbHJlYWR5IGZpbmFsaXplZFwiLFxuICAxMTogXCJPYmplY3QuZGVmaW5lUHJvcGVydHkoKSBjYW5ub3QgYmUgdXNlZCBvbiBhbiBJbW1lciBkcmFmdFwiLFxuICAxMjogXCJPYmplY3Quc2V0UHJvdG90eXBlT2YoKSBjYW5ub3QgYmUgdXNlZCBvbiBhbiBJbW1lciBkcmFmdFwiLFxuICAxMzogXCJJbW1lciBvbmx5IHN1cHBvcnRzIGRlbGV0aW5nIGFycmF5IGluZGljZXNcIixcbiAgMTQ6IFwiSW1tZXIgb25seSBzdXBwb3J0cyBzZXR0aW5nIGFycmF5IGluZGljZXMgYW5kIHRoZSAnbGVuZ3RoJyBwcm9wZXJ0eVwiLFxuICAxNTogZnVuY3Rpb24gXyhwYXRoKSB7XG4gICAgcmV0dXJuIFwiQ2Fubm90IGFwcGx5IHBhdGNoLCBwYXRoIGRvZXNuJ3QgcmVzb2x2ZTogXCIgKyBwYXRoO1xuICB9LFxuICAxNjogJ1NldHMgY2Fubm90IGhhdmUgXCJyZXBsYWNlXCIgcGF0Y2hlcy4nLFxuICAxNzogZnVuY3Rpb24gXyhvcCkge1xuICAgIHJldHVybiBcIlVuc3VwcG9ydGVkIHBhdGNoIG9wZXJhdGlvbjogXCIgKyBvcDtcbiAgfSxcbiAgMTg6IGZ1bmN0aW9uIF8ocGx1Z2luKSB7XG4gICAgcmV0dXJuIFwiVGhlIHBsdWdpbiBmb3IgJ1wiICsgcGx1Z2luICsgXCInIGhhcyBub3QgYmVlbiBsb2FkZWQgaW50byBJbW1lci4gVG8gZW5hYmxlIHRoZSBwbHVnaW4sIGltcG9ydCBhbmQgY2FsbCBgZW5hYmxlXCIgKyBwbHVnaW4gKyBcIigpYCB3aGVuIGluaXRpYWxpemluZyB5b3VyIGFwcGxpY2F0aW9uLlwiO1xuICB9LFxuICAyMDogXCJDYW5ub3QgdXNlIHByb3hpZXMgaWYgUHJveHksIFByb3h5LnJldm9jYWJsZSBvciBSZWZsZWN0IGFyZSBub3QgYXZhaWxhYmxlXCIsXG4gIDIxOiBmdW5jdGlvbiBfKHRoaW5nKSB7XG4gICAgcmV0dXJuIFwicHJvZHVjZSBjYW4gb25seSBiZSBjYWxsZWQgb24gdGhpbmdzIHRoYXQgYXJlIGRyYWZ0YWJsZTogcGxhaW4gb2JqZWN0cywgYXJyYXlzLCBNYXAsIFNldCBvciBjbGFzc2VzIHRoYXQgYXJlIG1hcmtlZCB3aXRoICdbaW1tZXJhYmxlXTogdHJ1ZScuIEdvdCAnXCIgKyB0aGluZyArIFwiJ1wiO1xuICB9LFxuICAyMjogZnVuY3Rpb24gXyh0aGluZykge1xuICAgIHJldHVybiBcIidjdXJyZW50JyBleHBlY3RzIGEgZHJhZnQsIGdvdDogXCIgKyB0aGluZztcbiAgfSxcbiAgMjM6IGZ1bmN0aW9uIF8odGhpbmcpIHtcbiAgICByZXR1cm4gXCInb3JpZ2luYWwnIGV4cGVjdHMgYSBkcmFmdCwgZ290OiBcIiArIHRoaW5nO1xuICB9LFxuICAyNDogXCJQYXRjaGluZyByZXNlcnZlZCBhdHRyaWJ1dGVzIGxpa2UgX19wcm90b19fLCBwcm90b3R5cGUgYW5kIGNvbnN0cnVjdG9yIGlzIG5vdCBhbGxvd2VkXCJcbn07XG5mdW5jdGlvbiBkaWUoZXJyb3IpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAge1xuICAgIHZhciBlID0gZXJyb3JzW2Vycm9yXTtcbiAgICB2YXIgbXNnID0gIWUgPyBcInVua25vd24gZXJyb3IgbnI6IFwiICsgZXJyb3IgOiB0eXBlb2YgZSA9PT0gXCJmdW5jdGlvblwiID8gZS5hcHBseShudWxsLCBhcmdzKSA6IGU7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiW0ltbWVyXSBcIiArIG1zZyk7XG4gIH1cbn1cblxuLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYW4gSW1tZXIgZHJhZnQgKi9cblxuLyojX19QVVJFX18qL1xuXG5mdW5jdGlvbiBpc0RyYWZ0KHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmICEhdmFsdWVbRFJBRlRfU1RBVEVdO1xufVxuLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gdmFsdWUgY2FuIGJlIGRyYWZ0ZWQgYnkgSW1tZXIgKi9cblxuLyojX19QVVJFX18qL1xuXG5mdW5jdGlvbiBpc0RyYWZ0YWJsZSh2YWx1ZSkge1xuICB2YXIgX3ZhbHVlJGNvbnN0cnVjdG9yO1xuXG4gIGlmICghdmFsdWUpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGlzUGxhaW5PYmplY3QodmFsdWUpIHx8IEFycmF5LmlzQXJyYXkodmFsdWUpIHx8ICEhdmFsdWVbRFJBRlRBQkxFXSB8fCAhISgoX3ZhbHVlJGNvbnN0cnVjdG9yID0gdmFsdWUuY29uc3RydWN0b3IpID09PSBudWxsIHx8IF92YWx1ZSRjb25zdHJ1Y3RvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3ZhbHVlJGNvbnN0cnVjdG9yW0RSQUZUQUJMRV0pIHx8IGlzTWFwKHZhbHVlKSB8fCBpc1NldCh2YWx1ZSk7XG59XG52YXIgb2JqZWN0Q3RvclN0cmluZyA9XG4vKiNfX1BVUkVfXyovXG5PYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yLnRvU3RyaW5nKCk7XG4vKiNfX1BVUkVfXyovXG5cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIpIHJldHVybiBmYWxzZTtcbiAgdmFyIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKTtcblxuICBpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBDdG9yID0gT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwocHJvdG8sIFwiY29uc3RydWN0b3JcIikgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIGlmIChDdG9yID09PSBPYmplY3QpIHJldHVybiB0cnVlO1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT0gXCJmdW5jdGlvblwiICYmIEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoQ3RvcikgPT09IG9iamVjdEN0b3JTdHJpbmc7XG59XG5mdW5jdGlvbiBvcmlnaW5hbCh2YWx1ZSkge1xuICBpZiAoIWlzRHJhZnQodmFsdWUpKSBkaWUoMjMsIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlW0RSQUZUX1NUQVRFXS5iYXNlXztcbn1cbi8qI19fUFVSRV9fKi9cblxudmFyIG93bktleXMgPSB0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0Lm93bktleXMgPyBSZWZsZWN0Lm93bktleXMgOiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAhPT0gXCJ1bmRlZmluZWRcIiA/IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqKSk7XG59IDpcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0YXJnZXQpIHtcbiAgLy8gUG9seWZpbGwgbmVlZGVkIGZvciBIZXJtZXMgYW5kIElFLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2hlcm1lcy9pc3N1ZXMvMjc0XG4gIHZhciByZXMgPSB7fTtcbiAgb3duS2V5cyh0YXJnZXQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHJlc1trZXldID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSk7XG4gIH0pO1xuICByZXR1cm4gcmVzO1xufTtcbmZ1bmN0aW9uIGVhY2gob2JqLCBpdGVyLCBlbnVtZXJhYmxlT25seSkge1xuICBpZiAoZW51bWVyYWJsZU9ubHkgPT09IHZvaWQgMCkge1xuICAgIGVudW1lcmFibGVPbmx5ID0gZmFsc2U7XG4gIH1cblxuICBpZiAoZ2V0QXJjaHR5cGUob2JqKSA9PT0gMFxuICAvKiBPYmplY3QgKi9cbiAgKSB7XG4gICAgICAoZW51bWVyYWJsZU9ubHkgPyBPYmplY3Qua2V5cyA6IG93bktleXMpKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICghZW51bWVyYWJsZU9ubHkgfHwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIikgaXRlcihrZXksIG9ialtrZXldLCBvYmopO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICBvYmouZm9yRWFjaChmdW5jdGlvbiAoZW50cnksIGluZGV4KSB7XG4gICAgICByZXR1cm4gaXRlcihpbmRleCwgZW50cnksIG9iaik7XG4gICAgfSk7XG4gIH1cbn1cbi8qI19fUFVSRV9fKi9cblxuZnVuY3Rpb24gZ2V0QXJjaHR5cGUodGhpbmcpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgdmFyIHN0YXRlID0gdGhpbmdbRFJBRlRfU1RBVEVdO1xuICByZXR1cm4gc3RhdGUgPyBzdGF0ZS50eXBlXyA+IDMgPyBzdGF0ZS50eXBlXyAtIDQgLy8gY2F1c2UgT2JqZWN0IGFuZCBBcnJheSBtYXAgYmFjayBmcm9tIDQgYW5kIDVcbiAgOiBzdGF0ZS50eXBlXyAvLyBvdGhlcnMgYXJlIHRoZSBzYW1lXG4gIDogQXJyYXkuaXNBcnJheSh0aGluZykgPyAxXG4gIC8qIEFycmF5ICovXG4gIDogaXNNYXAodGhpbmcpID8gMlxuICAvKiBNYXAgKi9cbiAgOiBpc1NldCh0aGluZykgPyAzXG4gIC8qIFNldCAqL1xuICA6IDBcbiAgLyogT2JqZWN0ICovXG4gIDtcbn1cbi8qI19fUFVSRV9fKi9cblxuZnVuY3Rpb24gaGFzKHRoaW5nLCBwcm9wKSB7XG4gIHJldHVybiBnZXRBcmNodHlwZSh0aGluZykgPT09IDJcbiAgLyogTWFwICovXG4gID8gdGhpbmcuaGFzKHByb3ApIDogT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaW5nLCBwcm9wKTtcbn1cbi8qI19fUFVSRV9fKi9cblxuZnVuY3Rpb24gZ2V0KHRoaW5nLCBwcm9wKSB7XG4gIC8vIEB0cy1pZ25vcmVcbiAgcmV0dXJuIGdldEFyY2h0eXBlKHRoaW5nKSA9PT0gMlxuICAvKiBNYXAgKi9cbiAgPyB0aGluZy5nZXQocHJvcCkgOiB0aGluZ1twcm9wXTtcbn1cbi8qI19fUFVSRV9fKi9cblxuZnVuY3Rpb24gc2V0KHRoaW5nLCBwcm9wT3JPbGRWYWx1ZSwgdmFsdWUpIHtcbiAgdmFyIHQgPSBnZXRBcmNodHlwZSh0aGluZyk7XG4gIGlmICh0ID09PSAyXG4gIC8qIE1hcCAqL1xuICApIHRoaW5nLnNldChwcm9wT3JPbGRWYWx1ZSwgdmFsdWUpO2Vsc2UgaWYgKHQgPT09IDNcbiAgLyogU2V0ICovXG4gICkge1xuICAgICAgdGhpbmcuZGVsZXRlKHByb3BPck9sZFZhbHVlKTtcbiAgICAgIHRoaW5nLmFkZCh2YWx1ZSk7XG4gICAgfSBlbHNlIHRoaW5nW3Byb3BPck9sZFZhbHVlXSA9IHZhbHVlO1xufVxuLyojX19QVVJFX18qL1xuXG5mdW5jdGlvbiBpcyh4LCB5KSB7XG4gIC8vIEZyb206IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mYmpzL2Jsb2IvYzY5OTA0YTUxMWI5MDAyNjY5MzUxNjgyMjMwNjNkZDg3NzJkZmM0MC9wYWNrYWdlcy9mYmpzL3NyYy9jb3JlL3NoYWxsb3dFcXVhbC5qc1xuICBpZiAoeCA9PT0geSkge1xuICAgIHJldHVybiB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICB9XG59XG4vKiNfX1BVUkVfXyovXG5cbmZ1bmN0aW9uIGlzTWFwKHRhcmdldCkge1xuICByZXR1cm4gaGFzTWFwICYmIHRhcmdldCBpbnN0YW5jZW9mIE1hcDtcbn1cbi8qI19fUFVSRV9fKi9cblxuZnVuY3Rpb24gaXNTZXQodGFyZ2V0KSB7XG4gIHJldHVybiBoYXNTZXQgJiYgdGFyZ2V0IGluc3RhbmNlb2YgU2V0O1xufVxuLyojX19QVVJFX18qL1xuXG5mdW5jdGlvbiBsYXRlc3Qoc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLmNvcHlfIHx8IHN0YXRlLmJhc2VfO1xufVxuLyojX19QVVJFX18qL1xuXG5mdW5jdGlvbiBzaGFsbG93Q29weShiYXNlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGJhc2UpKSByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYmFzZSk7XG4gIHZhciBkZXNjcmlwdG9ycyA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoYmFzZSk7XG4gIGRlbGV0ZSBkZXNjcmlwdG9yc1tEUkFGVF9TVEFURV07XG4gIHZhciBrZXlzID0gb3duS2V5cyhkZXNjcmlwdG9ycyk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgdmFyIGRlc2MgPSBkZXNjcmlwdG9yc1trZXldO1xuXG4gICAgaWYgKGRlc2Mud3JpdGFibGUgPT09IGZhbHNlKSB7XG4gICAgICBkZXNjLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIGRlc2MuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICB9IC8vIGxpa2Ugb2JqZWN0LmFzc2lnbiwgd2Ugd2lsbCByZWFkIGFueSBfb3duXywgZ2V0L3NldCBhY2Nlc3NvcnMuIFRoaXMgaGVscHMgaW4gZGVhbGluZ1xuICAgIC8vIHdpdGggbGlicmFyaWVzIHRoYXQgdHJhcCB2YWx1ZXMsIGxpa2UgbW9ieCBvciB2dWVcbiAgICAvLyB1bmxpa2Ugb2JqZWN0LmFzc2lnbiwgbm9uLWVudW1lcmFibGVzIHdpbGwgYmUgY29waWVkIGFzIHdlbGxcblxuXG4gICAgaWYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSBkZXNjcmlwdG9yc1trZXldID0ge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBkZXNjLmVudW1lcmFibGUsXG4gICAgICB2YWx1ZTogYmFzZVtrZXldXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihiYXNlKSwgZGVzY3JpcHRvcnMpO1xufVxuZnVuY3Rpb24gZnJlZXplKG9iaiwgZGVlcCkge1xuICBpZiAoZGVlcCA9PT0gdm9pZCAwKSB7XG4gICAgZGVlcCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKGlzRnJvemVuKG9iaikgfHwgaXNEcmFmdChvYmopIHx8ICFpc0RyYWZ0YWJsZShvYmopKSByZXR1cm4gb2JqO1xuXG4gIGlmIChnZXRBcmNodHlwZShvYmopID4gMVxuICAvKiBNYXAgb3IgU2V0ICovXG4gICkge1xuICAgICAgb2JqLnNldCA9IG9iai5hZGQgPSBvYmouY2xlYXIgPSBvYmouZGVsZXRlID0gZG9udE11dGF0ZUZyb3plbkNvbGxlY3Rpb25zO1xuICAgIH1cblxuICBPYmplY3QuZnJlZXplKG9iaik7XG4gIGlmIChkZWVwKSBlYWNoKG9iaiwgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gZnJlZXplKHZhbHVlLCB0cnVlKTtcbiAgfSwgdHJ1ZSk7XG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIGRvbnRNdXRhdGVGcm96ZW5Db2xsZWN0aW9ucygpIHtcbiAgZGllKDIpO1xufVxuXG5mdW5jdGlvbiBpc0Zyb3plbihvYmopIHtcbiAgaWYgKG9iaiA9PSBudWxsIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIpIHJldHVybiB0cnVlOyAvLyBTZWUgIzYwMCwgSUUgZGllcyBvbiBub24tb2JqZWN0cyBpbiBPYmplY3QuaXNGcm96ZW5cblxuICByZXR1cm4gT2JqZWN0LmlzRnJvemVuKG9iaik7XG59XG5cbi8qKiBQbHVnaW4gdXRpbGl0aWVzICovXG5cbnZhciBwbHVnaW5zID0ge307XG5mdW5jdGlvbiBnZXRQbHVnaW4ocGx1Z2luS2V5KSB7XG4gIHZhciBwbHVnaW4gPSBwbHVnaW5zW3BsdWdpbktleV07XG5cbiAgaWYgKCFwbHVnaW4pIHtcbiAgICBkaWUoMTgsIHBsdWdpbktleSk7XG4gIH0gLy8gQHRzLWlnbm9yZVxuXG5cbiAgcmV0dXJuIHBsdWdpbjtcbn1cbmZ1bmN0aW9uIGxvYWRQbHVnaW4ocGx1Z2luS2V5LCBpbXBsZW1lbnRhdGlvbikge1xuICBpZiAoIXBsdWdpbnNbcGx1Z2luS2V5XSkgcGx1Z2luc1twbHVnaW5LZXldID0gaW1wbGVtZW50YXRpb247XG59XG5cbnZhciBjdXJyZW50U2NvcGU7XG5mdW5jdGlvbiBnZXRDdXJyZW50U2NvcGUoKSB7XG4gIGlmICggIWN1cnJlbnRTY29wZSkgZGllKDApO1xuICByZXR1cm4gY3VycmVudFNjb3BlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTY29wZShwYXJlbnRfLCBpbW1lcl8pIHtcbiAgcmV0dXJuIHtcbiAgICBkcmFmdHNfOiBbXSxcbiAgICBwYXJlbnRfOiBwYXJlbnRfLFxuICAgIGltbWVyXzogaW1tZXJfLFxuICAgIC8vIFdoZW5ldmVyIHRoZSBtb2RpZmllZCBkcmFmdCBjb250YWlucyBhIGRyYWZ0IGZyb20gYW5vdGhlciBzY29wZSwgd2VcbiAgICAvLyBuZWVkIHRvIHByZXZlbnQgYXV0by1mcmVlemluZyBzbyB0aGUgdW5vd25lZCBkcmFmdCBjYW4gYmUgZmluYWxpemVkLlxuICAgIGNhbkF1dG9GcmVlemVfOiB0cnVlLFxuICAgIHVuZmluYWxpemVkRHJhZnRzXzogMFxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VQYXRjaGVzSW5TY29wZShzY29wZSwgcGF0Y2hMaXN0ZW5lcikge1xuICBpZiAocGF0Y2hMaXN0ZW5lcikge1xuICAgIGdldFBsdWdpbihcIlBhdGNoZXNcIik7IC8vIGFzc2VydCB3ZSBoYXZlIHRoZSBwbHVnaW5cblxuICAgIHNjb3BlLnBhdGNoZXNfID0gW107XG4gICAgc2NvcGUuaW52ZXJzZVBhdGNoZXNfID0gW107XG4gICAgc2NvcGUucGF0Y2hMaXN0ZW5lcl8gPSBwYXRjaExpc3RlbmVyO1xuICB9XG59XG5mdW5jdGlvbiByZXZva2VTY29wZShzY29wZSkge1xuICBsZWF2ZVNjb3BlKHNjb3BlKTtcbiAgc2NvcGUuZHJhZnRzXy5mb3JFYWNoKHJldm9rZURyYWZ0KTsgLy8gQHRzLWlnbm9yZVxuXG4gIHNjb3BlLmRyYWZ0c18gPSBudWxsO1xufVxuZnVuY3Rpb24gbGVhdmVTY29wZShzY29wZSkge1xuICBpZiAoc2NvcGUgPT09IGN1cnJlbnRTY29wZSkge1xuICAgIGN1cnJlbnRTY29wZSA9IHNjb3BlLnBhcmVudF87XG4gIH1cbn1cbmZ1bmN0aW9uIGVudGVyU2NvcGUoaW1tZXIpIHtcbiAgcmV0dXJuIGN1cnJlbnRTY29wZSA9IGNyZWF0ZVNjb3BlKGN1cnJlbnRTY29wZSwgaW1tZXIpO1xufVxuXG5mdW5jdGlvbiByZXZva2VEcmFmdChkcmFmdCkge1xuICB2YXIgc3RhdGUgPSBkcmFmdFtEUkFGVF9TVEFURV07XG4gIGlmIChzdGF0ZS50eXBlXyA9PT0gMFxuICAvKiBQcm94eU9iamVjdCAqL1xuICB8fCBzdGF0ZS50eXBlXyA9PT0gMVxuICAvKiBQcm94eUFycmF5ICovXG4gICkgc3RhdGUucmV2b2tlXygpO2Vsc2Ugc3RhdGUucmV2b2tlZF8gPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzUmVzdWx0KHJlc3VsdCwgc2NvcGUpIHtcbiAgc2NvcGUudW5maW5hbGl6ZWREcmFmdHNfID0gc2NvcGUuZHJhZnRzXy5sZW5ndGg7XG4gIHZhciBiYXNlRHJhZnQgPSBzY29wZS5kcmFmdHNfWzBdO1xuICB2YXIgaXNSZXBsYWNlZCA9IHJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIHJlc3VsdCAhPT0gYmFzZURyYWZ0O1xuICBpZiAoIXNjb3BlLmltbWVyXy51c2VQcm94aWVzXykgZ2V0UGx1Z2luKFwiRVM1XCIpLndpbGxGaW5hbGl6ZUVTNV8oc2NvcGUsIHJlc3VsdCwgaXNSZXBsYWNlZCk7XG5cbiAgaWYgKGlzUmVwbGFjZWQpIHtcbiAgICBpZiAoYmFzZURyYWZ0W0RSQUZUX1NUQVRFXS5tb2RpZmllZF8pIHtcbiAgICAgIHJldm9rZVNjb3BlKHNjb3BlKTtcbiAgICAgIGRpZSg0KTtcbiAgICB9XG5cbiAgICBpZiAoaXNEcmFmdGFibGUocmVzdWx0KSkge1xuICAgICAgLy8gRmluYWxpemUgdGhlIHJlc3VsdCBpbiBjYXNlIGl0IGNvbnRhaW5zIChvciBpcykgYSBzdWJzZXQgb2YgdGhlIGRyYWZ0LlxuICAgICAgcmVzdWx0ID0gZmluYWxpemUoc2NvcGUsIHJlc3VsdCk7XG4gICAgICBpZiAoIXNjb3BlLnBhcmVudF8pIG1heWJlRnJlZXplKHNjb3BlLCByZXN1bHQpO1xuICAgIH1cblxuICAgIGlmIChzY29wZS5wYXRjaGVzXykge1xuICAgICAgZ2V0UGx1Z2luKFwiUGF0Y2hlc1wiKS5nZW5lcmF0ZVJlcGxhY2VtZW50UGF0Y2hlc18oYmFzZURyYWZ0W0RSQUZUX1NUQVRFXS5iYXNlXywgcmVzdWx0LCBzY29wZS5wYXRjaGVzXywgc2NvcGUuaW52ZXJzZVBhdGNoZXNfKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRmluYWxpemUgdGhlIGJhc2UgZHJhZnQuXG4gICAgcmVzdWx0ID0gZmluYWxpemUoc2NvcGUsIGJhc2VEcmFmdCwgW10pO1xuICB9XG5cbiAgcmV2b2tlU2NvcGUoc2NvcGUpO1xuXG4gIGlmIChzY29wZS5wYXRjaGVzXykge1xuICAgIHNjb3BlLnBhdGNoTGlzdGVuZXJfKHNjb3BlLnBhdGNoZXNfLCBzY29wZS5pbnZlcnNlUGF0Y2hlc18pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdCAhPT0gTk9USElORyA/IHJlc3VsdCA6IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZmluYWxpemUocm9vdFNjb3BlLCB2YWx1ZSwgcGF0aCkge1xuICAvLyBEb24ndCByZWN1cnNlIGluIHRobyByZWN1cnNpdmUgZGF0YSBzdHJ1Y3R1cmVzXG4gIGlmIChpc0Zyb3plbih2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgdmFyIHN0YXRlID0gdmFsdWVbRFJBRlRfU1RBVEVdOyAvLyBBIHBsYWluIG9iamVjdCwgbWlnaHQgbmVlZCBmcmVlemluZywgbWlnaHQgY29udGFpbiBkcmFmdHNcblxuICBpZiAoIXN0YXRlKSB7XG4gICAgZWFjaCh2YWx1ZSwgZnVuY3Rpb24gKGtleSwgY2hpbGRWYWx1ZSkge1xuICAgICAgcmV0dXJuIGZpbmFsaXplUHJvcGVydHkocm9vdFNjb3BlLCBzdGF0ZSwgdmFsdWUsIGtleSwgY2hpbGRWYWx1ZSwgcGF0aCk7XG4gICAgfSwgdHJ1ZSAvLyBTZWUgIzU5MCwgZG9uJ3QgcmVjdXJzZSBpbnRvIG5vbi1lbnVtZXJhYmxlIG9mIG5vbiBkcmFmdGVkIG9iamVjdHNcbiAgICApO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSAvLyBOZXZlciBmaW5hbGl6ZSBkcmFmdHMgb3duZWQgYnkgYW5vdGhlciBzY29wZS5cblxuXG4gIGlmIChzdGF0ZS5zY29wZV8gIT09IHJvb3RTY29wZSkgcmV0dXJuIHZhbHVlOyAvLyBVbm1vZGlmaWVkIGRyYWZ0LCByZXR1cm4gdGhlIChmcm96ZW4pIG9yaWdpbmFsXG5cbiAgaWYgKCFzdGF0ZS5tb2RpZmllZF8pIHtcbiAgICBtYXliZUZyZWV6ZShyb290U2NvcGUsIHN0YXRlLmJhc2VfLCB0cnVlKTtcbiAgICByZXR1cm4gc3RhdGUuYmFzZV87XG4gIH0gLy8gTm90IGZpbmFsaXplZCB5ZXQsIGxldCdzIGRvIHRoYXQgbm93XG5cblxuICBpZiAoIXN0YXRlLmZpbmFsaXplZF8pIHtcbiAgICBzdGF0ZS5maW5hbGl6ZWRfID0gdHJ1ZTtcbiAgICBzdGF0ZS5zY29wZV8udW5maW5hbGl6ZWREcmFmdHNfLS07XG4gICAgdmFyIHJlc3VsdCA9IC8vIEZvciBFUzUsIGNyZWF0ZSBhIGdvb2QgY29weSBmcm9tIHRoZSBkcmFmdCBmaXJzdCwgd2l0aCBhZGRlZCBrZXlzIGFuZCB3aXRob3V0IGRlbGV0ZWQga2V5cy5cbiAgICBzdGF0ZS50eXBlXyA9PT0gNFxuICAgIC8qIEVTNU9iamVjdCAqL1xuICAgIHx8IHN0YXRlLnR5cGVfID09PSA1XG4gICAgLyogRVM1QXJyYXkgKi9cbiAgICA/IHN0YXRlLmNvcHlfID0gc2hhbGxvd0NvcHkoc3RhdGUuZHJhZnRfKSA6IHN0YXRlLmNvcHlfOyAvLyBGaW5hbGl6ZSBhbGwgY2hpbGRyZW4gb2YgdGhlIGNvcHlcbiAgICAvLyBGb3Igc2V0cyB3ZSBjbG9uZSBiZWZvcmUgaXRlcmF0aW5nLCBvdGhlcndpc2Ugd2UgY2FuIGdldCBpbiBlbmRsZXNzIGxvb3AgZHVlIHRvIG1vZGlmeWluZyBkdXJpbmcgaXRlcmF0aW9uLCBzZWUgIzYyOFxuICAgIC8vIEFsdGhvdWdoIHRoZSBvcmlnaW5hbCB0ZXN0IGNhc2UgZG9lc24ndCBzZWVtIHZhbGlkIGFueXdheSwgc28gaWYgdGhpcyBpbiB0aGUgd2F5IHdlIGNhbiB0dXJuIHRoZSBuZXh0IGxpbmVcbiAgICAvLyBiYWNrIHRvIGVhY2gocmVzdWx0LCAuLi4uKVxuXG4gICAgZWFjaChzdGF0ZS50eXBlXyA9PT0gM1xuICAgIC8qIFNldCAqL1xuICAgID8gbmV3IFNldChyZXN1bHQpIDogcmVzdWx0LCBmdW5jdGlvbiAoa2V5LCBjaGlsZFZhbHVlKSB7XG4gICAgICByZXR1cm4gZmluYWxpemVQcm9wZXJ0eShyb290U2NvcGUsIHN0YXRlLCByZXN1bHQsIGtleSwgY2hpbGRWYWx1ZSwgcGF0aCk7XG4gICAgfSk7IC8vIGV2ZXJ5dGhpbmcgaW5zaWRlIGlzIGZyb3plbiwgd2UgY2FuIGZyZWV6ZSBoZXJlXG5cbiAgICBtYXliZUZyZWV6ZShyb290U2NvcGUsIHJlc3VsdCwgZmFsc2UpOyAvLyBmaXJzdCB0aW1lIGZpbmFsaXppbmcsIGxldCdzIGNyZWF0ZSB0aG9zZSBwYXRjaGVzXG5cbiAgICBpZiAocGF0aCAmJiByb290U2NvcGUucGF0Y2hlc18pIHtcbiAgICAgIGdldFBsdWdpbihcIlBhdGNoZXNcIikuZ2VuZXJhdGVQYXRjaGVzXyhzdGF0ZSwgcGF0aCwgcm9vdFNjb3BlLnBhdGNoZXNfLCByb290U2NvcGUuaW52ZXJzZVBhdGNoZXNfKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RhdGUuY29weV87XG59XG5cbmZ1bmN0aW9uIGZpbmFsaXplUHJvcGVydHkocm9vdFNjb3BlLCBwYXJlbnRTdGF0ZSwgdGFyZ2V0T2JqZWN0LCBwcm9wLCBjaGlsZFZhbHVlLCByb290UGF0aCkge1xuICBpZiAoIGNoaWxkVmFsdWUgPT09IHRhcmdldE9iamVjdCkgZGllKDUpO1xuXG4gIGlmIChpc0RyYWZ0KGNoaWxkVmFsdWUpKSB7XG4gICAgdmFyIHBhdGggPSByb290UGF0aCAmJiBwYXJlbnRTdGF0ZSAmJiBwYXJlbnRTdGF0ZS50eXBlXyAhPT0gM1xuICAgIC8qIFNldCAqL1xuICAgICYmIC8vIFNldCBvYmplY3RzIGFyZSBhdG9taWMgc2luY2UgdGhleSBoYXZlIG5vIGtleXMuXG4gICAgIWhhcyhwYXJlbnRTdGF0ZS5hc3NpZ25lZF8sIHByb3ApIC8vIFNraXAgZGVlcCBwYXRjaGVzIGZvciBhc3NpZ25lZCBrZXlzLlxuICAgID8gcm9vdFBhdGguY29uY2F0KHByb3ApIDogdW5kZWZpbmVkOyAvLyBEcmFmdHMgb3duZWQgYnkgYHNjb3BlYCBhcmUgZmluYWxpemVkIGhlcmUuXG5cbiAgICB2YXIgcmVzID0gZmluYWxpemUocm9vdFNjb3BlLCBjaGlsZFZhbHVlLCBwYXRoKTtcbiAgICBzZXQodGFyZ2V0T2JqZWN0LCBwcm9wLCByZXMpOyAvLyBEcmFmdHMgZnJvbSBhbm90aGVyIHNjb3BlIG11c3QgcHJldmVudGVkIHRvIGJlIGZyb3plblxuICAgIC8vIGlmIHdlIGdvdCBhIGRyYWZ0IGJhY2sgZnJvbSBmaW5hbGl6ZSwgd2UncmUgaW4gYSBuZXN0ZWQgcHJvZHVjZSBhbmQgc2hvdWxkbid0IGZyZWV6ZVxuXG4gICAgaWYgKGlzRHJhZnQocmVzKSkge1xuICAgICAgcm9vdFNjb3BlLmNhbkF1dG9GcmVlemVfID0gZmFsc2U7XG4gICAgfSBlbHNlIHJldHVybjtcbiAgfSAvLyBTZWFyY2ggbmV3IG9iamVjdHMgZm9yIHVuZmluYWxpemVkIGRyYWZ0cy4gRnJvemVuIG9iamVjdHMgc2hvdWxkIG5ldmVyIGNvbnRhaW4gZHJhZnRzLlxuXG5cbiAgaWYgKGlzRHJhZnRhYmxlKGNoaWxkVmFsdWUpICYmICFpc0Zyb3plbihjaGlsZFZhbHVlKSkge1xuICAgIGlmICghcm9vdFNjb3BlLmltbWVyXy5hdXRvRnJlZXplXyAmJiByb290U2NvcGUudW5maW5hbGl6ZWREcmFmdHNfIDwgMSkge1xuICAgICAgLy8gb3B0aW1pemF0aW9uOiBpZiBhbiBvYmplY3QgaXMgbm90IGEgZHJhZnQsIGFuZCB3ZSBkb24ndCBoYXZlIHRvXG4gICAgICAvLyBkZWVwZnJlZXplIGV2ZXJ5dGhpbmcsIGFuZCB3ZSBhcmUgc3VyZSB0aGF0IG5vIGRyYWZ0cyBhcmUgbGVmdCBpbiB0aGUgcmVtYWluaW5nIG9iamVjdFxuICAgICAgLy8gY2F1c2Ugd2Ugc2F3IGFuZCBmaW5hbGl6ZWQgYWxsIGRyYWZ0cyBhbHJlYWR5OyB3ZSBjYW4gc3RvcCB2aXNpdGluZyB0aGUgcmVzdCBvZiB0aGUgdHJlZS5cbiAgICAgIC8vIFRoaXMgYmVuZWZpdHMgZXNwZWNpYWxseSBhZGRpbmcgbGFyZ2UgZGF0YSB0cmVlJ3Mgd2l0aG91dCBmdXJ0aGVyIHByb2Nlc3NpbmcuXG4gICAgICAvLyBTZWUgYWRkLWRhdGEuanMgcGVyZiB0ZXN0XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZmluYWxpemUocm9vdFNjb3BlLCBjaGlsZFZhbHVlKTsgLy8gaW1tZXIgZGVlcCBmcmVlemVzIHBsYWluIG9iamVjdHMsIHNvIGlmIHRoZXJlIGlzIG5vIHBhcmVudCBzdGF0ZSwgd2UgZnJlZXplIGFzIHdlbGxcblxuICAgIGlmICghcGFyZW50U3RhdGUgfHwgIXBhcmVudFN0YXRlLnNjb3BlXy5wYXJlbnRfKSBtYXliZUZyZWV6ZShyb290U2NvcGUsIGNoaWxkVmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlRnJlZXplKHNjb3BlLCB2YWx1ZSwgZGVlcCkge1xuICBpZiAoZGVlcCA9PT0gdm9pZCAwKSB7XG4gICAgZGVlcCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHNjb3BlLmltbWVyXy5hdXRvRnJlZXplXyAmJiBzY29wZS5jYW5BdXRvRnJlZXplXykge1xuICAgIGZyZWV6ZSh2YWx1ZSwgZGVlcCk7XG4gIH1cbn1cblxuLyoqXHJcbiAqIFJldHVybnMgYSBuZXcgZHJhZnQgb2YgdGhlIGBiYXNlYCBvYmplY3QuXHJcbiAqXHJcbiAqIFRoZSBzZWNvbmQgYXJndW1lbnQgaXMgdGhlIHBhcmVudCBkcmFmdC1zdGF0ZSAodXNlZCBpbnRlcm5hbGx5KS5cclxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZVByb3h5UHJveHkoYmFzZSwgcGFyZW50KSB7XG4gIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShiYXNlKTtcbiAgdmFyIHN0YXRlID0ge1xuICAgIHR5cGVfOiBpc0FycmF5ID8gMVxuICAgIC8qIFByb3h5QXJyYXkgKi9cbiAgICA6IDBcbiAgICAvKiBQcm94eU9iamVjdCAqL1xuICAgICxcbiAgICAvLyBUcmFjayB3aGljaCBwcm9kdWNlIGNhbGwgdGhpcyBpcyBhc3NvY2lhdGVkIHdpdGguXG4gICAgc2NvcGVfOiBwYXJlbnQgPyBwYXJlbnQuc2NvcGVfIDogZ2V0Q3VycmVudFNjb3BlKCksXG4gICAgLy8gVHJ1ZSBmb3IgYm90aCBzaGFsbG93IGFuZCBkZWVwIGNoYW5nZXMuXG4gICAgbW9kaWZpZWRfOiBmYWxzZSxcbiAgICAvLyBVc2VkIGR1cmluZyBmaW5hbGl6YXRpb24uXG4gICAgZmluYWxpemVkXzogZmFsc2UsXG4gICAgLy8gVHJhY2sgd2hpY2ggcHJvcGVydGllcyBoYXZlIGJlZW4gYXNzaWduZWQgKHRydWUpIG9yIGRlbGV0ZWQgKGZhbHNlKS5cbiAgICBhc3NpZ25lZF86IHt9LFxuICAgIC8vIFRoZSBwYXJlbnQgZHJhZnQgc3RhdGUuXG4gICAgcGFyZW50XzogcGFyZW50LFxuICAgIC8vIFRoZSBiYXNlIHN0YXRlLlxuICAgIGJhc2VfOiBiYXNlLFxuICAgIC8vIFRoZSBiYXNlIHByb3h5LlxuICAgIGRyYWZ0XzogbnVsbCxcbiAgICAvLyBUaGUgYmFzZSBjb3B5IHdpdGggYW55IHVwZGF0ZWQgdmFsdWVzLlxuICAgIGNvcHlfOiBudWxsLFxuICAgIC8vIENhbGxlZCBieSB0aGUgYHByb2R1Y2VgIGZ1bmN0aW9uLlxuICAgIHJldm9rZV86IG51bGwsXG4gICAgaXNNYW51YWxfOiBmYWxzZVxuICB9OyAvLyB0aGUgdHJhcHMgbXVzdCB0YXJnZXQgc29tZXRoaW5nLCBhIGJpdCBsaWtlIHRoZSAncmVhbCcgYmFzZS5cbiAgLy8gYnV0IGFsc28sIHdlIG5lZWQgdG8gYmUgYWJsZSB0byBkZXRlcm1pbmUgZnJvbSB0aGUgdGFyZ2V0IHdoYXQgdGhlIHJlbGV2YW50IHN0YXRlIGlzXG4gIC8vICh0byBhdm9pZCBjcmVhdGluZyB0cmFwcyBwZXIgaW5zdGFuY2UgdG8gY2FwdHVyZSB0aGUgc3RhdGUgaW4gY2xvc3VyZSxcbiAgLy8gYW5kIHRvIGF2b2lkIGNyZWF0aW5nIHdlaXJkIGhpZGRlbiBwcm9wZXJ0aWVzIGFzIHdlbGwpXG4gIC8vIFNvIHRoZSB0cmljayBpcyB0byB1c2UgJ3N0YXRlJyBhcyB0aGUgYWN0dWFsICd0YXJnZXQnISAoYW5kIG1ha2Ugc3VyZSB3ZSBpbnRlcmNlcHQgZXZlcnl0aGluZylcbiAgLy8gTm90ZSB0aGF0IGluIHRoZSBjYXNlIG9mIGFuIGFycmF5LCB3ZSBwdXQgdGhlIHN0YXRlIGluIGFuIGFycmF5IHRvIGhhdmUgYmV0dGVyIFJlZmxlY3QgZGVmYXVsdHMgb290YlxuXG4gIHZhciB0YXJnZXQgPSBzdGF0ZTtcbiAgdmFyIHRyYXBzID0gb2JqZWN0VHJhcHM7XG5cbiAgaWYgKGlzQXJyYXkpIHtcbiAgICB0YXJnZXQgPSBbc3RhdGVdO1xuICAgIHRyYXBzID0gYXJyYXlUcmFwcztcbiAgfVxuXG4gIHZhciBfUHJveHkkcmV2b2NhYmxlID0gUHJveHkucmV2b2NhYmxlKHRhcmdldCwgdHJhcHMpLFxuICAgICAgcmV2b2tlID0gX1Byb3h5JHJldm9jYWJsZS5yZXZva2UsXG4gICAgICBwcm94eSA9IF9Qcm94eSRyZXZvY2FibGUucHJveHk7XG5cbiAgc3RhdGUuZHJhZnRfID0gcHJveHk7XG4gIHN0YXRlLnJldm9rZV8gPSByZXZva2U7XG4gIHJldHVybiBwcm94eTtcbn1cbi8qKlxyXG4gKiBPYmplY3QgZHJhZnRzXHJcbiAqL1xuXG52YXIgb2JqZWN0VHJhcHMgPSB7XG4gIGdldDogZnVuY3Rpb24gZ2V0KHN0YXRlLCBwcm9wKSB7XG4gICAgaWYgKHByb3AgPT09IERSQUZUX1NUQVRFKSByZXR1cm4gc3RhdGU7XG4gICAgdmFyIHNvdXJjZSA9IGxhdGVzdChzdGF0ZSk7XG5cbiAgICBpZiAoIWhhcyhzb3VyY2UsIHByb3ApKSB7XG4gICAgICAvLyBub24tZXhpc3Rpbmcgb3Igbm9uLW93biBwcm9wZXJ0eS4uLlxuICAgICAgcmV0dXJuIHJlYWRQcm9wRnJvbVByb3RvKHN0YXRlLCBzb3VyY2UsIHByb3ApO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IHNvdXJjZVtwcm9wXTtcblxuICAgIGlmIChzdGF0ZS5maW5hbGl6ZWRfIHx8ICFpc0RyYWZ0YWJsZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9IC8vIENoZWNrIGZvciBleGlzdGluZyBkcmFmdCBpbiBtb2RpZmllZCBzdGF0ZS5cbiAgICAvLyBBc3NpZ25lZCB2YWx1ZXMgYXJlIG5ldmVyIGRyYWZ0ZWQuIFRoaXMgY2F0Y2hlcyBhbnkgZHJhZnRzIHdlIGNyZWF0ZWQsIHRvby5cblxuXG4gICAgaWYgKHZhbHVlID09PSBwZWVrKHN0YXRlLmJhc2VfLCBwcm9wKSkge1xuICAgICAgcHJlcGFyZUNvcHkoc3RhdGUpO1xuICAgICAgcmV0dXJuIHN0YXRlLmNvcHlfW3Byb3BdID0gY3JlYXRlUHJveHkoc3RhdGUuc2NvcGVfLmltbWVyXywgdmFsdWUsIHN0YXRlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG4gIGhhczogZnVuY3Rpb24gaGFzKHN0YXRlLCBwcm9wKSB7XG4gICAgcmV0dXJuIHByb3AgaW4gbGF0ZXN0KHN0YXRlKTtcbiAgfSxcbiAgb3duS2V5czogZnVuY3Rpb24gb3duS2V5cyhzdGF0ZSkge1xuICAgIHJldHVybiBSZWZsZWN0Lm93bktleXMobGF0ZXN0KHN0YXRlKSk7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHN0YXRlLCBwcm9wXG4gIC8qIHN0cmljdGx5IG5vdCwgYnV0IGhlbHBzIFRTICovXG4gICwgdmFsdWUpIHtcbiAgICB2YXIgZGVzYyA9IGdldERlc2NyaXB0b3JGcm9tUHJvdG8obGF0ZXN0KHN0YXRlKSwgcHJvcCk7XG5cbiAgICBpZiAoZGVzYyA9PT0gbnVsbCB8fCBkZXNjID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZXNjLnNldCkge1xuICAgICAgLy8gc3BlY2lhbCBjYXNlOiBpZiB0aGlzIHdyaXRlIGlzIGNhcHR1cmVkIGJ5IGEgc2V0dGVyLCB3ZSBoYXZlXG4gICAgICAvLyB0byB0cmlnZ2VyIGl0IHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuICAgICAgZGVzYy5zZXQuY2FsbChzdGF0ZS5kcmFmdF8sIHZhbHVlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICghc3RhdGUubW9kaWZpZWRfKSB7XG4gICAgICAvLyB0aGUgbGFzdCBjaGVjayBpcyBiZWNhdXNlIHdlIG5lZWQgdG8gYmUgYWJsZSB0byBkaXN0aW5ndWlzaCBzZXR0aW5nIGEgbm9uLWV4aXN0aW5nIHRvIHVuZGVmaW5lZCAod2hpY2ggaXMgYSBjaGFuZ2UpXG4gICAgICAvLyBmcm9tIHNldHRpbmcgYW4gZXhpc3RpbmcgcHJvcGVydHkgd2l0aCB2YWx1ZSB1bmRlZmluZWQgdG8gdW5kZWZpbmVkICh3aGljaCBpcyBub3QgYSBjaGFuZ2UpXG4gICAgICB2YXIgY3VycmVudCA9IHBlZWsobGF0ZXN0KHN0YXRlKSwgcHJvcCk7IC8vIHNwZWNpYWwgY2FzZSwgaWYgd2UgYXNzaWduaW5nIHRoZSBvcmlnaW5hbCB2YWx1ZSB0byBhIGRyYWZ0LCB3ZSBjYW4gaWdub3JlIHRoZSBhc3NpZ25tZW50XG5cbiAgICAgIHZhciBjdXJyZW50U3RhdGUgPSBjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnRbRFJBRlRfU1RBVEVdO1xuXG4gICAgICBpZiAoY3VycmVudFN0YXRlICYmIGN1cnJlbnRTdGF0ZS5iYXNlXyA9PT0gdmFsdWUpIHtcbiAgICAgICAgc3RhdGUuY29weV9bcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgc3RhdGUuYXNzaWduZWRfW3Byb3BdID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXModmFsdWUsIGN1cnJlbnQpICYmICh2YWx1ZSAhPT0gdW5kZWZpbmVkIHx8IGhhcyhzdGF0ZS5iYXNlXywgcHJvcCkpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIHByZXBhcmVDb3B5KHN0YXRlKTtcbiAgICAgIG1hcmtDaGFuZ2VkKHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuY29weV9bcHJvcF0gPT09IHZhbHVlICYmIC8vIHNwZWNpYWwgY2FzZTogTmFOXG4gICAgdHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiICYmICggLy8gc3BlY2lhbCBjYXNlOiBoYW5kbGUgbmV3IHByb3BzIHdpdGggdmFsdWUgJ3VuZGVmaW5lZCdcbiAgICB2YWx1ZSAhPT0gdW5kZWZpbmVkIHx8IHByb3AgaW4gc3RhdGUuY29weV8pKSByZXR1cm4gdHJ1ZTsgLy8gQHRzLWlnbm9yZVxuXG4gICAgc3RhdGUuY29weV9bcHJvcF0gPSB2YWx1ZTtcbiAgICBzdGF0ZS5hc3NpZ25lZF9bcHJvcF0gPSB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBkZWxldGVQcm9wZXJ0eTogZnVuY3Rpb24gZGVsZXRlUHJvcGVydHkoc3RhdGUsIHByb3ApIHtcbiAgICAvLyBUaGUgYHVuZGVmaW5lZGAgY2hlY2sgaXMgYSBmYXN0IHBhdGggZm9yIHByZS1leGlzdGluZyBrZXlzLlxuICAgIGlmIChwZWVrKHN0YXRlLmJhc2VfLCBwcm9wKSAhPT0gdW5kZWZpbmVkIHx8IHByb3AgaW4gc3RhdGUuYmFzZV8pIHtcbiAgICAgIHN0YXRlLmFzc2lnbmVkX1twcm9wXSA9IGZhbHNlO1xuICAgICAgcHJlcGFyZUNvcHkoc3RhdGUpO1xuICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiBhbiBvcmlnaW5hbGx5IG5vdCBhc3NpZ25lZCBwcm9wZXJ0eSB3YXMgZGVsZXRlZFxuICAgICAgZGVsZXRlIHN0YXRlLmFzc2lnbmVkX1twcm9wXTtcbiAgICB9IC8vIEB0cy1pZ25vcmVcblxuXG4gICAgaWYgKHN0YXRlLmNvcHlfKSBkZWxldGUgc3RhdGUuY29weV9bcHJvcF07XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIC8vIE5vdGU6IFdlIG5ldmVyIGNvZXJjZSBgZGVzYy52YWx1ZWAgaW50byBhbiBJbW1lciBkcmFmdCwgYmVjYXVzZSB3ZSBjYW4ndCBtYWtlXG4gIC8vIHRoZSBzYW1lIGd1YXJhbnRlZSBpbiBFUzUgbW9kZS5cbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc3RhdGUsIHByb3ApIHtcbiAgICB2YXIgb3duZXIgPSBsYXRlc3Qoc3RhdGUpO1xuICAgIHZhciBkZXNjID0gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob3duZXIsIHByb3ApO1xuICAgIGlmICghZGVzYykgcmV0dXJuIGRlc2M7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiBzdGF0ZS50eXBlXyAhPT0gMVxuICAgICAgLyogUHJveHlBcnJheSAqL1xuICAgICAgfHwgcHJvcCAhPT0gXCJsZW5ndGhcIixcbiAgICAgIGVudW1lcmFibGU6IGRlc2MuZW51bWVyYWJsZSxcbiAgICAgIHZhbHVlOiBvd25lcltwcm9wXVxuICAgIH07XG4gIH0sXG4gIGRlZmluZVByb3BlcnR5OiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eSgpIHtcbiAgICBkaWUoMTEpO1xuICB9LFxuICBnZXRQcm90b3R5cGVPZjogZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2Yoc3RhdGUpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKHN0YXRlLmJhc2VfKTtcbiAgfSxcbiAgc2V0UHJvdG90eXBlT2Y6IGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKCkge1xuICAgIGRpZSgxMik7XG4gIH1cbn07XG4vKipcclxuICogQXJyYXkgZHJhZnRzXHJcbiAqL1xuXG52YXIgYXJyYXlUcmFwcyA9IHt9O1xuZWFjaChvYmplY3RUcmFwcywgZnVuY3Rpb24gKGtleSwgZm4pIHtcbiAgLy8gQHRzLWlnbm9yZVxuICBhcnJheVRyYXBzW2tleV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgYXJndW1lbnRzWzBdID0gYXJndW1lbnRzWzBdWzBdO1xuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufSk7XG5cbmFycmF5VHJhcHMuZGVsZXRlUHJvcGVydHkgPSBmdW5jdGlvbiAoc3RhdGUsIHByb3ApIHtcbiAgaWYgKCBpc05hTihwYXJzZUludChwcm9wKSkpIGRpZSgxMyk7IC8vIEB0cy1pZ25vcmVcblxuICByZXR1cm4gYXJyYXlUcmFwcy5zZXQuY2FsbCh0aGlzLCBzdGF0ZSwgcHJvcCwgdW5kZWZpbmVkKTtcbn07XG5cbmFycmF5VHJhcHMuc2V0ID0gZnVuY3Rpb24gKHN0YXRlLCBwcm9wLCB2YWx1ZSkge1xuICBpZiAoIHByb3AgIT09IFwibGVuZ3RoXCIgJiYgaXNOYU4ocGFyc2VJbnQocHJvcCkpKSBkaWUoMTQpO1xuICByZXR1cm4gb2JqZWN0VHJhcHMuc2V0LmNhbGwodGhpcywgc3RhdGVbMF0sIHByb3AsIHZhbHVlLCBzdGF0ZVswXSk7XG59OyAvLyBBY2Nlc3MgYSBwcm9wZXJ0eSB3aXRob3V0IGNyZWF0aW5nIGFuIEltbWVyIGRyYWZ0LlxuXG5cbmZ1bmN0aW9uIHBlZWsoZHJhZnQsIHByb3ApIHtcbiAgdmFyIHN0YXRlID0gZHJhZnRbRFJBRlRfU1RBVEVdO1xuICB2YXIgc291cmNlID0gc3RhdGUgPyBsYXRlc3Qoc3RhdGUpIDogZHJhZnQ7XG4gIHJldHVybiBzb3VyY2VbcHJvcF07XG59XG5cbmZ1bmN0aW9uIHJlYWRQcm9wRnJvbVByb3RvKHN0YXRlLCBzb3VyY2UsIHByb3ApIHtcbiAgdmFyIF9kZXNjJGdldDtcblxuICB2YXIgZGVzYyA9IGdldERlc2NyaXB0b3JGcm9tUHJvdG8oc291cmNlLCBwcm9wKTtcbiAgcmV0dXJuIGRlc2MgPyBcInZhbHVlXCIgaW4gZGVzYyA/IGRlc2MudmFsdWUgOiAvLyBUaGlzIGlzIGEgdmVyeSBzcGVjaWFsIGNhc2UsIGlmIHRoZSBwcm9wIGlzIGEgZ2V0dGVyIGRlZmluZWQgYnkgdGhlXG4gIC8vIHByb3RvdHlwZSwgd2Ugc2hvdWxkIGludm9rZSBpdCB3aXRoIHRoZSBkcmFmdCBhcyBjb250ZXh0IVxuICAoX2Rlc2MkZ2V0ID0gZGVzYy5nZXQpID09PSBudWxsIHx8IF9kZXNjJGdldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Rlc2MkZ2V0LmNhbGwoc3RhdGUuZHJhZnRfKSA6IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZ2V0RGVzY3JpcHRvckZyb21Qcm90byhzb3VyY2UsIHByb3ApIHtcbiAgLy8gJ2luJyBjaGVja3MgcHJvdG8hXG4gIGlmICghKHByb3AgaW4gc291cmNlKSkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgdmFyIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHNvdXJjZSk7XG5cbiAgd2hpbGUgKHByb3RvKSB7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3RvLCBwcm9wKTtcbiAgICBpZiAoZGVzYykgcmV0dXJuIGRlc2M7XG4gICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gbWFya0NoYW5nZWQoc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5tb2RpZmllZF8pIHtcbiAgICBzdGF0ZS5tb2RpZmllZF8gPSB0cnVlO1xuXG4gICAgaWYgKHN0YXRlLnBhcmVudF8pIHtcbiAgICAgIG1hcmtDaGFuZ2VkKHN0YXRlLnBhcmVudF8pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcHJlcGFyZUNvcHkoc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5jb3B5Xykge1xuICAgIHN0YXRlLmNvcHlfID0gc2hhbGxvd0NvcHkoc3RhdGUuYmFzZV8pO1xuICB9XG59XG5cbnZhciBJbW1lciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEltbWVyKGNvbmZpZykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLnVzZVByb3hpZXNfID0gaGFzUHJveGllcztcbiAgICB0aGlzLmF1dG9GcmVlemVfID0gdHJ1ZTtcbiAgICAvKipcclxuICAgICAqIFRoZSBgcHJvZHVjZWAgZnVuY3Rpb24gdGFrZXMgYSB2YWx1ZSBhbmQgYSBcInJlY2lwZSBmdW5jdGlvblwiICh3aG9zZVxyXG4gICAgICogcmV0dXJuIHZhbHVlIG9mdGVuIGRlcGVuZHMgb24gdGhlIGJhc2Ugc3RhdGUpLiBUaGUgcmVjaXBlIGZ1bmN0aW9uIGlzXHJcbiAgICAgKiBmcmVlIHRvIG11dGF0ZSBpdHMgZmlyc3QgYXJndW1lbnQgaG93ZXZlciBpdCB3YW50cy4gQWxsIG11dGF0aW9ucyBhcmVcclxuICAgICAqIG9ubHkgZXZlciBhcHBsaWVkIHRvIGEgX19jb3B5X18gb2YgdGhlIGJhc2Ugc3RhdGUuXHJcbiAgICAgKlxyXG4gICAgICogUGFzcyBvbmx5IGEgZnVuY3Rpb24gdG8gY3JlYXRlIGEgXCJjdXJyaWVkIHByb2R1Y2VyXCIgd2hpY2ggcmVsaWV2ZXMgeW91XHJcbiAgICAgKiBmcm9tIHBhc3NpbmcgdGhlIHJlY2lwZSBmdW5jdGlvbiBldmVyeSB0aW1lLlxyXG4gICAgICpcclxuICAgICAqIE9ubHkgcGxhaW4gb2JqZWN0cyBhbmQgYXJyYXlzIGFyZSBtYWRlIG11dGFibGUuIEFsbCBvdGhlciBvYmplY3RzIGFyZVxyXG4gICAgICogY29uc2lkZXJlZCB1bmNvcHlhYmxlLlxyXG4gICAgICpcclxuICAgICAqIE5vdGU6IFRoaXMgZnVuY3Rpb24gaXMgX19ib3VuZF9fIHRvIGl0cyBgSW1tZXJgIGluc3RhbmNlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7YW55fSBiYXNlIC0gdGhlIGluaXRpYWwgc3RhdGVcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByb2R1Y2VyIC0gZnVuY3Rpb24gdGhhdCByZWNlaXZlcyBhIHByb3h5IG9mIHRoZSBiYXNlIHN0YXRlIGFzIGZpcnN0IGFyZ3VtZW50IGFuZCB3aGljaCBjYW4gYmUgZnJlZWx5IG1vZGlmaWVkXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwYXRjaExpc3RlbmVyIC0gb3B0aW9uYWwgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aXRoIGFsbCB0aGUgcGF0Y2hlcyBwcm9kdWNlZCBoZXJlXHJcbiAgICAgKiBAcmV0dXJucyB7YW55fSBhIG5ldyBzdGF0ZSwgb3IgdGhlIGluaXRpYWwgc3RhdGUgaWYgbm90aGluZyB3YXMgbW9kaWZpZWRcclxuICAgICAqL1xuXG4gICAgdGhpcy5wcm9kdWNlID0gZnVuY3Rpb24gKGJhc2UsIHJlY2lwZSwgcGF0Y2hMaXN0ZW5lcikge1xuICAgICAgLy8gY3VycmllZCBpbnZvY2F0aW9uXG4gICAgICBpZiAodHlwZW9mIGJhc2UgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgcmVjaXBlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRCYXNlID0gcmVjaXBlO1xuICAgICAgICByZWNpcGUgPSBiYXNlO1xuICAgICAgICB2YXIgc2VsZiA9IF90aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gY3VycmllZFByb2R1Y2UoYmFzZSkge1xuICAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgICAgaWYgKGJhc2UgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgYmFzZSA9IGRlZmF1bHRCYXNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzZWxmLnByb2R1Y2UoYmFzZSwgZnVuY3Rpb24gKGRyYWZ0KSB7XG4gICAgICAgICAgICB2YXIgX3JlY2lwZTtcblxuICAgICAgICAgICAgcmV0dXJuIChfcmVjaXBlID0gcmVjaXBlKS5jYWxsLmFwcGx5KF9yZWNpcGUsIFtfdGhpczIsIGRyYWZ0XS5jb25jYXQoYXJncykpO1xuICAgICAgICAgIH0pOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiByZWNpcGUgIT09IFwiZnVuY3Rpb25cIikgZGllKDYpO1xuICAgICAgaWYgKHBhdGNoTGlzdGVuZXIgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgcGF0Y2hMaXN0ZW5lciAhPT0gXCJmdW5jdGlvblwiKSBkaWUoNyk7XG4gICAgICB2YXIgcmVzdWx0OyAvLyBPbmx5IHBsYWluIG9iamVjdHMsIGFycmF5cywgYW5kIFwiaW1tZXJhYmxlIGNsYXNzZXNcIiBhcmUgZHJhZnRlZC5cblxuICAgICAgaWYgKGlzRHJhZnRhYmxlKGJhc2UpKSB7XG4gICAgICAgIHZhciBzY29wZSA9IGVudGVyU2NvcGUoX3RoaXMpO1xuICAgICAgICB2YXIgcHJveHkgPSBjcmVhdGVQcm94eShfdGhpcywgYmFzZSwgdW5kZWZpbmVkKTtcbiAgICAgICAgdmFyIGhhc0Vycm9yID0gdHJ1ZTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlc3VsdCA9IHJlY2lwZShwcm94eSk7XG4gICAgICAgICAgaGFzRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAvLyBmaW5hbGx5IGluc3RlYWQgb2YgY2F0Y2ggKyByZXRocm93IGJldHRlciBwcmVzZXJ2ZXMgb3JpZ2luYWwgc3RhY2tcbiAgICAgICAgICBpZiAoaGFzRXJyb3IpIHJldm9rZVNjb3BlKHNjb3BlKTtlbHNlIGxlYXZlU2NvcGUoc2NvcGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBQcm9taXNlICE9PSBcInVuZGVmaW5lZFwiICYmIHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgdXNlUGF0Y2hlc0luU2NvcGUoc2NvcGUsIHBhdGNoTGlzdGVuZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3NSZXN1bHQocmVzdWx0LCBzY29wZSk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICByZXZva2VTY29wZShzY29wZSk7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHVzZVBhdGNoZXNJblNjb3BlKHNjb3BlLCBwYXRjaExpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NSZXN1bHQocmVzdWx0LCBzY29wZSk7XG4gICAgICB9IGVsc2UgaWYgKCFiYXNlIHx8IHR5cGVvZiBiYXNlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlY2lwZShiYXNlKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSByZXN1bHQgPSBiYXNlO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBOT1RISU5HKSByZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChfdGhpcy5hdXRvRnJlZXplXykgZnJlZXplKHJlc3VsdCwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKHBhdGNoTGlzdGVuZXIpIHtcbiAgICAgICAgICB2YXIgcCA9IFtdO1xuICAgICAgICAgIHZhciBpcCA9IFtdO1xuICAgICAgICAgIGdldFBsdWdpbihcIlBhdGNoZXNcIikuZ2VuZXJhdGVSZXBsYWNlbWVudFBhdGNoZXNfKGJhc2UsIHJlc3VsdCwgcCwgaXApO1xuICAgICAgICAgIHBhdGNoTGlzdGVuZXIocCwgaXApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gZWxzZSBkaWUoMjEsIGJhc2UpO1xuICAgIH07XG5cbiAgICB0aGlzLnByb2R1Y2VXaXRoUGF0Y2hlcyA9IGZ1bmN0aW9uIChiYXNlLCByZWNpcGUpIHtcbiAgICAgIC8vIGN1cnJpZWQgaW52b2NhdGlvblxuICAgICAgaWYgKHR5cGVvZiBiYXNlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBfdGhpcy5wcm9kdWNlV2l0aFBhdGNoZXMoc3RhdGUsIGZ1bmN0aW9uIChkcmFmdCkge1xuICAgICAgICAgICAgcmV0dXJuIGJhc2UuYXBwbHkodm9pZCAwLCBbZHJhZnRdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHZhciBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcztcblxuICAgICAgdmFyIHJlc3VsdCA9IF90aGlzLnByb2R1Y2UoYmFzZSwgcmVjaXBlLCBmdW5jdGlvbiAocCwgaXApIHtcbiAgICAgICAgcGF0Y2hlcyA9IHA7XG4gICAgICAgIGludmVyc2VQYXRjaGVzID0gaXA7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHR5cGVvZiBQcm9taXNlICE9PSBcInVuZGVmaW5lZFwiICYmIHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKGZ1bmN0aW9uIChuZXh0U3RhdGUpIHtcbiAgICAgICAgICByZXR1cm4gW25leHRTdGF0ZSwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXNdO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtyZXN1bHQsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzXTtcbiAgICB9O1xuXG4gICAgaWYgKHR5cGVvZiAoY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLnVzZVByb3hpZXMpID09PSBcImJvb2xlYW5cIikgdGhpcy5zZXRVc2VQcm94aWVzKGNvbmZpZy51c2VQcm94aWVzKTtcbiAgICBpZiAodHlwZW9mIChjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcuYXV0b0ZyZWV6ZSkgPT09IFwiYm9vbGVhblwiKSB0aGlzLnNldEF1dG9GcmVlemUoY29uZmlnLmF1dG9GcmVlemUpO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEltbWVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uY3JlYXRlRHJhZnQgPSBmdW5jdGlvbiBjcmVhdGVEcmFmdChiYXNlKSB7XG4gICAgaWYgKCFpc0RyYWZ0YWJsZShiYXNlKSkgZGllKDgpO1xuICAgIGlmIChpc0RyYWZ0KGJhc2UpKSBiYXNlID0gY3VycmVudChiYXNlKTtcbiAgICB2YXIgc2NvcGUgPSBlbnRlclNjb3BlKHRoaXMpO1xuICAgIHZhciBwcm94eSA9IGNyZWF0ZVByb3h5KHRoaXMsIGJhc2UsIHVuZGVmaW5lZCk7XG4gICAgcHJveHlbRFJBRlRfU1RBVEVdLmlzTWFudWFsXyA9IHRydWU7XG4gICAgbGVhdmVTY29wZShzY29wZSk7XG4gICAgcmV0dXJuIHByb3h5O1xuICB9O1xuXG4gIF9wcm90by5maW5pc2hEcmFmdCA9IGZ1bmN0aW9uIGZpbmlzaERyYWZ0KGRyYWZ0LCBwYXRjaExpc3RlbmVyKSB7XG4gICAgdmFyIHN0YXRlID0gZHJhZnQgJiYgZHJhZnRbRFJBRlRfU1RBVEVdO1xuXG4gICAge1xuICAgICAgaWYgKCFzdGF0ZSB8fCAhc3RhdGUuaXNNYW51YWxfKSBkaWUoOSk7XG4gICAgICBpZiAoc3RhdGUuZmluYWxpemVkXykgZGllKDEwKTtcbiAgICB9XG5cbiAgICB2YXIgc2NvcGUgPSBzdGF0ZS5zY29wZV87XG4gICAgdXNlUGF0Y2hlc0luU2NvcGUoc2NvcGUsIHBhdGNoTGlzdGVuZXIpO1xuICAgIHJldHVybiBwcm9jZXNzUmVzdWx0KHVuZGVmaW5lZCwgc2NvcGUpO1xuICB9XG4gIC8qKlxyXG4gICAqIFBhc3MgdHJ1ZSB0byBhdXRvbWF0aWNhbGx5IGZyZWV6ZSBhbGwgY29waWVzIGNyZWF0ZWQgYnkgSW1tZXIuXHJcbiAgICpcclxuICAgKiBCeSBkZWZhdWx0LCBhdXRvLWZyZWV6aW5nIGlzIGVuYWJsZWQuXHJcbiAgICovXG4gIDtcblxuICBfcHJvdG8uc2V0QXV0b0ZyZWV6ZSA9IGZ1bmN0aW9uIHNldEF1dG9GcmVlemUodmFsdWUpIHtcbiAgICB0aGlzLmF1dG9GcmVlemVfID0gdmFsdWU7XG4gIH1cbiAgLyoqXHJcbiAgICogUGFzcyB0cnVlIHRvIHVzZSB0aGUgRVMyMDE1IGBQcm94eWAgY2xhc3Mgd2hlbiBjcmVhdGluZyBkcmFmdHMsIHdoaWNoIGlzXHJcbiAgICogYWx3YXlzIGZhc3RlciB0aGFuIHVzaW5nIEVTNSBwcm94aWVzLlxyXG4gICAqXHJcbiAgICogQnkgZGVmYXVsdCwgZmVhdHVyZSBkZXRlY3Rpb24gaXMgdXNlZCwgc28gY2FsbGluZyB0aGlzIGlzIHJhcmVseSBuZWNlc3NhcnkuXHJcbiAgICovXG4gIDtcblxuICBfcHJvdG8uc2V0VXNlUHJveGllcyA9IGZ1bmN0aW9uIHNldFVzZVByb3hpZXModmFsdWUpIHtcbiAgICBpZiAodmFsdWUgJiYgIWhhc1Byb3hpZXMpIHtcbiAgICAgIGRpZSgyMCk7XG4gICAgfVxuXG4gICAgdGhpcy51c2VQcm94aWVzXyA9IHZhbHVlO1xuICB9O1xuXG4gIF9wcm90by5hcHBseVBhdGNoZXMgPSBmdW5jdGlvbiBhcHBseVBhdGNoZXMoYmFzZSwgcGF0Y2hlcykge1xuICAgIC8vIElmIGEgcGF0Y2ggcmVwbGFjZXMgdGhlIGVudGlyZSBzdGF0ZSwgdGFrZSB0aGF0IHJlcGxhY2VtZW50IGFzIGJhc2VcbiAgICAvLyBiZWZvcmUgYXBwbHlpbmcgcGF0Y2hlc1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gcGF0Y2hlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIHBhdGNoID0gcGF0Y2hlc1tpXTtcblxuICAgICAgaWYgKHBhdGNoLnBhdGgubGVuZ3RoID09PSAwICYmIHBhdGNoLm9wID09PSBcInJlcGxhY2VcIikge1xuICAgICAgICBiYXNlID0gcGF0Y2gudmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gLy8gSWYgdGhlcmUgd2FzIGEgcGF0Y2ggdGhhdCByZXBsYWNlZCB0aGUgZW50aXJlIHN0YXRlLCBzdGFydCBmcm9tIHRoZVxuICAgIC8vIHBhdGNoIGFmdGVyIHRoYXQuXG5cblxuICAgIGlmIChpID4gLTEpIHtcbiAgICAgIHBhdGNoZXMgPSBwYXRjaGVzLnNsaWNlKGkgKyAxKTtcbiAgICB9XG5cbiAgICB2YXIgYXBwbHlQYXRjaGVzSW1wbCA9IGdldFBsdWdpbihcIlBhdGNoZXNcIikuYXBwbHlQYXRjaGVzXztcblxuICAgIGlmIChpc0RyYWZ0KGJhc2UpKSB7XG4gICAgICAvLyBOLkI6IG5ldmVyIGhpdHMgaWYgc29tZSBwYXRjaCBhIHJlcGxhY2VtZW50LCBwYXRjaGVzIGFyZSBuZXZlciBkcmFmdHNcbiAgICAgIHJldHVybiBhcHBseVBhdGNoZXNJbXBsKGJhc2UsIHBhdGNoZXMpO1xuICAgIH0gLy8gT3RoZXJ3aXNlLCBwcm9kdWNlIGEgY29weSBvZiB0aGUgYmFzZSBzdGF0ZS5cblxuXG4gICAgcmV0dXJuIHRoaXMucHJvZHVjZShiYXNlLCBmdW5jdGlvbiAoZHJhZnQpIHtcbiAgICAgIHJldHVybiBhcHBseVBhdGNoZXNJbXBsKGRyYWZ0LCBwYXRjaGVzKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gSW1tZXI7XG59KCk7XG5mdW5jdGlvbiBjcmVhdGVQcm94eShpbW1lciwgdmFsdWUsIHBhcmVudCkge1xuICAvLyBwcmVjb25kaXRpb246IGNyZWF0ZVByb3h5IHNob3VsZCBiZSBndWFyZGVkIGJ5IGlzRHJhZnRhYmxlLCBzbyB3ZSBrbm93IHdlIGNhbiBzYWZlbHkgZHJhZnRcbiAgdmFyIGRyYWZ0ID0gaXNNYXAodmFsdWUpID8gZ2V0UGx1Z2luKFwiTWFwU2V0XCIpLnByb3h5TWFwXyh2YWx1ZSwgcGFyZW50KSA6IGlzU2V0KHZhbHVlKSA/IGdldFBsdWdpbihcIk1hcFNldFwiKS5wcm94eVNldF8odmFsdWUsIHBhcmVudCkgOiBpbW1lci51c2VQcm94aWVzXyA/IGNyZWF0ZVByb3h5UHJveHkodmFsdWUsIHBhcmVudCkgOiBnZXRQbHVnaW4oXCJFUzVcIikuY3JlYXRlRVM1UHJveHlfKHZhbHVlLCBwYXJlbnQpO1xuICB2YXIgc2NvcGUgPSBwYXJlbnQgPyBwYXJlbnQuc2NvcGVfIDogZ2V0Q3VycmVudFNjb3BlKCk7XG4gIHNjb3BlLmRyYWZ0c18ucHVzaChkcmFmdCk7XG4gIHJldHVybiBkcmFmdDtcbn1cblxuZnVuY3Rpb24gY3VycmVudCh2YWx1ZSkge1xuICBpZiAoIWlzRHJhZnQodmFsdWUpKSBkaWUoMjIsIHZhbHVlKTtcbiAgcmV0dXJuIGN1cnJlbnRJbXBsKHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gY3VycmVudEltcGwodmFsdWUpIHtcbiAgaWYgKCFpc0RyYWZ0YWJsZSh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgdmFyIHN0YXRlID0gdmFsdWVbRFJBRlRfU1RBVEVdO1xuICB2YXIgY29weTtcbiAgdmFyIGFyY2hUeXBlID0gZ2V0QXJjaHR5cGUodmFsdWUpO1xuXG4gIGlmIChzdGF0ZSkge1xuICAgIGlmICghc3RhdGUubW9kaWZpZWRfICYmIChzdGF0ZS50eXBlXyA8IDQgfHwgIWdldFBsdWdpbihcIkVTNVwiKS5oYXNDaGFuZ2VzXyhzdGF0ZSkpKSByZXR1cm4gc3RhdGUuYmFzZV87IC8vIE9wdGltaXphdGlvbjogYXZvaWQgZ2VuZXJhdGluZyBuZXcgZHJhZnRzIGR1cmluZyBjb3B5aW5nXG5cbiAgICBzdGF0ZS5maW5hbGl6ZWRfID0gdHJ1ZTtcbiAgICBjb3B5ID0gY29weUhlbHBlcih2YWx1ZSwgYXJjaFR5cGUpO1xuICAgIHN0YXRlLmZpbmFsaXplZF8gPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICBjb3B5ID0gY29weUhlbHBlcih2YWx1ZSwgYXJjaFR5cGUpO1xuICB9XG5cbiAgZWFjaChjb3B5LCBmdW5jdGlvbiAoa2V5LCBjaGlsZFZhbHVlKSB7XG4gICAgaWYgKHN0YXRlICYmIGdldChzdGF0ZS5iYXNlXywga2V5KSA9PT0gY2hpbGRWYWx1ZSkgcmV0dXJuOyAvLyBubyBuZWVkIHRvIGNvcHkgb3Igc2VhcmNoIGluIHNvbWV0aGluZyB0aGF0IGRpZG4ndCBjaGFuZ2VcblxuICAgIHNldChjb3B5LCBrZXksIGN1cnJlbnRJbXBsKGNoaWxkVmFsdWUpKTtcbiAgfSk7IC8vIEluIHRoZSBmdXR1cmUsIHdlIG1pZ2h0IGNvbnNpZGVyIGZyZWV6aW5nIGhlcmUsIGJhc2VkIG9uIHRoZSBjdXJyZW50IHNldHRpbmdzXG5cbiAgcmV0dXJuIGFyY2hUeXBlID09PSAzXG4gIC8qIFNldCAqL1xuICA/IG5ldyBTZXQoY29weSkgOiBjb3B5O1xufVxuXG5mdW5jdGlvbiBjb3B5SGVscGVyKHZhbHVlLCBhcmNoVHlwZSkge1xuICAvLyBjcmVhdGVzIGEgc2hhbGxvdyBjb3B5LCBldmVuIGlmIGl0IGlzIGEgbWFwIG9yIHNldFxuICBzd2l0Y2ggKGFyY2hUeXBlKSB7XG4gICAgY2FzZSAyXG4gICAgLyogTWFwICovXG4gICAgOlxuICAgICAgcmV0dXJuIG5ldyBNYXAodmFsdWUpO1xuXG4gICAgY2FzZSAzXG4gICAgLyogU2V0ICovXG4gICAgOlxuICAgICAgLy8gU2V0IHdpbGwgYmUgY2xvbmVkIGFzIGFycmF5IHRlbXBvcmFyaWx5LCBzbyB0aGF0IHdlIGNhbiByZXBsYWNlIGluZGl2aWR1YWwgaXRlbXNcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiBzaGFsbG93Q29weSh2YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIGVuYWJsZUVTNSgpIHtcbiAgZnVuY3Rpb24gd2lsbEZpbmFsaXplRVM1XyhzY29wZSwgcmVzdWx0LCBpc1JlcGxhY2VkKSB7XG4gICAgaWYgKCFpc1JlcGxhY2VkKSB7XG4gICAgICBpZiAoc2NvcGUucGF0Y2hlc18pIHtcbiAgICAgICAgbWFya0NoYW5nZXNSZWN1cnNpdmVseShzY29wZS5kcmFmdHNfWzBdKTtcbiAgICAgIH0gLy8gVGhpcyBpcyBmYXN0ZXIgd2hlbiB3ZSBkb24ndCBjYXJlIGFib3V0IHdoaWNoIGF0dHJpYnV0ZXMgY2hhbmdlZC5cblxuXG4gICAgICBtYXJrQ2hhbmdlc1N3ZWVwKHNjb3BlLmRyYWZ0c18pO1xuICAgIH0gLy8gV2hlbiBhIGNoaWxkIGRyYWZ0IGlzIHJldHVybmVkLCBsb29rIGZvciBjaGFuZ2VzLlxuICAgIGVsc2UgaWYgKGlzRHJhZnQocmVzdWx0KSAmJiByZXN1bHRbRFJBRlRfU1RBVEVdLnNjb3BlXyA9PT0gc2NvcGUpIHtcbiAgICAgICAgbWFya0NoYW5nZXNTd2VlcChzY29wZS5kcmFmdHNfKTtcbiAgICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVTNURyYWZ0KGlzQXJyYXksIGJhc2UpIHtcbiAgICBpZiAoaXNBcnJheSkge1xuICAgICAgdmFyIGRyYWZ0ID0gbmV3IEFycmF5KGJhc2UubGVuZ3RoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYXNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkcmFmdCwgXCJcIiArIGksIHByb3h5UHJvcGVydHkoaSwgdHJ1ZSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZHJhZnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfZGVzY3JpcHRvcnMgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKGJhc2UpO1xuXG4gICAgICBkZWxldGUgX2Rlc2NyaXB0b3JzW0RSQUZUX1NUQVRFXTtcbiAgICAgIHZhciBrZXlzID0gb3duS2V5cyhfZGVzY3JpcHRvcnMpO1xuXG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwga2V5cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbX2ldO1xuICAgICAgICBfZGVzY3JpcHRvcnNba2V5XSA9IHByb3h5UHJvcGVydHkoa2V5LCBpc0FycmF5IHx8ICEhX2Rlc2NyaXB0b3JzW2tleV0uZW51bWVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihiYXNlKSwgX2Rlc2NyaXB0b3JzKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFUzVQcm94eV8oYmFzZSwgcGFyZW50KSB7XG4gICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KGJhc2UpO1xuICAgIHZhciBkcmFmdCA9IGNyZWF0ZUVTNURyYWZ0KGlzQXJyYXksIGJhc2UpO1xuICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgIHR5cGVfOiBpc0FycmF5ID8gNVxuICAgICAgLyogRVM1QXJyYXkgKi9cbiAgICAgIDogNFxuICAgICAgLyogRVM1T2JqZWN0ICovXG4gICAgICAsXG4gICAgICBzY29wZV86IHBhcmVudCA/IHBhcmVudC5zY29wZV8gOiBnZXRDdXJyZW50U2NvcGUoKSxcbiAgICAgIG1vZGlmaWVkXzogZmFsc2UsXG4gICAgICBmaW5hbGl6ZWRfOiBmYWxzZSxcbiAgICAgIGFzc2lnbmVkXzoge30sXG4gICAgICBwYXJlbnRfOiBwYXJlbnQsXG4gICAgICAvLyBiYXNlIGlzIHRoZSBvYmplY3Qgd2UgYXJlIGRyYWZ0aW5nXG4gICAgICBiYXNlXzogYmFzZSxcbiAgICAgIC8vIGRyYWZ0IGlzIHRoZSBkcmFmdCBvYmplY3QgaXRzZWxmLCB0aGF0IHRyYXBzIGFsbCByZWFkcyBhbmQgcmVhZHMgZnJvbSBlaXRoZXIgdGhlIGJhc2UgKGlmIHVubW9kaWZpZWQpIG9yIGNvcHkgKGlmIG1vZGlmaWVkKVxuICAgICAgZHJhZnRfOiBkcmFmdCxcbiAgICAgIGNvcHlfOiBudWxsLFxuICAgICAgcmV2b2tlZF86IGZhbHNlLFxuICAgICAgaXNNYW51YWxfOiBmYWxzZVxuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRyYWZ0LCBEUkFGVF9TVEFURSwge1xuICAgICAgdmFsdWU6IHN0YXRlLFxuICAgICAgLy8gZW51bWVyYWJsZTogZmFsc2UgPC0gdGhlIGRlZmF1bHRcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIGRyYWZ0O1xuICB9IC8vIHByb3BlcnR5IGRlc2NyaXB0b3JzIGFyZSByZWN5Y2xlZCB0byBtYWtlIHN1cmUgd2UgZG9uJ3QgY3JlYXRlIGEgZ2V0IGFuZCBzZXQgY2xvc3VyZSBwZXIgcHJvcGVydHksXG4gIC8vIGJ1dCBzaGFyZSB0aGVtIGFsbCBpbnN0ZWFkXG5cblxuICB2YXIgZGVzY3JpcHRvcnMgPSB7fTtcblxuICBmdW5jdGlvbiBwcm94eVByb3BlcnR5KHByb3AsIGVudW1lcmFibGUpIHtcbiAgICB2YXIgZGVzYyA9IGRlc2NyaXB0b3JzW3Byb3BdO1xuXG4gICAgaWYgKGRlc2MpIHtcbiAgICAgIGRlc2MuZW51bWVyYWJsZSA9IGVudW1lcmFibGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlc2NyaXB0b3JzW3Byb3BdID0gZGVzYyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiBlbnVtZXJhYmxlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICB2YXIgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpOyAvLyBAdHMtaWdub3JlXG5cbiAgICAgICAgICByZXR1cm4gb2JqZWN0VHJhcHMuZ2V0KHN0YXRlLCBwcm9wKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICB2YXIgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpOyAvLyBAdHMtaWdub3JlXG5cbiAgICAgICAgICBvYmplY3RUcmFwcy5zZXQoc3RhdGUsIHByb3AsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVzYztcbiAgfSAvLyBUaGlzIGxvb2tzIGV4cGVuc2l2ZSwgYnV0IG9ubHkgcHJveGllcyBhcmUgdmlzaXRlZCwgYW5kIG9ubHkgb2JqZWN0cyB3aXRob3V0IGtub3duIGNoYW5nZXMgYXJlIHNjYW5uZWQuXG5cblxuICBmdW5jdGlvbiBtYXJrQ2hhbmdlc1N3ZWVwKGRyYWZ0cykge1xuICAgIC8vIFRoZSBuYXR1cmFsIG9yZGVyIG9mIGRyYWZ0cyBpbiB0aGUgYHNjb3BlYCBhcnJheSBpcyBiYXNlZCBvbiB3aGVuIHRoZXlcbiAgICAvLyB3ZXJlIGFjY2Vzc2VkLiBCeSBwcm9jZXNzaW5nIGRyYWZ0cyBpbiByZXZlcnNlIG5hdHVyYWwgb3JkZXIsIHdlIGhhdmUgYVxuICAgIC8vIGJldHRlciBjaGFuY2Ugb2YgcHJvY2Vzc2luZyBsZWFmIG5vZGVzIGZpcnN0LiBXaGVuIGEgbGVhZiBub2RlIGlzIGtub3duIHRvXG4gICAgLy8gaGF2ZSBjaGFuZ2VkLCB3ZSBjYW4gYXZvaWQgYW55IHRyYXZlcnNhbCBvZiBpdHMgYW5jZXN0b3Igbm9kZXMuXG4gICAgZm9yICh2YXIgaSA9IGRyYWZ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIHN0YXRlID0gZHJhZnRzW2ldW0RSQUZUX1NUQVRFXTtcblxuICAgICAgaWYgKCFzdGF0ZS5tb2RpZmllZF8pIHtcbiAgICAgICAgc3dpdGNoIChzdGF0ZS50eXBlXykge1xuICAgICAgICAgIGNhc2UgNVxuICAgICAgICAgIC8qIEVTNUFycmF5ICovXG4gICAgICAgICAgOlxuICAgICAgICAgICAgaWYgKGhhc0FycmF5Q2hhbmdlcyhzdGF0ZSkpIG1hcmtDaGFuZ2VkKHN0YXRlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSA0XG4gICAgICAgICAgLyogRVM1T2JqZWN0ICovXG4gICAgICAgICAgOlxuICAgICAgICAgICAgaWYgKGhhc09iamVjdENoYW5nZXMoc3RhdGUpKSBtYXJrQ2hhbmdlZChzdGF0ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtDaGFuZ2VzUmVjdXJzaXZlbHkob2JqZWN0KSB7XG4gICAgaWYgKCFvYmplY3QgfHwgdHlwZW9mIG9iamVjdCAhPT0gXCJvYmplY3RcIikgcmV0dXJuO1xuICAgIHZhciBzdGF0ZSA9IG9iamVjdFtEUkFGVF9TVEFURV07XG4gICAgaWYgKCFzdGF0ZSkgcmV0dXJuO1xuICAgIHZhciBiYXNlXyA9IHN0YXRlLmJhc2VfLFxuICAgICAgICBkcmFmdF8gPSBzdGF0ZS5kcmFmdF8sXG4gICAgICAgIGFzc2lnbmVkXyA9IHN0YXRlLmFzc2lnbmVkXyxcbiAgICAgICAgdHlwZV8gPSBzdGF0ZS50eXBlXztcblxuICAgIGlmICh0eXBlXyA9PT0gNFxuICAgIC8qIEVTNU9iamVjdCAqL1xuICAgICkge1xuICAgICAgICAvLyBMb29rIGZvciBhZGRlZCBrZXlzLlxuICAgICAgICAvLyBwcm9iYWJseSB0aGVyZSBpcyBhIGZhc3RlciB3YXkgdG8gZGV0ZWN0IGNoYW5nZXMsIGFzIHN3ZWVwICsgcmVjdXJzZSBzZWVtcyB0byBkbyBzb21lXG4gICAgICAgIC8vIHVubmVjZXNzYXJ5IHdvcmsuXG4gICAgICAgIC8vIGFsc286IHByb2JhYmx5IHdlIGNhbiBzdG9yZSB0aGUgaW5mb3JtYXRpb24gd2UgZGV0ZWN0IGhlcmUsIHRvIHNwZWVkIHVwIHRyZWUgZmluYWxpemF0aW9uIVxuICAgICAgICBlYWNoKGRyYWZ0XywgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIGlmIChrZXkgPT09IERSQUZUX1NUQVRFKSByZXR1cm47IC8vIFRoZSBgdW5kZWZpbmVkYCBjaGVjayBpcyBhIGZhc3QgcGF0aCBmb3IgcHJlLWV4aXN0aW5nIGtleXMuXG5cbiAgICAgICAgICBpZiAoYmFzZV9ba2V5XSA9PT0gdW5kZWZpbmVkICYmICFoYXMoYmFzZV8sIGtleSkpIHtcbiAgICAgICAgICAgIGFzc2lnbmVkX1trZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIG1hcmtDaGFuZ2VkKHN0YXRlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFhc3NpZ25lZF9ba2V5XSkge1xuICAgICAgICAgICAgLy8gT25seSB1bnRvdWNoZWQgcHJvcGVydGllcyB0cmlnZ2VyIHJlY3Vyc2lvbi5cbiAgICAgICAgICAgIG1hcmtDaGFuZ2VzUmVjdXJzaXZlbHkoZHJhZnRfW2tleV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7IC8vIExvb2sgZm9yIHJlbW92ZWQga2V5cy5cblxuICAgICAgICBlYWNoKGJhc2VfLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgLy8gVGhlIGB1bmRlZmluZWRgIGNoZWNrIGlzIGEgZmFzdCBwYXRoIGZvciBwcmUtZXhpc3Rpbmcga2V5cy5cbiAgICAgICAgICBpZiAoZHJhZnRfW2tleV0gPT09IHVuZGVmaW5lZCAmJiAhaGFzKGRyYWZ0Xywga2V5KSkge1xuICAgICAgICAgICAgYXNzaWduZWRfW2tleV0gPSBmYWxzZTtcbiAgICAgICAgICAgIG1hcmtDaGFuZ2VkKHN0YXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICh0eXBlXyA9PT0gNVxuICAgIC8qIEVTNUFycmF5ICovXG4gICAgKSB7XG4gICAgICAgIGlmIChoYXNBcnJheUNoYW5nZXMoc3RhdGUpKSB7XG4gICAgICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgICAgICAgIGFzc2lnbmVkXy5sZW5ndGggPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRyYWZ0Xy5sZW5ndGggPCBiYXNlXy5sZW5ndGgpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gZHJhZnRfLmxlbmd0aDsgaSA8IGJhc2VfLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhc3NpZ25lZF9baV0gPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yICh2YXIgX2kyID0gYmFzZV8ubGVuZ3RoOyBfaTIgPCBkcmFmdF8ubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgICAgYXNzaWduZWRfW19pMl0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBNaW5pbXVtIGNvdW50IGlzIGVub3VnaCwgdGhlIG90aGVyIHBhcnRzIGhhcyBiZWVuIHByb2Nlc3NlZC5cblxuXG4gICAgICAgIHZhciBtaW4gPSBNYXRoLm1pbihkcmFmdF8ubGVuZ3RoLCBiYXNlXy5sZW5ndGgpO1xuXG4gICAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IG1pbjsgX2kzKyspIHtcbiAgICAgICAgICAvLyBPbmx5IHVudG91Y2hlZCBpbmRpY2VzIHRyaWdnZXIgcmVjdXJzaW9uLlxuICAgICAgICAgIGlmICghZHJhZnRfLmhhc093blByb3BlcnR5KF9pMykpIHtcbiAgICAgICAgICAgIGFzc2lnbmVkX1tfaTNdID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYXNzaWduZWRfW19pM10gPT09IHVuZGVmaW5lZCkgbWFya0NoYW5nZXNSZWN1cnNpdmVseShkcmFmdF9bX2kzXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc09iamVjdENoYW5nZXMoc3RhdGUpIHtcbiAgICB2YXIgYmFzZV8gPSBzdGF0ZS5iYXNlXyxcbiAgICAgICAgZHJhZnRfID0gc3RhdGUuZHJhZnRfOyAvLyBTZWFyY2ggZm9yIGFkZGVkIGtleXMgYW5kIGNoYW5nZWQga2V5cy4gU3RhcnQgYXQgdGhlIGJhY2ssIGJlY2F1c2VcbiAgICAvLyBub24tbnVtZXJpYyBrZXlzIGFyZSBvcmRlcmVkIGJ5IHRpbWUgb2YgZGVmaW5pdGlvbiBvbiB0aGUgb2JqZWN0LlxuXG4gICAgdmFyIGtleXMgPSBvd25LZXlzKGRyYWZ0Xyk7XG5cbiAgICBmb3IgKHZhciBpID0ga2V5cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICBpZiAoa2V5ID09PSBEUkFGVF9TVEFURSkgY29udGludWU7XG4gICAgICB2YXIgYmFzZVZhbHVlID0gYmFzZV9ba2V5XTsgLy8gVGhlIGB1bmRlZmluZWRgIGNoZWNrIGlzIGEgZmFzdCBwYXRoIGZvciBwcmUtZXhpc3Rpbmcga2V5cy5cblxuICAgICAgaWYgKGJhc2VWYWx1ZSA9PT0gdW5kZWZpbmVkICYmICFoYXMoYmFzZV8sIGtleSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IC8vIE9uY2UgYSBiYXNlIGtleSBpcyBkZWxldGVkLCBmdXR1cmUgY2hhbmdlcyBnbyB1bmRldGVjdGVkLCBiZWNhdXNlIGl0c1xuICAgICAgLy8gZGVzY3JpcHRvciBpcyBlcmFzZWQuIFRoaXMgYnJhbmNoIGRldGVjdHMgYW55IG1pc3NlZCBjaGFuZ2VzLlxuICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gZHJhZnRfW2tleV07XG5cbiAgICAgICAgICB2YXIgX3N0YXRlID0gdmFsdWUgJiYgdmFsdWVbRFJBRlRfU1RBVEVdO1xuXG4gICAgICAgICAgaWYgKF9zdGF0ZSA/IF9zdGF0ZS5iYXNlXyAhPT0gYmFzZVZhbHVlIDogIWlzKHZhbHVlLCBiYXNlVmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IC8vIEF0IHRoaXMgcG9pbnQsIG5vIGtleXMgd2VyZSBhZGRlZCBvciBjaGFuZ2VkLlxuICAgIC8vIENvbXBhcmUga2V5IGNvdW50IHRvIGRldGVybWluZSBpZiBrZXlzIHdlcmUgZGVsZXRlZC5cblxuXG4gICAgdmFyIGJhc2VJc0RyYWZ0ID0gISFiYXNlX1tEUkFGVF9TVEFURV07XG4gICAgcmV0dXJuIGtleXMubGVuZ3RoICE9PSBvd25LZXlzKGJhc2VfKS5sZW5ndGggKyAoYmFzZUlzRHJhZnQgPyAwIDogMSk7IC8vICsgMSB0byBjb3JyZWN0IGZvciBEUkFGVF9TVEFURVxuICB9XG5cbiAgZnVuY3Rpb24gaGFzQXJyYXlDaGFuZ2VzKHN0YXRlKSB7XG4gICAgdmFyIGRyYWZ0XyA9IHN0YXRlLmRyYWZ0XztcbiAgICBpZiAoZHJhZnRfLmxlbmd0aCAhPT0gc3RhdGUuYmFzZV8ubGVuZ3RoKSByZXR1cm4gdHJ1ZTsgLy8gU2VlICMxMTZcbiAgICAvLyBJZiB3ZSBmaXJzdCBzaG9ydGVuIHRoZSBsZW5ndGgsIG91ciBhcnJheSBpbnRlcmNlcHRvcnMgd2lsbCBiZSByZW1vdmVkLlxuICAgIC8vIElmIGFmdGVyIHRoYXQgbmV3IGl0ZW1zIGFyZSBhZGRlZCwgcmVzdWx0IGluIHRoZSBzYW1lIG9yaWdpbmFsIGxlbmd0aCxcbiAgICAvLyB0aG9zZSBsYXN0IGl0ZW1zIHdpbGwgaGF2ZSBubyBpbnRlcmNlcHRpbmcgcHJvcGVydHkuXG4gICAgLy8gU28gaWYgdGhlcmUgaXMgbm8gb3duIGRlc2NyaXB0b3Igb24gdGhlIGxhc3QgcG9zaXRpb24sIHdlIGtub3cgdGhhdCBpdGVtcyB3ZXJlIHJlbW92ZWQgYW5kIGFkZGVkXG4gICAgLy8gTi5CLjogc3BsaWNlLCB1bnNoaWZ0LCBldGMgb25seSBzaGlmdCB2YWx1ZXMgYXJvdW5kLCBidXQgbm90IHByb3AgZGVzY3JpcHRvcnMsIHNvIHdlIG9ubHkgaGF2ZSB0byBjaGVja1xuICAgIC8vIHRoZSBsYXN0IG9uZVxuICAgIC8vIGxhc3QgZGVzY3JpcHRvciBjYW4gYmUgbm90IGEgdHJhcCwgaWYgdGhlIGFycmF5IHdhcyBleHRlbmRlZFxuXG4gICAgdmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGRyYWZ0XywgZHJhZnRfLmxlbmd0aCAtIDEpOyAvLyBkZXNjcmlwdG9yIGNhbiBiZSBudWxsLCBidXQgb25seSBmb3IgbmV3bHkgY3JlYXRlZCBzcGFyc2UgYXJyYXlzLCBlZy4gbmV3IEFycmF5KDEwKVxuXG4gICAgaWYgKGRlc2NyaXB0b3IgJiYgIWRlc2NyaXB0b3IuZ2V0KSByZXR1cm4gdHJ1ZTsgLy8gaWYgd2UgbWlzcyBhIHByb3BlcnR5LCBpdCBoYXMgYmVlbiBkZWxldGVkLCBzbyBhcnJheSBwcm9ib2JhbHkgY2hhbmdlZFxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkcmFmdF8ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghZHJhZnRfLmhhc093blByb3BlcnR5KGkpKSByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIEZvciBhbGwgb3RoZXIgY2FzZXMsIHdlIGRvbid0IGhhdmUgdG8gY29tcGFyZSwgYXMgdGhleSB3b3VsZCBoYXZlIGJlZW4gcGlja2VkIHVwIGJ5IHRoZSBpbmRleCBzZXR0ZXJzXG5cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc0NoYW5nZXNfKHN0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlLnR5cGVfID09PSA0XG4gICAgLyogRVM1T2JqZWN0ICovXG4gICAgPyBoYXNPYmplY3RDaGFuZ2VzKHN0YXRlKSA6IGhhc0FycmF5Q2hhbmdlcyhzdGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnRVbnJldm9rZWQoc3RhdGVcbiAgLypFUzVTdGF0ZSB8IE1hcFN0YXRlIHwgU2V0U3RhdGUqL1xuICApIHtcbiAgICBpZiAoc3RhdGUucmV2b2tlZF8pIGRpZSgzLCBKU09OLnN0cmluZ2lmeShsYXRlc3Qoc3RhdGUpKSk7XG4gIH1cblxuICBsb2FkUGx1Z2luKFwiRVM1XCIsIHtcbiAgICBjcmVhdGVFUzVQcm94eV86IGNyZWF0ZUVTNVByb3h5XyxcbiAgICB3aWxsRmluYWxpemVFUzVfOiB3aWxsRmluYWxpemVFUzVfLFxuICAgIGhhc0NoYW5nZXNfOiBoYXNDaGFuZ2VzX1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZW5hYmxlUGF0Y2hlcygpIHtcbiAgdmFyIFJFUExBQ0UgPSBcInJlcGxhY2VcIjtcbiAgdmFyIEFERCA9IFwiYWRkXCI7XG4gIHZhciBSRU1PVkUgPSBcInJlbW92ZVwiO1xuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlUGF0Y2hlc18oc3RhdGUsIGJhc2VQYXRoLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcykge1xuICAgIHN3aXRjaCAoc3RhdGUudHlwZV8pIHtcbiAgICAgIGNhc2UgMFxuICAgICAgLyogUHJveHlPYmplY3QgKi9cbiAgICAgIDpcbiAgICAgIGNhc2UgNFxuICAgICAgLyogRVM1T2JqZWN0ICovXG4gICAgICA6XG4gICAgICBjYXNlIDJcbiAgICAgIC8qIE1hcCAqL1xuICAgICAgOlxuICAgICAgICByZXR1cm4gZ2VuZXJhdGVQYXRjaGVzRnJvbUFzc2lnbmVkKHN0YXRlLCBiYXNlUGF0aCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpO1xuXG4gICAgICBjYXNlIDVcbiAgICAgIC8qIEVTNUFycmF5ICovXG4gICAgICA6XG4gICAgICBjYXNlIDFcbiAgICAgIC8qIFByb3h5QXJyYXkgKi9cbiAgICAgIDpcbiAgICAgICAgcmV0dXJuIGdlbmVyYXRlQXJyYXlQYXRjaGVzKHN0YXRlLCBiYXNlUGF0aCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpO1xuXG4gICAgICBjYXNlIDNcbiAgICAgIC8qIFNldCAqL1xuICAgICAgOlxuICAgICAgICByZXR1cm4gZ2VuZXJhdGVTZXRQYXRjaGVzKHN0YXRlLCBiYXNlUGF0aCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlQXJyYXlQYXRjaGVzKHN0YXRlLCBiYXNlUGF0aCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpIHtcbiAgICB2YXIgYmFzZV8gPSBzdGF0ZS5iYXNlXyxcbiAgICAgICAgYXNzaWduZWRfID0gc3RhdGUuYXNzaWduZWRfO1xuICAgIHZhciBjb3B5XyA9IHN0YXRlLmNvcHlfOyAvLyBSZWR1Y2UgY29tcGxleGl0eSBieSBlbnN1cmluZyBgYmFzZWAgaXMgbmV2ZXIgbG9uZ2VyLlxuXG4gICAgaWYgKGNvcHlfLmxlbmd0aCA8IGJhc2VfLmxlbmd0aCkge1xuICAgICAgdmFyIF9yZWYgPSBbY29weV8sIGJhc2VfXTtcbiAgICAgIGJhc2VfID0gX3JlZlswXTtcbiAgICAgIGNvcHlfID0gX3JlZlsxXTtcbiAgICAgIHZhciBfcmVmMiA9IFtpbnZlcnNlUGF0Y2hlcywgcGF0Y2hlc107XG4gICAgICBwYXRjaGVzID0gX3JlZjJbMF07XG4gICAgICBpbnZlcnNlUGF0Y2hlcyA9IF9yZWYyWzFdO1xuICAgIH0gLy8gUHJvY2VzcyByZXBsYWNlZCBpbmRpY2VzLlxuXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhc2VfLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYXNzaWduZWRfW2ldICYmIGNvcHlfW2ldICE9PSBiYXNlX1tpXSkge1xuICAgICAgICB2YXIgcGF0aCA9IGJhc2VQYXRoLmNvbmNhdChbaV0pO1xuICAgICAgICBwYXRjaGVzLnB1c2goe1xuICAgICAgICAgIG9wOiBSRVBMQUNFLFxuICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgLy8gTmVlZCB0byBtYXliZSBjbG9uZSBpdCwgYXMgaXQgY2FuIGluIGZhY3QgYmUgdGhlIG9yaWdpbmFsIHZhbHVlXG4gICAgICAgICAgLy8gZHVlIHRvIHRoZSBiYXNlL2NvcHkgaW52ZXJzaW9uIGF0IHRoZSBzdGFydCBvZiB0aGlzIGZ1bmN0aW9uXG4gICAgICAgICAgdmFsdWU6IGNsb25lUGF0Y2hWYWx1ZUlmTmVlZGVkKGNvcHlfW2ldKVxuICAgICAgICB9KTtcbiAgICAgICAgaW52ZXJzZVBhdGNoZXMucHVzaCh7XG4gICAgICAgICAgb3A6IFJFUExBQ0UsXG4gICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICB2YWx1ZTogY2xvbmVQYXRjaFZhbHVlSWZOZWVkZWQoYmFzZV9baV0pXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gLy8gUHJvY2VzcyBhZGRlZCBpbmRpY2VzLlxuXG5cbiAgICBmb3IgKHZhciBfaSA9IGJhc2VfLmxlbmd0aDsgX2kgPCBjb3B5Xy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfcGF0aCA9IGJhc2VQYXRoLmNvbmNhdChbX2ldKTtcblxuICAgICAgcGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgb3A6IEFERCxcbiAgICAgICAgcGF0aDogX3BhdGgsXG4gICAgICAgIC8vIE5lZWQgdG8gbWF5YmUgY2xvbmUgaXQsIGFzIGl0IGNhbiBpbiBmYWN0IGJlIHRoZSBvcmlnaW5hbCB2YWx1ZVxuICAgICAgICAvLyBkdWUgdG8gdGhlIGJhc2UvY29weSBpbnZlcnNpb24gYXQgdGhlIHN0YXJ0IG9mIHRoaXMgZnVuY3Rpb25cbiAgICAgICAgdmFsdWU6IGNsb25lUGF0Y2hWYWx1ZUlmTmVlZGVkKGNvcHlfW19pXSlcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChiYXNlXy5sZW5ndGggPCBjb3B5Xy5sZW5ndGgpIHtcbiAgICAgIGludmVyc2VQYXRjaGVzLnB1c2goe1xuICAgICAgICBvcDogUkVQTEFDRSxcbiAgICAgICAgcGF0aDogYmFzZVBhdGguY29uY2F0KFtcImxlbmd0aFwiXSksXG4gICAgICAgIHZhbHVlOiBiYXNlXy5sZW5ndGhcbiAgICAgIH0pO1xuICAgIH1cbiAgfSAvLyBUaGlzIGlzIHVzZWQgZm9yIGJvdGggTWFwIG9iamVjdHMgYW5kIG5vcm1hbCBvYmplY3RzLlxuXG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGVQYXRjaGVzRnJvbUFzc2lnbmVkKHN0YXRlLCBiYXNlUGF0aCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpIHtcbiAgICB2YXIgYmFzZV8gPSBzdGF0ZS5iYXNlXyxcbiAgICAgICAgY29weV8gPSBzdGF0ZS5jb3B5XztcbiAgICBlYWNoKHN0YXRlLmFzc2lnbmVkXywgZnVuY3Rpb24gKGtleSwgYXNzaWduZWRWYWx1ZSkge1xuICAgICAgdmFyIG9yaWdWYWx1ZSA9IGdldChiYXNlXywga2V5KTtcbiAgICAgIHZhciB2YWx1ZSA9IGdldChjb3B5Xywga2V5KTtcbiAgICAgIHZhciBvcCA9ICFhc3NpZ25lZFZhbHVlID8gUkVNT1ZFIDogaGFzKGJhc2VfLCBrZXkpID8gUkVQTEFDRSA6IEFERDtcbiAgICAgIGlmIChvcmlnVmFsdWUgPT09IHZhbHVlICYmIG9wID09PSBSRVBMQUNFKSByZXR1cm47XG4gICAgICB2YXIgcGF0aCA9IGJhc2VQYXRoLmNvbmNhdChrZXkpO1xuICAgICAgcGF0Y2hlcy5wdXNoKG9wID09PSBSRU1PVkUgPyB7XG4gICAgICAgIG9wOiBvcCxcbiAgICAgICAgcGF0aDogcGF0aFxuICAgICAgfSA6IHtcbiAgICAgICAgb3A6IG9wLFxuICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgICAgaW52ZXJzZVBhdGNoZXMucHVzaChvcCA9PT0gQUREID8ge1xuICAgICAgICBvcDogUkVNT1ZFLFxuICAgICAgICBwYXRoOiBwYXRoXG4gICAgICB9IDogb3AgPT09IFJFTU9WRSA/IHtcbiAgICAgICAgb3A6IEFERCxcbiAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgdmFsdWU6IGNsb25lUGF0Y2hWYWx1ZUlmTmVlZGVkKG9yaWdWYWx1ZSlcbiAgICAgIH0gOiB7XG4gICAgICAgIG9wOiBSRVBMQUNFLFxuICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICB2YWx1ZTogY2xvbmVQYXRjaFZhbHVlSWZOZWVkZWQob3JpZ1ZhbHVlKVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZW5lcmF0ZVNldFBhdGNoZXMoc3RhdGUsIGJhc2VQYXRoLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcykge1xuICAgIHZhciBiYXNlXyA9IHN0YXRlLmJhc2VfLFxuICAgICAgICBjb3B5XyA9IHN0YXRlLmNvcHlfO1xuICAgIHZhciBpID0gMDtcbiAgICBiYXNlXy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKCFjb3B5Xy5oYXModmFsdWUpKSB7XG4gICAgICAgIHZhciBwYXRoID0gYmFzZVBhdGguY29uY2F0KFtpXSk7XG4gICAgICAgIHBhdGNoZXMucHVzaCh7XG4gICAgICAgICAgb3A6IFJFTU9WRSxcbiAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgaW52ZXJzZVBhdGNoZXMudW5zaGlmdCh7XG4gICAgICAgICAgb3A6IEFERCxcbiAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaSsrO1xuICAgIH0pO1xuICAgIGkgPSAwO1xuICAgIGNvcHlfLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAoIWJhc2VfLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgdmFyIHBhdGggPSBiYXNlUGF0aC5jb25jYXQoW2ldKTtcbiAgICAgICAgcGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICBvcDogQURELFxuICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICBpbnZlcnNlUGF0Y2hlcy51bnNoaWZ0KHtcbiAgICAgICAgICBvcDogUkVNT1ZFLFxuICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpKys7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZW5lcmF0ZVJlcGxhY2VtZW50UGF0Y2hlc18oYmFzZVZhbHVlLCByZXBsYWNlbWVudCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpIHtcbiAgICBwYXRjaGVzLnB1c2goe1xuICAgICAgb3A6IFJFUExBQ0UsXG4gICAgICBwYXRoOiBbXSxcbiAgICAgIHZhbHVlOiByZXBsYWNlbWVudCA9PT0gTk9USElORyA/IHVuZGVmaW5lZCA6IHJlcGxhY2VtZW50XG4gICAgfSk7XG4gICAgaW52ZXJzZVBhdGNoZXMucHVzaCh7XG4gICAgICBvcDogUkVQTEFDRSxcbiAgICAgIHBhdGg6IFtdLFxuICAgICAgdmFsdWU6IGJhc2VWYWx1ZVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwbHlQYXRjaGVzXyhkcmFmdCwgcGF0Y2hlcykge1xuICAgIHBhdGNoZXMuZm9yRWFjaChmdW5jdGlvbiAocGF0Y2gpIHtcbiAgICAgIHZhciBwYXRoID0gcGF0Y2gucGF0aCxcbiAgICAgICAgICBvcCA9IHBhdGNoLm9wO1xuICAgICAgdmFyIGJhc2UgPSBkcmFmdDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICB2YXIgcGFyZW50VHlwZSA9IGdldEFyY2h0eXBlKGJhc2UpO1xuICAgICAgICB2YXIgcCA9IFwiXCIgKyBwYXRoW2ldOyAvLyBTZWUgIzczOCwgYXZvaWQgcHJvdG90eXBlIHBvbGx1dGlvblxuXG4gICAgICAgIGlmICgocGFyZW50VHlwZSA9PT0gMFxuICAgICAgICAvKiBPYmplY3QgKi9cbiAgICAgICAgfHwgcGFyZW50VHlwZSA9PT0gMVxuICAgICAgICAvKiBBcnJheSAqL1xuICAgICAgICApICYmIChwID09PSBcIl9fcHJvdG9fX1wiIHx8IHAgPT09IFwiY29uc3RydWN0b3JcIikpIGRpZSgyNCk7XG4gICAgICAgIGlmICh0eXBlb2YgYmFzZSA9PT0gXCJmdW5jdGlvblwiICYmIHAgPT09IFwicHJvdG90eXBlXCIpIGRpZSgyNCk7XG4gICAgICAgIGJhc2UgPSBnZXQoYmFzZSwgcCk7XG4gICAgICAgIGlmICh0eXBlb2YgYmFzZSAhPT0gXCJvYmplY3RcIikgZGllKDE1LCBwYXRoLmpvaW4oXCIvXCIpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGUgPSBnZXRBcmNodHlwZShiYXNlKTtcbiAgICAgIHZhciB2YWx1ZSA9IGRlZXBDbG9uZVBhdGNoVmFsdWUocGF0Y2gudmFsdWUpOyAvLyB1c2VkIHRvIGNsb25lIHBhdGNoIHRvIGVuc3VyZSBvcmlnaW5hbCBwYXRjaCBpcyBub3QgbW9kaWZpZWQsIHNlZSAjNDExXG5cbiAgICAgIHZhciBrZXkgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG5cbiAgICAgIHN3aXRjaCAob3ApIHtcbiAgICAgICAgY2FzZSBSRVBMQUNFOlxuICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAyXG4gICAgICAgICAgICAvKiBNYXAgKi9cbiAgICAgICAgICAgIDpcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2Uuc2V0KGtleSwgdmFsdWUpO1xuXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG4gICAgICAgICAgICBjYXNlIDNcbiAgICAgICAgICAgIC8qIFNldCAqL1xuICAgICAgICAgICAgOlxuICAgICAgICAgICAgICBkaWUoMTYpO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAvLyBpZiB2YWx1ZSBpcyBhbiBvYmplY3QsIHRoZW4gaXQncyBhc3NpZ25lZCBieSByZWZlcmVuY2VcbiAgICAgICAgICAgICAgLy8gaW4gdGhlIGZvbGxvd2luZyBhZGQgb3IgcmVtb3ZlIG9wcywgdGhlIHZhbHVlIGZpZWxkIGluc2lkZSB0aGUgcGF0Y2ggd2lsbCBhbHNvIGJlIG1vZGlmeWVkXG4gICAgICAgICAgICAgIC8vIHNvIHdlIHVzZSB2YWx1ZSBmcm9tIHRoZSBjbG9uZWQgcGF0Y2hcbiAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICByZXR1cm4gYmFzZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgQUREOlxuICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAxXG4gICAgICAgICAgICAvKiBBcnJheSAqL1xuICAgICAgICAgICAgOlxuICAgICAgICAgICAgICByZXR1cm4ga2V5ID09PSBcIi1cIiA/IGJhc2UucHVzaCh2YWx1ZSkgOiBiYXNlLnNwbGljZShrZXksIDAsIHZhbHVlKTtcblxuICAgICAgICAgICAgY2FzZSAyXG4gICAgICAgICAgICAvKiBNYXAgKi9cbiAgICAgICAgICAgIDpcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2Uuc2V0KGtleSwgdmFsdWUpO1xuXG4gICAgICAgICAgICBjYXNlIDNcbiAgICAgICAgICAgIC8qIFNldCAqL1xuICAgICAgICAgICAgOlxuICAgICAgICAgICAgICByZXR1cm4gYmFzZS5hZGQodmFsdWUpO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXR1cm4gYmFzZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVNT1ZFOlxuICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAxXG4gICAgICAgICAgICAvKiBBcnJheSAqL1xuICAgICAgICAgICAgOlxuICAgICAgICAgICAgICByZXR1cm4gYmFzZS5zcGxpY2Uoa2V5LCAxKTtcblxuICAgICAgICAgICAgY2FzZSAyXG4gICAgICAgICAgICAvKiBNYXAgKi9cbiAgICAgICAgICAgIDpcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2UuZGVsZXRlKGtleSk7XG5cbiAgICAgICAgICAgIGNhc2UgM1xuICAgICAgICAgICAgLyogU2V0ICovXG4gICAgICAgICAgICA6XG4gICAgICAgICAgICAgIHJldHVybiBiYXNlLmRlbGV0ZShwYXRjaC52YWx1ZSk7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiBkZWxldGUgYmFzZVtrZXldO1xuICAgICAgICAgIH1cblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGRpZSgxNywgb3ApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBkcmFmdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZXBDbG9uZVBhdGNoVmFsdWUob2JqKSB7XG4gICAgaWYgKCFpc0RyYWZ0YWJsZShvYmopKSByZXR1cm4gb2JqO1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHJldHVybiBvYmoubWFwKGRlZXBDbG9uZVBhdGNoVmFsdWUpO1xuICAgIGlmIChpc01hcChvYmopKSByZXR1cm4gbmV3IE1hcChBcnJheS5mcm9tKG9iai5lbnRyaWVzKCkpLm1hcChmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICAgIHZhciBrID0gX3JlZjNbMF0sXG4gICAgICAgICAgdiA9IF9yZWYzWzFdO1xuICAgICAgcmV0dXJuIFtrLCBkZWVwQ2xvbmVQYXRjaFZhbHVlKHYpXTtcbiAgICB9KSk7XG4gICAgaWYgKGlzU2V0KG9iaikpIHJldHVybiBuZXcgU2V0KEFycmF5LmZyb20ob2JqKS5tYXAoZGVlcENsb25lUGF0Y2hWYWx1ZSkpO1xuICAgIHZhciBjbG9uZWQgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopKTtcblxuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGNsb25lZFtrZXldID0gZGVlcENsb25lUGF0Y2hWYWx1ZShvYmpba2V5XSk7XG4gICAgfVxuXG4gICAgaWYgKGhhcyhvYmosIERSQUZUQUJMRSkpIGNsb25lZFtEUkFGVEFCTEVdID0gb2JqW0RSQUZUQUJMRV07XG4gICAgcmV0dXJuIGNsb25lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb25lUGF0Y2hWYWx1ZUlmTmVlZGVkKG9iaikge1xuICAgIGlmIChpc0RyYWZ0KG9iaikpIHtcbiAgICAgIHJldHVybiBkZWVwQ2xvbmVQYXRjaFZhbHVlKG9iaik7XG4gICAgfSBlbHNlIHJldHVybiBvYmo7XG4gIH1cblxuICBsb2FkUGx1Z2luKFwiUGF0Y2hlc1wiLCB7XG4gICAgYXBwbHlQYXRjaGVzXzogYXBwbHlQYXRjaGVzXyxcbiAgICBnZW5lcmF0ZVBhdGNoZXNfOiBnZW5lcmF0ZVBhdGNoZXNfLFxuICAgIGdlbmVyYXRlUmVwbGFjZW1lbnRQYXRjaGVzXzogZ2VuZXJhdGVSZXBsYWNlbWVudFBhdGNoZXNfXG4gIH0pO1xufVxuXG4vLyB0eXBlcyBvbmx5IVxuZnVuY3Rpb24gZW5hYmxlTWFwU2V0KCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB2YXIgX2V4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiBleHRlbmRTdGF0aWNzKGQsIGIpIHtcbiAgICBfZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7XG4gICAgICBfX3Byb3RvX186IFtdXG4gICAgfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICBkLl9fcHJvdG9fXyA9IGI7XG4gICAgfSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgZm9yICh2YXIgcCBpbiBiKSB7XG4gICAgICAgIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIF9leHRlbmRTdGF0aWNzKGQsIGIpO1xuICB9OyAvLyBVZ2x5IGhhY2sgdG8gcmVzb2x2ZSAjNTAyIGFuZCBpbmhlcml0IGJ1aWx0IGluIE1hcCAvIFNldFxuXG5cbiAgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcbiAgICBfZXh0ZW5kU3RhdGljcyhkLCBiKTtcblxuICAgIGZ1bmN0aW9uIF9fKCkge1xuICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7XG4gICAgfVxuXG4gICAgZC5wcm90b3R5cGUgPSAoIC8vIEB0cy1pZ25vcmVcbiAgICBfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICB9XG5cbiAgdmFyIERyYWZ0TWFwID0gZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEcmFmdE1hcCwgX3N1cGVyKTsgLy8gQ3JlYXRlIGNsYXNzIG1hbnVhbGx5LCBjYXVzZSAjNTAyXG5cblxuICAgIGZ1bmN0aW9uIERyYWZ0TWFwKHRhcmdldCwgcGFyZW50KSB7XG4gICAgICB0aGlzW0RSQUZUX1NUQVRFXSA9IHtcbiAgICAgICAgdHlwZV86IDJcbiAgICAgICAgLyogTWFwICovXG4gICAgICAgICxcbiAgICAgICAgcGFyZW50XzogcGFyZW50LFxuICAgICAgICBzY29wZV86IHBhcmVudCA/IHBhcmVudC5zY29wZV8gOiBnZXRDdXJyZW50U2NvcGUoKSxcbiAgICAgICAgbW9kaWZpZWRfOiBmYWxzZSxcbiAgICAgICAgZmluYWxpemVkXzogZmFsc2UsXG4gICAgICAgIGNvcHlfOiB1bmRlZmluZWQsXG4gICAgICAgIGFzc2lnbmVkXzogdW5kZWZpbmVkLFxuICAgICAgICBiYXNlXzogdGFyZ2V0LFxuICAgICAgICBkcmFmdF86IHRoaXMsXG4gICAgICAgIGlzTWFudWFsXzogZmFsc2UsXG4gICAgICAgIHJldm9rZWRfOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBwID0gRHJhZnRNYXAucHJvdG90eXBlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwLCBcInNpemVcIiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBsYXRlc3QodGhpc1tEUkFGVF9TVEFURV0pLnNpemU7XG4gICAgICB9IC8vIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgLy8gY29uZmlndXJhYmxlOiB0cnVlXG5cbiAgICB9KTtcblxuICAgIHAuaGFzID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIGxhdGVzdCh0aGlzW0RSQUZUX1NUQVRFXSkuaGFzKGtleSk7XG4gICAgfTtcblxuICAgIHAuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdO1xuICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcblxuICAgICAgaWYgKCFsYXRlc3Qoc3RhdGUpLmhhcyhrZXkpIHx8IGxhdGVzdChzdGF0ZSkuZ2V0KGtleSkgIT09IHZhbHVlKSB7XG4gICAgICAgIHByZXBhcmVNYXBDb3B5KHN0YXRlKTtcbiAgICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgICAgICBzdGF0ZS5hc3NpZ25lZF8uc2V0KGtleSwgdHJ1ZSk7XG4gICAgICAgIHN0YXRlLmNvcHlfLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgc3RhdGUuYXNzaWduZWRfLnNldChrZXksIHRydWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgcC5kZWxldGUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBpZiAoIXRoaXMuaGFzKGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7XG4gICAgICBwcmVwYXJlTWFwQ29weShzdGF0ZSk7XG4gICAgICBtYXJrQ2hhbmdlZChzdGF0ZSk7XG5cbiAgICAgIGlmIChzdGF0ZS5iYXNlXy5oYXMoa2V5KSkge1xuICAgICAgICBzdGF0ZS5hc3NpZ25lZF8uc2V0KGtleSwgZmFsc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUuYXNzaWduZWRfLmRlbGV0ZShrZXkpO1xuICAgICAgfVxuXG4gICAgICBzdGF0ZS5jb3B5Xy5kZWxldGUoa2V5KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICBwLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuXG4gICAgICBpZiAobGF0ZXN0KHN0YXRlKS5zaXplKSB7XG4gICAgICAgIHByZXBhcmVNYXBDb3B5KHN0YXRlKTtcbiAgICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgICAgICBzdGF0ZS5hc3NpZ25lZF8gPSBuZXcgTWFwKCk7XG4gICAgICAgIGVhY2goc3RhdGUuYmFzZV8sIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICBzdGF0ZS5hc3NpZ25lZF8uc2V0KGtleSwgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgc3RhdGUuY29weV8uY2xlYXIoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcC5mb3JFYWNoID0gZnVuY3Rpb24gKGNiLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGxhdGVzdChzdGF0ZSkuZm9yRWFjaChmdW5jdGlvbiAoX3ZhbHVlLCBrZXksIF9tYXApIHtcbiAgICAgICAgY2IuY2FsbCh0aGlzQXJnLCBfdGhpcy5nZXQoa2V5KSwga2V5LCBfdGhpcyk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcC5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7XG4gICAgICB2YXIgdmFsdWUgPSBsYXRlc3Qoc3RhdGUpLmdldChrZXkpO1xuXG4gICAgICBpZiAoc3RhdGUuZmluYWxpemVkXyB8fCAhaXNEcmFmdGFibGUodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlICE9PSBzdGF0ZS5iYXNlXy5nZXQoa2V5KSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7IC8vIGVpdGhlciBhbHJlYWR5IGRyYWZ0ZWQgb3IgcmVhc3NpZ25lZFxuICAgICAgfSAvLyBkZXNwaXRlIHdoYXQgaXQgbG9va3MsIHRoaXMgY3JlYXRlcyBhIGRyYWZ0IG9ubHkgb25jZSwgc2VlIGFib3ZlIGNvbmRpdGlvblxuXG5cbiAgICAgIHZhciBkcmFmdCA9IGNyZWF0ZVByb3h5KHN0YXRlLnNjb3BlXy5pbW1lcl8sIHZhbHVlLCBzdGF0ZSk7XG4gICAgICBwcmVwYXJlTWFwQ29weShzdGF0ZSk7XG4gICAgICBzdGF0ZS5jb3B5Xy5zZXQoa2V5LCBkcmFmdCk7XG4gICAgICByZXR1cm4gZHJhZnQ7XG4gICAgfTtcblxuICAgIHAua2V5cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBsYXRlc3QodGhpc1tEUkFGVF9TVEFURV0pLmtleXMoKTtcbiAgICB9O1xuXG4gICAgcC52YWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcyxcbiAgICAgICAgICBfcmVmO1xuXG4gICAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLmtleXMoKTtcbiAgICAgIHJldHVybiBfcmVmID0ge30sIF9yZWZbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLnZhbHVlcygpO1xuICAgICAgfSwgX3JlZi5uZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgdmFyIHIgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cbiAgICAgICAgaWYgKHIuZG9uZSkgcmV0dXJuIHI7XG5cbiAgICAgICAgdmFyIHZhbHVlID0gX3RoaXMyLmdldChyLnZhbHVlKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9O1xuICAgICAgfSwgX3JlZjtcbiAgICB9O1xuXG4gICAgcC5lbnRyaWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXMsXG4gICAgICAgICAgX3JlZjI7XG5cbiAgICAgIHZhciBpdGVyYXRvciA9IHRoaXMua2V5cygpO1xuICAgICAgcmV0dXJuIF9yZWYyID0ge30sIF9yZWYyW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMy5lbnRyaWVzKCk7XG4gICAgICB9LCBfcmVmMi5uZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgdmFyIHIgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cbiAgICAgICAgaWYgKHIuZG9uZSkgcmV0dXJuIHI7XG5cbiAgICAgICAgdmFyIHZhbHVlID0gX3RoaXMzLmdldChyLnZhbHVlKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgIHZhbHVlOiBbci52YWx1ZSwgdmFsdWVdXG4gICAgICAgIH07XG4gICAgICB9LCBfcmVmMjtcbiAgICB9O1xuXG4gICAgcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbnRyaWVzKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBEcmFmdE1hcDtcbiAgfShNYXApO1xuXG4gIGZ1bmN0aW9uIHByb3h5TWFwXyh0YXJnZXQsIHBhcmVudCkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gbmV3IERyYWZ0TWFwKHRhcmdldCwgcGFyZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByZXBhcmVNYXBDb3B5KHN0YXRlKSB7XG4gICAgaWYgKCFzdGF0ZS5jb3B5Xykge1xuICAgICAgc3RhdGUuYXNzaWduZWRfID0gbmV3IE1hcCgpO1xuICAgICAgc3RhdGUuY29weV8gPSBuZXcgTWFwKHN0YXRlLmJhc2VfKTtcbiAgICB9XG4gIH1cblxuICB2YXIgRHJhZnRTZXQgPSBmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERyYWZ0U2V0LCBfc3VwZXIpOyAvLyBDcmVhdGUgY2xhc3MgbWFudWFsbHksIGNhdXNlICM1MDJcblxuXG4gICAgZnVuY3Rpb24gRHJhZnRTZXQodGFyZ2V0LCBwYXJlbnQpIHtcbiAgICAgIHRoaXNbRFJBRlRfU1RBVEVdID0ge1xuICAgICAgICB0eXBlXzogM1xuICAgICAgICAvKiBTZXQgKi9cbiAgICAgICAgLFxuICAgICAgICBwYXJlbnRfOiBwYXJlbnQsXG4gICAgICAgIHNjb3BlXzogcGFyZW50ID8gcGFyZW50LnNjb3BlXyA6IGdldEN1cnJlbnRTY29wZSgpLFxuICAgICAgICBtb2RpZmllZF86IGZhbHNlLFxuICAgICAgICBmaW5hbGl6ZWRfOiBmYWxzZSxcbiAgICAgICAgY29weV86IHVuZGVmaW5lZCxcbiAgICAgICAgYmFzZV86IHRhcmdldCxcbiAgICAgICAgZHJhZnRfOiB0aGlzLFxuICAgICAgICBkcmFmdHNfOiBuZXcgTWFwKCksXG4gICAgICAgIHJldm9rZWRfOiBmYWxzZSxcbiAgICAgICAgaXNNYW51YWxfOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBwID0gRHJhZnRTZXQucHJvdG90eXBlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwLCBcInNpemVcIiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBsYXRlc3QodGhpc1tEUkFGVF9TVEFURV0pLnNpemU7XG4gICAgICB9IC8vIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICB9KTtcblxuICAgIHAuaGFzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7IC8vIGJpdCBvZiB0cmlja2VyeSBoZXJlLCB0byBiZSBhYmxlIHRvIHJlY29nbml6ZSBib3RoIHRoZSB2YWx1ZSwgYW5kIHRoZSBkcmFmdCBvZiBpdHMgdmFsdWVcblxuICAgICAgaWYgKCFzdGF0ZS5jb3B5Xykge1xuICAgICAgICByZXR1cm4gc3RhdGUuYmFzZV8uaGFzKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlLmNvcHlfLmhhcyh2YWx1ZSkpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKHN0YXRlLmRyYWZ0c18uaGFzKHZhbHVlKSAmJiBzdGF0ZS5jb3B5Xy5oYXMoc3RhdGUuZHJhZnRzXy5nZXQodmFsdWUpKSkgcmV0dXJuIHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIHAuYWRkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7XG5cbiAgICAgIGlmICghdGhpcy5oYXModmFsdWUpKSB7XG4gICAgICAgIHByZXBhcmVTZXRDb3B5KHN0YXRlKTtcbiAgICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgICAgICBzdGF0ZS5jb3B5Xy5hZGQodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgcC5kZWxldGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmICghdGhpcy5oYXModmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuICAgICAgcHJlcGFyZVNldENvcHkoc3RhdGUpO1xuICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgICAgcmV0dXJuIHN0YXRlLmNvcHlfLmRlbGV0ZSh2YWx1ZSkgfHwgKHN0YXRlLmRyYWZ0c18uaGFzKHZhbHVlKSA/IHN0YXRlLmNvcHlfLmRlbGV0ZShzdGF0ZS5kcmFmdHNfLmdldCh2YWx1ZSkpIDpcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICBmYWxzZSk7XG4gICAgfTtcblxuICAgIHAuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7XG5cbiAgICAgIGlmIChsYXRlc3Qoc3RhdGUpLnNpemUpIHtcbiAgICAgICAgcHJlcGFyZVNldENvcHkoc3RhdGUpO1xuICAgICAgICBtYXJrQ2hhbmdlZChzdGF0ZSk7XG4gICAgICAgIHN0YXRlLmNvcHlfLmNsZWFyKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHAudmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuICAgICAgcHJlcGFyZVNldENvcHkoc3RhdGUpO1xuICAgICAgcmV0dXJuIHN0YXRlLmNvcHlfLnZhbHVlcygpO1xuICAgIH07XG5cbiAgICBwLmVudHJpZXMgPSBmdW5jdGlvbiBlbnRyaWVzKCkge1xuICAgICAgdmFyIHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuICAgICAgcHJlcGFyZVNldENvcHkoc3RhdGUpO1xuICAgICAgcmV0dXJuIHN0YXRlLmNvcHlfLmVudHJpZXMoKTtcbiAgICB9O1xuXG4gICAgcC5rZXlzID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWVzKCk7XG4gICAgfTtcblxuICAgIHBbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWVzKCk7XG4gICAgfTtcblxuICAgIHAuZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2goY2IsIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpdGVyYXRvciA9IHRoaXMudmFsdWVzKCk7XG4gICAgICB2YXIgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuXG4gICAgICB3aGlsZSAoIXJlc3VsdC5kb25lKSB7XG4gICAgICAgIGNiLmNhbGwodGhpc0FyZywgcmVzdWx0LnZhbHVlLCByZXN1bHQudmFsdWUsIHRoaXMpO1xuICAgICAgICByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBEcmFmdFNldDtcbiAgfShTZXQpO1xuXG4gIGZ1bmN0aW9uIHByb3h5U2V0Xyh0YXJnZXQsIHBhcmVudCkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gbmV3IERyYWZ0U2V0KHRhcmdldCwgcGFyZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByZXBhcmVTZXRDb3B5KHN0YXRlKSB7XG4gICAgaWYgKCFzdGF0ZS5jb3B5Xykge1xuICAgICAgLy8gY3JlYXRlIGRyYWZ0cyBmb3IgYWxsIGVudHJpZXMgdG8gcHJlc2VydmUgaW5zZXJ0aW9uIG9yZGVyXG4gICAgICBzdGF0ZS5jb3B5XyA9IG5ldyBTZXQoKTtcbiAgICAgIHN0YXRlLmJhc2VfLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0RyYWZ0YWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgICB2YXIgZHJhZnQgPSBjcmVhdGVQcm94eShzdGF0ZS5zY29wZV8uaW1tZXJfLCB2YWx1ZSwgc3RhdGUpO1xuICAgICAgICAgIHN0YXRlLmRyYWZ0c18uc2V0KHZhbHVlLCBkcmFmdCk7XG4gICAgICAgICAgc3RhdGUuY29weV8uYWRkKGRyYWZ0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZS5jb3B5Xy5hZGQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnRVbnJldm9rZWQoc3RhdGVcbiAgLypFUzVTdGF0ZSB8IE1hcFN0YXRlIHwgU2V0U3RhdGUqL1xuICApIHtcbiAgICBpZiAoc3RhdGUucmV2b2tlZF8pIGRpZSgzLCBKU09OLnN0cmluZ2lmeShsYXRlc3Qoc3RhdGUpKSk7XG4gIH1cblxuICBsb2FkUGx1Z2luKFwiTWFwU2V0XCIsIHtcbiAgICBwcm94eU1hcF86IHByb3h5TWFwXyxcbiAgICBwcm94eVNldF86IHByb3h5U2V0X1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZW5hYmxlQWxsUGx1Z2lucygpIHtcbiAgZW5hYmxlRVM1KCk7XG4gIGVuYWJsZU1hcFNldCgpO1xuICBlbmFibGVQYXRjaGVzKCk7XG59XG5cbnZhciBpbW1lciA9XG4vKiNfX1BVUkVfXyovXG5uZXcgSW1tZXIoKTtcbi8qKlxyXG4gKiBUaGUgYHByb2R1Y2VgIGZ1bmN0aW9uIHRha2VzIGEgdmFsdWUgYW5kIGEgXCJyZWNpcGUgZnVuY3Rpb25cIiAod2hvc2VcclxuICogcmV0dXJuIHZhbHVlIG9mdGVuIGRlcGVuZHMgb24gdGhlIGJhc2Ugc3RhdGUpLiBUaGUgcmVjaXBlIGZ1bmN0aW9uIGlzXHJcbiAqIGZyZWUgdG8gbXV0YXRlIGl0cyBmaXJzdCBhcmd1bWVudCBob3dldmVyIGl0IHdhbnRzLiBBbGwgbXV0YXRpb25zIGFyZVxyXG4gKiBvbmx5IGV2ZXIgYXBwbGllZCB0byBhIF9fY29weV9fIG9mIHRoZSBiYXNlIHN0YXRlLlxyXG4gKlxyXG4gKiBQYXNzIG9ubHkgYSBmdW5jdGlvbiB0byBjcmVhdGUgYSBcImN1cnJpZWQgcHJvZHVjZXJcIiB3aGljaCByZWxpZXZlcyB5b3VcclxuICogZnJvbSBwYXNzaW5nIHRoZSByZWNpcGUgZnVuY3Rpb24gZXZlcnkgdGltZS5cclxuICpcclxuICogT25seSBwbGFpbiBvYmplY3RzIGFuZCBhcnJheXMgYXJlIG1hZGUgbXV0YWJsZS4gQWxsIG90aGVyIG9iamVjdHMgYXJlXHJcbiAqIGNvbnNpZGVyZWQgdW5jb3B5YWJsZS5cclxuICpcclxuICogTm90ZTogVGhpcyBmdW5jdGlvbiBpcyBfX2JvdW5kX18gdG8gaXRzIGBJbW1lcmAgaW5zdGFuY2UuXHJcbiAqXHJcbiAqIEBwYXJhbSB7YW55fSBiYXNlIC0gdGhlIGluaXRpYWwgc3RhdGVcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJvZHVjZXIgLSBmdW5jdGlvbiB0aGF0IHJlY2VpdmVzIGEgcHJveHkgb2YgdGhlIGJhc2Ugc3RhdGUgYXMgZmlyc3QgYXJndW1lbnQgYW5kIHdoaWNoIGNhbiBiZSBmcmVlbHkgbW9kaWZpZWRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gcGF0Y2hMaXN0ZW5lciAtIG9wdGlvbmFsIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2l0aCBhbGwgdGhlIHBhdGNoZXMgcHJvZHVjZWQgaGVyZVxyXG4gKiBAcmV0dXJucyB7YW55fSBhIG5ldyBzdGF0ZSwgb3IgdGhlIGluaXRpYWwgc3RhdGUgaWYgbm90aGluZyB3YXMgbW9kaWZpZWRcclxuICovXG5cbnZhciBwcm9kdWNlID0gaW1tZXIucHJvZHVjZTtcbi8qKlxyXG4gKiBMaWtlIGBwcm9kdWNlYCwgYnV0IGBwcm9kdWNlV2l0aFBhdGNoZXNgIGFsd2F5cyByZXR1cm5zIGEgdHVwbGVcclxuICogW25leHRTdGF0ZSwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXNdIChpbnN0ZWFkIG9mIGp1c3QgdGhlIG5leHQgc3RhdGUpXHJcbiAqL1xuXG52YXIgcHJvZHVjZVdpdGhQYXRjaGVzID1cbi8qI19fUFVSRV9fKi9cbmltbWVyLnByb2R1Y2VXaXRoUGF0Y2hlcy5iaW5kKGltbWVyKTtcbi8qKlxyXG4gKiBQYXNzIHRydWUgdG8gYXV0b21hdGljYWxseSBmcmVlemUgYWxsIGNvcGllcyBjcmVhdGVkIGJ5IEltbWVyLlxyXG4gKlxyXG4gKiBBbHdheXMgZnJlZXplIGJ5IGRlZmF1bHQsIGV2ZW4gaW4gcHJvZHVjdGlvbiBtb2RlXHJcbiAqL1xuXG52YXIgc2V0QXV0b0ZyZWV6ZSA9XG4vKiNfX1BVUkVfXyovXG5pbW1lci5zZXRBdXRvRnJlZXplLmJpbmQoaW1tZXIpO1xuLyoqXHJcbiAqIFBhc3MgdHJ1ZSB0byB1c2UgdGhlIEVTMjAxNSBgUHJveHlgIGNsYXNzIHdoZW4gY3JlYXRpbmcgZHJhZnRzLCB3aGljaCBpc1xyXG4gKiBhbHdheXMgZmFzdGVyIHRoYW4gdXNpbmcgRVM1IHByb3hpZXMuXHJcbiAqXHJcbiAqIEJ5IGRlZmF1bHQsIGZlYXR1cmUgZGV0ZWN0aW9uIGlzIHVzZWQsIHNvIGNhbGxpbmcgdGhpcyBpcyByYXJlbHkgbmVjZXNzYXJ5LlxyXG4gKi9cblxudmFyIHNldFVzZVByb3hpZXMgPVxuLyojX19QVVJFX18qL1xuaW1tZXIuc2V0VXNlUHJveGllcy5iaW5kKGltbWVyKTtcbi8qKlxyXG4gKiBBcHBseSBhbiBhcnJheSBvZiBJbW1lciBwYXRjaGVzIHRvIHRoZSBmaXJzdCBhcmd1bWVudC5cclxuICpcclxuICogVGhpcyBmdW5jdGlvbiBpcyBhIHByb2R1Y2VyLCB3aGljaCBtZWFucyBjb3B5LW9uLXdyaXRlIGlzIGluIGVmZmVjdC5cclxuICovXG5cbnZhciBhcHBseVBhdGNoZXMgPVxuLyojX19QVVJFX18qL1xuaW1tZXIuYXBwbHlQYXRjaGVzLmJpbmQoaW1tZXIpO1xuLyoqXHJcbiAqIENyZWF0ZSBhbiBJbW1lciBkcmFmdCBmcm9tIHRoZSBnaXZlbiBiYXNlIHN0YXRlLCB3aGljaCBtYXkgYmUgYSBkcmFmdCBpdHNlbGYuXHJcbiAqIFRoZSBkcmFmdCBjYW4gYmUgbW9kaWZpZWQgdW50aWwgeW91IGZpbmFsaXplIGl0IHdpdGggdGhlIGBmaW5pc2hEcmFmdGAgZnVuY3Rpb24uXHJcbiAqL1xuXG52YXIgY3JlYXRlRHJhZnQgPVxuLyojX19QVVJFX18qL1xuaW1tZXIuY3JlYXRlRHJhZnQuYmluZChpbW1lcik7XG4vKipcclxuICogRmluYWxpemUgYW4gSW1tZXIgZHJhZnQgZnJvbSBhIGBjcmVhdGVEcmFmdGAgY2FsbCwgcmV0dXJuaW5nIHRoZSBiYXNlIHN0YXRlXHJcbiAqIChpZiBubyBjaGFuZ2VzIHdlcmUgbWFkZSkgb3IgYSBtb2RpZmllZCBjb3B5LiBUaGUgZHJhZnQgbXVzdCAqbm90KiBiZVxyXG4gKiBtdXRhdGVkIGFmdGVyd2FyZHMuXHJcbiAqXHJcbiAqIFBhc3MgYSBmdW5jdGlvbiBhcyB0aGUgMm5kIGFyZ3VtZW50IHRvIGdlbmVyYXRlIEltbWVyIHBhdGNoZXMgYmFzZWQgb24gdGhlXHJcbiAqIGNoYW5nZXMgdGhhdCB3ZXJlIG1hZGUuXHJcbiAqL1xuXG52YXIgZmluaXNoRHJhZnQgPVxuLyojX19QVVJFX18qL1xuaW1tZXIuZmluaXNoRHJhZnQuYmluZChpbW1lcik7XG4vKipcclxuICogVGhpcyBmdW5jdGlvbiBpcyBhY3R1YWxseSBhIG5vLW9wLCBidXQgY2FuIGJlIHVzZWQgdG8gY2FzdCBhbiBpbW11dGFibGUgdHlwZVxyXG4gKiB0byBhbiBkcmFmdCB0eXBlIGFuZCBtYWtlIFR5cGVTY3JpcHQgaGFwcHlcclxuICpcclxuICogQHBhcmFtIHZhbHVlXHJcbiAqL1xuXG5mdW5jdGlvbiBjYXN0RHJhZnQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXHJcbiAqIFRoaXMgZnVuY3Rpb24gaXMgYWN0dWFsbHkgYSBuby1vcCwgYnV0IGNhbiBiZSB1c2VkIHRvIGNhc3QgYSBtdXRhYmxlIHR5cGVcclxuICogdG8gYW4gaW1tdXRhYmxlIHR5cGUgYW5kIG1ha2UgVHlwZVNjcmlwdCBoYXBweVxyXG4gKiBAcGFyYW0gdmFsdWVcclxuICovXG5cbmZ1bmN0aW9uIGNhc3RJbW11dGFibGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnRzLkltbWVyID0gSW1tZXI7XG5leHBvcnRzLmFwcGx5UGF0Y2hlcyA9IGFwcGx5UGF0Y2hlcztcbmV4cG9ydHMuY2FzdERyYWZ0ID0gY2FzdERyYWZ0O1xuZXhwb3J0cy5jYXN0SW1tdXRhYmxlID0gY2FzdEltbXV0YWJsZTtcbmV4cG9ydHMuY3JlYXRlRHJhZnQgPSBjcmVhdGVEcmFmdDtcbmV4cG9ydHMuY3VycmVudCA9IGN1cnJlbnQ7XG5leHBvcnRzLmRlZmF1bHQgPSBwcm9kdWNlO1xuZXhwb3J0cy5lbmFibGVBbGxQbHVnaW5zID0gZW5hYmxlQWxsUGx1Z2lucztcbmV4cG9ydHMuZW5hYmxlRVM1ID0gZW5hYmxlRVM1O1xuZXhwb3J0cy5lbmFibGVNYXBTZXQgPSBlbmFibGVNYXBTZXQ7XG5leHBvcnRzLmVuYWJsZVBhdGNoZXMgPSBlbmFibGVQYXRjaGVzO1xuZXhwb3J0cy5maW5pc2hEcmFmdCA9IGZpbmlzaERyYWZ0O1xuZXhwb3J0cy5mcmVlemUgPSBmcmVlemU7XG5leHBvcnRzLmltbWVyYWJsZSA9IERSQUZUQUJMRTtcbmV4cG9ydHMuaXNEcmFmdCA9IGlzRHJhZnQ7XG5leHBvcnRzLmlzRHJhZnRhYmxlID0gaXNEcmFmdGFibGU7XG5leHBvcnRzLm5vdGhpbmcgPSBOT1RISU5HO1xuZXhwb3J0cy5vcmlnaW5hbCA9IG9yaWdpbmFsO1xuZXhwb3J0cy5wcm9kdWNlID0gcHJvZHVjZTtcbmV4cG9ydHMucHJvZHVjZVdpdGhQYXRjaGVzID0gcHJvZHVjZVdpdGhQYXRjaGVzO1xuZXhwb3J0cy5zZXRBdXRvRnJlZXplID0gc2V0QXV0b0ZyZWV6ZTtcbmV4cG9ydHMuc2V0VXNlUHJveGllcyA9IHNldFVzZVByb3hpZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbW1lci5janMuZGV2ZWxvcG1lbnQuanMubWFwXG4iLCJcbid1c2Ugc3RyaWN0J1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vaW1tZXIuY2pzLnByb2R1Y3Rpb24ubWluLmpzJylcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9pbW1lci5janMuZGV2ZWxvcG1lbnQuanMnKVxufVxuIiwiZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgIGVudW1lcmFibGVPbmx5ICYmIChzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgfSkpLCBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gIH1cblxuICByZXR1cm4ga2V5cztcbn1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZDIodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307XG4gICAgaSAlIDIgPyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKSA6IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gIH0gOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgfSwgX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfd3JhcFJlZ0V4cCgpIHtcbiAgX3dyYXBSZWdFeHAgPSBmdW5jdGlvbiAocmUsIGdyb3Vwcykge1xuICAgIHJldHVybiBuZXcgQmFiZWxSZWdFeHAocmUsIHZvaWQgMCwgZ3JvdXBzKTtcbiAgfTtcblxuICB2YXIgX3N1cGVyID0gUmVnRXhwLnByb3RvdHlwZSxcbiAgICAgIF9ncm91cHMgPSBuZXcgV2Vha01hcCgpO1xuXG4gIGZ1bmN0aW9uIEJhYmVsUmVnRXhwKHJlLCBmbGFncywgZ3JvdXBzKSB7XG4gICAgdmFyIF90aGlzID0gbmV3IFJlZ0V4cChyZSwgZmxhZ3MpO1xuXG4gICAgcmV0dXJuIF9ncm91cHMuc2V0KF90aGlzLCBncm91cHMgfHwgX2dyb3Vwcy5nZXQocmUpKSwgX3NldFByb3RvdHlwZU9mKF90aGlzLCBCYWJlbFJlZ0V4cC5wcm90b3R5cGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gYnVpbGRHcm91cHMocmVzdWx0LCByZSkge1xuICAgIHZhciBnID0gX2dyb3Vwcy5nZXQocmUpO1xuXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGcpLnJlZHVjZShmdW5jdGlvbiAoZ3JvdXBzLCBuYW1lKSB7XG4gICAgICByZXR1cm4gZ3JvdXBzW25hbWVdID0gcmVzdWx0W2dbbmFtZV1dLCBncm91cHM7XG4gICAgfSwgT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gIH1cblxuICByZXR1cm4gX2luaGVyaXRzKEJhYmVsUmVnRXhwLCBSZWdFeHApLCBCYWJlbFJlZ0V4cC5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICB2YXIgcmVzdWx0ID0gX3N1cGVyLmV4ZWMuY2FsbCh0aGlzLCBzdHIpO1xuXG4gICAgcmV0dXJuIHJlc3VsdCAmJiAocmVzdWx0Lmdyb3VwcyA9IGJ1aWxkR3JvdXBzKHJlc3VsdCwgdGhpcykpLCByZXN1bHQ7XG4gIH0sIEJhYmVsUmVnRXhwLnByb3RvdHlwZVtTeW1ib2wucmVwbGFjZV0gPSBmdW5jdGlvbiAoc3RyLCBzdWJzdGl0dXRpb24pIHtcbiAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2Ygc3Vic3RpdHV0aW9uKSB7XG4gICAgICB2YXIgZ3JvdXBzID0gX2dyb3Vwcy5nZXQodGhpcyk7XG5cbiAgICAgIHJldHVybiBfc3VwZXJbU3ltYm9sLnJlcGxhY2VdLmNhbGwodGhpcywgc3RyLCBzdWJzdGl0dXRpb24ucmVwbGFjZSgvXFwkPChbXj5dKyk+L2csIGZ1bmN0aW9uIChfLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiBcIiRcIiArIGdyb3Vwc1tuYW1lXTtcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBzdWJzdGl0dXRpb24pIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHJldHVybiBfc3VwZXJbU3ltYm9sLnJlcGxhY2VdLmNhbGwodGhpcywgc3RyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gXCJvYmplY3RcIiAhPSB0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdICYmIChhcmdzID0gW10uc2xpY2UuY2FsbChhcmdzKSkucHVzaChidWlsZEdyb3VwcyhhcmdzLCBfdGhpcykpLCBzdWJzdGl0dXRpb24uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3N1cGVyW1N5bWJvbC5yZXBsYWNlXS5jYWxsKHRoaXMsIHN0ciwgc3Vic3RpdHV0aW9uKTtcbiAgfSwgX3dyYXBSZWdFeHAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTtcbn1cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVyW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICB2YXIgX2kgPSBhcnIgPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGFycltTeW1ib2wuaXRlcmF0b3JdIHx8IGFycltcIkBAaXRlcmF0b3JcIl07XG5cbiAgaWYgKF9pID09IG51bGwpIHJldHVybjtcbiAgdmFyIF9hcnIgPSBbXTtcbiAgdmFyIF9uID0gdHJ1ZTtcbiAgdmFyIF9kID0gZmFsc2U7XG5cbiAgdmFyIF9zLCBfZTtcblxuICB0cnkge1xuICAgIGZvciAoX2kgPSBfaS5jYWxsKGFycik7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kID0gdHJ1ZTtcbiAgICBfZSA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfYXJyO1xufVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICByZXR1cm4gYXJyMjtcbn1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxudmFyIG5vb3AgPSBmdW5jdGlvbiBub29wKCkge307XG5cbnZhciBfV0lORE9XID0ge307XG52YXIgX0RPQ1VNRU5UID0ge307XG52YXIgX01VVEFUSU9OX09CU0VSVkVSID0gbnVsbDtcbnZhciBfUEVSRk9STUFOQ0UgPSB7XG4gIG1hcms6IG5vb3AsXG4gIG1lYXN1cmU6IG5vb3Bcbn07XG5cbnRyeSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgX1dJTkRPVyA9IHdpbmRvdztcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIF9ET0NVTUVOVCA9IGRvY3VtZW50O1xuICBpZiAodHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnKSBfTVVUQVRJT05fT0JTRVJWRVIgPSBNdXRhdGlvbk9ic2VydmVyO1xuICBpZiAodHlwZW9mIHBlcmZvcm1hbmNlICE9PSAndW5kZWZpbmVkJykgX1BFUkZPUk1BTkNFID0gcGVyZm9ybWFuY2U7XG59IGNhdGNoIChlKSB7fVxuXG52YXIgX3JlZiA9IF9XSU5ET1cubmF2aWdhdG9yIHx8IHt9LFxuICAgIF9yZWYkdXNlckFnZW50ID0gX3JlZi51c2VyQWdlbnQsXG4gICAgdXNlckFnZW50ID0gX3JlZiR1c2VyQWdlbnQgPT09IHZvaWQgMCA/ICcnIDogX3JlZiR1c2VyQWdlbnQ7XG52YXIgV0lORE9XID0gX1dJTkRPVztcbnZhciBET0NVTUVOVCA9IF9ET0NVTUVOVDtcbnZhciBNVVRBVElPTl9PQlNFUlZFUiA9IF9NVVRBVElPTl9PQlNFUlZFUjtcbnZhciBQRVJGT1JNQU5DRSA9IF9QRVJGT1JNQU5DRTtcbnZhciBJU19CUk9XU0VSID0gISFXSU5ET1cuZG9jdW1lbnQ7XG52YXIgSVNfRE9NID0gISFET0NVTUVOVC5kb2N1bWVudEVsZW1lbnQgJiYgISFET0NVTUVOVC5oZWFkICYmIHR5cGVvZiBET0NVTUVOVC5hZGRFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBET0NVTUVOVC5jcmVhdGVFbGVtZW50ID09PSAnZnVuY3Rpb24nO1xudmFyIElTX0lFID0gfnVzZXJBZ2VudC5pbmRleE9mKCdNU0lFJykgfHwgfnVzZXJBZ2VudC5pbmRleE9mKCdUcmlkZW50LycpO1xuXG52YXIgX2ZhbWlseVByb3h5LCBfZmFtaWx5UHJveHkyLCBfZmFtaWx5UHJveHkzLCBfZmFtaWx5UHJveHk0LCBfZmFtaWx5UHJveHk1O1xuXG52YXIgTkFNRVNQQUNFX0lERU5USUZJRVIgPSAnX19fRk9OVF9BV0VTT01FX19fJztcbnZhciBVTklUU19JTl9HUklEID0gMTY7XG52YXIgREVGQVVMVF9DU1NfUFJFRklYID0gJ2ZhJztcbnZhciBERUZBVUxUX1JFUExBQ0VNRU5UX0NMQVNTID0gJ3N2Zy1pbmxpbmUtLWZhJztcbnZhciBEQVRBX0ZBX0kyU1ZHID0gJ2RhdGEtZmEtaTJzdmcnO1xudmFyIERBVEFfRkFfUFNFVURPX0VMRU1FTlQgPSAnZGF0YS1mYS1wc2V1ZG8tZWxlbWVudCc7XG52YXIgREFUQV9GQV9QU0VVRE9fRUxFTUVOVF9QRU5ESU5HID0gJ2RhdGEtZmEtcHNldWRvLWVsZW1lbnQtcGVuZGluZyc7XG52YXIgREFUQV9QUkVGSVggPSAnZGF0YS1wcmVmaXgnO1xudmFyIERBVEFfSUNPTiA9ICdkYXRhLWljb24nO1xudmFyIEhUTUxfQ0xBU1NfSTJTVkdfQkFTRV9DTEFTUyA9ICdmb250YXdlc29tZS1pMnN2Zyc7XG52YXIgTVVUQVRJT05fQVBQUk9BQ0hfQVNZTkMgPSAnYXN5bmMnO1xudmFyIFRBR05BTUVTX1RPX1NLSVBfRk9SX1BTRVVET0VMRU1FTlRTID0gWydIVE1MJywgJ0hFQUQnLCAnU1RZTEUnLCAnU0NSSVBUJ107XG52YXIgUFJPRFVDVElPTiA9IGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJztcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufSgpO1xudmFyIEZBTUlMWV9DTEFTU0lDID0gJ2NsYXNzaWMnO1xudmFyIEZBTUlMWV9TSEFSUCA9ICdzaGFycCc7XG52YXIgRkFNSUxJRVMgPSBbRkFNSUxZX0NMQVNTSUMsIEZBTUlMWV9TSEFSUF07XG5cbmZ1bmN0aW9uIGZhbWlseVByb3h5KG9iaikge1xuICAvLyBEZWZhdWx0cyB0byB0aGUgY2xhc3NpYyBmYW1pbHkgaWYgZmFtaWx5IGlzIG5vdCBhdmFpbGFibGVcbiAgcmV0dXJuIG5ldyBQcm94eShvYmosIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCh0YXJnZXQsIHByb3ApIHtcbiAgICAgIHJldHVybiBwcm9wIGluIHRhcmdldCA/IHRhcmdldFtwcm9wXSA6IHRhcmdldFtGQU1JTFlfQ0xBU1NJQ107XG4gICAgfVxuICB9KTtcbn1cbnZhciBQUkVGSVhfVE9fU1RZTEUgPSBmYW1pbHlQcm94eSgoX2ZhbWlseVByb3h5ID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfZmFtaWx5UHJveHksIEZBTUlMWV9DTEFTU0lDLCB7XG4gICdmYSc6ICdzb2xpZCcsXG4gICdmYXMnOiAnc29saWQnLFxuICAnZmEtc29saWQnOiAnc29saWQnLFxuICAnZmFyJzogJ3JlZ3VsYXInLFxuICAnZmEtcmVndWxhcic6ICdyZWd1bGFyJyxcbiAgJ2ZhbCc6ICdsaWdodCcsXG4gICdmYS1saWdodCc6ICdsaWdodCcsXG4gICdmYXQnOiAndGhpbicsXG4gICdmYS10aGluJzogJ3RoaW4nLFxuICAnZmFkJzogJ2R1b3RvbmUnLFxuICAnZmEtZHVvdG9uZSc6ICdkdW90b25lJyxcbiAgJ2ZhYic6ICdicmFuZHMnLFxuICAnZmEtYnJhbmRzJzogJ2JyYW5kcycsXG4gICdmYWsnOiAna2l0JyxcbiAgJ2ZhLWtpdCc6ICdraXQnXG59KSwgX2RlZmluZVByb3BlcnR5KF9mYW1pbHlQcm94eSwgRkFNSUxZX1NIQVJQLCB7XG4gICdmYSc6ICdzb2xpZCcsXG4gICdmYXNzJzogJ3NvbGlkJyxcbiAgJ2ZhLXNvbGlkJzogJ3NvbGlkJ1xufSksIF9mYW1pbHlQcm94eSkpO1xudmFyIFNUWUxFX1RPX1BSRUZJWCA9IGZhbWlseVByb3h5KChfZmFtaWx5UHJveHkyID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfZmFtaWx5UHJveHkyLCBGQU1JTFlfQ0xBU1NJQywge1xuICAnc29saWQnOiAnZmFzJyxcbiAgJ3JlZ3VsYXInOiAnZmFyJyxcbiAgJ2xpZ2h0JzogJ2ZhbCcsXG4gICd0aGluJzogJ2ZhdCcsXG4gICdkdW90b25lJzogJ2ZhZCcsXG4gICdicmFuZHMnOiAnZmFiJyxcbiAgJ2tpdCc6ICdmYWsnXG59KSwgX2RlZmluZVByb3BlcnR5KF9mYW1pbHlQcm94eTIsIEZBTUlMWV9TSEFSUCwge1xuICAnc29saWQnOiAnZmFzcydcbn0pLCBfZmFtaWx5UHJveHkyKSk7XG52YXIgUFJFRklYX1RPX0xPTkdfU1RZTEUgPSBmYW1pbHlQcm94eSgoX2ZhbWlseVByb3h5MyA9IHt9LCBfZGVmaW5lUHJvcGVydHkoX2ZhbWlseVByb3h5MywgRkFNSUxZX0NMQVNTSUMsIHtcbiAgJ2ZhYic6ICdmYS1icmFuZHMnLFxuICAnZmFkJzogJ2ZhLWR1b3RvbmUnLFxuICAnZmFrJzogJ2ZhLWtpdCcsXG4gICdmYWwnOiAnZmEtbGlnaHQnLFxuICAnZmFyJzogJ2ZhLXJlZ3VsYXInLFxuICAnZmFzJzogJ2ZhLXNvbGlkJyxcbiAgJ2ZhdCc6ICdmYS10aGluJ1xufSksIF9kZWZpbmVQcm9wZXJ0eShfZmFtaWx5UHJveHkzLCBGQU1JTFlfU0hBUlAsIHtcbiAgJ2Zhc3MnOiAnZmEtc29saWQnXG59KSwgX2ZhbWlseVByb3h5MykpO1xudmFyIExPTkdfU1RZTEVfVE9fUFJFRklYID0gZmFtaWx5UHJveHkoKF9mYW1pbHlQcm94eTQgPSB7fSwgX2RlZmluZVByb3BlcnR5KF9mYW1pbHlQcm94eTQsIEZBTUlMWV9DTEFTU0lDLCB7XG4gICdmYS1icmFuZHMnOiAnZmFiJyxcbiAgJ2ZhLWR1b3RvbmUnOiAnZmFkJyxcbiAgJ2ZhLWtpdCc6ICdmYWsnLFxuICAnZmEtbGlnaHQnOiAnZmFsJyxcbiAgJ2ZhLXJlZ3VsYXInOiAnZmFyJyxcbiAgJ2ZhLXNvbGlkJzogJ2ZhcycsXG4gICdmYS10aGluJzogJ2ZhdCdcbn0pLCBfZGVmaW5lUHJvcGVydHkoX2ZhbWlseVByb3h5NCwgRkFNSUxZX1NIQVJQLCB7XG4gICdmYS1zb2xpZCc6ICdmYXNzJ1xufSksIF9mYW1pbHlQcm94eTQpKTtcbnZhciBJQ09OX1NFTEVDVElPTl9TWU5UQVhfUEFUVEVSTiA9IC9mYShzfHJ8bHx0fGR8YnxrfHNzKT9bXFwtXFwgXS87IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcblxudmFyIExBWUVSU19URVhUX0NMQVNTTkFNRSA9ICdmYS1sYXllcnMtdGV4dCc7XG52YXIgRk9OVF9GQU1JTFlfUEFUVEVSTiA9IC9Gb250ID9Bd2Vzb21lID8oWzU2IF0qKShTb2xpZHxSZWd1bGFyfExpZ2h0fFRoaW58RHVvdG9uZXxCcmFuZHN8RnJlZXxQcm98U2hhcnB8S2l0KT8uKi9pOyAvLyBUT0RPOiB0aGlzIG5lZWRzIHRvIHN1cHBvcnQgZmFzc1xuLy8gVE9ETzogZG8gd2UgbmVlZCB0byBoYW5kbGUgZm9udC13ZWlnaHQgZm9yIGtpdCBTVkcgcHNldWRvLWVsZW1lbnRzP1xuXG52YXIgRk9OVF9XRUlHSFRfVE9fUFJFRklYID0gZmFtaWx5UHJveHkoKF9mYW1pbHlQcm94eTUgPSB7fSwgX2RlZmluZVByb3BlcnR5KF9mYW1pbHlQcm94eTUsIEZBTUlMWV9DTEFTU0lDLCB7XG4gICc5MDAnOiAnZmFzJyxcbiAgJzQwMCc6ICdmYXInLFxuICAnbm9ybWFsJzogJ2ZhcicsXG4gICczMDAnOiAnZmFsJyxcbiAgJzEwMCc6ICdmYXQnXG59KSwgX2RlZmluZVByb3BlcnR5KF9mYW1pbHlQcm94eTUsIEZBTUlMWV9TSEFSUCwge1xuICAnOTAwJzogJ2Zhc3MnXG59KSwgX2ZhbWlseVByb3h5NSkpO1xudmFyIG9uZVRvVGVuID0gWzEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwXTtcbnZhciBvbmVUb1R3ZW50eSA9IG9uZVRvVGVuLmNvbmNhdChbMTEsIDEyLCAxMywgMTQsIDE1LCAxNiwgMTcsIDE4LCAxOSwgMjBdKTtcbnZhciBBVFRSSUJVVEVTX1dBVENIRURfRk9SX01VVEFUSU9OID0gWydjbGFzcycsICdkYXRhLXByZWZpeCcsICdkYXRhLWljb24nLCAnZGF0YS1mYS10cmFuc2Zvcm0nLCAnZGF0YS1mYS1tYXNrJ107XG52YXIgRFVPVE9ORV9DTEFTU0VTID0ge1xuICBHUk9VUDogJ2R1b3RvbmUtZ3JvdXAnLFxuICBTV0FQX09QQUNJVFk6ICdzd2FwLW9wYWNpdHknLFxuICBQUklNQVJZOiAncHJpbWFyeScsXG4gIFNFQ09OREFSWTogJ3NlY29uZGFyeSdcbn07XG52YXIgcHJlZml4ZXMgPSBuZXcgU2V0KCk7XG5PYmplY3Qua2V5cyhTVFlMRV9UT19QUkVGSVhbRkFNSUxZX0NMQVNTSUNdKS5tYXAocHJlZml4ZXMuYWRkLmJpbmQocHJlZml4ZXMpKTtcbk9iamVjdC5rZXlzKFNUWUxFX1RPX1BSRUZJWFtGQU1JTFlfU0hBUlBdKS5tYXAocHJlZml4ZXMuYWRkLmJpbmQocHJlZml4ZXMpKTtcbnZhciBSRVNFUlZFRF9DTEFTU0VTID0gW10uY29uY2F0KEZBTUlMSUVTLCBfdG9Db25zdW1hYmxlQXJyYXkocHJlZml4ZXMpLCBbJzJ4cycsICd4cycsICdzbScsICdsZycsICd4bCcsICcyeGwnLCAnYmVhdCcsICdib3JkZXInLCAnZmFkZScsICdiZWF0LWZhZGUnLCAnYm91bmNlJywgJ2ZsaXAtYm90aCcsICdmbGlwLWhvcml6b250YWwnLCAnZmxpcC12ZXJ0aWNhbCcsICdmbGlwJywgJ2Z3JywgJ2ludmVyc2UnLCAnbGF5ZXJzLWNvdW50ZXInLCAnbGF5ZXJzLXRleHQnLCAnbGF5ZXJzJywgJ2xpJywgJ3B1bGwtbGVmdCcsICdwdWxsLXJpZ2h0JywgJ3B1bHNlJywgJ3JvdGF0ZS0xODAnLCAncm90YXRlLTI3MCcsICdyb3RhdGUtOTAnLCAncm90YXRlLWJ5JywgJ3NoYWtlJywgJ3NwaW4tcHVsc2UnLCAnc3Bpbi1yZXZlcnNlJywgJ3NwaW4nLCAnc3RhY2stMXgnLCAnc3RhY2stMngnLCAnc3RhY2snLCAndWwnLCBEVU9UT05FX0NMQVNTRVMuR1JPVVAsIERVT1RPTkVfQ0xBU1NFUy5TV0FQX09QQUNJVFksIERVT1RPTkVfQ0xBU1NFUy5QUklNQVJZLCBEVU9UT05FX0NMQVNTRVMuU0VDT05EQVJZXSkuY29uY2F0KG9uZVRvVGVuLm1hcChmdW5jdGlvbiAobikge1xuICByZXR1cm4gXCJcIi5jb25jYXQobiwgXCJ4XCIpO1xufSkpLmNvbmNhdChvbmVUb1R3ZW50eS5tYXAoZnVuY3Rpb24gKG4pIHtcbiAgcmV0dXJuIFwidy1cIi5jb25jYXQobik7XG59KSk7XG5cbnZhciBpbml0aWFsID0gV0lORE9XLkZvbnRBd2Vzb21lQ29uZmlnIHx8IHt9O1xuXG5mdW5jdGlvbiBnZXRBdHRyQ29uZmlnKGF0dHIpIHtcbiAgdmFyIGVsZW1lbnQgPSBET0NVTUVOVC5xdWVyeVNlbGVjdG9yKCdzY3JpcHRbJyArIGF0dHIgKyAnXScpO1xuXG4gIGlmIChlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKGF0dHIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgLy8gR2V0dGluZyBhbiBlbXB0eSBzdHJpbmcgd2lsbCBvY2N1ciBpZiB0aGUgYXR0cmlidXRlIGlzIHNldCBvbiB0aGUgSFRNTCB0YWcgYnV0IHdpdGhvdXQgYSB2YWx1ZVxuICAvLyBXZSdsbCBhc3N1bWUgdGhhdCB0aGlzIGlzIGFuIGluZGljYXRpb24gdGhhdCBpdCBzaG91bGQgYmUgdG9nZ2xlZCB0byB0cnVlXG4gIGlmICh2YWwgPT09ICcnKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKHZhbCA9PT0gJ2ZhbHNlJykgcmV0dXJuIGZhbHNlO1xuICBpZiAodmFsID09PSAndHJ1ZScpIHJldHVybiB0cnVlO1xuICByZXR1cm4gdmFsO1xufVxuXG5pZiAoRE9DVU1FTlQgJiYgdHlwZW9mIERPQ1VNRU5ULnF1ZXJ5U2VsZWN0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgdmFyIGF0dHJzID0gW1snZGF0YS1mYW1pbHktcHJlZml4JywgJ2ZhbWlseVByZWZpeCddLCBbJ2RhdGEtY3NzLXByZWZpeCcsICdjc3NQcmVmaXgnXSwgWydkYXRhLWZhbWlseS1kZWZhdWx0JywgJ2ZhbWlseURlZmF1bHQnXSwgWydkYXRhLXN0eWxlLWRlZmF1bHQnLCAnc3R5bGVEZWZhdWx0J10sIFsnZGF0YS1yZXBsYWNlbWVudC1jbGFzcycsICdyZXBsYWNlbWVudENsYXNzJ10sIFsnZGF0YS1hdXRvLXJlcGxhY2Utc3ZnJywgJ2F1dG9SZXBsYWNlU3ZnJ10sIFsnZGF0YS1hdXRvLWFkZC1jc3MnLCAnYXV0b0FkZENzcyddLCBbJ2RhdGEtYXV0by1hMTF5JywgJ2F1dG9BMTF5J10sIFsnZGF0YS1zZWFyY2gtcHNldWRvLWVsZW1lbnRzJywgJ3NlYXJjaFBzZXVkb0VsZW1lbnRzJ10sIFsnZGF0YS1vYnNlcnZlLW11dGF0aW9ucycsICdvYnNlcnZlTXV0YXRpb25zJ10sIFsnZGF0YS1tdXRhdGUtYXBwcm9hY2gnLCAnbXV0YXRlQXBwcm9hY2gnXSwgWydkYXRhLWtlZXAtb3JpZ2luYWwtc291cmNlJywgJ2tlZXBPcmlnaW5hbFNvdXJjZSddLCBbJ2RhdGEtbWVhc3VyZS1wZXJmb3JtYW5jZScsICdtZWFzdXJlUGVyZm9ybWFuY2UnXSwgWydkYXRhLXNob3ctbWlzc2luZy1pY29ucycsICdzaG93TWlzc2luZ0ljb25zJ11dO1xuICBhdHRycy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMiksXG4gICAgICAgIGF0dHIgPSBfcmVmMlswXSxcbiAgICAgICAga2V5ID0gX3JlZjJbMV07XG5cbiAgICB2YXIgdmFsID0gY29lcmNlKGdldEF0dHJDb25maWcoYXR0cikpO1xuXG4gICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkICYmIHZhbCAhPT0gbnVsbCkge1xuICAgICAgaW5pdGlhbFtrZXldID0gdmFsO1xuICAgIH1cbiAgfSk7XG59XG5cbnZhciBfZGVmYXVsdCA9IHtcbiAgc3R5bGVEZWZhdWx0OiAnc29saWQnLFxuICBmYW1pbHlEZWZhdWx0OiAnY2xhc3NpYycsXG4gIGNzc1ByZWZpeDogREVGQVVMVF9DU1NfUFJFRklYLFxuICByZXBsYWNlbWVudENsYXNzOiBERUZBVUxUX1JFUExBQ0VNRU5UX0NMQVNTLFxuICBhdXRvUmVwbGFjZVN2ZzogdHJ1ZSxcbiAgYXV0b0FkZENzczogdHJ1ZSxcbiAgYXV0b0ExMXk6IHRydWUsXG4gIHNlYXJjaFBzZXVkb0VsZW1lbnRzOiBmYWxzZSxcbiAgb2JzZXJ2ZU11dGF0aW9uczogdHJ1ZSxcbiAgbXV0YXRlQXBwcm9hY2g6ICdhc3luYycsXG4gIGtlZXBPcmlnaW5hbFNvdXJjZTogdHJ1ZSxcbiAgbWVhc3VyZVBlcmZvcm1hbmNlOiBmYWxzZSxcbiAgc2hvd01pc3NpbmdJY29uczogdHJ1ZVxufTsgLy8gZmFtaWx5UHJlZml4IGlzIGRlcHJlY2F0ZWQgYnV0IHdlIG11c3Qgc3RpbGwgc3VwcG9ydCBpdCBpZiBwcmVzZW50XG5cbmlmIChpbml0aWFsLmZhbWlseVByZWZpeCkge1xuICBpbml0aWFsLmNzc1ByZWZpeCA9IGluaXRpYWwuZmFtaWx5UHJlZml4O1xufVxuXG52YXIgX2NvbmZpZyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBfZGVmYXVsdCksIGluaXRpYWwpO1xuXG5pZiAoIV9jb25maWcuYXV0b1JlcGxhY2VTdmcpIF9jb25maWcub2JzZXJ2ZU11dGF0aW9ucyA9IGZhbHNlO1xudmFyIGNvbmZpZyA9IHt9O1xuT2JqZWN0LmtleXMoX2RlZmF1bHQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29uZmlnLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbCkge1xuICAgICAgX2NvbmZpZ1trZXldID0gdmFsO1xuXG4gICAgICBfb25DaGFuZ2VDYi5mb3JFYWNoKGZ1bmN0aW9uIChjYikge1xuICAgICAgICByZXR1cm4gY2IoY29uZmlnKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX2NvbmZpZ1trZXldO1xuICAgIH1cbiAgfSk7XG59KTsgLy8gZmFtaWx5UHJlZml4IGlzIGRlcHJlY2F0ZWQgYXMgb2YgNi4yLjAgYW5kIHNob3VsZCBiZSByZW1vdmVkIGluIDcuMC4wXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb25maWcsICdmYW1pbHlQcmVmaXgnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHNldDogZnVuY3Rpb24gc2V0KHZhbCkge1xuICAgIF9jb25maWcuY3NzUHJlZml4ID0gdmFsO1xuXG4gICAgX29uQ2hhbmdlQ2IuZm9yRWFjaChmdW5jdGlvbiAoY2IpIHtcbiAgICAgIHJldHVybiBjYihjb25maWcpO1xuICAgIH0pO1xuICB9LFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2NvbmZpZy5jc3NQcmVmaXg7XG4gIH1cbn0pO1xuV0lORE9XLkZvbnRBd2Vzb21lQ29uZmlnID0gY29uZmlnO1xudmFyIF9vbkNoYW5nZUNiID0gW107XG5mdW5jdGlvbiBvbkNoYW5nZShjYikge1xuICBfb25DaGFuZ2VDYi5wdXNoKGNiKTtcblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIF9vbkNoYW5nZUNiLnNwbGljZShfb25DaGFuZ2VDYi5pbmRleE9mKGNiKSwgMSk7XG4gIH07XG59XG5cbnZhciBkID0gVU5JVFNfSU5fR1JJRDtcbnZhciBtZWFuaW5nbGVzc1RyYW5zZm9ybSA9IHtcbiAgc2l6ZTogMTYsXG4gIHg6IDAsXG4gIHk6IDAsXG4gIHJvdGF0ZTogMCxcbiAgZmxpcFg6IGZhbHNlLFxuICBmbGlwWTogZmFsc2Vcbn07XG5mdW5jdGlvbiBpbnNlcnRDc3MoY3NzKSB7XG4gIGlmICghY3NzIHx8ICFJU19ET00pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc3R5bGUgPSBET0NVTUVOVC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dC9jc3MnKTtcbiAgc3R5bGUuaW5uZXJIVE1MID0gY3NzO1xuICB2YXIgaGVhZENoaWxkcmVuID0gRE9DVU1FTlQuaGVhZC5jaGlsZE5vZGVzO1xuICB2YXIgYmVmb3JlQ2hpbGQgPSBudWxsO1xuXG4gIGZvciAodmFyIGkgPSBoZWFkQ2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+IC0xOyBpLS0pIHtcbiAgICB2YXIgY2hpbGQgPSBoZWFkQ2hpbGRyZW5baV07XG4gICAgdmFyIHRhZ05hbWUgPSAoY2hpbGQudGFnTmFtZSB8fCAnJykudG9VcHBlckNhc2UoKTtcblxuICAgIGlmIChbJ1NUWUxFJywgJ0xJTksnXS5pbmRleE9mKHRhZ05hbWUpID4gLTEpIHtcbiAgICAgIGJlZm9yZUNoaWxkID0gY2hpbGQ7XG4gICAgfVxuICB9XG5cbiAgRE9DVU1FTlQuaGVhZC5pbnNlcnRCZWZvcmUoc3R5bGUsIGJlZm9yZUNoaWxkKTtcbiAgcmV0dXJuIGNzcztcbn1cbnZhciBpZFBvb2wgPSAnMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVonO1xuZnVuY3Rpb24gbmV4dFVuaXF1ZUlkKCkge1xuICB2YXIgc2l6ZSA9IDEyO1xuICB2YXIgaWQgPSAnJztcblxuICB3aGlsZSAoc2l6ZS0tID4gMCkge1xuICAgIGlkICs9IGlkUG9vbFtNYXRoLnJhbmRvbSgpICogNjIgfCAwXTtcbiAgfVxuXG4gIHJldHVybiBpZDtcbn1cbmZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XG4gIHZhciBhcnJheSA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAob2JqIHx8IFtdKS5sZW5ndGggPj4+IDA7IGktLTspIHtcbiAgICBhcnJheVtpXSA9IG9ialtpXTtcbiAgfVxuXG4gIHJldHVybiBhcnJheTtcbn1cbmZ1bmN0aW9uIGNsYXNzQXJyYXkobm9kZSkge1xuICBpZiAobm9kZS5jbGFzc0xpc3QpIHtcbiAgICByZXR1cm4gdG9BcnJheShub2RlLmNsYXNzTGlzdCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChub2RlLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykuc3BsaXQoJyAnKS5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBodG1sRXNjYXBlKHN0cikge1xuICByZXR1cm4gXCJcIi5jb25jYXQoc3RyKS5yZXBsYWNlKC8mL2csICcmYW1wOycpLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKS5yZXBsYWNlKC8nL2csICcmIzM5OycpLnJlcGxhY2UoLzwvZywgJyZsdDsnKS5yZXBsYWNlKC8+L2csICcmZ3Q7Jyk7XG59XG5mdW5jdGlvbiBqb2luQXR0cmlidXRlcyhhdHRyaWJ1dGVzKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzIHx8IHt9KS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgYXR0cmlidXRlTmFtZSkge1xuICAgIHJldHVybiBhY2MgKyBcIlwiLmNvbmNhdChhdHRyaWJ1dGVOYW1lLCBcIj1cXFwiXCIpLmNvbmNhdChodG1sRXNjYXBlKGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV0pLCBcIlxcXCIgXCIpO1xuICB9LCAnJykudHJpbSgpO1xufVxuZnVuY3Rpb24gam9pblN0eWxlcyhzdHlsZXMpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHN0eWxlcyB8fCB7fSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHN0eWxlTmFtZSkge1xuICAgIHJldHVybiBhY2MgKyBcIlwiLmNvbmNhdChzdHlsZU5hbWUsIFwiOiBcIikuY29uY2F0KHN0eWxlc1tzdHlsZU5hbWVdLnRyaW0oKSwgXCI7XCIpO1xuICB9LCAnJyk7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1Jc01lYW5pbmdmdWwodHJhbnNmb3JtKSB7XG4gIHJldHVybiB0cmFuc2Zvcm0uc2l6ZSAhPT0gbWVhbmluZ2xlc3NUcmFuc2Zvcm0uc2l6ZSB8fCB0cmFuc2Zvcm0ueCAhPT0gbWVhbmluZ2xlc3NUcmFuc2Zvcm0ueCB8fCB0cmFuc2Zvcm0ueSAhPT0gbWVhbmluZ2xlc3NUcmFuc2Zvcm0ueSB8fCB0cmFuc2Zvcm0ucm90YXRlICE9PSBtZWFuaW5nbGVzc1RyYW5zZm9ybS5yb3RhdGUgfHwgdHJhbnNmb3JtLmZsaXBYIHx8IHRyYW5zZm9ybS5mbGlwWTtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybUZvclN2ZyhfcmVmKSB7XG4gIHZhciB0cmFuc2Zvcm0gPSBfcmVmLnRyYW5zZm9ybSxcbiAgICAgIGNvbnRhaW5lcldpZHRoID0gX3JlZi5jb250YWluZXJXaWR0aCxcbiAgICAgIGljb25XaWR0aCA9IF9yZWYuaWNvbldpZHRoO1xuICB2YXIgb3V0ZXIgPSB7XG4gICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIi5jb25jYXQoY29udGFpbmVyV2lkdGggLyAyLCBcIiAyNTYpXCIpXG4gIH07XG4gIHZhciBpbm5lclRyYW5zbGF0ZSA9IFwidHJhbnNsYXRlKFwiLmNvbmNhdCh0cmFuc2Zvcm0ueCAqIDMyLCBcIiwgXCIpLmNvbmNhdCh0cmFuc2Zvcm0ueSAqIDMyLCBcIikgXCIpO1xuICB2YXIgaW5uZXJTY2FsZSA9IFwic2NhbGUoXCIuY29uY2F0KHRyYW5zZm9ybS5zaXplIC8gMTYgKiAodHJhbnNmb3JtLmZsaXBYID8gLTEgOiAxKSwgXCIsIFwiKS5jb25jYXQodHJhbnNmb3JtLnNpemUgLyAxNiAqICh0cmFuc2Zvcm0uZmxpcFkgPyAtMSA6IDEpLCBcIikgXCIpO1xuICB2YXIgaW5uZXJSb3RhdGUgPSBcInJvdGF0ZShcIi5jb25jYXQodHJhbnNmb3JtLnJvdGF0ZSwgXCIgMCAwKVwiKTtcbiAgdmFyIGlubmVyID0ge1xuICAgIHRyYW5zZm9ybTogXCJcIi5jb25jYXQoaW5uZXJUcmFuc2xhdGUsIFwiIFwiKS5jb25jYXQoaW5uZXJTY2FsZSwgXCIgXCIpLmNvbmNhdChpbm5lclJvdGF0ZSlcbiAgfTtcbiAgdmFyIHBhdGggPSB7XG4gICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIi5jb25jYXQoaWNvbldpZHRoIC8gMiAqIC0xLCBcIiAtMjU2KVwiKVxuICB9O1xuICByZXR1cm4ge1xuICAgIG91dGVyOiBvdXRlcixcbiAgICBpbm5lcjogaW5uZXIsXG4gICAgcGF0aDogcGF0aFxuICB9O1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtRm9yQ3NzKF9yZWYyKSB7XG4gIHZhciB0cmFuc2Zvcm0gPSBfcmVmMi50cmFuc2Zvcm0sXG4gICAgICBfcmVmMiR3aWR0aCA9IF9yZWYyLndpZHRoLFxuICAgICAgd2lkdGggPSBfcmVmMiR3aWR0aCA9PT0gdm9pZCAwID8gVU5JVFNfSU5fR1JJRCA6IF9yZWYyJHdpZHRoLFxuICAgICAgX3JlZjIkaGVpZ2h0ID0gX3JlZjIuaGVpZ2h0LFxuICAgICAgaGVpZ2h0ID0gX3JlZjIkaGVpZ2h0ID09PSB2b2lkIDAgPyBVTklUU19JTl9HUklEIDogX3JlZjIkaGVpZ2h0LFxuICAgICAgX3JlZjIkc3RhcnRDZW50ZXJlZCA9IF9yZWYyLnN0YXJ0Q2VudGVyZWQsXG4gICAgICBzdGFydENlbnRlcmVkID0gX3JlZjIkc3RhcnRDZW50ZXJlZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmMiRzdGFydENlbnRlcmVkO1xuICB2YXIgdmFsID0gJyc7XG5cbiAgaWYgKHN0YXJ0Q2VudGVyZWQgJiYgSVNfSUUpIHtcbiAgICB2YWwgKz0gXCJ0cmFuc2xhdGUoXCIuY29uY2F0KHRyYW5zZm9ybS54IC8gZCAtIHdpZHRoIC8gMiwgXCJlbSwgXCIpLmNvbmNhdCh0cmFuc2Zvcm0ueSAvIGQgLSBoZWlnaHQgLyAyLCBcImVtKSBcIik7XG4gIH0gZWxzZSBpZiAoc3RhcnRDZW50ZXJlZCkge1xuICAgIHZhbCArPSBcInRyYW5zbGF0ZShjYWxjKC01MCUgKyBcIi5jb25jYXQodHJhbnNmb3JtLnggLyBkLCBcImVtKSwgY2FsYygtNTAlICsgXCIpLmNvbmNhdCh0cmFuc2Zvcm0ueSAvIGQsIFwiZW0pKSBcIik7XG4gIH0gZWxzZSB7XG4gICAgdmFsICs9IFwidHJhbnNsYXRlKFwiLmNvbmNhdCh0cmFuc2Zvcm0ueCAvIGQsIFwiZW0sIFwiKS5jb25jYXQodHJhbnNmb3JtLnkgLyBkLCBcImVtKSBcIik7XG4gIH1cblxuICB2YWwgKz0gXCJzY2FsZShcIi5jb25jYXQodHJhbnNmb3JtLnNpemUgLyBkICogKHRyYW5zZm9ybS5mbGlwWCA/IC0xIDogMSksIFwiLCBcIikuY29uY2F0KHRyYW5zZm9ybS5zaXplIC8gZCAqICh0cmFuc2Zvcm0uZmxpcFkgPyAtMSA6IDEpLCBcIikgXCIpO1xuICB2YWwgKz0gXCJyb3RhdGUoXCIuY29uY2F0KHRyYW5zZm9ybS5yb3RhdGUsIFwiZGVnKSBcIik7XG4gIHJldHVybiB2YWw7XG59XG5cbnZhciBiYXNlU3R5bGVzID0gXCI6cm9vdCwgOmhvc3Qge1xcbiAgLS1mYS1mb250LXNvbGlkOiBub3JtYWwgOTAwIDFlbS8xIFxcXCJGb250IEF3ZXNvbWUgNiBTb2xpZFxcXCI7XFxuICAtLWZhLWZvbnQtcmVndWxhcjogbm9ybWFsIDQwMCAxZW0vMSBcXFwiRm9udCBBd2Vzb21lIDYgUmVndWxhclxcXCI7XFxuICAtLWZhLWZvbnQtbGlnaHQ6IG5vcm1hbCAzMDAgMWVtLzEgXFxcIkZvbnQgQXdlc29tZSA2IExpZ2h0XFxcIjtcXG4gIC0tZmEtZm9udC10aGluOiBub3JtYWwgMTAwIDFlbS8xIFxcXCJGb250IEF3ZXNvbWUgNiBUaGluXFxcIjtcXG4gIC0tZmEtZm9udC1kdW90b25lOiBub3JtYWwgOTAwIDFlbS8xIFxcXCJGb250IEF3ZXNvbWUgNiBEdW90b25lXFxcIjtcXG4gIC0tZmEtZm9udC1zaGFycC1zb2xpZDogbm9ybWFsIDkwMCAxZW0vMSBcXFwiRm9udCBBd2Vzb21lIDYgU2hhcnBcXFwiO1xcbiAgLS1mYS1mb250LWJyYW5kczogbm9ybWFsIDQwMCAxZW0vMSBcXFwiRm9udCBBd2Vzb21lIDYgQnJhbmRzXFxcIjtcXG59XFxuXFxuc3ZnOm5vdCg6cm9vdCkuc3ZnLWlubGluZS0tZmEsIHN2Zzpub3QoOmhvc3QpLnN2Zy1pbmxpbmUtLWZhIHtcXG4gIG92ZXJmbG93OiB2aXNpYmxlO1xcbiAgYm94LXNpemluZzogY29udGVudC1ib3g7XFxufVxcblxcbi5zdmctaW5saW5lLS1mYSB7XFxuICBkaXNwbGF5OiB2YXIoLS1mYS1kaXNwbGF5LCBpbmxpbmUtYmxvY2spO1xcbiAgaGVpZ2h0OiAxZW07XFxuICBvdmVyZmxvdzogdmlzaWJsZTtcXG4gIHZlcnRpY2FsLWFsaWduOiAtMC4xMjVlbTtcXG59XFxuLnN2Zy1pbmxpbmUtLWZhLmZhLTJ4cyB7XFxuICB2ZXJ0aWNhbC1hbGlnbjogMC4xZW07XFxufVxcbi5zdmctaW5saW5lLS1mYS5mYS14cyB7XFxuICB2ZXJ0aWNhbC1hbGlnbjogMGVtO1xcbn1cXG4uc3ZnLWlubGluZS0tZmEuZmEtc20ge1xcbiAgdmVydGljYWwtYWxpZ246IC0wLjA3MTQyODU3MDVlbTtcXG59XFxuLnN2Zy1pbmxpbmUtLWZhLmZhLWxnIHtcXG4gIHZlcnRpY2FsLWFsaWduOiAtMC4yZW07XFxufVxcbi5zdmctaW5saW5lLS1mYS5mYS14bCB7XFxuICB2ZXJ0aWNhbC1hbGlnbjogLTAuMjVlbTtcXG59XFxuLnN2Zy1pbmxpbmUtLWZhLmZhLTJ4bCB7XFxuICB2ZXJ0aWNhbC1hbGlnbjogLTAuMzEyNWVtO1xcbn1cXG4uc3ZnLWlubGluZS0tZmEuZmEtcHVsbC1sZWZ0IHtcXG4gIG1hcmdpbi1yaWdodDogdmFyKC0tZmEtcHVsbC1tYXJnaW4sIDAuM2VtKTtcXG4gIHdpZHRoOiBhdXRvO1xcbn1cXG4uc3ZnLWlubGluZS0tZmEuZmEtcHVsbC1yaWdodCB7XFxuICBtYXJnaW4tbGVmdDogdmFyKC0tZmEtcHVsbC1tYXJnaW4sIDAuM2VtKTtcXG4gIHdpZHRoOiBhdXRvO1xcbn1cXG4uc3ZnLWlubGluZS0tZmEuZmEtbGkge1xcbiAgd2lkdGg6IHZhcigtLWZhLWxpLXdpZHRoLCAyZW0pO1xcbiAgdG9wOiAwLjI1ZW07XFxufVxcbi5zdmctaW5saW5lLS1mYS5mYS1mdyB7XFxuICB3aWR0aDogdmFyKC0tZmEtZnctd2lkdGgsIDEuMjVlbSk7XFxufVxcblxcbi5mYS1sYXllcnMgc3ZnLnN2Zy1pbmxpbmUtLWZhIHtcXG4gIGJvdHRvbTogMDtcXG4gIGxlZnQ6IDA7XFxuICBtYXJnaW46IGF1dG87XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICByaWdodDogMDtcXG4gIHRvcDogMDtcXG59XFxuXFxuLmZhLWxheWVycy1jb3VudGVyLCAuZmEtbGF5ZXJzLXRleHQge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbn1cXG5cXG4uZmEtbGF5ZXJzIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIGhlaWdodDogMWVtO1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgdmVydGljYWwtYWxpZ246IC0wLjEyNWVtO1xcbiAgd2lkdGg6IDFlbTtcXG59XFxuLmZhLWxheWVycyBzdmcuc3ZnLWlubGluZS0tZmEge1xcbiAgLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiBjZW50ZXIgY2VudGVyO1xcbiAgICAgICAgICB0cmFuc2Zvcm0tb3JpZ2luOiBjZW50ZXIgY2VudGVyO1xcbn1cXG5cXG4uZmEtbGF5ZXJzLXRleHQge1xcbiAgbGVmdDogNTAlO1xcbiAgdG9wOiA1MCU7XFxuICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpO1xcbiAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAtNTAlKTtcXG4gIC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjogY2VudGVyIGNlbnRlcjtcXG4gICAgICAgICAgdHJhbnNmb3JtLW9yaWdpbjogY2VudGVyIGNlbnRlcjtcXG59XFxuXFxuLmZhLWxheWVycy1jb3VudGVyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWZhLWNvdW50ZXItYmFja2dyb3VuZC1jb2xvciwgI2ZmMjUzYSk7XFxuICBib3JkZXItcmFkaXVzOiB2YXIoLS1mYS1jb3VudGVyLWJvcmRlci1yYWRpdXMsIDFlbSk7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgY29sb3I6IHZhcigtLWZhLWludmVyc2UsICNmZmYpO1xcbiAgbGluZS1oZWlnaHQ6IHZhcigtLWZhLWNvdW50ZXItbGluZS1oZWlnaHQsIDEpO1xcbiAgbWF4LXdpZHRoOiB2YXIoLS1mYS1jb3VudGVyLW1heC13aWR0aCwgNWVtKTtcXG4gIG1pbi13aWR0aDogdmFyKC0tZmEtY291bnRlci1taW4td2lkdGgsIDEuNWVtKTtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICBwYWRkaW5nOiB2YXIoLS1mYS1jb3VudGVyLXBhZGRpbmcsIDAuMjVlbSAwLjVlbSk7XFxuICByaWdodDogdmFyKC0tZmEtcmlnaHQsIDApO1xcbiAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XFxuICB0b3A6IHZhcigtLWZhLXRvcCwgMCk7XFxuICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUodmFyKC0tZmEtY291bnRlci1zY2FsZSwgMC4yNSkpO1xcbiAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKHZhcigtLWZhLWNvdW50ZXItc2NhbGUsIDAuMjUpKTtcXG4gIC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjogdG9wIHJpZ2h0O1xcbiAgICAgICAgICB0cmFuc2Zvcm0tb3JpZ2luOiB0b3AgcmlnaHQ7XFxufVxcblxcbi5mYS1sYXllcnMtYm90dG9tLXJpZ2h0IHtcXG4gIGJvdHRvbTogdmFyKC0tZmEtYm90dG9tLCAwKTtcXG4gIHJpZ2h0OiB2YXIoLS1mYS1yaWdodCwgMCk7XFxuICB0b3A6IGF1dG87XFxuICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUodmFyKC0tZmEtbGF5ZXJzLXNjYWxlLCAwLjI1KSk7XFxuICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUodmFyKC0tZmEtbGF5ZXJzLXNjYWxlLCAwLjI1KSk7XFxuICAtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IGJvdHRvbSByaWdodDtcXG4gICAgICAgICAgdHJhbnNmb3JtLW9yaWdpbjogYm90dG9tIHJpZ2h0O1xcbn1cXG5cXG4uZmEtbGF5ZXJzLWJvdHRvbS1sZWZ0IHtcXG4gIGJvdHRvbTogdmFyKC0tZmEtYm90dG9tLCAwKTtcXG4gIGxlZnQ6IHZhcigtLWZhLWxlZnQsIDApO1xcbiAgcmlnaHQ6IGF1dG87XFxuICB0b3A6IGF1dG87XFxuICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUodmFyKC0tZmEtbGF5ZXJzLXNjYWxlLCAwLjI1KSk7XFxuICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUodmFyKC0tZmEtbGF5ZXJzLXNjYWxlLCAwLjI1KSk7XFxuICAtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IGJvdHRvbSBsZWZ0O1xcbiAgICAgICAgICB0cmFuc2Zvcm0tb3JpZ2luOiBib3R0b20gbGVmdDtcXG59XFxuXFxuLmZhLWxheWVycy10b3AtcmlnaHQge1xcbiAgdG9wOiB2YXIoLS1mYS10b3AsIDApO1xcbiAgcmlnaHQ6IHZhcigtLWZhLXJpZ2h0LCAwKTtcXG4gIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSh2YXIoLS1mYS1sYXllcnMtc2NhbGUsIDAuMjUpKTtcXG4gICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSh2YXIoLS1mYS1sYXllcnMtc2NhbGUsIDAuMjUpKTtcXG4gIC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjogdG9wIHJpZ2h0O1xcbiAgICAgICAgICB0cmFuc2Zvcm0tb3JpZ2luOiB0b3AgcmlnaHQ7XFxufVxcblxcbi5mYS1sYXllcnMtdG9wLWxlZnQge1xcbiAgbGVmdDogdmFyKC0tZmEtbGVmdCwgMCk7XFxuICByaWdodDogYXV0bztcXG4gIHRvcDogdmFyKC0tZmEtdG9wLCAwKTtcXG4gIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSh2YXIoLS1mYS1sYXllcnMtc2NhbGUsIDAuMjUpKTtcXG4gICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSh2YXIoLS1mYS1sYXllcnMtc2NhbGUsIDAuMjUpKTtcXG4gIC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjogdG9wIGxlZnQ7XFxuICAgICAgICAgIHRyYW5zZm9ybS1vcmlnaW46IHRvcCBsZWZ0O1xcbn1cXG5cXG4uZmEtMXgge1xcbiAgZm9udC1zaXplOiAxZW07XFxufVxcblxcbi5mYS0yeCB7XFxuICBmb250LXNpemU6IDJlbTtcXG59XFxuXFxuLmZhLTN4IHtcXG4gIGZvbnQtc2l6ZTogM2VtO1xcbn1cXG5cXG4uZmEtNHgge1xcbiAgZm9udC1zaXplOiA0ZW07XFxufVxcblxcbi5mYS01eCB7XFxuICBmb250LXNpemU6IDVlbTtcXG59XFxuXFxuLmZhLTZ4IHtcXG4gIGZvbnQtc2l6ZTogNmVtO1xcbn1cXG5cXG4uZmEtN3gge1xcbiAgZm9udC1zaXplOiA3ZW07XFxufVxcblxcbi5mYS04eCB7XFxuICBmb250LXNpemU6IDhlbTtcXG59XFxuXFxuLmZhLTl4IHtcXG4gIGZvbnQtc2l6ZTogOWVtO1xcbn1cXG5cXG4uZmEtMTB4IHtcXG4gIGZvbnQtc2l6ZTogMTBlbTtcXG59XFxuXFxuLmZhLTJ4cyB7XFxuICBmb250LXNpemU6IDAuNjI1ZW07XFxuICBsaW5lLWhlaWdodDogMC4xZW07XFxuICB2ZXJ0aWNhbC1hbGlnbjogMC4yMjVlbTtcXG59XFxuXFxuLmZhLXhzIHtcXG4gIGZvbnQtc2l6ZTogMC43NWVtO1xcbiAgbGluZS1oZWlnaHQ6IDAuMDgzMzMzMzMzN2VtO1xcbiAgdmVydGljYWwtYWxpZ246IDAuMTI1ZW07XFxufVxcblxcbi5mYS1zbSB7XFxuICBmb250LXNpemU6IDAuODc1ZW07XFxuICBsaW5lLWhlaWdodDogMC4wNzE0Mjg1NzE4ZW07XFxuICB2ZXJ0aWNhbC1hbGlnbjogMC4wNTM1NzE0Mjk1ZW07XFxufVxcblxcbi5mYS1sZyB7XFxuICBmb250LXNpemU6IDEuMjVlbTtcXG4gIGxpbmUtaGVpZ2h0OiAwLjA1ZW07XFxuICB2ZXJ0aWNhbC1hbGlnbjogLTAuMDc1ZW07XFxufVxcblxcbi5mYS14bCB7XFxuICBmb250LXNpemU6IDEuNWVtO1xcbiAgbGluZS1oZWlnaHQ6IDAuMDQxNjY2NjY4MmVtO1xcbiAgdmVydGljYWwtYWxpZ246IC0wLjEyNWVtO1xcbn1cXG5cXG4uZmEtMnhsIHtcXG4gIGZvbnQtc2l6ZTogMmVtO1xcbiAgbGluZS1oZWlnaHQ6IDAuMDMxMjVlbTtcXG4gIHZlcnRpY2FsLWFsaWduOiAtMC4xODc1ZW07XFxufVxcblxcbi5mYS1mdyB7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICB3aWR0aDogMS4yNWVtO1xcbn1cXG5cXG4uZmEtdWwge1xcbiAgbGlzdC1zdHlsZS10eXBlOiBub25lO1xcbiAgbWFyZ2luLWxlZnQ6IHZhcigtLWZhLWxpLW1hcmdpbiwgMi41ZW0pO1xcbiAgcGFkZGluZy1sZWZ0OiAwO1xcbn1cXG4uZmEtdWwgPiBsaSB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxufVxcblxcbi5mYS1saSB7XFxuICBsZWZ0OiBjYWxjKHZhcigtLWZhLWxpLXdpZHRoLCAyZW0pICogLTEpO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgd2lkdGg6IHZhcigtLWZhLWxpLXdpZHRoLCAyZW0pO1xcbiAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7XFxufVxcblxcbi5mYS1ib3JkZXIge1xcbiAgYm9yZGVyLWNvbG9yOiB2YXIoLS1mYS1ib3JkZXItY29sb3IsICNlZWUpO1xcbiAgYm9yZGVyLXJhZGl1czogdmFyKC0tZmEtYm9yZGVyLXJhZGl1cywgMC4xZW0pO1xcbiAgYm9yZGVyLXN0eWxlOiB2YXIoLS1mYS1ib3JkZXItc3R5bGUsIHNvbGlkKTtcXG4gIGJvcmRlci13aWR0aDogdmFyKC0tZmEtYm9yZGVyLXdpZHRoLCAwLjA4ZW0pO1xcbiAgcGFkZGluZzogdmFyKC0tZmEtYm9yZGVyLXBhZGRpbmcsIDAuMmVtIDAuMjVlbSAwLjE1ZW0pO1xcbn1cXG5cXG4uZmEtcHVsbC1sZWZ0IHtcXG4gIGZsb2F0OiBsZWZ0O1xcbiAgbWFyZ2luLXJpZ2h0OiB2YXIoLS1mYS1wdWxsLW1hcmdpbiwgMC4zZW0pO1xcbn1cXG5cXG4uZmEtcHVsbC1yaWdodCB7XFxuICBmbG9hdDogcmlnaHQ7XFxuICBtYXJnaW4tbGVmdDogdmFyKC0tZmEtcHVsbC1tYXJnaW4sIDAuM2VtKTtcXG59XFxuXFxuLmZhLWJlYXQge1xcbiAgLXdlYmtpdC1hbmltYXRpb24tbmFtZTogZmEtYmVhdDtcXG4gICAgICAgICAgYW5pbWF0aW9uLW5hbWU6IGZhLWJlYXQ7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1kZWxheTogdmFyKC0tZmEtYW5pbWF0aW9uLWRlbGF5LCAwcyk7XFxuICAgICAgICAgIGFuaW1hdGlvbi1kZWxheTogdmFyKC0tZmEtYW5pbWF0aW9uLWRlbGF5LCAwcyk7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1kaXJlY3Rpb246IHZhcigtLWZhLWFuaW1hdGlvbi1kaXJlY3Rpb24sIG5vcm1hbCk7XFxuICAgICAgICAgIGFuaW1hdGlvbi1kaXJlY3Rpb246IHZhcigtLWZhLWFuaW1hdGlvbi1kaXJlY3Rpb24sIG5vcm1hbCk7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjogdmFyKC0tZmEtYW5pbWF0aW9uLWR1cmF0aW9uLCAxcyk7XFxuICAgICAgICAgIGFuaW1hdGlvbi1kdXJhdGlvbjogdmFyKC0tZmEtYW5pbWF0aW9uLWR1cmF0aW9uLCAxcyk7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IHZhcigtLWZhLWFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQsIGluZmluaXRlKTtcXG4gICAgICAgICAgYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogdmFyKC0tZmEtYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudCwgaW5maW5pdGUpO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiB2YXIoLS1mYS1hbmltYXRpb24tdGltaW5nLCBlYXNlLWluLW91dCk7XFxuICAgICAgICAgIGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IHZhcigtLWZhLWFuaW1hdGlvbi10aW1pbmcsIGVhc2UtaW4tb3V0KTtcXG59XFxuXFxuLmZhLWJvdW5jZSB7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1uYW1lOiBmYS1ib3VuY2U7XFxuICAgICAgICAgIGFuaW1hdGlvbi1uYW1lOiBmYS1ib3VuY2U7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1kZWxheTogdmFyKC0tZmEtYW5pbWF0aW9uLWRlbGF5LCAwcyk7XFxuICAgICAgICAgIGFuaW1hdGlvbi1kZWxheTogdmFyKC0tZmEtYW5pbWF0aW9uLWRlbGF5LCAwcyk7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1kaXJlY3Rpb246IHZhcigtLWZhLWFuaW1hdGlvbi1kaXJlY3Rpb24sIG5vcm1hbCk7XFxuICAgICAgICAgIGFuaW1hdGlvbi1kaXJlY3Rpb246IHZhcigtLWZhLWFuaW1hdGlvbi1kaXJlY3Rpb24sIG5vcm1hbCk7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjogdmFyKC0tZmEtYW5pbWF0aW9uLWR1cmF0aW9uLCAxcyk7XFxuICAgICAgICAgIGFuaW1hdGlvbi1kdXJhdGlvbjogdmFyKC0tZmEtYW5pbWF0aW9uLWR1cmF0aW9uLCAxcyk7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IHZhcigtLWZhLWFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQsIGluZmluaXRlKTtcXG4gICAgICAgICAgYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogdmFyKC0tZmEtYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudCwgaW5maW5pdGUpO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiB2YXIoLS1mYS1hbmltYXRpb24tdGltaW5nLCBjdWJpYy1iZXppZXIoMC4yOCwgMC44NCwgMC40MiwgMSkpO1xcbiAgICAgICAgICBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiB2YXIoLS1mYS1hbmltYXRpb24tdGltaW5nLCBjdWJpYy1iZXppZXIoMC4yOCwgMC44NCwgMC40MiwgMSkpO1xcbn1cXG5cXG4uZmEtZmFkZSB7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1uYW1lOiBmYS1mYWRlO1xcbiAgICAgICAgICBhbmltYXRpb24tbmFtZTogZmEtZmFkZTtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWRlbGF5OiB2YXIoLS1mYS1hbmltYXRpb24tZGVsYXksIDBzKTtcXG4gICAgICAgICAgYW5pbWF0aW9uLWRlbGF5OiB2YXIoLS1mYS1hbmltYXRpb24tZGVsYXksIDBzKTtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWRpcmVjdGlvbjogdmFyKC0tZmEtYW5pbWF0aW9uLWRpcmVjdGlvbiwgbm9ybWFsKTtcXG4gICAgICAgICAgYW5pbWF0aW9uLWRpcmVjdGlvbjogdmFyKC0tZmEtYW5pbWF0aW9uLWRpcmVjdGlvbiwgbm9ybWFsKTtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWR1cmF0aW9uOiB2YXIoLS1mYS1hbmltYXRpb24tZHVyYXRpb24sIDFzKTtcXG4gICAgICAgICAgYW5pbWF0aW9uLWR1cmF0aW9uOiB2YXIoLS1mYS1hbmltYXRpb24tZHVyYXRpb24sIDFzKTtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogdmFyKC0tZmEtYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudCwgaW5maW5pdGUpO1xcbiAgICAgICAgICBhbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiB2YXIoLS1mYS1hbmltYXRpb24taXRlcmF0aW9uLWNvdW50LCBpbmZpbml0ZSk7XFxuICAtd2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IHZhcigtLWZhLWFuaW1hdGlvbi10aW1pbmcsIGN1YmljLWJlemllcigwLjQsIDAsIDAuNiwgMSkpO1xcbiAgICAgICAgICBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiB2YXIoLS1mYS1hbmltYXRpb24tdGltaW5nLCBjdWJpYy1iZXppZXIoMC40LCAwLCAwLjYsIDEpKTtcXG59XFxuXFxuLmZhLWJlYXQtZmFkZSB7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1uYW1lOiBmYS1iZWF0LWZhZGU7XFxuICAgICAgICAgIGFuaW1hdGlvbi1uYW1lOiBmYS1iZWF0LWZhZGU7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1kZWxheTogdmFyKC0tZmEtYW5pbWF0aW9uLWRlbGF5LCAwcyk7XFxuICAgICAgICAgIGFuaW1hdGlvbi1kZWxheTogdmFyKC0tZmEtYW5pbWF0aW9uLWRlbGF5LCAwcyk7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1kaXJlY3Rpb246IHZhcigtLWZhLWFuaW1hdGlvbi1kaXJlY3Rpb24sIG5vcm1hbCk7XFxuICAgICAgICAgIGFuaW1hdGlvbi1kaXJlY3Rpb246IHZhcigtLWZhLWFuaW1hdGlvbi1kaXJlY3Rpb24sIG5vcm1hbCk7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjogdmFyKC0tZmEtYW5pbWF0aW9uLWR1cmF0aW9uLCAxcyk7XFxuICAgICAgICAgIGFuaW1hdGlvbi1kdXJhdGlvbjogdmFyKC0tZmEtYW5pbWF0aW9uLWR1cmF0aW9uLCAxcyk7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IHZhcigtLWZhLWFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQsIGluZmluaXRlKTtcXG4gICAgICAgICAgYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogdmFyKC0tZmEtYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudCwgaW5maW5pdGUpO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiB2YXIoLS1mYS1hbmltYXRpb24tdGltaW5nLCBjdWJpYy1iZXppZXIoMC40LCAwLCAwLjYsIDEpKTtcXG4gICAgICAgICAgYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogdmFyKC0tZmEtYW5pbWF0aW9uLXRpbWluZywgY3ViaWMtYmV6aWVyKDAuNCwgMCwgMC42LCAxKSk7XFxufVxcblxcbi5mYS1mbGlwIHtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLW5hbWU6IGZhLWZsaXA7XFxuICAgICAgICAgIGFuaW1hdGlvbi1uYW1lOiBmYS1mbGlwO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZGVsYXk6IHZhcigtLWZhLWFuaW1hdGlvbi1kZWxheSwgMHMpO1xcbiAgICAgICAgICBhbmltYXRpb24tZGVsYXk6IHZhcigtLWZhLWFuaW1hdGlvbi1kZWxheSwgMHMpO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZGlyZWN0aW9uOiB2YXIoLS1mYS1hbmltYXRpb24tZGlyZWN0aW9uLCBub3JtYWwpO1xcbiAgICAgICAgICBhbmltYXRpb24tZGlyZWN0aW9uOiB2YXIoLS1mYS1hbmltYXRpb24tZGlyZWN0aW9uLCBub3JtYWwpO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZHVyYXRpb246IHZhcigtLWZhLWFuaW1hdGlvbi1kdXJhdGlvbiwgMXMpO1xcbiAgICAgICAgICBhbmltYXRpb24tZHVyYXRpb246IHZhcigtLWZhLWFuaW1hdGlvbi1kdXJhdGlvbiwgMXMpO1xcbiAgLXdlYmtpdC1hbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiB2YXIoLS1mYS1hbmltYXRpb24taXRlcmF0aW9uLWNvdW50LCBpbmZpbml0ZSk7XFxuICAgICAgICAgIGFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IHZhcigtLWZhLWFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQsIGluZmluaXRlKTtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogdmFyKC0tZmEtYW5pbWF0aW9uLXRpbWluZywgZWFzZS1pbi1vdXQpO1xcbiAgICAgICAgICBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiB2YXIoLS1mYS1hbmltYXRpb24tdGltaW5nLCBlYXNlLWluLW91dCk7XFxufVxcblxcbi5mYS1zaGFrZSB7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1uYW1lOiBmYS1zaGFrZTtcXG4gICAgICAgICAgYW5pbWF0aW9uLW5hbWU6IGZhLXNoYWtlO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZGVsYXk6IHZhcigtLWZhLWFuaW1hdGlvbi1kZWxheSwgMHMpO1xcbiAgICAgICAgICBhbmltYXRpb24tZGVsYXk6IHZhcigtLWZhLWFuaW1hdGlvbi1kZWxheSwgMHMpO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZGlyZWN0aW9uOiB2YXIoLS1mYS1hbmltYXRpb24tZGlyZWN0aW9uLCBub3JtYWwpO1xcbiAgICAgICAgICBhbmltYXRpb24tZGlyZWN0aW9uOiB2YXIoLS1mYS1hbmltYXRpb24tZGlyZWN0aW9uLCBub3JtYWwpO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZHVyYXRpb246IHZhcigtLWZhLWFuaW1hdGlvbi1kdXJhdGlvbiwgMXMpO1xcbiAgICAgICAgICBhbmltYXRpb24tZHVyYXRpb246IHZhcigtLWZhLWFuaW1hdGlvbi1kdXJhdGlvbiwgMXMpO1xcbiAgLXdlYmtpdC1hbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiB2YXIoLS1mYS1hbmltYXRpb24taXRlcmF0aW9uLWNvdW50LCBpbmZpbml0ZSk7XFxuICAgICAgICAgIGFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IHZhcigtLWZhLWFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQsIGluZmluaXRlKTtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogdmFyKC0tZmEtYW5pbWF0aW9uLXRpbWluZywgbGluZWFyKTtcXG4gICAgICAgICAgYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogdmFyKC0tZmEtYW5pbWF0aW9uLXRpbWluZywgbGluZWFyKTtcXG59XFxuXFxuLmZhLXNwaW4ge1xcbiAgLXdlYmtpdC1hbmltYXRpb24tbmFtZTogZmEtc3BpbjtcXG4gICAgICAgICAgYW5pbWF0aW9uLW5hbWU6IGZhLXNwaW47XFxuICAtd2Via2l0LWFuaW1hdGlvbi1kZWxheTogdmFyKC0tZmEtYW5pbWF0aW9uLWRlbGF5LCAwcyk7XFxuICAgICAgICAgIGFuaW1hdGlvbi1kZWxheTogdmFyKC0tZmEtYW5pbWF0aW9uLWRlbGF5LCAwcyk7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1kaXJlY3Rpb246IHZhcigtLWZhLWFuaW1hdGlvbi1kaXJlY3Rpb24sIG5vcm1hbCk7XFxuICAgICAgICAgIGFuaW1hdGlvbi1kaXJlY3Rpb246IHZhcigtLWZhLWFuaW1hdGlvbi1kaXJlY3Rpb24sIG5vcm1hbCk7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjogdmFyKC0tZmEtYW5pbWF0aW9uLWR1cmF0aW9uLCAycyk7XFxuICAgICAgICAgIGFuaW1hdGlvbi1kdXJhdGlvbjogdmFyKC0tZmEtYW5pbWF0aW9uLWR1cmF0aW9uLCAycyk7XFxuICAtd2Via2l0LWFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IHZhcigtLWZhLWFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQsIGluZmluaXRlKTtcXG4gICAgICAgICAgYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogdmFyKC0tZmEtYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudCwgaW5maW5pdGUpO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiB2YXIoLS1mYS1hbmltYXRpb24tdGltaW5nLCBsaW5lYXIpO1xcbiAgICAgICAgICBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiB2YXIoLS1mYS1hbmltYXRpb24tdGltaW5nLCBsaW5lYXIpO1xcbn1cXG5cXG4uZmEtc3Bpbi1yZXZlcnNlIHtcXG4gIC0tZmEtYW5pbWF0aW9uLWRpcmVjdGlvbjogcmV2ZXJzZTtcXG59XFxuXFxuLmZhLXB1bHNlLFxcbi5mYS1zcGluLXB1bHNlIHtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLW5hbWU6IGZhLXNwaW47XFxuICAgICAgICAgIGFuaW1hdGlvbi1uYW1lOiBmYS1zcGluO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZGlyZWN0aW9uOiB2YXIoLS1mYS1hbmltYXRpb24tZGlyZWN0aW9uLCBub3JtYWwpO1xcbiAgICAgICAgICBhbmltYXRpb24tZGlyZWN0aW9uOiB2YXIoLS1mYS1hbmltYXRpb24tZGlyZWN0aW9uLCBub3JtYWwpO1xcbiAgLXdlYmtpdC1hbmltYXRpb24tZHVyYXRpb246IHZhcigtLWZhLWFuaW1hdGlvbi1kdXJhdGlvbiwgMXMpO1xcbiAgICAgICAgICBhbmltYXRpb24tZHVyYXRpb246IHZhcigtLWZhLWFuaW1hdGlvbi1kdXJhdGlvbiwgMXMpO1xcbiAgLXdlYmtpdC1hbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiB2YXIoLS1mYS1hbmltYXRpb24taXRlcmF0aW9uLWNvdW50LCBpbmZpbml0ZSk7XFxuICAgICAgICAgIGFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IHZhcigtLWZhLWFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQsIGluZmluaXRlKTtcXG4gIC13ZWJraXQtYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogdmFyKC0tZmEtYW5pbWF0aW9uLXRpbWluZywgc3RlcHMoOCkpO1xcbiAgICAgICAgICBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiB2YXIoLS1mYS1hbmltYXRpb24tdGltaW5nLCBzdGVwcyg4KSk7XFxufVxcblxcbkBtZWRpYSAocHJlZmVycy1yZWR1Y2VkLW1vdGlvbjogcmVkdWNlKSB7XFxuICAuZmEtYmVhdCxcXG4uZmEtYm91bmNlLFxcbi5mYS1mYWRlLFxcbi5mYS1iZWF0LWZhZGUsXFxuLmZhLWZsaXAsXFxuLmZhLXB1bHNlLFxcbi5mYS1zaGFrZSxcXG4uZmEtc3BpbixcXG4uZmEtc3Bpbi1wdWxzZSB7XFxuICAgIC13ZWJraXQtYW5pbWF0aW9uLWRlbGF5OiAtMW1zO1xcbiAgICAgICAgICAgIGFuaW1hdGlvbi1kZWxheTogLTFtcztcXG4gICAgLXdlYmtpdC1hbmltYXRpb24tZHVyYXRpb246IDFtcztcXG4gICAgICAgICAgICBhbmltYXRpb24tZHVyYXRpb246IDFtcztcXG4gICAgLXdlYmtpdC1hbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiAxO1xcbiAgICAgICAgICAgIGFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IDE7XFxuICAgIHRyYW5zaXRpb24tZGVsYXk6IDBzO1xcbiAgICB0cmFuc2l0aW9uLWR1cmF0aW9uOiAwcztcXG4gIH1cXG59XFxuQC13ZWJraXQta2V5ZnJhbWVzIGZhLWJlYXQge1xcbiAgMCUsIDkwJSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgxKTtcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDEpO1xcbiAgfVxcbiAgNDUlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKHZhcigtLWZhLWJlYXQtc2NhbGUsIDEuMjUpKTtcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKHZhcigtLWZhLWJlYXQtc2NhbGUsIDEuMjUpKTtcXG4gIH1cXG59XFxuQGtleWZyYW1lcyBmYS1iZWF0IHtcXG4gIDAlLCA5MCUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMSk7XFxuICAgICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgxKTtcXG4gIH1cXG4gIDQ1JSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSh2YXIoLS1mYS1iZWF0LXNjYWxlLCAxLjI1KSk7XFxuICAgICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSh2YXIoLS1mYS1iZWF0LXNjYWxlLCAxLjI1KSk7XFxuICB9XFxufVxcbkAtd2Via2l0LWtleWZyYW1lcyBmYS1ib3VuY2Uge1xcbiAgMCUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMSwgMSkgdHJhbnNsYXRlWSgwKTtcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDEsIDEpIHRyYW5zbGF0ZVkoMCk7XFxuICB9XFxuICAxMCUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUodmFyKC0tZmEtYm91bmNlLXN0YXJ0LXNjYWxlLXgsIDEuMSksIHZhcigtLWZhLWJvdW5jZS1zdGFydC1zY2FsZS15LCAwLjkpKSB0cmFuc2xhdGVZKDApO1xcbiAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUodmFyKC0tZmEtYm91bmNlLXN0YXJ0LXNjYWxlLXgsIDEuMSksIHZhcigtLWZhLWJvdW5jZS1zdGFydC1zY2FsZS15LCAwLjkpKSB0cmFuc2xhdGVZKDApO1xcbiAgfVxcbiAgMzAlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKHZhcigtLWZhLWJvdW5jZS1qdW1wLXNjYWxlLXgsIDAuOSksIHZhcigtLWZhLWJvdW5jZS1qdW1wLXNjYWxlLXksIDEuMSkpIHRyYW5zbGF0ZVkodmFyKC0tZmEtYm91bmNlLWhlaWdodCwgLTAuNWVtKSk7XFxuICAgICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSh2YXIoLS1mYS1ib3VuY2UtanVtcC1zY2FsZS14LCAwLjkpLCB2YXIoLS1mYS1ib3VuY2UtanVtcC1zY2FsZS15LCAxLjEpKSB0cmFuc2xhdGVZKHZhcigtLWZhLWJvdW5jZS1oZWlnaHQsIC0wLjVlbSkpO1xcbiAgfVxcbiAgNTAlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKHZhcigtLWZhLWJvdW5jZS1sYW5kLXNjYWxlLXgsIDEuMDUpLCB2YXIoLS1mYS1ib3VuY2UtbGFuZC1zY2FsZS15LCAwLjk1KSkgdHJhbnNsYXRlWSgwKTtcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKHZhcigtLWZhLWJvdW5jZS1sYW5kLXNjYWxlLXgsIDEuMDUpLCB2YXIoLS1mYS1ib3VuY2UtbGFuZC1zY2FsZS15LCAwLjk1KSkgdHJhbnNsYXRlWSgwKTtcXG4gIH1cXG4gIDU3JSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgxLCAxKSB0cmFuc2xhdGVZKHZhcigtLWZhLWJvdW5jZS1yZWJvdW5kLCAtMC4xMjVlbSkpO1xcbiAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMSwgMSkgdHJhbnNsYXRlWSh2YXIoLS1mYS1ib3VuY2UtcmVib3VuZCwgLTAuMTI1ZW0pKTtcXG4gIH1cXG4gIDY0JSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgxLCAxKSB0cmFuc2xhdGVZKDApO1xcbiAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMSwgMSkgdHJhbnNsYXRlWSgwKTtcXG4gIH1cXG4gIDEwMCUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMSwgMSkgdHJhbnNsYXRlWSgwKTtcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDEsIDEpIHRyYW5zbGF0ZVkoMCk7XFxuICB9XFxufVxcbkBrZXlmcmFtZXMgZmEtYm91bmNlIHtcXG4gIDAlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDEsIDEpIHRyYW5zbGF0ZVkoMCk7XFxuICAgICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgxLCAxKSB0cmFuc2xhdGVZKDApO1xcbiAgfVxcbiAgMTAlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKHZhcigtLWZhLWJvdW5jZS1zdGFydC1zY2FsZS14LCAxLjEpLCB2YXIoLS1mYS1ib3VuY2Utc3RhcnQtc2NhbGUteSwgMC45KSkgdHJhbnNsYXRlWSgwKTtcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKHZhcigtLWZhLWJvdW5jZS1zdGFydC1zY2FsZS14LCAxLjEpLCB2YXIoLS1mYS1ib3VuY2Utc3RhcnQtc2NhbGUteSwgMC45KSkgdHJhbnNsYXRlWSgwKTtcXG4gIH1cXG4gIDMwJSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSh2YXIoLS1mYS1ib3VuY2UtanVtcC1zY2FsZS14LCAwLjkpLCB2YXIoLS1mYS1ib3VuY2UtanVtcC1zY2FsZS15LCAxLjEpKSB0cmFuc2xhdGVZKHZhcigtLWZhLWJvdW5jZS1oZWlnaHQsIC0wLjVlbSkpO1xcbiAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUodmFyKC0tZmEtYm91bmNlLWp1bXAtc2NhbGUteCwgMC45KSwgdmFyKC0tZmEtYm91bmNlLWp1bXAtc2NhbGUteSwgMS4xKSkgdHJhbnNsYXRlWSh2YXIoLS1mYS1ib3VuY2UtaGVpZ2h0LCAtMC41ZW0pKTtcXG4gIH1cXG4gIDUwJSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSh2YXIoLS1mYS1ib3VuY2UtbGFuZC1zY2FsZS14LCAxLjA1KSwgdmFyKC0tZmEtYm91bmNlLWxhbmQtc2NhbGUteSwgMC45NSkpIHRyYW5zbGF0ZVkoMCk7XFxuICAgICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSh2YXIoLS1mYS1ib3VuY2UtbGFuZC1zY2FsZS14LCAxLjA1KSwgdmFyKC0tZmEtYm91bmNlLWxhbmQtc2NhbGUteSwgMC45NSkpIHRyYW5zbGF0ZVkoMCk7XFxuICB9XFxuICA1NyUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMSwgMSkgdHJhbnNsYXRlWSh2YXIoLS1mYS1ib3VuY2UtcmVib3VuZCwgLTAuMTI1ZW0pKTtcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDEsIDEpIHRyYW5zbGF0ZVkodmFyKC0tZmEtYm91bmNlLXJlYm91bmQsIC0wLjEyNWVtKSk7XFxuICB9XFxuICA2NCUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMSwgMSkgdHJhbnNsYXRlWSgwKTtcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDEsIDEpIHRyYW5zbGF0ZVkoMCk7XFxuICB9XFxuICAxMDAlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDEsIDEpIHRyYW5zbGF0ZVkoMCk7XFxuICAgICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgxLCAxKSB0cmFuc2xhdGVZKDApO1xcbiAgfVxcbn1cXG5ALXdlYmtpdC1rZXlmcmFtZXMgZmEtZmFkZSB7XFxuICA1MCUge1xcbiAgICBvcGFjaXR5OiB2YXIoLS1mYS1mYWRlLW9wYWNpdHksIDAuNCk7XFxuICB9XFxufVxcbkBrZXlmcmFtZXMgZmEtZmFkZSB7XFxuICA1MCUge1xcbiAgICBvcGFjaXR5OiB2YXIoLS1mYS1mYWRlLW9wYWNpdHksIDAuNCk7XFxuICB9XFxufVxcbkAtd2Via2l0LWtleWZyYW1lcyBmYS1iZWF0LWZhZGUge1xcbiAgMCUsIDEwMCUge1xcbiAgICBvcGFjaXR5OiB2YXIoLS1mYS1iZWF0LWZhZGUtb3BhY2l0eSwgMC40KTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDEpO1xcbiAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7XFxuICB9XFxuICA1MCUge1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUodmFyKC0tZmEtYmVhdC1mYWRlLXNjYWxlLCAxLjEyNSkpO1xcbiAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUodmFyKC0tZmEtYmVhdC1mYWRlLXNjYWxlLCAxLjEyNSkpO1xcbiAgfVxcbn1cXG5Aa2V5ZnJhbWVzIGZhLWJlYXQtZmFkZSB7XFxuICAwJSwgMTAwJSB7XFxuICAgIG9wYWNpdHk6IHZhcigtLWZhLWJlYXQtZmFkZS1vcGFjaXR5LCAwLjQpO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMSk7XFxuICAgICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgxKTtcXG4gIH1cXG4gIDUwJSB7XFxuICAgIG9wYWNpdHk6IDE7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSh2YXIoLS1mYS1iZWF0LWZhZGUtc2NhbGUsIDEuMTI1KSk7XFxuICAgICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSh2YXIoLS1mYS1iZWF0LWZhZGUtc2NhbGUsIDEuMTI1KSk7XFxuICB9XFxufVxcbkAtd2Via2l0LWtleWZyYW1lcyBmYS1mbGlwIHtcXG4gIDUwJSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUzZCh2YXIoLS1mYS1mbGlwLXgsIDApLCB2YXIoLS1mYS1mbGlwLXksIDEpLCB2YXIoLS1mYS1mbGlwLXosIDApLCB2YXIoLS1mYS1mbGlwLWFuZ2xlLCAtMTgwZGVnKSk7XFxuICAgICAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUzZCh2YXIoLS1mYS1mbGlwLXgsIDApLCB2YXIoLS1mYS1mbGlwLXksIDEpLCB2YXIoLS1mYS1mbGlwLXosIDApLCB2YXIoLS1mYS1mbGlwLWFuZ2xlLCAtMTgwZGVnKSk7XFxuICB9XFxufVxcbkBrZXlmcmFtZXMgZmEtZmxpcCB7XFxuICA1MCUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlM2QodmFyKC0tZmEtZmxpcC14LCAwKSwgdmFyKC0tZmEtZmxpcC15LCAxKSwgdmFyKC0tZmEtZmxpcC16LCAwKSwgdmFyKC0tZmEtZmxpcC1hbmdsZSwgLTE4MGRlZykpO1xcbiAgICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlM2QodmFyKC0tZmEtZmxpcC14LCAwKSwgdmFyKC0tZmEtZmxpcC15LCAxKSwgdmFyKC0tZmEtZmxpcC16LCAwKSwgdmFyKC0tZmEtZmxpcC1hbmdsZSwgLTE4MGRlZykpO1xcbiAgfVxcbn1cXG5ALXdlYmtpdC1rZXlmcmFtZXMgZmEtc2hha2Uge1xcbiAgMCUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKC0xNWRlZyk7XFxuICAgICAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoLTE1ZGVnKTtcXG4gIH1cXG4gIDQlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgxNWRlZyk7XFxuICAgICAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMTVkZWcpO1xcbiAgfVxcbiAgOCUsIDI0JSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoLTE4ZGVnKTtcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgtMThkZWcpO1xcbiAgfVxcbiAgMTIlLCAyOCUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDE4ZGVnKTtcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgxOGRlZyk7XFxuICB9XFxuICAxNiUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKC0yMmRlZyk7XFxuICAgICAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoLTIyZGVnKTtcXG4gIH1cXG4gIDIwJSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMjJkZWcpO1xcbiAgICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDIyZGVnKTtcXG4gIH1cXG4gIDMyJSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoLTEyZGVnKTtcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgtMTJkZWcpO1xcbiAgfVxcbiAgMzYlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgxMmRlZyk7XFxuICAgICAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMTJkZWcpO1xcbiAgfVxcbiAgNDAlLCAxMDAlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcXG4gIH1cXG59XFxuQGtleWZyYW1lcyBmYS1zaGFrZSB7XFxuICAwJSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoLTE1ZGVnKTtcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgtMTVkZWcpO1xcbiAgfVxcbiAgNCUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDE1ZGVnKTtcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgxNWRlZyk7XFxuICB9XFxuICA4JSwgMjQlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgtMThkZWcpO1xcbiAgICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKC0xOGRlZyk7XFxuICB9XFxuICAxMiUsIDI4JSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMThkZWcpO1xcbiAgICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDE4ZGVnKTtcXG4gIH1cXG4gIDE2JSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoLTIyZGVnKTtcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgtMjJkZWcpO1xcbiAgfVxcbiAgMjAlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgyMmRlZyk7XFxuICAgICAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMjJkZWcpO1xcbiAgfVxcbiAgMzIlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgtMTJkZWcpO1xcbiAgICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKC0xMmRlZyk7XFxuICB9XFxuICAzNiUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDEyZGVnKTtcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgxMmRlZyk7XFxuICB9XFxuICA0MCUsIDEwMCUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xcbiAgICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xcbiAgfVxcbn1cXG5ALXdlYmtpdC1rZXlmcmFtZXMgZmEtc3BpbiB7XFxuICAwJSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XFxuICAgICAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XFxuICB9XFxuICAxMDAlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xcbiAgICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxuICB9XFxufVxcbkBrZXlmcmFtZXMgZmEtc3BpbiB7XFxuICAwJSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XFxuICAgICAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XFxuICB9XFxuICAxMDAlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xcbiAgICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxuICB9XFxufVxcbi5mYS1yb3RhdGUtOTAge1xcbiAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSg5MGRlZyk7XFxuICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDkwZGVnKTtcXG59XFxuXFxuLmZhLXJvdGF0ZS0xODAge1xcbiAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgxODBkZWcpO1xcbiAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgxODBkZWcpO1xcbn1cXG5cXG4uZmEtcm90YXRlLTI3MCB7XFxuICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDI3MGRlZyk7XFxuICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDI3MGRlZyk7XFxufVxcblxcbi5mYS1mbGlwLWhvcml6b250YWwge1xcbiAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKC0xLCAxKTtcXG4gICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgtMSwgMSk7XFxufVxcblxcbi5mYS1mbGlwLXZlcnRpY2FsIHtcXG4gIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgxLCAtMSk7XFxuICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMSwgLTEpO1xcbn1cXG5cXG4uZmEtZmxpcC1ib3RoLFxcbi5mYS1mbGlwLWhvcml6b250YWwuZmEtZmxpcC12ZXJ0aWNhbCB7XFxuICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoLTEsIC0xKTtcXG4gICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgtMSwgLTEpO1xcbn1cXG5cXG4uZmEtcm90YXRlLWJ5IHtcXG4gIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUodmFyKC0tZmEtcm90YXRlLWFuZ2xlLCBub25lKSk7XFxuICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKHZhcigtLWZhLXJvdGF0ZS1hbmdsZSwgbm9uZSkpO1xcbn1cXG5cXG4uZmEtc3RhY2sge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gIGhlaWdodDogMmVtO1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgd2lkdGg6IDIuNWVtO1xcbn1cXG5cXG4uZmEtc3RhY2stMXgsXFxuLmZhLXN0YWNrLTJ4IHtcXG4gIGJvdHRvbTogMDtcXG4gIGxlZnQ6IDA7XFxuICBtYXJnaW46IGF1dG87XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICByaWdodDogMDtcXG4gIHRvcDogMDtcXG4gIHotaW5kZXg6IHZhcigtLWZhLXN0YWNrLXotaW5kZXgsIGF1dG8pO1xcbn1cXG5cXG4uc3ZnLWlubGluZS0tZmEuZmEtc3RhY2stMXgge1xcbiAgaGVpZ2h0OiAxZW07XFxuICB3aWR0aDogMS4yNWVtO1xcbn1cXG4uc3ZnLWlubGluZS0tZmEuZmEtc3RhY2stMngge1xcbiAgaGVpZ2h0OiAyZW07XFxuICB3aWR0aDogMi41ZW07XFxufVxcblxcbi5mYS1pbnZlcnNlIHtcXG4gIGNvbG9yOiB2YXIoLS1mYS1pbnZlcnNlLCAjZmZmKTtcXG59XFxuXFxuLnNyLW9ubHksXFxuLmZhLXNyLW9ubHkge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgd2lkdGg6IDFweDtcXG4gIGhlaWdodDogMXB4O1xcbiAgcGFkZGluZzogMDtcXG4gIG1hcmdpbjogLTFweDtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICBjbGlwOiByZWN0KDAsIDAsIDAsIDApO1xcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG4gIGJvcmRlci13aWR0aDogMDtcXG59XFxuXFxuLnNyLW9ubHktZm9jdXNhYmxlOm5vdCg6Zm9jdXMpLFxcbi5mYS1zci1vbmx5LWZvY3VzYWJsZTpub3QoOmZvY3VzKSB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB3aWR0aDogMXB4O1xcbiAgaGVpZ2h0OiAxcHg7XFxuICBwYWRkaW5nOiAwO1xcbiAgbWFyZ2luOiAtMXB4O1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIGNsaXA6IHJlY3QoMCwgMCwgMCwgMCk7XFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbiAgYm9yZGVyLXdpZHRoOiAwO1xcbn1cXG5cXG4uc3ZnLWlubGluZS0tZmEgLmZhLXByaW1hcnkge1xcbiAgZmlsbDogdmFyKC0tZmEtcHJpbWFyeS1jb2xvciwgY3VycmVudENvbG9yKTtcXG4gIG9wYWNpdHk6IHZhcigtLWZhLXByaW1hcnktb3BhY2l0eSwgMSk7XFxufVxcblxcbi5zdmctaW5saW5lLS1mYSAuZmEtc2Vjb25kYXJ5IHtcXG4gIGZpbGw6IHZhcigtLWZhLXNlY29uZGFyeS1jb2xvciwgY3VycmVudENvbG9yKTtcXG4gIG9wYWNpdHk6IHZhcigtLWZhLXNlY29uZGFyeS1vcGFjaXR5LCAwLjQpO1xcbn1cXG5cXG4uc3ZnLWlubGluZS0tZmEuZmEtc3dhcC1vcGFjaXR5IC5mYS1wcmltYXJ5IHtcXG4gIG9wYWNpdHk6IHZhcigtLWZhLXNlY29uZGFyeS1vcGFjaXR5LCAwLjQpO1xcbn1cXG5cXG4uc3ZnLWlubGluZS0tZmEuZmEtc3dhcC1vcGFjaXR5IC5mYS1zZWNvbmRhcnkge1xcbiAgb3BhY2l0eTogdmFyKC0tZmEtcHJpbWFyeS1vcGFjaXR5LCAxKTtcXG59XFxuXFxuLnN2Zy1pbmxpbmUtLWZhIG1hc2sgLmZhLXByaW1hcnksXFxuLnN2Zy1pbmxpbmUtLWZhIG1hc2sgLmZhLXNlY29uZGFyeSB7XFxuICBmaWxsOiBibGFjaztcXG59XFxuXFxuLmZhZC5mYS1pbnZlcnNlLFxcbi5mYS1kdW90b25lLmZhLWludmVyc2Uge1xcbiAgY29sb3I6IHZhcigtLWZhLWludmVyc2UsICNmZmYpO1xcbn1cIjtcblxuZnVuY3Rpb24gY3NzKCkge1xuICB2YXIgZGNwID0gREVGQVVMVF9DU1NfUFJFRklYO1xuICB2YXIgZHJjID0gREVGQVVMVF9SRVBMQUNFTUVOVF9DTEFTUztcbiAgdmFyIGZwID0gY29uZmlnLmNzc1ByZWZpeDtcbiAgdmFyIHJjID0gY29uZmlnLnJlcGxhY2VtZW50Q2xhc3M7XG4gIHZhciBzID0gYmFzZVN0eWxlcztcblxuICBpZiAoZnAgIT09IGRjcCB8fCByYyAhPT0gZHJjKSB7XG4gICAgdmFyIGRQYXR0ID0gbmV3IFJlZ0V4cChcIlxcXFwuXCIuY29uY2F0KGRjcCwgXCJcXFxcLVwiKSwgJ2cnKTtcbiAgICB2YXIgY3VzdG9tUHJvcFBhdHQgPSBuZXcgUmVnRXhwKFwiXFxcXC0tXCIuY29uY2F0KGRjcCwgXCJcXFxcLVwiKSwgJ2cnKTtcbiAgICB2YXIgclBhdHQgPSBuZXcgUmVnRXhwKFwiXFxcXC5cIi5jb25jYXQoZHJjKSwgJ2cnKTtcbiAgICBzID0gcy5yZXBsYWNlKGRQYXR0LCBcIi5cIi5jb25jYXQoZnAsIFwiLVwiKSkucmVwbGFjZShjdXN0b21Qcm9wUGF0dCwgXCItLVwiLmNvbmNhdChmcCwgXCItXCIpKS5yZXBsYWNlKHJQYXR0LCBcIi5cIi5jb25jYXQocmMpKTtcbiAgfVxuXG4gIHJldHVybiBzO1xufVxuXG52YXIgX2Nzc0luc2VydGVkID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGVuc3VyZUNzcygpIHtcbiAgaWYgKGNvbmZpZy5hdXRvQWRkQ3NzICYmICFfY3NzSW5zZXJ0ZWQpIHtcbiAgICBpbnNlcnRDc3MoY3NzKCkpO1xuICAgIF9jc3NJbnNlcnRlZCA9IHRydWU7XG4gIH1cbn1cblxudmFyIEluamVjdENTUyA9IHtcbiAgbWl4b3V0OiBmdW5jdGlvbiBtaXhvdXQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRvbToge1xuICAgICAgICBjc3M6IGNzcyxcbiAgICAgICAgaW5zZXJ0Q3NzOiBlbnN1cmVDc3NcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBob29rczogZnVuY3Rpb24gaG9va3MoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJlZm9yZURPTUVsZW1lbnRDcmVhdGlvbjogZnVuY3Rpb24gYmVmb3JlRE9NRWxlbWVudENyZWF0aW9uKCkge1xuICAgICAgICBlbnN1cmVDc3MoKTtcbiAgICAgIH0sXG4gICAgICBiZWZvcmVJMnN2ZzogZnVuY3Rpb24gYmVmb3JlSTJzdmcoKSB7XG4gICAgICAgIGVuc3VyZUNzcygpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG5cbnZhciB3ID0gV0lORE9XIHx8IHt9O1xuaWYgKCF3W05BTUVTUEFDRV9JREVOVElGSUVSXSkgd1tOQU1FU1BBQ0VfSURFTlRJRklFUl0gPSB7fTtcbmlmICghd1tOQU1FU1BBQ0VfSURFTlRJRklFUl0uc3R5bGVzKSB3W05BTUVTUEFDRV9JREVOVElGSUVSXS5zdHlsZXMgPSB7fTtcbmlmICghd1tOQU1FU1BBQ0VfSURFTlRJRklFUl0uaG9va3MpIHdbTkFNRVNQQUNFX0lERU5USUZJRVJdLmhvb2tzID0ge307XG5pZiAoIXdbTkFNRVNQQUNFX0lERU5USUZJRVJdLnNoaW1zKSB3W05BTUVTUEFDRV9JREVOVElGSUVSXS5zaGltcyA9IFtdO1xudmFyIG5hbWVzcGFjZSA9IHdbTkFNRVNQQUNFX0lERU5USUZJRVJdO1xuXG52YXIgZnVuY3Rpb25zID0gW107XG5cbnZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIGxpc3RlbmVyKCkge1xuICBET0NVTUVOVC5yZW1vdmVFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgbGlzdGVuZXIpO1xuICBsb2FkZWQgPSAxO1xuICBmdW5jdGlvbnMubWFwKGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiBmbigpO1xuICB9KTtcbn07XG5cbnZhciBsb2FkZWQgPSBmYWxzZTtcblxuaWYgKElTX0RPTSkge1xuICBsb2FkZWQgPSAoRE9DVU1FTlQuZG9jdW1lbnRFbGVtZW50LmRvU2Nyb2xsID8gL15sb2FkZWR8XmMvIDogL15sb2FkZWR8Xml8XmMvKS50ZXN0KERPQ1VNRU5ULnJlYWR5U3RhdGUpO1xuICBpZiAoIWxvYWRlZCkgRE9DVU1FTlQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGxpc3RlbmVyKTtcbn1cblxuZnVuY3Rpb24gZG9tcmVhZHkgKGZuKSB7XG4gIGlmICghSVNfRE9NKSByZXR1cm47XG4gIGxvYWRlZCA/IHNldFRpbWVvdXQoZm4sIDApIDogZnVuY3Rpb25zLnB1c2goZm4pO1xufVxuXG5mdW5jdGlvbiB0b0h0bWwoYWJzdHJhY3ROb2Rlcykge1xuICB2YXIgdGFnID0gYWJzdHJhY3ROb2Rlcy50YWcsXG4gICAgICBfYWJzdHJhY3ROb2RlcyRhdHRyaWIgPSBhYnN0cmFjdE5vZGVzLmF0dHJpYnV0ZXMsXG4gICAgICBhdHRyaWJ1dGVzID0gX2Fic3RyYWN0Tm9kZXMkYXR0cmliID09PSB2b2lkIDAgPyB7fSA6IF9hYnN0cmFjdE5vZGVzJGF0dHJpYixcbiAgICAgIF9hYnN0cmFjdE5vZGVzJGNoaWxkciA9IGFic3RyYWN0Tm9kZXMuY2hpbGRyZW4sXG4gICAgICBjaGlsZHJlbiA9IF9hYnN0cmFjdE5vZGVzJGNoaWxkciA9PT0gdm9pZCAwID8gW10gOiBfYWJzdHJhY3ROb2RlcyRjaGlsZHI7XG5cbiAgaWYgKHR5cGVvZiBhYnN0cmFjdE5vZGVzID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBodG1sRXNjYXBlKGFic3RyYWN0Tm9kZXMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBcIjxcIi5jb25jYXQodGFnLCBcIiBcIikuY29uY2F0KGpvaW5BdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpLCBcIj5cIikuY29uY2F0KGNoaWxkcmVuLm1hcCh0b0h0bWwpLmpvaW4oJycpLCBcIjwvXCIpLmNvbmNhdCh0YWcsIFwiPlwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpY29uRnJvbU1hcHBpbmcobWFwcGluZywgcHJlZml4LCBpY29uTmFtZSkge1xuICBpZiAobWFwcGluZyAmJiBtYXBwaW5nW3ByZWZpeF0gJiYgbWFwcGluZ1twcmVmaXhdW2ljb25OYW1lXSkge1xuICAgIHJldHVybiB7XG4gICAgICBwcmVmaXg6IHByZWZpeCxcbiAgICAgIGljb25OYW1lOiBpY29uTmFtZSxcbiAgICAgIGljb246IG1hcHBpbmdbcHJlZml4XVtpY29uTmFtZV1cbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogSW50ZXJuYWwgaGVscGVyIHRvIGJpbmQgYSBmdW5jdGlvbiBrbm93biB0byBoYXZlIDQgYXJndW1lbnRzXG4gKiB0byBhIGdpdmVuIGNvbnRleHQuXG4gKi9cblxudmFyIGJpbmRJbnRlcm5hbDQgPSBmdW5jdGlvbiBiaW5kSW50ZXJuYWw0KGZ1bmMsIHRoaXNDb250ZXh0KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xuICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0NvbnRleHQsIGEsIGIsIGMsIGQpO1xuICB9O1xufTtcblxuLyoqXG4gKiAjIFJlZHVjZVxuICpcbiAqIEEgZmFzdCBvYmplY3QgYC5yZWR1Y2UoKWAgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSAgIHN1YmplY3QgICAgICBUaGUgb2JqZWN0IHRvIHJlZHVjZSBvdmVyLlxuICogQHBhcmFtICB7RnVuY3Rpb259IGZuICAgICAgICAgICBUaGUgcmVkdWNlciBmdW5jdGlvbi5cbiAqIEBwYXJhbSAge21peGVkfSAgICBpbml0aWFsVmFsdWUgVGhlIGluaXRpYWwgdmFsdWUgZm9yIHRoZSByZWR1Y2VyLCBkZWZhdWx0cyB0byBzdWJqZWN0WzBdLlxuICogQHBhcmFtICB7T2JqZWN0fSAgIHRoaXNDb250ZXh0ICBUaGUgY29udGV4dCBmb3IgdGhlIHJlZHVjZXIuXG4gKiBAcmV0dXJuIHttaXhlZH0gICAgICAgICAgICAgICAgIFRoZSBmaW5hbCByZXN1bHQuXG4gKi9cblxuXG52YXIgcmVkdWNlID0gZnVuY3Rpb24gZmFzdFJlZHVjZU9iamVjdChzdWJqZWN0LCBmbiwgaW5pdGlhbFZhbHVlLCB0aGlzQ29udGV4dCkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHN1YmplY3QpLFxuICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGgsXG4gICAgICBpdGVyYXRvciA9IHRoaXNDb250ZXh0ICE9PSB1bmRlZmluZWQgPyBiaW5kSW50ZXJuYWw0KGZuLCB0aGlzQ29udGV4dCkgOiBmbixcbiAgICAgIGksXG4gICAgICBrZXksXG4gICAgICByZXN1bHQ7XG5cbiAgaWYgKGluaXRpYWxWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaSA9IDE7XG4gICAgcmVzdWx0ID0gc3ViamVjdFtrZXlzWzBdXTtcbiAgfSBlbHNlIHtcbiAgICBpID0gMDtcbiAgICByZXN1bHQgPSBpbml0aWFsVmFsdWU7XG4gIH1cblxuICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0ga2V5c1tpXTtcbiAgICByZXN1bHQgPSBpdGVyYXRvcihyZXN1bHQsIHN1YmplY3Rba2V5XSwga2V5LCBzdWJqZWN0KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIHVjczJkZWNvZGUoKSBhbmQgY29kZVBvaW50QXQoKSBhcmUgYm90aCB3b3JrcyBvZiBNYXRoaWFzIEJ5bmVucyBhbmQgbGljZW5zZWQgdW5kZXIgTUlUXG4gKlxuICogQ29weXJpZ2h0IE1hdGhpYXMgQnluZW5zIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvPlxuXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcbiAqIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuICogXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4gKiB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4gKiBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbiAqIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0b1xuICogdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAqIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gKiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFXG4gKiBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OXG4gKiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cbiAqIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG5mdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIHZhciBjb3VudGVyID0gMDtcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cbiAgd2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXG4gICAgaWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuICAgICAgdmFyIGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblxuICAgICAgaWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgICAgIG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXRwdXQucHVzaCh2YWx1ZSk7XG4gICAgICAgIGNvdW50ZXItLTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2godmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbmZ1bmN0aW9uIHRvSGV4KHVuaWNvZGUpIHtcbiAgdmFyIGRlY29kZWQgPSB1Y3MyZGVjb2RlKHVuaWNvZGUpO1xuICByZXR1cm4gZGVjb2RlZC5sZW5ndGggPT09IDEgPyBkZWNvZGVkWzBdLnRvU3RyaW5nKDE2KSA6IG51bGw7XG59XG5mdW5jdGlvbiBjb2RlUG9pbnRBdChzdHJpbmcsIGluZGV4KSB7XG4gIHZhciBzaXplID0gc3RyaW5nLmxlbmd0aDtcbiAgdmFyIGZpcnN0ID0gc3RyaW5nLmNoYXJDb2RlQXQoaW5kZXgpO1xuICB2YXIgc2Vjb25kO1xuXG4gIGlmIChmaXJzdCA+PSAweEQ4MDAgJiYgZmlyc3QgPD0gMHhEQkZGICYmIHNpemUgPiBpbmRleCArIDEpIHtcbiAgICBzZWNvbmQgPSBzdHJpbmcuY2hhckNvZGVBdChpbmRleCArIDEpO1xuXG4gICAgaWYgKHNlY29uZCA+PSAweERDMDAgJiYgc2Vjb25kIDw9IDB4REZGRikge1xuICAgICAgcmV0dXJuIChmaXJzdCAtIDB4RDgwMCkgKiAweDQwMCArIHNlY29uZCAtIDB4REMwMCArIDB4MTAwMDA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZpcnN0O1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVJY29ucyhpY29ucykge1xuICByZXR1cm4gT2JqZWN0LmtleXMoaWNvbnMpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBpY29uTmFtZSkge1xuICAgIHZhciBpY29uID0gaWNvbnNbaWNvbk5hbWVdO1xuICAgIHZhciBleHBhbmRlZCA9ICEhaWNvbi5pY29uO1xuXG4gICAgaWYgKGV4cGFuZGVkKSB7XG4gICAgICBhY2NbaWNvbi5pY29uTmFtZV0gPSBpY29uLmljb247XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjY1tpY29uTmFtZV0gPSBpY29uO1xuICAgIH1cblxuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbn1cblxuZnVuY3Rpb24gZGVmaW5lSWNvbnMocHJlZml4LCBpY29ucykge1xuICB2YXIgcGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgdmFyIF9wYXJhbXMkc2tpcEhvb2tzID0gcGFyYW1zLnNraXBIb29rcyxcbiAgICAgIHNraXBIb29rcyA9IF9wYXJhbXMkc2tpcEhvb2tzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wYXJhbXMkc2tpcEhvb2tzO1xuICB2YXIgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZUljb25zKGljb25zKTtcblxuICBpZiAodHlwZW9mIG5hbWVzcGFjZS5ob29rcy5hZGRQYWNrID09PSAnZnVuY3Rpb24nICYmICFza2lwSG9va3MpIHtcbiAgICBuYW1lc3BhY2UuaG9va3MuYWRkUGFjayhwcmVmaXgsIG5vcm1hbGl6ZUljb25zKGljb25zKSk7XG4gIH0gZWxzZSB7XG4gICAgbmFtZXNwYWNlLnN0eWxlc1twcmVmaXhdID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIG5hbWVzcGFjZS5zdHlsZXNbcHJlZml4XSB8fCB7fSksIG5vcm1hbGl6ZWQpO1xuICB9XG4gIC8qKlxuICAgKiBGb250IEF3ZXNvbWUgNCB1c2VkIHRoZSBwcmVmaXggb2YgYGZhYCBmb3IgYWxsIGljb25zLiBXaXRoIHRoZSBpbnRyb2R1Y3Rpb25cbiAgICogb2YgbmV3IHN0eWxlcyB3ZSBuZWVkZWQgdG8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIHRoZW0uIFByZWZpeCBgZmFgIGlzIG5vdyBhbiBhbGlhc1xuICAgKiBmb3IgYGZhc2Agc28gd2UnbGwgZWFzZSB0aGUgdXBncmFkZSBwcm9jZXNzIGZvciBvdXIgdXNlcnMgYnkgYXV0b21hdGljYWxseSBkZWZpbmluZ1xuICAgKiB0aGlzIGFzIHdlbGwuXG4gICAqL1xuXG5cbiAgaWYgKHByZWZpeCA9PT0gJ2ZhcycpIHtcbiAgICBkZWZpbmVJY29ucygnZmEnLCBpY29ucyk7XG4gIH1cbn1cblxudmFyIGR1b3RvbmVQYXRoUmUgPSBbLyojX19QVVJFX18qL193cmFwUmVnRXhwKC9wYXRoIGQ9XCIoKD86KD8hXCIpW1xcc1xcU10pKylcIi4qcGF0aCBkPVwiKCg/Oig/IVwiKVtcXHNcXFNdKSspXCIvLCB7XG4gIGQxOiAxLFxuICBkMjogMlxufSksIC8qI19fUFVSRV9fKi9fd3JhcFJlZ0V4cCgvcGF0aCBjbGFzcz1cIigoPzooPyFcIilbXFxzXFxTXSkrKVwiLipkPVwiKCg/Oig/IVwiKVtcXHNcXFNdKSspXCIuKnBhdGggY2xhc3M9XCIoKD86KD8hXCIpW1xcc1xcU10pKylcIi4qZD1cIigoPzooPyFcIilbXFxzXFxTXSkrKVwiLywge1xuICBjbHMxOiAxLFxuICBkMTogMixcbiAgY2xzMjogMyxcbiAgZDI6IDRcbn0pLCAvKiNfX1BVUkVfXyovX3dyYXBSZWdFeHAoL3BhdGggY2xhc3M9XCIoKD86KD8hXCIpW1xcc1xcU10pKylcIi4qZD1cIigoPzooPyFcIilbXFxzXFxTXSkrKVwiLywge1xuICBjbHMxOiAxLFxuICBkMTogMlxufSldO1xuXG52YXIgX0xPTkdfU1RZTEUsIF9QUkVGSVhFUywgX1BSRUZJWEVTX0ZPUl9GQU1JTFk7XG52YXIgc3R5bGVzID0gbmFtZXNwYWNlLnN0eWxlcyxcbiAgICBzaGltcyA9IG5hbWVzcGFjZS5zaGltcztcbnZhciBMT05HX1NUWUxFID0gKF9MT05HX1NUWUxFID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfTE9OR19TVFlMRSwgRkFNSUxZX0NMQVNTSUMsIE9iamVjdC52YWx1ZXMoUFJFRklYX1RPX0xPTkdfU1RZTEVbRkFNSUxZX0NMQVNTSUNdKSksIF9kZWZpbmVQcm9wZXJ0eShfTE9OR19TVFlMRSwgRkFNSUxZX1NIQVJQLCBPYmplY3QudmFsdWVzKFBSRUZJWF9UT19MT05HX1NUWUxFW0ZBTUlMWV9TSEFSUF0pKSwgX0xPTkdfU1RZTEUpO1xudmFyIF9kZWZhdWx0VXNhYmxlUHJlZml4ID0gbnVsbDtcbnZhciBfYnlVbmljb2RlID0ge307XG52YXIgX2J5TGlnYXR1cmUgPSB7fTtcbnZhciBfYnlPbGROYW1lID0ge307XG52YXIgX2J5T2xkVW5pY29kZSA9IHt9O1xudmFyIF9ieUFsaWFzID0ge307XG52YXIgUFJFRklYRVMgPSAoX1BSRUZJWEVTID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfUFJFRklYRVMsIEZBTUlMWV9DTEFTU0lDLCBPYmplY3Qua2V5cyhQUkVGSVhfVE9fU1RZTEVbRkFNSUxZX0NMQVNTSUNdKSksIF9kZWZpbmVQcm9wZXJ0eShfUFJFRklYRVMsIEZBTUlMWV9TSEFSUCwgT2JqZWN0LmtleXMoUFJFRklYX1RPX1NUWUxFW0ZBTUlMWV9TSEFSUF0pKSwgX1BSRUZJWEVTKTtcblxuZnVuY3Rpb24gaXNSZXNlcnZlZChuYW1lKSB7XG4gIHJldHVybiB+UkVTRVJWRURfQ0xBU1NFUy5pbmRleE9mKG5hbWUpO1xufVxuXG5mdW5jdGlvbiBnZXRJY29uTmFtZShjc3NQcmVmaXgsIGNscykge1xuICB2YXIgcGFydHMgPSBjbHMuc3BsaXQoJy0nKTtcbiAgdmFyIHByZWZpeCA9IHBhcnRzWzBdO1xuICB2YXIgaWNvbk5hbWUgPSBwYXJ0cy5zbGljZSgxKS5qb2luKCctJyk7XG5cbiAgaWYgKHByZWZpeCA9PT0gY3NzUHJlZml4ICYmIGljb25OYW1lICE9PSAnJyAmJiAhaXNSZXNlcnZlZChpY29uTmFtZSkpIHtcbiAgICByZXR1cm4gaWNvbk5hbWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbnZhciBidWlsZCA9IGZ1bmN0aW9uIGJ1aWxkKCkge1xuICB2YXIgbG9va3VwID0gZnVuY3Rpb24gbG9va3VwKHJlZHVjZXIpIHtcbiAgICByZXR1cm4gcmVkdWNlKHN0eWxlcywgZnVuY3Rpb24gKG8sIHN0eWxlLCBwcmVmaXgpIHtcbiAgICAgIG9bcHJlZml4XSA9IHJlZHVjZShzdHlsZSwgcmVkdWNlciwge30pO1xuICAgICAgcmV0dXJuIG87XG4gICAgfSwge30pO1xuICB9O1xuXG4gIF9ieVVuaWNvZGUgPSBsb29rdXAoZnVuY3Rpb24gKGFjYywgaWNvbiwgaWNvbk5hbWUpIHtcbiAgICBpZiAoaWNvblszXSkge1xuICAgICAgYWNjW2ljb25bM11dID0gaWNvbk5hbWU7XG4gICAgfVxuXG4gICAgaWYgKGljb25bMl0pIHtcbiAgICAgIHZhciBhbGlhc2VzID0gaWNvblsyXS5maWx0ZXIoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBhID09PSAnbnVtYmVyJztcbiAgICAgIH0pO1xuICAgICAgYWxpYXNlcy5mb3JFYWNoKGZ1bmN0aW9uIChhbGlhcykge1xuICAgICAgICBhY2NbYWxpYXMudG9TdHJpbmcoMTYpXSA9IGljb25OYW1lO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjYztcbiAgfSk7XG4gIF9ieUxpZ2F0dXJlID0gbG9va3VwKGZ1bmN0aW9uIChhY2MsIGljb24sIGljb25OYW1lKSB7XG4gICAgYWNjW2ljb25OYW1lXSA9IGljb25OYW1lO1xuXG4gICAgaWYgKGljb25bMl0pIHtcbiAgICAgIHZhciBhbGlhc2VzID0gaWNvblsyXS5maWx0ZXIoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBhID09PSAnc3RyaW5nJztcbiAgICAgIH0pO1xuICAgICAgYWxpYXNlcy5mb3JFYWNoKGZ1bmN0aW9uIChhbGlhcykge1xuICAgICAgICBhY2NbYWxpYXNdID0gaWNvbk5hbWU7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWNjO1xuICB9KTtcbiAgX2J5QWxpYXMgPSBsb29rdXAoZnVuY3Rpb24gKGFjYywgaWNvbiwgaWNvbk5hbWUpIHtcbiAgICB2YXIgYWxpYXNlcyA9IGljb25bMl07XG4gICAgYWNjW2ljb25OYW1lXSA9IGljb25OYW1lO1xuICAgIGFsaWFzZXMuZm9yRWFjaChmdW5jdGlvbiAoYWxpYXMpIHtcbiAgICAgIGFjY1thbGlhc10gPSBpY29uTmFtZTtcbiAgICB9KTtcbiAgICByZXR1cm4gYWNjO1xuICB9KTsgLy8gSWYgd2UgaGF2ZSBhIEtpdCwgd2UgY2FuJ3QgZGV0ZXJtaW5lIGlmIHJlZ3VsYXIgaXMgYXZhaWxhYmxlIHNpbmNlIHdlXG4gIC8vIGNvdWxkIGJlIGF1dG8tZmV0Y2hpbmcgaXQuIFdlJ2xsIGhhdmUgdG8gYXNzdW1lIHRoYXQgaXQgaXMgYXZhaWxhYmxlLlxuXG4gIHZhciBoYXNSZWd1bGFyID0gJ2ZhcicgaW4gc3R5bGVzIHx8IGNvbmZpZy5hdXRvRmV0Y2hTdmc7XG4gIHZhciBzaGltTG9va3VwcyA9IHJlZHVjZShzaGltcywgZnVuY3Rpb24gKGFjYywgc2hpbSkge1xuICAgIHZhciBtYXliZU5hbWVNYXliZVVuaWNvZGUgPSBzaGltWzBdO1xuICAgIHZhciBwcmVmaXggPSBzaGltWzFdO1xuICAgIHZhciBpY29uTmFtZSA9IHNoaW1bMl07XG5cbiAgICBpZiAocHJlZml4ID09PSAnZmFyJyAmJiAhaGFzUmVndWxhcikge1xuICAgICAgcHJlZml4ID0gJ2Zhcyc7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBtYXliZU5hbWVNYXliZVVuaWNvZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBhY2MubmFtZXNbbWF5YmVOYW1lTWF5YmVVbmljb2RlXSA9IHtcbiAgICAgICAgcHJlZml4OiBwcmVmaXgsXG4gICAgICAgIGljb25OYW1lOiBpY29uTmFtZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG1heWJlTmFtZU1heWJlVW5pY29kZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGFjYy51bmljb2Rlc1ttYXliZU5hbWVNYXliZVVuaWNvZGUudG9TdHJpbmcoMTYpXSA9IHtcbiAgICAgICAgcHJlZml4OiBwcmVmaXgsXG4gICAgICAgIGljb25OYW1lOiBpY29uTmFtZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWNjO1xuICB9LCB7XG4gICAgbmFtZXM6IHt9LFxuICAgIHVuaWNvZGVzOiB7fVxuICB9KTtcbiAgX2J5T2xkTmFtZSA9IHNoaW1Mb29rdXBzLm5hbWVzO1xuICBfYnlPbGRVbmljb2RlID0gc2hpbUxvb2t1cHMudW5pY29kZXM7XG4gIF9kZWZhdWx0VXNhYmxlUHJlZml4ID0gZ2V0Q2Fub25pY2FsUHJlZml4KGNvbmZpZy5zdHlsZURlZmF1bHQsIHtcbiAgICBmYW1pbHk6IGNvbmZpZy5mYW1pbHlEZWZhdWx0XG4gIH0pO1xufTtcbm9uQ2hhbmdlKGZ1bmN0aW9uIChjKSB7XG4gIF9kZWZhdWx0VXNhYmxlUHJlZml4ID0gZ2V0Q2Fub25pY2FsUHJlZml4KGMuc3R5bGVEZWZhdWx0LCB7XG4gICAgZmFtaWx5OiBjb25maWcuZmFtaWx5RGVmYXVsdFxuICB9KTtcbn0pO1xuYnVpbGQoKTtcbmZ1bmN0aW9uIGJ5VW5pY29kZShwcmVmaXgsIHVuaWNvZGUpIHtcbiAgcmV0dXJuIChfYnlVbmljb2RlW3ByZWZpeF0gfHwge30pW3VuaWNvZGVdO1xufVxuZnVuY3Rpb24gYnlMaWdhdHVyZShwcmVmaXgsIGxpZ2F0dXJlKSB7XG4gIHJldHVybiAoX2J5TGlnYXR1cmVbcHJlZml4XSB8fCB7fSlbbGlnYXR1cmVdO1xufVxuZnVuY3Rpb24gYnlBbGlhcyhwcmVmaXgsIGFsaWFzKSB7XG4gIHJldHVybiAoX2J5QWxpYXNbcHJlZml4XSB8fCB7fSlbYWxpYXNdO1xufVxuZnVuY3Rpb24gYnlPbGROYW1lKG5hbWUpIHtcbiAgcmV0dXJuIF9ieU9sZE5hbWVbbmFtZV0gfHwge1xuICAgIHByZWZpeDogbnVsbCxcbiAgICBpY29uTmFtZTogbnVsbFxuICB9O1xufVxuZnVuY3Rpb24gYnlPbGRVbmljb2RlKHVuaWNvZGUpIHtcbiAgdmFyIG9sZFVuaWNvZGUgPSBfYnlPbGRVbmljb2RlW3VuaWNvZGVdO1xuICB2YXIgbmV3VW5pY29kZSA9IGJ5VW5pY29kZSgnZmFzJywgdW5pY29kZSk7XG4gIHJldHVybiBvbGRVbmljb2RlIHx8IChuZXdVbmljb2RlID8ge1xuICAgIHByZWZpeDogJ2ZhcycsXG4gICAgaWNvbk5hbWU6IG5ld1VuaWNvZGVcbiAgfSA6IG51bGwpIHx8IHtcbiAgICBwcmVmaXg6IG51bGwsXG4gICAgaWNvbk5hbWU6IG51bGxcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldERlZmF1bHRVc2FibGVQcmVmaXgoKSB7XG4gIHJldHVybiBfZGVmYXVsdFVzYWJsZVByZWZpeDtcbn1cbnZhciBlbXB0eUNhbm9uaWNhbEljb24gPSBmdW5jdGlvbiBlbXB0eUNhbm9uaWNhbEljb24oKSB7XG4gIHJldHVybiB7XG4gICAgcHJlZml4OiBudWxsLFxuICAgIGljb25OYW1lOiBudWxsLFxuICAgIHJlc3Q6IFtdXG4gIH07XG59O1xuZnVuY3Rpb24gZ2V0Q2Fub25pY2FsUHJlZml4KHN0eWxlT3JQcmVmaXgpIHtcbiAgdmFyIHBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciBfcGFyYW1zJGZhbWlseSA9IHBhcmFtcy5mYW1pbHksXG4gICAgICBmYW1pbHkgPSBfcGFyYW1zJGZhbWlseSA9PT0gdm9pZCAwID8gRkFNSUxZX0NMQVNTSUMgOiBfcGFyYW1zJGZhbWlseTtcbiAgdmFyIHN0eWxlID0gUFJFRklYX1RPX1NUWUxFW2ZhbWlseV1bc3R5bGVPclByZWZpeF07XG4gIHZhciBwcmVmaXggPSBTVFlMRV9UT19QUkVGSVhbZmFtaWx5XVtzdHlsZU9yUHJlZml4XSB8fCBTVFlMRV9UT19QUkVGSVhbZmFtaWx5XVtzdHlsZV07XG4gIHZhciBkZWZpbmVkID0gc3R5bGVPclByZWZpeCBpbiBuYW1lc3BhY2Uuc3R5bGVzID8gc3R5bGVPclByZWZpeCA6IG51bGw7XG4gIHJldHVybiBwcmVmaXggfHwgZGVmaW5lZCB8fCBudWxsO1xufVxudmFyIFBSRUZJWEVTX0ZPUl9GQU1JTFkgPSAoX1BSRUZJWEVTX0ZPUl9GQU1JTFkgPSB7fSwgX2RlZmluZVByb3BlcnR5KF9QUkVGSVhFU19GT1JfRkFNSUxZLCBGQU1JTFlfQ0xBU1NJQywgT2JqZWN0LmtleXMoUFJFRklYX1RPX0xPTkdfU1RZTEVbRkFNSUxZX0NMQVNTSUNdKSksIF9kZWZpbmVQcm9wZXJ0eShfUFJFRklYRVNfRk9SX0ZBTUlMWSwgRkFNSUxZX1NIQVJQLCBPYmplY3Qua2V5cyhQUkVGSVhfVE9fTE9OR19TVFlMRVtGQU1JTFlfU0hBUlBdKSksIF9QUkVGSVhFU19GT1JfRkFNSUxZKTtcbmZ1bmN0aW9uIGdldENhbm9uaWNhbEljb24odmFsdWVzKSB7XG4gIHZhciBfZmFtUHJvcHM7XG5cbiAgdmFyIHBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciBfcGFyYW1zJHNraXBMb29rdXBzID0gcGFyYW1zLnNraXBMb29rdXBzLFxuICAgICAgc2tpcExvb2t1cHMgPSBfcGFyYW1zJHNraXBMb29rdXBzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wYXJhbXMkc2tpcExvb2t1cHM7XG4gIHZhciBmYW1Qcm9wcyA9IChfZmFtUHJvcHMgPSB7fSwgX2RlZmluZVByb3BlcnR5KF9mYW1Qcm9wcywgRkFNSUxZX0NMQVNTSUMsIFwiXCIuY29uY2F0KGNvbmZpZy5jc3NQcmVmaXgsIFwiLVwiKS5jb25jYXQoRkFNSUxZX0NMQVNTSUMpKSwgX2RlZmluZVByb3BlcnR5KF9mYW1Qcm9wcywgRkFNSUxZX1NIQVJQLCBcIlwiLmNvbmNhdChjb25maWcuY3NzUHJlZml4LCBcIi1cIikuY29uY2F0KEZBTUlMWV9TSEFSUCkpLCBfZmFtUHJvcHMpO1xuICB2YXIgZ2l2ZW5QcmVmaXggPSBudWxsO1xuICB2YXIgZmFtaWx5ID0gRkFNSUxZX0NMQVNTSUM7XG5cbiAgaWYgKHZhbHVlcy5pbmNsdWRlcyhmYW1Qcm9wc1tGQU1JTFlfQ0xBU1NJQ10pIHx8IHZhbHVlcy5zb21lKGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIFBSRUZJWEVTX0ZPUl9GQU1JTFlbRkFNSUxZX0NMQVNTSUNdLmluY2x1ZGVzKHYpO1xuICB9KSkge1xuICAgIGZhbWlseSA9IEZBTUlMWV9DTEFTU0lDO1xuICB9XG5cbiAgaWYgKHZhbHVlcy5pbmNsdWRlcyhmYW1Qcm9wc1tGQU1JTFlfU0hBUlBdKSB8fCB2YWx1ZXMuc29tZShmdW5jdGlvbiAodikge1xuICAgIHJldHVybiBQUkVGSVhFU19GT1JfRkFNSUxZW0ZBTUlMWV9TSEFSUF0uaW5jbHVkZXModik7XG4gIH0pKSB7XG4gICAgZmFtaWx5ID0gRkFNSUxZX1NIQVJQO1xuICB9XG5cbiAgdmFyIGNhbm9uaWNhbCA9IHZhbHVlcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgY2xzKSB7XG4gICAgdmFyIGljb25OYW1lID0gZ2V0SWNvbk5hbWUoY29uZmlnLmNzc1ByZWZpeCwgY2xzKTtcblxuICAgIGlmIChzdHlsZXNbY2xzXSkge1xuICAgICAgY2xzID0gTE9OR19TVFlMRVtmYW1pbHldLmluY2x1ZGVzKGNscykgPyBMT05HX1NUWUxFX1RPX1BSRUZJWFtmYW1pbHldW2Nsc10gOiBjbHM7XG4gICAgICBnaXZlblByZWZpeCA9IGNscztcbiAgICAgIGFjYy5wcmVmaXggPSBjbHM7XG4gICAgfSBlbHNlIGlmIChQUkVGSVhFU1tmYW1pbHldLmluZGV4T2YoY2xzKSA+IC0xKSB7XG4gICAgICBnaXZlblByZWZpeCA9IGNscztcbiAgICAgIGFjYy5wcmVmaXggPSBnZXRDYW5vbmljYWxQcmVmaXgoY2xzLCB7XG4gICAgICAgIGZhbWlseTogZmFtaWx5XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGljb25OYW1lKSB7XG4gICAgICBhY2MuaWNvbk5hbWUgPSBpY29uTmFtZTtcbiAgICB9IGVsc2UgaWYgKGNscyAhPT0gY29uZmlnLnJlcGxhY2VtZW50Q2xhc3MgJiYgY2xzICE9PSBmYW1Qcm9wc1tGQU1JTFlfQ0xBU1NJQ10gJiYgY2xzICE9PSBmYW1Qcm9wc1tGQU1JTFlfU0hBUlBdKSB7XG4gICAgICBhY2MucmVzdC5wdXNoKGNscyk7XG4gICAgfVxuXG4gICAgaWYgKCFza2lwTG9va3VwcyAmJiBhY2MucHJlZml4ICYmIGFjYy5pY29uTmFtZSkge1xuICAgICAgdmFyIHNoaW0gPSBnaXZlblByZWZpeCA9PT0gJ2ZhJyA/IGJ5T2xkTmFtZShhY2MuaWNvbk5hbWUpIDoge307XG4gICAgICB2YXIgYWxpYXNJY29uTmFtZSA9IGJ5QWxpYXMoYWNjLnByZWZpeCwgYWNjLmljb25OYW1lKTtcblxuICAgICAgaWYgKHNoaW0ucHJlZml4KSB7XG4gICAgICAgIGdpdmVuUHJlZml4ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgYWNjLmljb25OYW1lID0gc2hpbS5pY29uTmFtZSB8fCBhbGlhc0ljb25OYW1lIHx8IGFjYy5pY29uTmFtZTtcbiAgICAgIGFjYy5wcmVmaXggPSBzaGltLnByZWZpeCB8fCBhY2MucHJlZml4O1xuXG4gICAgICBpZiAoYWNjLnByZWZpeCA9PT0gJ2ZhcicgJiYgIXN0eWxlc1snZmFyJ10gJiYgc3R5bGVzWydmYXMnXSAmJiAhY29uZmlnLmF1dG9GZXRjaFN2Zykge1xuICAgICAgICAvLyBBbGxvdyBhIGZhbGxiYWNrIGZyb20gdGhlIHJlZ3VsYXIgc3R5bGUgdG8gc29saWQgaWYgcmVndWxhciBpcyBub3QgYXZhaWxhYmxlXG4gICAgICAgIC8vIGJ1dCBvbmx5IGlmIHdlIGFyZW4ndCBhdXRvLWZldGNoaW5nIFNWR3NcbiAgICAgICAgYWNjLnByZWZpeCA9ICdmYXMnO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhY2M7XG4gIH0sIGVtcHR5Q2Fub25pY2FsSWNvbigpKTtcblxuICBpZiAodmFsdWVzLmluY2x1ZGVzKCdmYS1icmFuZHMnKSB8fCB2YWx1ZXMuaW5jbHVkZXMoJ2ZhYicpKSB7XG4gICAgY2Fub25pY2FsLnByZWZpeCA9ICdmYWInO1xuICB9XG5cbiAgaWYgKHZhbHVlcy5pbmNsdWRlcygnZmEtZHVvdG9uZScpIHx8IHZhbHVlcy5pbmNsdWRlcygnZmFkJykpIHtcbiAgICBjYW5vbmljYWwucHJlZml4ID0gJ2ZhZCc7XG4gIH1cblxuICBpZiAoIWNhbm9uaWNhbC5wcmVmaXggJiYgZmFtaWx5ID09PSBGQU1JTFlfU0hBUlAgJiYgKHN0eWxlc1snZmFzcyddIHx8IGNvbmZpZy5hdXRvRmV0Y2hTdmcpKSB7XG4gICAgY2Fub25pY2FsLnByZWZpeCA9ICdmYXNzJztcbiAgICBjYW5vbmljYWwuaWNvbk5hbWUgPSBieUFsaWFzKGNhbm9uaWNhbC5wcmVmaXgsIGNhbm9uaWNhbC5pY29uTmFtZSkgfHwgY2Fub25pY2FsLmljb25OYW1lO1xuICB9XG5cbiAgaWYgKGNhbm9uaWNhbC5wcmVmaXggPT09ICdmYScgfHwgZ2l2ZW5QcmVmaXggPT09ICdmYScpIHtcbiAgICAvLyBUaGUgZmEgcHJlZml4IGlzIG5vdCBjYW5vbmljYWwuIFNvIGlmIGl0IGhhcyBtYWRlIGl0IHRocm91Z2ggdW50aWwgdGhpcyBwb2ludFxuICAgIC8vIHdlIHdpbGwgc2hpZnQgaXQgdG8gdGhlIGNvcnJlY3QgcHJlZml4LlxuICAgIGNhbm9uaWNhbC5wcmVmaXggPSBnZXREZWZhdWx0VXNhYmxlUHJlZml4KCkgfHwgJ2Zhcyc7XG4gIH1cblxuICByZXR1cm4gY2Fub25pY2FsO1xufVxuXG52YXIgTGlicmFyeSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIExpYnJhcnkoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExpYnJhcnkpO1xuXG4gICAgdGhpcy5kZWZpbml0aW9ucyA9IHt9O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKExpYnJhcnksIFt7XG4gICAga2V5OiBcImFkZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgZGVmaW5pdGlvbnMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGRlZmluaXRpb25zW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICB2YXIgYWRkaXRpb25zID0gZGVmaW5pdGlvbnMucmVkdWNlKHRoaXMuX3B1bGxEZWZpbml0aW9ucywge30pO1xuICAgICAgT2JqZWN0LmtleXMoYWRkaXRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX3RoaXMuZGVmaW5pdGlvbnNba2V5XSA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBfdGhpcy5kZWZpbml0aW9uc1trZXldIHx8IHt9KSwgYWRkaXRpb25zW2tleV0pO1xuICAgICAgICBkZWZpbmVJY29ucyhrZXksIGFkZGl0aW9uc1trZXldKTsgLy8gVE9ETyBjYW4gd2Ugc3RvcCBkb2luZyB0aGlzPyBXZSBjYW4ndCBnZXQgdGhlIGljb25zIGJ5ICdmYS1zb2xpZCcgYW55IGxvbmdlciBzbyB0aGlzIHByb2JhYmx5IG5lZWRzIHRvIGNoYW5nZVxuXG4gICAgICAgIHZhciBsb25nUHJlZml4ID0gUFJFRklYX1RPX0xPTkdfU1RZTEVbRkFNSUxZX0NMQVNTSUNdW2tleV07XG4gICAgICAgIGlmIChsb25nUHJlZml4KSBkZWZpbmVJY29ucyhsb25nUHJlZml4LCBhZGRpdGlvbnNba2V5XSk7XG4gICAgICAgIGJ1aWxkKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICB0aGlzLmRlZmluaXRpb25zID0ge307XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9wdWxsRGVmaW5pdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3B1bGxEZWZpbml0aW9ucyhhZGRpdGlvbnMsIGRlZmluaXRpb24pIHtcbiAgICAgIHZhciBub3JtYWxpemVkID0gZGVmaW5pdGlvbi5wcmVmaXggJiYgZGVmaW5pdGlvbi5pY29uTmFtZSAmJiBkZWZpbml0aW9uLmljb24gPyB7XG4gICAgICAgIDA6IGRlZmluaXRpb25cbiAgICAgIH0gOiBkZWZpbml0aW9uO1xuICAgICAgT2JqZWN0LmtleXMobm9ybWFsaXplZCkubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIF9ub3JtYWxpemVkJGtleSA9IG5vcm1hbGl6ZWRba2V5XSxcbiAgICAgICAgICAgIHByZWZpeCA9IF9ub3JtYWxpemVkJGtleS5wcmVmaXgsXG4gICAgICAgICAgICBpY29uTmFtZSA9IF9ub3JtYWxpemVkJGtleS5pY29uTmFtZSxcbiAgICAgICAgICAgIGljb24gPSBfbm9ybWFsaXplZCRrZXkuaWNvbjtcbiAgICAgICAgdmFyIGFsaWFzZXMgPSBpY29uWzJdO1xuICAgICAgICBpZiAoIWFkZGl0aW9uc1twcmVmaXhdKSBhZGRpdGlvbnNbcHJlZml4XSA9IHt9O1xuXG4gICAgICAgIGlmIChhbGlhc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBhbGlhc2VzLmZvckVhY2goZnVuY3Rpb24gKGFsaWFzKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFsaWFzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBhZGRpdGlvbnNbcHJlZml4XVthbGlhc10gPSBpY29uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgYWRkaXRpb25zW3ByZWZpeF1baWNvbk5hbWVdID0gaWNvbjtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFkZGl0aW9ucztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTGlicmFyeTtcbn0oKTtcblxudmFyIF9wbHVnaW5zID0gW107XG52YXIgX2hvb2tzID0ge307XG52YXIgcHJvdmlkZXJzID0ge307XG52YXIgZGVmYXVsdFByb3ZpZGVyS2V5cyA9IE9iamVjdC5rZXlzKHByb3ZpZGVycyk7XG5mdW5jdGlvbiByZWdpc3RlclBsdWdpbnMobmV4dFBsdWdpbnMsIF9yZWYpIHtcbiAgdmFyIG9iaiA9IF9yZWYubWl4b3V0c1RvO1xuICBfcGx1Z2lucyA9IG5leHRQbHVnaW5zO1xuICBfaG9va3MgPSB7fTtcbiAgT2JqZWN0LmtleXMocHJvdmlkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgaWYgKGRlZmF1bHRQcm92aWRlcktleXMuaW5kZXhPZihrKSA9PT0gLTEpIHtcbiAgICAgIGRlbGV0ZSBwcm92aWRlcnNba107XG4gICAgfVxuICB9KTtcblxuICBfcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICB2YXIgbWl4b3V0ID0gcGx1Z2luLm1peG91dCA/IHBsdWdpbi5taXhvdXQoKSA6IHt9O1xuICAgIE9iamVjdC5rZXlzKG1peG91dCkuZm9yRWFjaChmdW5jdGlvbiAodGspIHtcbiAgICAgIGlmICh0eXBlb2YgbWl4b3V0W3RrXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvYmpbdGtdID0gbWl4b3V0W3RrXTtcbiAgICAgIH1cblxuICAgICAgaWYgKF90eXBlb2YobWl4b3V0W3RrXSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKG1peG91dFt0a10pLmZvckVhY2goZnVuY3Rpb24gKHNrKSB7XG4gICAgICAgICAgaWYgKCFvYmpbdGtdKSB7XG4gICAgICAgICAgICBvYmpbdGtdID0ge307XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgb2JqW3RrXVtza10gPSBtaXhvdXRbdGtdW3NrXTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAocGx1Z2luLmhvb2tzKSB7XG4gICAgICB2YXIgaG9va3MgPSBwbHVnaW4uaG9va3MoKTtcbiAgICAgIE9iamVjdC5rZXlzKGhvb2tzKS5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XG4gICAgICAgIGlmICghX2hvb2tzW2hvb2tdKSB7XG4gICAgICAgICAgX2hvb2tzW2hvb2tdID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBfaG9va3NbaG9va10ucHVzaChob29rc1tob29rXSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAocGx1Z2luLnByb3ZpZGVzKSB7XG4gICAgICBwbHVnaW4ucHJvdmlkZXMocHJvdmlkZXJzKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBjaGFpbkhvb2tzKGhvb2ssIGFjY3VtdWxhdG9yKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAyID8gX2xlbiAtIDIgOiAwKSwgX2tleSA9IDI7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHZhciBob29rRm5zID0gX2hvb2tzW2hvb2tdIHx8IFtdO1xuICBob29rRm5zLmZvckVhY2goZnVuY3Rpb24gKGhvb2tGbikge1xuICAgIGFjY3VtdWxhdG9yID0gaG9va0ZuLmFwcGx5KG51bGwsIFthY2N1bXVsYXRvcl0uY29uY2F0KGFyZ3MpKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11c2VsZXNzLWNhbGxcbiAgfSk7XG4gIHJldHVybiBhY2N1bXVsYXRvcjtcbn1cbmZ1bmN0aW9uIGNhbGxIb29rcyhob29rKSB7XG4gIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgfVxuXG4gIHZhciBob29rRm5zID0gX2hvb2tzW2hvb2tdIHx8IFtdO1xuICBob29rRm5zLmZvckVhY2goZnVuY3Rpb24gKGhvb2tGbikge1xuICAgIGhvb2tGbi5hcHBseShudWxsLCBhcmdzKTtcbiAgfSk7XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBjYWxsUHJvdmlkZWQoKSB7XG4gIHZhciBob29rID0gYXJndW1lbnRzWzBdO1xuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHJldHVybiBwcm92aWRlcnNbaG9va10gPyBwcm92aWRlcnNbaG9va10uYXBwbHkobnVsbCwgYXJncykgOiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGZpbmRJY29uRGVmaW5pdGlvbihpY29uTG9va3VwKSB7XG4gIGlmIChpY29uTG9va3VwLnByZWZpeCA9PT0gJ2ZhJykge1xuICAgIGljb25Mb29rdXAucHJlZml4ID0gJ2Zhcyc7XG4gIH1cblxuICB2YXIgaWNvbk5hbWUgPSBpY29uTG9va3VwLmljb25OYW1lO1xuICB2YXIgcHJlZml4ID0gaWNvbkxvb2t1cC5wcmVmaXggfHwgZ2V0RGVmYXVsdFVzYWJsZVByZWZpeCgpO1xuICBpZiAoIWljb25OYW1lKSByZXR1cm47XG4gIGljb25OYW1lID0gYnlBbGlhcyhwcmVmaXgsIGljb25OYW1lKSB8fCBpY29uTmFtZTtcbiAgcmV0dXJuIGljb25Gcm9tTWFwcGluZyhsaWJyYXJ5LmRlZmluaXRpb25zLCBwcmVmaXgsIGljb25OYW1lKSB8fCBpY29uRnJvbU1hcHBpbmcobmFtZXNwYWNlLnN0eWxlcywgcHJlZml4LCBpY29uTmFtZSk7XG59XG52YXIgbGlicmFyeSA9IG5ldyBMaWJyYXJ5KCk7XG52YXIgbm9BdXRvID0gZnVuY3Rpb24gbm9BdXRvKCkge1xuICBjb25maWcuYXV0b1JlcGxhY2VTdmcgPSBmYWxzZTtcbiAgY29uZmlnLm9ic2VydmVNdXRhdGlvbnMgPSBmYWxzZTtcbiAgY2FsbEhvb2tzKCdub0F1dG8nKTtcbn07XG52YXIgZG9tID0ge1xuICBpMnN2ZzogZnVuY3Rpb24gaTJzdmcoKSB7XG4gICAgdmFyIHBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICBpZiAoSVNfRE9NKSB7XG4gICAgICBjYWxsSG9va3MoJ2JlZm9yZUkyc3ZnJywgcGFyYW1zKTtcbiAgICAgIGNhbGxQcm92aWRlZCgncHNldWRvRWxlbWVudHMyc3ZnJywgcGFyYW1zKTtcbiAgICAgIHJldHVybiBjYWxsUHJvdmlkZWQoJ2kyc3ZnJywgcGFyYW1zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdPcGVyYXRpb24gcmVxdWlyZXMgYSBET00gb2Ygc29tZSBraW5kLicpO1xuICAgIH1cbiAgfSxcbiAgd2F0Y2g6IGZ1bmN0aW9uIHdhdGNoKCkge1xuICAgIHZhciBwYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHZhciBhdXRvUmVwbGFjZVN2Z1Jvb3QgPSBwYXJhbXMuYXV0b1JlcGxhY2VTdmdSb290O1xuXG4gICAgaWYgKGNvbmZpZy5hdXRvUmVwbGFjZVN2ZyA9PT0gZmFsc2UpIHtcbiAgICAgIGNvbmZpZy5hdXRvUmVwbGFjZVN2ZyA9IHRydWU7XG4gICAgfVxuXG4gICAgY29uZmlnLm9ic2VydmVNdXRhdGlvbnMgPSB0cnVlO1xuICAgIGRvbXJlYWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgIGF1dG9SZXBsYWNlKHtcbiAgICAgICAgYXV0b1JlcGxhY2VTdmdSb290OiBhdXRvUmVwbGFjZVN2Z1Jvb3RcbiAgICAgIH0pO1xuICAgICAgY2FsbEhvb2tzKCd3YXRjaCcsIHBhcmFtcyk7XG4gICAgfSk7XG4gIH1cbn07XG52YXIgcGFyc2UgPSB7XG4gIGljb246IGZ1bmN0aW9uIGljb24oX2ljb24pIHtcbiAgICBpZiAoX2ljb24gPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChfdHlwZW9mKF9pY29uKSA9PT0gJ29iamVjdCcgJiYgX2ljb24ucHJlZml4ICYmIF9pY29uLmljb25OYW1lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcmVmaXg6IF9pY29uLnByZWZpeCxcbiAgICAgICAgaWNvbk5hbWU6IGJ5QWxpYXMoX2ljb24ucHJlZml4LCBfaWNvbi5pY29uTmFtZSkgfHwgX2ljb24uaWNvbk5hbWVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoX2ljb24pICYmIF9pY29uLmxlbmd0aCA9PT0gMikge1xuICAgICAgdmFyIGljb25OYW1lID0gX2ljb25bMV0uaW5kZXhPZignZmEtJykgPT09IDAgPyBfaWNvblsxXS5zbGljZSgzKSA6IF9pY29uWzFdO1xuICAgICAgdmFyIHByZWZpeCA9IGdldENhbm9uaWNhbFByZWZpeChfaWNvblswXSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcmVmaXg6IHByZWZpeCxcbiAgICAgICAgaWNvbk5hbWU6IGJ5QWxpYXMocHJlZml4LCBpY29uTmFtZSkgfHwgaWNvbk5hbWVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBfaWNvbiA9PT0gJ3N0cmluZycgJiYgKF9pY29uLmluZGV4T2YoXCJcIi5jb25jYXQoY29uZmlnLmNzc1ByZWZpeCwgXCItXCIpKSA+IC0xIHx8IF9pY29uLm1hdGNoKElDT05fU0VMRUNUSU9OX1NZTlRBWF9QQVRURVJOKSkpIHtcbiAgICAgIHZhciBjYW5vbmljYWxJY29uID0gZ2V0Q2Fub25pY2FsSWNvbihfaWNvbi5zcGxpdCgnICcpLCB7XG4gICAgICAgIHNraXBMb29rdXBzOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByZWZpeDogY2Fub25pY2FsSWNvbi5wcmVmaXggfHwgZ2V0RGVmYXVsdFVzYWJsZVByZWZpeCgpLFxuICAgICAgICBpY29uTmFtZTogYnlBbGlhcyhjYW5vbmljYWxJY29uLnByZWZpeCwgY2Fub25pY2FsSWNvbi5pY29uTmFtZSkgfHwgY2Fub25pY2FsSWNvbi5pY29uTmFtZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIF9pY29uID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIF9wcmVmaXggPSBnZXREZWZhdWx0VXNhYmxlUHJlZml4KCk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByZWZpeDogX3ByZWZpeCxcbiAgICAgICAgaWNvbk5hbWU6IGJ5QWxpYXMoX3ByZWZpeCwgX2ljb24pIHx8IF9pY29uXG4gICAgICB9O1xuICAgIH1cbiAgfVxufTtcbnZhciBhcGkgPSB7XG4gIG5vQXV0bzogbm9BdXRvLFxuICBjb25maWc6IGNvbmZpZyxcbiAgZG9tOiBkb20sXG4gIHBhcnNlOiBwYXJzZSxcbiAgbGlicmFyeTogbGlicmFyeSxcbiAgZmluZEljb25EZWZpbml0aW9uOiBmaW5kSWNvbkRlZmluaXRpb24sXG4gIHRvSHRtbDogdG9IdG1sXG59O1xuXG52YXIgYXV0b1JlcGxhY2UgPSBmdW5jdGlvbiBhdXRvUmVwbGFjZSgpIHtcbiAgdmFyIHBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIHZhciBfcGFyYW1zJGF1dG9SZXBsYWNlU3YgPSBwYXJhbXMuYXV0b1JlcGxhY2VTdmdSb290LFxuICAgICAgYXV0b1JlcGxhY2VTdmdSb290ID0gX3BhcmFtcyRhdXRvUmVwbGFjZVN2ID09PSB2b2lkIDAgPyBET0NVTUVOVCA6IF9wYXJhbXMkYXV0b1JlcGxhY2VTdjtcbiAgaWYgKChPYmplY3Qua2V5cyhuYW1lc3BhY2Uuc3R5bGVzKS5sZW5ndGggPiAwIHx8IGNvbmZpZy5hdXRvRmV0Y2hTdmcpICYmIElTX0RPTSAmJiBjb25maWcuYXV0b1JlcGxhY2VTdmcpIGFwaS5kb20uaTJzdmcoe1xuICAgIG5vZGU6IGF1dG9SZXBsYWNlU3ZnUm9vdFxuICB9KTtcbn07XG5cbmZ1bmN0aW9uIGRvbVZhcmlhbnRzKHZhbCwgYWJzdHJhY3RDcmVhdG9yKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWwsICdhYnN0cmFjdCcsIHtcbiAgICBnZXQ6IGFic3RyYWN0Q3JlYXRvclxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbCwgJ2h0bWwnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdmFsLmFic3RyYWN0Lm1hcChmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gdG9IdG1sKGEpO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbCwgJ25vZGUnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlTX0RPTSkgcmV0dXJuO1xuICAgICAgdmFyIGNvbnRhaW5lciA9IERPQ1VNRU5ULmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9IHZhbC5odG1sO1xuICAgICAgcmV0dXJuIGNvbnRhaW5lci5jaGlsZHJlbjtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdmFsO1xufVxuXG5mdW5jdGlvbiBhc0ljb24gKF9yZWYpIHtcbiAgdmFyIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIG1haW4gPSBfcmVmLm1haW4sXG4gICAgICBtYXNrID0gX3JlZi5tYXNrLFxuICAgICAgYXR0cmlidXRlcyA9IF9yZWYuYXR0cmlidXRlcyxcbiAgICAgIHN0eWxlcyA9IF9yZWYuc3R5bGVzLFxuICAgICAgdHJhbnNmb3JtID0gX3JlZi50cmFuc2Zvcm07XG5cbiAgaWYgKHRyYW5zZm9ybUlzTWVhbmluZ2Z1bCh0cmFuc2Zvcm0pICYmIG1haW4uZm91bmQgJiYgIW1hc2suZm91bmQpIHtcbiAgICB2YXIgd2lkdGggPSBtYWluLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBtYWluLmhlaWdodDtcbiAgICB2YXIgb2Zmc2V0ID0ge1xuICAgICAgeDogd2lkdGggLyBoZWlnaHQgLyAyLFxuICAgICAgeTogMC41XG4gICAgfTtcbiAgICBhdHRyaWJ1dGVzWydzdHlsZSddID0gam9pblN0eWxlcyhfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgc3R5bGVzKSwge30sIHtcbiAgICAgICd0cmFuc2Zvcm0tb3JpZ2luJzogXCJcIi5jb25jYXQob2Zmc2V0LnggKyB0cmFuc2Zvcm0ueCAvIDE2LCBcImVtIFwiKS5jb25jYXQob2Zmc2V0LnkgKyB0cmFuc2Zvcm0ueSAvIDE2LCBcImVtXCIpXG4gICAgfSkpO1xuICB9XG5cbiAgcmV0dXJuIFt7XG4gICAgdGFnOiAnc3ZnJyxcbiAgICBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVzLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICB9XTtcbn1cblxuZnVuY3Rpb24gYXNTeW1ib2wgKF9yZWYpIHtcbiAgdmFyIHByZWZpeCA9IF9yZWYucHJlZml4LFxuICAgICAgaWNvbk5hbWUgPSBfcmVmLmljb25OYW1lLFxuICAgICAgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgYXR0cmlidXRlcyA9IF9yZWYuYXR0cmlidXRlcyxcbiAgICAgIHN5bWJvbCA9IF9yZWYuc3ltYm9sO1xuICB2YXIgaWQgPSBzeW1ib2wgPT09IHRydWUgPyBcIlwiLmNvbmNhdChwcmVmaXgsIFwiLVwiKS5jb25jYXQoY29uZmlnLmNzc1ByZWZpeCwgXCItXCIpLmNvbmNhdChpY29uTmFtZSkgOiBzeW1ib2w7XG4gIHJldHVybiBbe1xuICAgIHRhZzogJ3N2ZycsXG4gICAgYXR0cmlidXRlczoge1xuICAgICAgc3R5bGU6ICdkaXNwbGF5OiBub25lOydcbiAgICB9LFxuICAgIGNoaWxkcmVuOiBbe1xuICAgICAgdGFnOiAnc3ltYm9sJyxcbiAgICAgIGF0dHJpYnV0ZXM6IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBhdHRyaWJ1dGVzKSwge30sIHtcbiAgICAgICAgaWQ6IGlkXG4gICAgICB9KSxcbiAgICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICAgIH1dXG4gIH1dO1xufVxuXG5mdW5jdGlvbiBtYWtlSW5saW5lU3ZnQWJzdHJhY3QocGFyYW1zKSB7XG4gIHZhciBfcGFyYW1zJGljb25zID0gcGFyYW1zLmljb25zLFxuICAgICAgbWFpbiA9IF9wYXJhbXMkaWNvbnMubWFpbixcbiAgICAgIG1hc2sgPSBfcGFyYW1zJGljb25zLm1hc2ssXG4gICAgICBwcmVmaXggPSBwYXJhbXMucHJlZml4LFxuICAgICAgaWNvbk5hbWUgPSBwYXJhbXMuaWNvbk5hbWUsXG4gICAgICB0cmFuc2Zvcm0gPSBwYXJhbXMudHJhbnNmb3JtLFxuICAgICAgc3ltYm9sID0gcGFyYW1zLnN5bWJvbCxcbiAgICAgIHRpdGxlID0gcGFyYW1zLnRpdGxlLFxuICAgICAgbWFza0lkID0gcGFyYW1zLm1hc2tJZCxcbiAgICAgIHRpdGxlSWQgPSBwYXJhbXMudGl0bGVJZCxcbiAgICAgIGV4dHJhID0gcGFyYW1zLmV4dHJhLFxuICAgICAgX3BhcmFtcyR3YXRjaGFibGUgPSBwYXJhbXMud2F0Y2hhYmxlLFxuICAgICAgd2F0Y2hhYmxlID0gX3BhcmFtcyR3YXRjaGFibGUgPT09IHZvaWQgMCA/IGZhbHNlIDogX3BhcmFtcyR3YXRjaGFibGU7XG5cbiAgdmFyIF9yZWYgPSBtYXNrLmZvdW5kID8gbWFzayA6IG1haW4sXG4gICAgICB3aWR0aCA9IF9yZWYud2lkdGgsXG4gICAgICBoZWlnaHQgPSBfcmVmLmhlaWdodDtcblxuICB2YXIgaXNVcGxvYWRlZEljb24gPSBwcmVmaXggPT09ICdmYWsnO1xuICB2YXIgYXR0ckNsYXNzID0gW2NvbmZpZy5yZXBsYWNlbWVudENsYXNzLCBpY29uTmFtZSA/IFwiXCIuY29uY2F0KGNvbmZpZy5jc3NQcmVmaXgsIFwiLVwiKS5jb25jYXQoaWNvbk5hbWUpIDogJyddLmZpbHRlcihmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiBleHRyYS5jbGFzc2VzLmluZGV4T2YoYykgPT09IC0xO1xuICB9KS5maWx0ZXIoZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gYyAhPT0gJycgfHwgISFjO1xuICB9KS5jb25jYXQoZXh0cmEuY2xhc3Nlcykuam9pbignICcpO1xuICB2YXIgY29udGVudCA9IHtcbiAgICBjaGlsZHJlbjogW10sXG4gICAgYXR0cmlidXRlczogX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGV4dHJhLmF0dHJpYnV0ZXMpLCB7fSwge1xuICAgICAgJ2RhdGEtcHJlZml4JzogcHJlZml4LFxuICAgICAgJ2RhdGEtaWNvbic6IGljb25OYW1lLFxuICAgICAgJ2NsYXNzJzogYXR0ckNsYXNzLFxuICAgICAgJ3JvbGUnOiBleHRyYS5hdHRyaWJ1dGVzLnJvbGUgfHwgJ2ltZycsXG4gICAgICAneG1sbnMnOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuICAgICAgJ3ZpZXdCb3gnOiBcIjAgMCBcIi5jb25jYXQod2lkdGgsIFwiIFwiKS5jb25jYXQoaGVpZ2h0KVxuICAgIH0pXG4gIH07XG4gIHZhciB1cGxvYWRlZEljb25XaWR0aFN0eWxlID0gaXNVcGxvYWRlZEljb24gJiYgIX5leHRyYS5jbGFzc2VzLmluZGV4T2YoJ2ZhLWZ3JykgPyB7XG4gICAgd2lkdGg6IFwiXCIuY29uY2F0KHdpZHRoIC8gaGVpZ2h0ICogMTYgKiAwLjA2MjUsIFwiZW1cIilcbiAgfSA6IHt9O1xuXG4gIGlmICh3YXRjaGFibGUpIHtcbiAgICBjb250ZW50LmF0dHJpYnV0ZXNbREFUQV9GQV9JMlNWR10gPSAnJztcbiAgfVxuXG4gIGlmICh0aXRsZSkge1xuICAgIGNvbnRlbnQuY2hpbGRyZW4ucHVzaCh7XG4gICAgICB0YWc6ICd0aXRsZScsXG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIGlkOiBjb250ZW50LmF0dHJpYnV0ZXNbJ2FyaWEtbGFiZWxsZWRieSddIHx8IFwidGl0bGUtXCIuY29uY2F0KHRpdGxlSWQgfHwgbmV4dFVuaXF1ZUlkKCkpXG4gICAgICB9LFxuICAgICAgY2hpbGRyZW46IFt0aXRsZV1cbiAgICB9KTtcbiAgICBkZWxldGUgY29udGVudC5hdHRyaWJ1dGVzLnRpdGxlO1xuICB9XG5cbiAgdmFyIGFyZ3MgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgY29udGVudCksIHt9LCB7XG4gICAgcHJlZml4OiBwcmVmaXgsXG4gICAgaWNvbk5hbWU6IGljb25OYW1lLFxuICAgIG1haW46IG1haW4sXG4gICAgbWFzazogbWFzayxcbiAgICBtYXNrSWQ6IG1hc2tJZCxcbiAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgICBzeW1ib2w6IHN5bWJvbCxcbiAgICBzdHlsZXM6IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCB1cGxvYWRlZEljb25XaWR0aFN0eWxlKSwgZXh0cmEuc3R5bGVzKVxuICB9KTtcblxuICB2YXIgX3JlZjIgPSBtYXNrLmZvdW5kICYmIG1haW4uZm91bmQgPyBjYWxsUHJvdmlkZWQoJ2dlbmVyYXRlQWJzdHJhY3RNYXNrJywgYXJncykgfHwge1xuICAgIGNoaWxkcmVuOiBbXSxcbiAgICBhdHRyaWJ1dGVzOiB7fVxuICB9IDogY2FsbFByb3ZpZGVkKCdnZW5lcmF0ZUFic3RyYWN0SWNvbicsIGFyZ3MpIHx8IHtcbiAgICBjaGlsZHJlbjogW10sXG4gICAgYXR0cmlidXRlczoge31cbiAgfSxcbiAgICAgIGNoaWxkcmVuID0gX3JlZjIuY2hpbGRyZW4sXG4gICAgICBhdHRyaWJ1dGVzID0gX3JlZjIuYXR0cmlidXRlcztcblxuICBhcmdzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIGFyZ3MuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG5cbiAgaWYgKHN5bWJvbCkge1xuICAgIHJldHVybiBhc1N5bWJvbChhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYXNJY29uKGFyZ3MpO1xuICB9XG59XG5mdW5jdGlvbiBtYWtlTGF5ZXJzVGV4dEFic3RyYWN0KHBhcmFtcykge1xuICB2YXIgY29udGVudCA9IHBhcmFtcy5jb250ZW50LFxuICAgICAgd2lkdGggPSBwYXJhbXMud2lkdGgsXG4gICAgICBoZWlnaHQgPSBwYXJhbXMuaGVpZ2h0LFxuICAgICAgdHJhbnNmb3JtID0gcGFyYW1zLnRyYW5zZm9ybSxcbiAgICAgIHRpdGxlID0gcGFyYW1zLnRpdGxlLFxuICAgICAgZXh0cmEgPSBwYXJhbXMuZXh0cmEsXG4gICAgICBfcGFyYW1zJHdhdGNoYWJsZTIgPSBwYXJhbXMud2F0Y2hhYmxlLFxuICAgICAgd2F0Y2hhYmxlID0gX3BhcmFtcyR3YXRjaGFibGUyID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wYXJhbXMkd2F0Y2hhYmxlMjtcblxuICB2YXIgYXR0cmlidXRlcyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBleHRyYS5hdHRyaWJ1dGVzKSwgdGl0bGUgPyB7XG4gICAgJ3RpdGxlJzogdGl0bGVcbiAgfSA6IHt9KSwge30sIHtcbiAgICAnY2xhc3MnOiBleHRyYS5jbGFzc2VzLmpvaW4oJyAnKVxuICB9KTtcblxuICBpZiAod2F0Y2hhYmxlKSB7XG4gICAgYXR0cmlidXRlc1tEQVRBX0ZBX0kyU1ZHXSA9ICcnO1xuICB9XG5cbiAgdmFyIHN0eWxlcyA9IF9vYmplY3RTcHJlYWQyKHt9LCBleHRyYS5zdHlsZXMpO1xuXG4gIGlmICh0cmFuc2Zvcm1Jc01lYW5pbmdmdWwodHJhbnNmb3JtKSkge1xuICAgIHN0eWxlc1sndHJhbnNmb3JtJ10gPSB0cmFuc2Zvcm1Gb3JDc3Moe1xuICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gICAgICBzdGFydENlbnRlcmVkOiB0cnVlLFxuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICB9KTtcbiAgICBzdHlsZXNbJy13ZWJraXQtdHJhbnNmb3JtJ10gPSBzdHlsZXNbJ3RyYW5zZm9ybSddO1xuICB9XG5cbiAgdmFyIHN0eWxlU3RyaW5nID0gam9pblN0eWxlcyhzdHlsZXMpO1xuXG4gIGlmIChzdHlsZVN0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgYXR0cmlidXRlc1snc3R5bGUnXSA9IHN0eWxlU3RyaW5nO1xuICB9XG5cbiAgdmFyIHZhbCA9IFtdO1xuICB2YWwucHVzaCh7XG4gICAgdGFnOiAnc3BhbicsXG4gICAgYXR0cmlidXRlczogYXR0cmlidXRlcyxcbiAgICBjaGlsZHJlbjogW2NvbnRlbnRdXG4gIH0pO1xuXG4gIGlmICh0aXRsZSkge1xuICAgIHZhbC5wdXNoKHtcbiAgICAgIHRhZzogJ3NwYW4nLFxuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICBjbGFzczogJ3NyLW9ubHknXG4gICAgICB9LFxuICAgICAgY2hpbGRyZW46IFt0aXRsZV1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB2YWw7XG59XG5mdW5jdGlvbiBtYWtlTGF5ZXJzQ291bnRlckFic3RyYWN0KHBhcmFtcykge1xuICB2YXIgY29udGVudCA9IHBhcmFtcy5jb250ZW50LFxuICAgICAgdGl0bGUgPSBwYXJhbXMudGl0bGUsXG4gICAgICBleHRyYSA9IHBhcmFtcy5leHRyYTtcblxuICB2YXIgYXR0cmlidXRlcyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBleHRyYS5hdHRyaWJ1dGVzKSwgdGl0bGUgPyB7XG4gICAgJ3RpdGxlJzogdGl0bGVcbiAgfSA6IHt9KSwge30sIHtcbiAgICAnY2xhc3MnOiBleHRyYS5jbGFzc2VzLmpvaW4oJyAnKVxuICB9KTtcblxuICB2YXIgc3R5bGVTdHJpbmcgPSBqb2luU3R5bGVzKGV4dHJhLnN0eWxlcyk7XG5cbiAgaWYgKHN0eWxlU3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICBhdHRyaWJ1dGVzWydzdHlsZSddID0gc3R5bGVTdHJpbmc7XG4gIH1cblxuICB2YXIgdmFsID0gW107XG4gIHZhbC5wdXNoKHtcbiAgICB0YWc6ICdzcGFuJyxcbiAgICBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVzLFxuICAgIGNoaWxkcmVuOiBbY29udGVudF1cbiAgfSk7XG5cbiAgaWYgKHRpdGxlKSB7XG4gICAgdmFsLnB1c2goe1xuICAgICAgdGFnOiAnc3BhbicsXG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIGNsYXNzOiAnc3Itb25seSdcbiAgICAgIH0sXG4gICAgICBjaGlsZHJlbjogW3RpdGxlXVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn1cblxudmFyIHN0eWxlcyQxID0gbmFtZXNwYWNlLnN0eWxlcztcbmZ1bmN0aW9uIGFzRm91bmRJY29uKGljb24pIHtcbiAgdmFyIHdpZHRoID0gaWNvblswXTtcbiAgdmFyIGhlaWdodCA9IGljb25bMV07XG5cbiAgdmFyIF9pY29uJHNsaWNlID0gaWNvbi5zbGljZSg0KSxcbiAgICAgIF9pY29uJHNsaWNlMiA9IF9zbGljZWRUb0FycmF5KF9pY29uJHNsaWNlLCAxKSxcbiAgICAgIHZlY3RvckRhdGEgPSBfaWNvbiRzbGljZTJbMF07XG5cbiAgdmFyIGVsZW1lbnQgPSBudWxsO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KHZlY3RvckRhdGEpKSB7XG4gICAgZWxlbWVudCA9IHtcbiAgICAgIHRhZzogJ2cnLFxuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICBjbGFzczogXCJcIi5jb25jYXQoY29uZmlnLmNzc1ByZWZpeCwgXCItXCIpLmNvbmNhdChEVU9UT05FX0NMQVNTRVMuR1JPVVApXG4gICAgICB9LFxuICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgIHRhZzogJ3BhdGgnLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgY2xhc3M6IFwiXCIuY29uY2F0KGNvbmZpZy5jc3NQcmVmaXgsIFwiLVwiKS5jb25jYXQoRFVPVE9ORV9DTEFTU0VTLlNFQ09OREFSWSksXG4gICAgICAgICAgZmlsbDogJ2N1cnJlbnRDb2xvcicsXG4gICAgICAgICAgZDogdmVjdG9yRGF0YVswXVxuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIHRhZzogJ3BhdGgnLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgY2xhc3M6IFwiXCIuY29uY2F0KGNvbmZpZy5jc3NQcmVmaXgsIFwiLVwiKS5jb25jYXQoRFVPVE9ORV9DTEFTU0VTLlBSSU1BUlkpLFxuICAgICAgICAgIGZpbGw6ICdjdXJyZW50Q29sb3InLFxuICAgICAgICAgIGQ6IHZlY3RvckRhdGFbMV1cbiAgICAgICAgfVxuICAgICAgfV1cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGVsZW1lbnQgPSB7XG4gICAgICB0YWc6ICdwYXRoJyxcbiAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgZmlsbDogJ2N1cnJlbnRDb2xvcicsXG4gICAgICAgIGQ6IHZlY3RvckRhdGFcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBmb3VuZDogdHJ1ZSxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgaWNvbjogZWxlbWVudFxuICB9O1xufVxudmFyIG1pc3NpbmdJY29uUmVzb2x1dGlvbk1peGluID0ge1xuICBmb3VuZDogZmFsc2UsXG4gIHdpZHRoOiA1MTIsXG4gIGhlaWdodDogNTEyXG59O1xuXG5mdW5jdGlvbiBtYXliZU5vdGlmeU1pc3NpbmcoaWNvbk5hbWUsIHByZWZpeCkge1xuICBpZiAoIVBST0RVQ1RJT04gJiYgIWNvbmZpZy5zaG93TWlzc2luZ0ljb25zICYmIGljb25OYW1lKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkljb24gd2l0aCBuYW1lIFxcXCJcIi5jb25jYXQoaWNvbk5hbWUsIFwiXFxcIiBhbmQgcHJlZml4IFxcXCJcIikuY29uY2F0KHByZWZpeCwgXCJcXFwiIGlzIG1pc3NpbmcuXCIpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kSWNvbihpY29uTmFtZSwgcHJlZml4KSB7XG4gIHZhciBnaXZlblByZWZpeCA9IHByZWZpeDtcblxuICBpZiAocHJlZml4ID09PSAnZmEnICYmIGNvbmZpZy5zdHlsZURlZmF1bHQgIT09IG51bGwpIHtcbiAgICBwcmVmaXggPSBnZXREZWZhdWx0VXNhYmxlUHJlZml4KCk7XG4gIH1cblxuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciB2YWwgPSB7XG4gICAgICBmb3VuZDogZmFsc2UsXG4gICAgICB3aWR0aDogNTEyLFxuICAgICAgaGVpZ2h0OiA1MTIsXG4gICAgICBpY29uOiBjYWxsUHJvdmlkZWQoJ21pc3NpbmdJY29uQWJzdHJhY3QnKSB8fCB7fVxuICAgIH07XG5cbiAgICBpZiAoZ2l2ZW5QcmVmaXggPT09ICdmYScpIHtcbiAgICAgIHZhciBzaGltID0gYnlPbGROYW1lKGljb25OYW1lKSB8fCB7fTtcbiAgICAgIGljb25OYW1lID0gc2hpbS5pY29uTmFtZSB8fCBpY29uTmFtZTtcbiAgICAgIHByZWZpeCA9IHNoaW0ucHJlZml4IHx8IHByZWZpeDtcbiAgICB9XG5cbiAgICBpZiAoaWNvbk5hbWUgJiYgcHJlZml4ICYmIHN0eWxlcyQxW3ByZWZpeF0gJiYgc3R5bGVzJDFbcHJlZml4XVtpY29uTmFtZV0pIHtcbiAgICAgIHZhciBpY29uID0gc3R5bGVzJDFbcHJlZml4XVtpY29uTmFtZV07XG4gICAgICByZXR1cm4gcmVzb2x2ZShhc0ZvdW5kSWNvbihpY29uKSk7XG4gICAgfVxuXG4gICAgbWF5YmVOb3RpZnlNaXNzaW5nKGljb25OYW1lLCBwcmVmaXgpO1xuICAgIHJlc29sdmUoX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIG1pc3NpbmdJY29uUmVzb2x1dGlvbk1peGluKSwge30sIHtcbiAgICAgIGljb246IGNvbmZpZy5zaG93TWlzc2luZ0ljb25zICYmIGljb25OYW1lID8gY2FsbFByb3ZpZGVkKCdtaXNzaW5nSWNvbkFic3RyYWN0JykgfHwge30gOiB7fVxuICAgIH0pKTtcbiAgfSk7XG59XG5cbnZhciBub29wJDEgPSBmdW5jdGlvbiBub29wKCkge307XG5cbnZhciBwID0gY29uZmlnLm1lYXN1cmVQZXJmb3JtYW5jZSAmJiBQRVJGT1JNQU5DRSAmJiBQRVJGT1JNQU5DRS5tYXJrICYmIFBFUkZPUk1BTkNFLm1lYXN1cmUgPyBQRVJGT1JNQU5DRSA6IHtcbiAgbWFyazogbm9vcCQxLFxuICBtZWFzdXJlOiBub29wJDFcbn07XG52YXIgcHJlYW1ibGUgPSBcIkZBIFxcXCI2LjIuMVxcXCJcIjtcblxudmFyIGJlZ2luID0gZnVuY3Rpb24gYmVnaW4obmFtZSkge1xuICBwLm1hcmsoXCJcIi5jb25jYXQocHJlYW1ibGUsIFwiIFwiKS5jb25jYXQobmFtZSwgXCIgYmVnaW5zXCIpKTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZW5kKG5hbWUpO1xuICB9O1xufTtcblxudmFyIGVuZCA9IGZ1bmN0aW9uIGVuZChuYW1lKSB7XG4gIHAubWFyayhcIlwiLmNvbmNhdChwcmVhbWJsZSwgXCIgXCIpLmNvbmNhdChuYW1lLCBcIiBlbmRzXCIpKTtcbiAgcC5tZWFzdXJlKFwiXCIuY29uY2F0KHByZWFtYmxlLCBcIiBcIikuY29uY2F0KG5hbWUpLCBcIlwiLmNvbmNhdChwcmVhbWJsZSwgXCIgXCIpLmNvbmNhdChuYW1lLCBcIiBiZWdpbnNcIiksIFwiXCIuY29uY2F0KHByZWFtYmxlLCBcIiBcIikuY29uY2F0KG5hbWUsIFwiIGVuZHNcIikpO1xufTtcblxudmFyIHBlcmYgPSB7XG4gIGJlZ2luOiBiZWdpbixcbiAgZW5kOiBlbmRcbn07XG5cbnZhciBub29wJDIgPSBmdW5jdGlvbiBub29wKCkge307XG5cbmZ1bmN0aW9uIGlzV2F0Y2hlZChub2RlKSB7XG4gIHZhciBpMnN2ZyA9IG5vZGUuZ2V0QXR0cmlidXRlID8gbm9kZS5nZXRBdHRyaWJ1dGUoREFUQV9GQV9JMlNWRykgOiBudWxsO1xuICByZXR1cm4gdHlwZW9mIGkyc3ZnID09PSAnc3RyaW5nJztcbn1cblxuZnVuY3Rpb24gaGFzUHJlZml4QW5kSWNvbihub2RlKSB7XG4gIHZhciBwcmVmaXggPSBub2RlLmdldEF0dHJpYnV0ZSA/IG5vZGUuZ2V0QXR0cmlidXRlKERBVEFfUFJFRklYKSA6IG51bGw7XG4gIHZhciBpY29uID0gbm9kZS5nZXRBdHRyaWJ1dGUgPyBub2RlLmdldEF0dHJpYnV0ZShEQVRBX0lDT04pIDogbnVsbDtcbiAgcmV0dXJuIHByZWZpeCAmJiBpY29uO1xufVxuXG5mdW5jdGlvbiBoYXNCZWVuUmVwbGFjZWQobm9kZSkge1xuICByZXR1cm4gbm9kZSAmJiBub2RlLmNsYXNzTGlzdCAmJiBub2RlLmNsYXNzTGlzdC5jb250YWlucyAmJiBub2RlLmNsYXNzTGlzdC5jb250YWlucyhjb25maWcucmVwbGFjZW1lbnRDbGFzcyk7XG59XG5cbmZ1bmN0aW9uIGdldE11dGF0b3IoKSB7XG4gIGlmIChjb25maWcuYXV0b1JlcGxhY2VTdmcgPT09IHRydWUpIHtcbiAgICByZXR1cm4gbXV0YXRvcnMucmVwbGFjZTtcbiAgfVxuXG4gIHZhciBtdXRhdG9yID0gbXV0YXRvcnNbY29uZmlnLmF1dG9SZXBsYWNlU3ZnXTtcbiAgcmV0dXJuIG11dGF0b3IgfHwgbXV0YXRvcnMucmVwbGFjZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudE5TKHRhZykge1xuICByZXR1cm4gRE9DVU1FTlQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsIHRhZyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodGFnKSB7XG4gIHJldHVybiBET0NVTUVOVC5jcmVhdGVFbGVtZW50KHRhZyk7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRTVkcoYWJzdHJhY3RPYmopIHtcbiAgdmFyIHBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciBfcGFyYW1zJGNlRm4gPSBwYXJhbXMuY2VGbixcbiAgICAgIGNlRm4gPSBfcGFyYW1zJGNlRm4gPT09IHZvaWQgMCA/IGFic3RyYWN0T2JqLnRhZyA9PT0gJ3N2ZycgPyBjcmVhdGVFbGVtZW50TlMgOiBjcmVhdGVFbGVtZW50IDogX3BhcmFtcyRjZUZuO1xuXG4gIGlmICh0eXBlb2YgYWJzdHJhY3RPYmogPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIERPQ1VNRU5ULmNyZWF0ZVRleHROb2RlKGFic3RyYWN0T2JqKTtcbiAgfVxuXG4gIHZhciB0YWcgPSBjZUZuKGFic3RyYWN0T2JqLnRhZyk7XG4gIE9iamVjdC5rZXlzKGFic3RyYWN0T2JqLmF0dHJpYnV0ZXMgfHwgW10pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHRhZy5zZXRBdHRyaWJ1dGUoa2V5LCBhYnN0cmFjdE9iai5hdHRyaWJ1dGVzW2tleV0pO1xuICB9KTtcbiAgdmFyIGNoaWxkcmVuID0gYWJzdHJhY3RPYmouY2hpbGRyZW4gfHwgW107XG4gIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgdGFnLmFwcGVuZENoaWxkKGNvbnZlcnRTVkcoY2hpbGQsIHtcbiAgICAgIGNlRm46IGNlRm5cbiAgICB9KSk7XG4gIH0pO1xuICByZXR1cm4gdGFnO1xufVxuXG5mdW5jdGlvbiBub2RlQXNDb21tZW50KG5vZGUpIHtcbiAgdmFyIGNvbW1lbnQgPSBcIiBcIi5jb25jYXQobm9kZS5vdXRlckhUTUwsIFwiIFwiKTtcbiAgLyogQkVHSU4uQVRUUklCVVRJT04gKi9cblxuICBjb21tZW50ID0gXCJcIi5jb25jYXQoY29tbWVudCwgXCJGb250IEF3ZXNvbWUgZm9udGF3ZXNvbWUuY29tIFwiKTtcbiAgLyogRU5ELkFUVFJJQlVUSU9OICovXG5cbiAgcmV0dXJuIGNvbW1lbnQ7XG59XG5cbnZhciBtdXRhdG9ycyA9IHtcbiAgcmVwbGFjZTogZnVuY3Rpb24gcmVwbGFjZShtdXRhdGlvbikge1xuICAgIHZhciBub2RlID0gbXV0YXRpb25bMF07XG5cbiAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICBtdXRhdGlvblsxXS5mb3JFYWNoKGZ1bmN0aW9uIChhYnN0cmFjdCkge1xuICAgICAgICBub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNvbnZlcnRTVkcoYWJzdHJhY3QpLCBub2RlKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAobm9kZS5nZXRBdHRyaWJ1dGUoREFUQV9GQV9JMlNWRykgPT09IG51bGwgJiYgY29uZmlnLmtlZXBPcmlnaW5hbFNvdXJjZSkge1xuICAgICAgICB2YXIgY29tbWVudCA9IERPQ1VNRU5ULmNyZWF0ZUNvbW1lbnQobm9kZUFzQ29tbWVudChub2RlKSk7XG4gICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoY29tbWVudCwgbm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbmVzdDogZnVuY3Rpb24gbmVzdChtdXRhdGlvbikge1xuICAgIHZhciBub2RlID0gbXV0YXRpb25bMF07XG4gICAgdmFyIGFic3RyYWN0ID0gbXV0YXRpb25bMV07IC8vIElmIHdlIGFscmVhZHkgaGF2ZSBhIHJlcGxhY2VkIG5vZGUgd2UgZG8gbm90IHdhbnQgdG8gY29udGludWUgbmVzdGluZyB3aXRoaW4gaXQuXG4gICAgLy8gU2hvcnQtY2lyY3VpdCB0byB0aGUgc3RhbmRhcmQgcmVwbGFjZW1lbnRcblxuICAgIGlmICh+Y2xhc3NBcnJheShub2RlKS5pbmRleE9mKGNvbmZpZy5yZXBsYWNlbWVudENsYXNzKSkge1xuICAgICAgcmV0dXJuIG11dGF0b3JzLnJlcGxhY2UobXV0YXRpb24pO1xuICAgIH1cblxuICAgIHZhciBmb3JTdmcgPSBuZXcgUmVnRXhwKFwiXCIuY29uY2F0KGNvbmZpZy5jc3NQcmVmaXgsIFwiLS4qXCIpKTtcbiAgICBkZWxldGUgYWJzdHJhY3RbMF0uYXR0cmlidXRlcy5pZDtcblxuICAgIGlmIChhYnN0cmFjdFswXS5hdHRyaWJ1dGVzLmNsYXNzKSB7XG4gICAgICB2YXIgc3BsaXRDbGFzc2VzID0gYWJzdHJhY3RbMF0uYXR0cmlidXRlcy5jbGFzcy5zcGxpdCgnICcpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBjbHMpIHtcbiAgICAgICAgaWYgKGNscyA9PT0gY29uZmlnLnJlcGxhY2VtZW50Q2xhc3MgfHwgY2xzLm1hdGNoKGZvclN2ZykpIHtcbiAgICAgICAgICBhY2MudG9TdmcucHVzaChjbHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFjYy50b05vZGUucHVzaChjbHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sIHtcbiAgICAgICAgdG9Ob2RlOiBbXSxcbiAgICAgICAgdG9Tdmc6IFtdXG4gICAgICB9KTtcbiAgICAgIGFic3RyYWN0WzBdLmF0dHJpYnV0ZXMuY2xhc3MgPSBzcGxpdENsYXNzZXMudG9Tdmcuam9pbignICcpO1xuXG4gICAgICBpZiAoc3BsaXRDbGFzc2VzLnRvTm9kZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBzcGxpdENsYXNzZXMudG9Ob2RlLmpvaW4oJyAnKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5ld0lubmVySFRNTCA9IGFic3RyYWN0Lm1hcChmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIHRvSHRtbChhKTtcbiAgICB9KS5qb2luKCdcXG4nKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShEQVRBX0ZBX0kyU1ZHLCAnJyk7XG4gICAgbm9kZS5pbm5lckhUTUwgPSBuZXdJbm5lckhUTUw7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHBlcmZvcm1PcGVyYXRpb25TeW5jKG9wKSB7XG4gIG9wKCk7XG59XG5cbmZ1bmN0aW9uIHBlcmZvcm0obXV0YXRpb25zLCBjYWxsYmFjaykge1xuICB2YXIgY2FsbGJhY2tGdW5jdGlvbiA9IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyA/IGNhbGxiYWNrIDogbm9vcCQyO1xuXG4gIGlmIChtdXRhdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgY2FsbGJhY2tGdW5jdGlvbigpO1xuICB9IGVsc2Uge1xuICAgIHZhciBmcmFtZSA9IHBlcmZvcm1PcGVyYXRpb25TeW5jO1xuXG4gICAgaWYgKGNvbmZpZy5tdXRhdGVBcHByb2FjaCA9PT0gTVVUQVRJT05fQVBQUk9BQ0hfQVNZTkMpIHtcbiAgICAgIGZyYW1lID0gV0lORE9XLnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCBwZXJmb3JtT3BlcmF0aW9uU3luYztcbiAgICB9XG5cbiAgICBmcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbXV0YXRvciA9IGdldE11dGF0b3IoKTtcbiAgICAgIHZhciBtYXJrID0gcGVyZi5iZWdpbignbXV0YXRlJyk7XG4gICAgICBtdXRhdGlvbnMubWFwKG11dGF0b3IpO1xuICAgICAgbWFyaygpO1xuICAgICAgY2FsbGJhY2tGdW5jdGlvbigpO1xuICAgIH0pO1xuICB9XG59XG52YXIgZGlzYWJsZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGRpc2FibGVPYnNlcnZhdGlvbigpIHtcbiAgZGlzYWJsZWQgPSB0cnVlO1xufVxuZnVuY3Rpb24gZW5hYmxlT2JzZXJ2YXRpb24oKSB7XG4gIGRpc2FibGVkID0gZmFsc2U7XG59XG52YXIgbW8gPSBudWxsO1xuZnVuY3Rpb24gb2JzZXJ2ZShvcHRpb25zKSB7XG4gIGlmICghTVVUQVRJT05fT0JTRVJWRVIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoIWNvbmZpZy5vYnNlcnZlTXV0YXRpb25zKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIF9vcHRpb25zJHRyZWVDYWxsYmFjayA9IG9wdGlvbnMudHJlZUNhbGxiYWNrLFxuICAgICAgdHJlZUNhbGxiYWNrID0gX29wdGlvbnMkdHJlZUNhbGxiYWNrID09PSB2b2lkIDAgPyBub29wJDIgOiBfb3B0aW9ucyR0cmVlQ2FsbGJhY2ssXG4gICAgICBfb3B0aW9ucyRub2RlQ2FsbGJhY2sgPSBvcHRpb25zLm5vZGVDYWxsYmFjayxcbiAgICAgIG5vZGVDYWxsYmFjayA9IF9vcHRpb25zJG5vZGVDYWxsYmFjayA9PT0gdm9pZCAwID8gbm9vcCQyIDogX29wdGlvbnMkbm9kZUNhbGxiYWNrLFxuICAgICAgX29wdGlvbnMkcHNldWRvRWxlbWVuID0gb3B0aW9ucy5wc2V1ZG9FbGVtZW50c0NhbGxiYWNrLFxuICAgICAgcHNldWRvRWxlbWVudHNDYWxsYmFjayA9IF9vcHRpb25zJHBzZXVkb0VsZW1lbiA9PT0gdm9pZCAwID8gbm9vcCQyIDogX29wdGlvbnMkcHNldWRvRWxlbWVuLFxuICAgICAgX29wdGlvbnMkb2JzZXJ2ZU11dGF0ID0gb3B0aW9ucy5vYnNlcnZlTXV0YXRpb25zUm9vdCxcbiAgICAgIG9ic2VydmVNdXRhdGlvbnNSb290ID0gX29wdGlvbnMkb2JzZXJ2ZU11dGF0ID09PSB2b2lkIDAgPyBET0NVTUVOVCA6IF9vcHRpb25zJG9ic2VydmVNdXRhdDtcbiAgbW8gPSBuZXcgTVVUQVRJT05fT0JTRVJWRVIoZnVuY3Rpb24gKG9iamVjdHMpIHtcbiAgICBpZiAoZGlzYWJsZWQpIHJldHVybjtcbiAgICB2YXIgZGVmYXVsdFByZWZpeCA9IGdldERlZmF1bHRVc2FibGVQcmVmaXgoKTtcbiAgICB0b0FycmF5KG9iamVjdHMpLmZvckVhY2goZnVuY3Rpb24gKG11dGF0aW9uUmVjb3JkKSB7XG4gICAgICBpZiAobXV0YXRpb25SZWNvcmQudHlwZSA9PT0gJ2NoaWxkTGlzdCcgJiYgbXV0YXRpb25SZWNvcmQuYWRkZWROb2Rlcy5sZW5ndGggPiAwICYmICFpc1dhdGNoZWQobXV0YXRpb25SZWNvcmQuYWRkZWROb2Rlc1swXSkpIHtcbiAgICAgICAgaWYgKGNvbmZpZy5zZWFyY2hQc2V1ZG9FbGVtZW50cykge1xuICAgICAgICAgIHBzZXVkb0VsZW1lbnRzQ2FsbGJhY2sobXV0YXRpb25SZWNvcmQudGFyZ2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyZWVDYWxsYmFjayhtdXRhdGlvblJlY29yZC50YXJnZXQpO1xuICAgICAgfVxuXG4gICAgICBpZiAobXV0YXRpb25SZWNvcmQudHlwZSA9PT0gJ2F0dHJpYnV0ZXMnICYmIG11dGF0aW9uUmVjb3JkLnRhcmdldC5wYXJlbnROb2RlICYmIGNvbmZpZy5zZWFyY2hQc2V1ZG9FbGVtZW50cykge1xuICAgICAgICBwc2V1ZG9FbGVtZW50c0NhbGxiYWNrKG11dGF0aW9uUmVjb3JkLnRhcmdldC5wYXJlbnROb2RlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG11dGF0aW9uUmVjb3JkLnR5cGUgPT09ICdhdHRyaWJ1dGVzJyAmJiBpc1dhdGNoZWQobXV0YXRpb25SZWNvcmQudGFyZ2V0KSAmJiB+QVRUUklCVVRFU19XQVRDSEVEX0ZPUl9NVVRBVElPTi5pbmRleE9mKG11dGF0aW9uUmVjb3JkLmF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgIGlmIChtdXRhdGlvblJlY29yZC5hdHRyaWJ1dGVOYW1lID09PSAnY2xhc3MnICYmIGhhc1ByZWZpeEFuZEljb24obXV0YXRpb25SZWNvcmQudGFyZ2V0KSkge1xuICAgICAgICAgIHZhciBfZ2V0Q2Fub25pY2FsSWNvbiA9IGdldENhbm9uaWNhbEljb24oY2xhc3NBcnJheShtdXRhdGlvblJlY29yZC50YXJnZXQpKSxcbiAgICAgICAgICAgICAgcHJlZml4ID0gX2dldENhbm9uaWNhbEljb24ucHJlZml4LFxuICAgICAgICAgICAgICBpY29uTmFtZSA9IF9nZXRDYW5vbmljYWxJY29uLmljb25OYW1lO1xuXG4gICAgICAgICAgbXV0YXRpb25SZWNvcmQudGFyZ2V0LnNldEF0dHJpYnV0ZShEQVRBX1BSRUZJWCwgcHJlZml4IHx8IGRlZmF1bHRQcmVmaXgpO1xuICAgICAgICAgIGlmIChpY29uTmFtZSkgbXV0YXRpb25SZWNvcmQudGFyZ2V0LnNldEF0dHJpYnV0ZShEQVRBX0lDT04sIGljb25OYW1lKTtcbiAgICAgICAgfSBlbHNlIGlmIChoYXNCZWVuUmVwbGFjZWQobXV0YXRpb25SZWNvcmQudGFyZ2V0KSkge1xuICAgICAgICAgIG5vZGVDYWxsYmFjayhtdXRhdGlvblJlY29yZC50YXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICBpZiAoIUlTX0RPTSkgcmV0dXJuO1xuICBtby5vYnNlcnZlKG9ic2VydmVNdXRhdGlvbnNSb290LCB7XG4gICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcbiAgICBzdWJ0cmVlOiB0cnVlXG4gIH0pO1xufVxuZnVuY3Rpb24gZGlzY29ubmVjdCgpIHtcbiAgaWYgKCFtbykgcmV0dXJuO1xuICBtby5kaXNjb25uZWN0KCk7XG59XG5cbmZ1bmN0aW9uIHN0eWxlUGFyc2VyIChub2RlKSB7XG4gIHZhciBzdHlsZSA9IG5vZGUuZ2V0QXR0cmlidXRlKCdzdHlsZScpO1xuICB2YXIgdmFsID0gW107XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgdmFsID0gc3R5bGUuc3BsaXQoJzsnKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgc3R5bGUpIHtcbiAgICAgIHZhciBzdHlsZXMgPSBzdHlsZS5zcGxpdCgnOicpO1xuICAgICAgdmFyIHByb3AgPSBzdHlsZXNbMF07XG4gICAgICB2YXIgdmFsdWUgPSBzdHlsZXMuc2xpY2UoMSk7XG5cbiAgICAgIGlmIChwcm9wICYmIHZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYWNjW3Byb3BdID0gdmFsdWUuam9pbignOicpLnRyaW0oKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG4gIH1cblxuICByZXR1cm4gdmFsO1xufVxuXG5mdW5jdGlvbiBjbGFzc1BhcnNlciAobm9kZSkge1xuICB2YXIgZXhpc3RpbmdQcmVmaXggPSBub2RlLmdldEF0dHJpYnV0ZSgnZGF0YS1wcmVmaXgnKTtcbiAgdmFyIGV4aXN0aW5nSWNvbk5hbWUgPSBub2RlLmdldEF0dHJpYnV0ZSgnZGF0YS1pY29uJyk7XG4gIHZhciBpbm5lclRleHQgPSBub2RlLmlubmVyVGV4dCAhPT0gdW5kZWZpbmVkID8gbm9kZS5pbm5lclRleHQudHJpbSgpIDogJyc7XG4gIHZhciB2YWwgPSBnZXRDYW5vbmljYWxJY29uKGNsYXNzQXJyYXkobm9kZSkpO1xuXG4gIGlmICghdmFsLnByZWZpeCkge1xuICAgIHZhbC5wcmVmaXggPSBnZXREZWZhdWx0VXNhYmxlUHJlZml4KCk7XG4gIH1cblxuICBpZiAoZXhpc3RpbmdQcmVmaXggJiYgZXhpc3RpbmdJY29uTmFtZSkge1xuICAgIHZhbC5wcmVmaXggPSBleGlzdGluZ1ByZWZpeDtcbiAgICB2YWwuaWNvbk5hbWUgPSBleGlzdGluZ0ljb25OYW1lO1xuICB9XG5cbiAgaWYgKHZhbC5pY29uTmFtZSAmJiB2YWwucHJlZml4KSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIGlmICh2YWwucHJlZml4ICYmIGlubmVyVGV4dC5sZW5ndGggPiAwKSB7XG4gICAgdmFsLmljb25OYW1lID0gYnlMaWdhdHVyZSh2YWwucHJlZml4LCBub2RlLmlubmVyVGV4dCkgfHwgYnlVbmljb2RlKHZhbC5wcmVmaXgsIHRvSGV4KG5vZGUuaW5uZXJUZXh0KSk7XG4gIH1cblxuICBpZiAoIXZhbC5pY29uTmFtZSAmJiBjb25maWcuYXV0b0ZldGNoU3ZnICYmIG5vZGUuZmlyc3RDaGlsZCAmJiBub2RlLmZpcnN0Q2hpbGQubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgdmFsLmljb25OYW1lID0gbm9kZS5maXJzdENoaWxkLmRhdGE7XG4gIH1cblxuICByZXR1cm4gdmFsO1xufVxuXG5mdW5jdGlvbiBhdHRyaWJ1dGVzUGFyc2VyIChub2RlKSB7XG4gIHZhciBleHRyYUF0dHJpYnV0ZXMgPSB0b0FycmF5KG5vZGUuYXR0cmlidXRlcykucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGF0dHIpIHtcbiAgICBpZiAoYWNjLm5hbWUgIT09ICdjbGFzcycgJiYgYWNjLm5hbWUgIT09ICdzdHlsZScpIHtcbiAgICAgIGFjY1thdHRyLm5hbWVdID0gYXR0ci52YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG4gIHZhciB0aXRsZSA9IG5vZGUuZ2V0QXR0cmlidXRlKCd0aXRsZScpO1xuICB2YXIgdGl0bGVJZCA9IG5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLWZhLXRpdGxlLWlkJyk7XG5cbiAgaWYgKGNvbmZpZy5hdXRvQTExeSkge1xuICAgIGlmICh0aXRsZSkge1xuICAgICAgZXh0cmFBdHRyaWJ1dGVzWydhcmlhLWxhYmVsbGVkYnknXSA9IFwiXCIuY29uY2F0KGNvbmZpZy5yZXBsYWNlbWVudENsYXNzLCBcIi10aXRsZS1cIikuY29uY2F0KHRpdGxlSWQgfHwgbmV4dFVuaXF1ZUlkKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHRyYUF0dHJpYnV0ZXNbJ2FyaWEtaGlkZGVuJ10gPSAndHJ1ZSc7XG4gICAgICBleHRyYUF0dHJpYnV0ZXNbJ2ZvY3VzYWJsZSddID0gJ2ZhbHNlJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXh0cmFBdHRyaWJ1dGVzO1xufVxuXG5mdW5jdGlvbiBibGFua01ldGEoKSB7XG4gIHJldHVybiB7XG4gICAgaWNvbk5hbWU6IG51bGwsXG4gICAgdGl0bGU6IG51bGwsXG4gICAgdGl0bGVJZDogbnVsbCxcbiAgICBwcmVmaXg6IG51bGwsXG4gICAgdHJhbnNmb3JtOiBtZWFuaW5nbGVzc1RyYW5zZm9ybSxcbiAgICBzeW1ib2w6IGZhbHNlLFxuICAgIG1hc2s6IHtcbiAgICAgIGljb25OYW1lOiBudWxsLFxuICAgICAgcHJlZml4OiBudWxsLFxuICAgICAgcmVzdDogW11cbiAgICB9LFxuICAgIG1hc2tJZDogbnVsbCxcbiAgICBleHRyYToge1xuICAgICAgY2xhc3NlczogW10sXG4gICAgICBzdHlsZXM6IHt9LFxuICAgICAgYXR0cmlidXRlczoge31cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZU1ldGEobm9kZSkge1xuICB2YXIgcGFyc2VyID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7XG4gICAgc3R5bGVQYXJzZXI6IHRydWVcbiAgfTtcblxuICB2YXIgX2NsYXNzUGFyc2VyID0gY2xhc3NQYXJzZXIobm9kZSksXG4gICAgICBpY29uTmFtZSA9IF9jbGFzc1BhcnNlci5pY29uTmFtZSxcbiAgICAgIHByZWZpeCA9IF9jbGFzc1BhcnNlci5wcmVmaXgsXG4gICAgICBleHRyYUNsYXNzZXMgPSBfY2xhc3NQYXJzZXIucmVzdDtcblxuICB2YXIgZXh0cmFBdHRyaWJ1dGVzID0gYXR0cmlidXRlc1BhcnNlcihub2RlKTtcbiAgdmFyIHBsdWdpbk1ldGEgPSBjaGFpbkhvb2tzKCdwYXJzZU5vZGVBdHRyaWJ1dGVzJywge30sIG5vZGUpO1xuICB2YXIgZXh0cmFTdHlsZXMgPSBwYXJzZXIuc3R5bGVQYXJzZXIgPyBzdHlsZVBhcnNlcihub2RlKSA6IFtdO1xuICByZXR1cm4gX29iamVjdFNwcmVhZDIoe1xuICAgIGljb25OYW1lOiBpY29uTmFtZSxcbiAgICB0aXRsZTogbm9kZS5nZXRBdHRyaWJ1dGUoJ3RpdGxlJyksXG4gICAgdGl0bGVJZDogbm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtZmEtdGl0bGUtaWQnKSxcbiAgICBwcmVmaXg6IHByZWZpeCxcbiAgICB0cmFuc2Zvcm06IG1lYW5pbmdsZXNzVHJhbnNmb3JtLFxuICAgIG1hc2s6IHtcbiAgICAgIGljb25OYW1lOiBudWxsLFxuICAgICAgcHJlZml4OiBudWxsLFxuICAgICAgcmVzdDogW11cbiAgICB9LFxuICAgIG1hc2tJZDogbnVsbCxcbiAgICBzeW1ib2w6IGZhbHNlLFxuICAgIGV4dHJhOiB7XG4gICAgICBjbGFzc2VzOiBleHRyYUNsYXNzZXMsXG4gICAgICBzdHlsZXM6IGV4dHJhU3R5bGVzLFxuICAgICAgYXR0cmlidXRlczogZXh0cmFBdHRyaWJ1dGVzXG4gICAgfVxuICB9LCBwbHVnaW5NZXRhKTtcbn1cblxudmFyIHN0eWxlcyQyID0gbmFtZXNwYWNlLnN0eWxlcztcblxuZnVuY3Rpb24gZ2VuZXJhdGVNdXRhdGlvbihub2RlKSB7XG4gIHZhciBub2RlTWV0YSA9IGNvbmZpZy5hdXRvUmVwbGFjZVN2ZyA9PT0gJ25lc3QnID8gcGFyc2VNZXRhKG5vZGUsIHtcbiAgICBzdHlsZVBhcnNlcjogZmFsc2VcbiAgfSkgOiBwYXJzZU1ldGEobm9kZSk7XG5cbiAgaWYgKH5ub2RlTWV0YS5leHRyYS5jbGFzc2VzLmluZGV4T2YoTEFZRVJTX1RFWFRfQ0xBU1NOQU1FKSkge1xuICAgIHJldHVybiBjYWxsUHJvdmlkZWQoJ2dlbmVyYXRlTGF5ZXJzVGV4dCcsIG5vZGUsIG5vZGVNZXRhKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY2FsbFByb3ZpZGVkKCdnZW5lcmF0ZVN2Z1JlcGxhY2VtZW50TXV0YXRpb24nLCBub2RlLCBub2RlTWV0YSk7XG4gIH1cbn1cblxudmFyIGtub3duUHJlZml4ZXMgPSBuZXcgU2V0KCk7XG5GQU1JTElFUy5tYXAoZnVuY3Rpb24gKGZhbWlseSkge1xuICBrbm93blByZWZpeGVzLmFkZChcImZhLVwiLmNvbmNhdChmYW1pbHkpKTtcbn0pO1xuT2JqZWN0LmtleXMoUFJFRklYX1RPX1NUWUxFW0ZBTUlMWV9DTEFTU0lDXSkubWFwKGtub3duUHJlZml4ZXMuYWRkLmJpbmQoa25vd25QcmVmaXhlcykpO1xuT2JqZWN0LmtleXMoUFJFRklYX1RPX1NUWUxFW0ZBTUlMWV9TSEFSUF0pLm1hcChrbm93blByZWZpeGVzLmFkZC5iaW5kKGtub3duUHJlZml4ZXMpKTtcbmtub3duUHJlZml4ZXMgPSBfdG9Db25zdW1hYmxlQXJyYXkoa25vd25QcmVmaXhlcyk7XG5cbmZ1bmN0aW9uIG9uVHJlZShyb290KSB7XG4gIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcbiAgaWYgKCFJU19ET00pIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgdmFyIGh0bWxDbGFzc0xpc3QgPSBET0NVTUVOVC5kb2N1bWVudEVsZW1lbnQuY2xhc3NMaXN0O1xuXG4gIHZhciBoY2xBZGQgPSBmdW5jdGlvbiBoY2xBZGQoc3VmZml4KSB7XG4gICAgcmV0dXJuIGh0bWxDbGFzc0xpc3QuYWRkKFwiXCIuY29uY2F0KEhUTUxfQ0xBU1NfSTJTVkdfQkFTRV9DTEFTUywgXCItXCIpLmNvbmNhdChzdWZmaXgpKTtcbiAgfTtcblxuICB2YXIgaGNsUmVtb3ZlID0gZnVuY3Rpb24gaGNsUmVtb3ZlKHN1ZmZpeCkge1xuICAgIHJldHVybiBodG1sQ2xhc3NMaXN0LnJlbW92ZShcIlwiLmNvbmNhdChIVE1MX0NMQVNTX0kyU1ZHX0JBU0VfQ0xBU1MsIFwiLVwiKS5jb25jYXQoc3VmZml4KSk7XG4gIH07XG5cbiAgdmFyIHByZWZpeGVzID0gY29uZmlnLmF1dG9GZXRjaFN2ZyA/IGtub3duUHJlZml4ZXMgOiBGQU1JTElFUy5tYXAoZnVuY3Rpb24gKGYpIHtcbiAgICByZXR1cm4gXCJmYS1cIi5jb25jYXQoZik7XG4gIH0pLmNvbmNhdChPYmplY3Qua2V5cyhzdHlsZXMkMikpO1xuXG4gIGlmICghcHJlZml4ZXMuaW5jbHVkZXMoJ2ZhJykpIHtcbiAgICBwcmVmaXhlcy5wdXNoKCdmYScpO1xuICB9XG5cbiAgdmFyIHByZWZpeGVzRG9tUXVlcnkgPSBbXCIuXCIuY29uY2F0KExBWUVSU19URVhUX0NMQVNTTkFNRSwgXCI6bm90KFtcIikuY29uY2F0KERBVEFfRkFfSTJTVkcsIFwiXSlcIildLmNvbmNhdChwcmVmaXhlcy5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gXCIuXCIuY29uY2F0KHAsIFwiOm5vdChbXCIpLmNvbmNhdChEQVRBX0ZBX0kyU1ZHLCBcIl0pXCIpO1xuICB9KSkuam9pbignLCAnKTtcblxuICBpZiAocHJlZml4ZXNEb21RdWVyeS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cblxuICB2YXIgY2FuZGlkYXRlcyA9IFtdO1xuXG4gIHRyeSB7XG4gICAgY2FuZGlkYXRlcyA9IHRvQXJyYXkocm9vdC5xdWVyeVNlbGVjdG9yQWxsKHByZWZpeGVzRG9tUXVlcnkpKTtcbiAgfSBjYXRjaCAoZSkgey8vIG5vb3BcbiAgfVxuXG4gIGlmIChjYW5kaWRhdGVzLmxlbmd0aCA+IDApIHtcbiAgICBoY2xBZGQoJ3BlbmRpbmcnKTtcbiAgICBoY2xSZW1vdmUoJ2NvbXBsZXRlJyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG5cbiAgdmFyIG1hcmsgPSBwZXJmLmJlZ2luKCdvblRyZWUnKTtcbiAgdmFyIG11dGF0aW9ucyA9IGNhbmRpZGF0ZXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIG5vZGUpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIG11dGF0aW9uID0gZ2VuZXJhdGVNdXRhdGlvbihub2RlKTtcblxuICAgICAgaWYgKG11dGF0aW9uKSB7XG4gICAgICAgIGFjYy5wdXNoKG11dGF0aW9uKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoIVBST0RVQ1RJT04pIHtcbiAgICAgICAgaWYgKGUubmFtZSA9PT0gJ01pc3NpbmdJY29uJykge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYWNjO1xuICB9LCBbXSk7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgUHJvbWlzZS5hbGwobXV0YXRpb25zKS50aGVuKGZ1bmN0aW9uIChyZXNvbHZlZE11dGF0aW9ucykge1xuICAgICAgcGVyZm9ybShyZXNvbHZlZE11dGF0aW9ucywgZnVuY3Rpb24gKCkge1xuICAgICAgICBoY2xBZGQoJ2FjdGl2ZScpO1xuICAgICAgICBoY2xBZGQoJ2NvbXBsZXRlJyk7XG4gICAgICAgIGhjbFJlbW92ZSgncGVuZGluZycpO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSBjYWxsYmFjaygpO1xuICAgICAgICBtYXJrKCk7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0pO1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICBtYXJrKCk7XG4gICAgICByZWplY3QoZSk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBvbk5vZGUobm9kZSkge1xuICB2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG4gIGdlbmVyYXRlTXV0YXRpb24obm9kZSkudGhlbihmdW5jdGlvbiAobXV0YXRpb24pIHtcbiAgICBpZiAobXV0YXRpb24pIHtcbiAgICAgIHBlcmZvcm0oW211dGF0aW9uXSwgY2FsbGJhY2spO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVJY29ucyhuZXh0KSB7XG4gIHJldHVybiBmdW5jdGlvbiAobWF5YmVJY29uRGVmaW5pdGlvbikge1xuICAgIHZhciBwYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciBpY29uRGVmaW5pdGlvbiA9IChtYXliZUljb25EZWZpbml0aW9uIHx8IHt9KS5pY29uID8gbWF5YmVJY29uRGVmaW5pdGlvbiA6IGZpbmRJY29uRGVmaW5pdGlvbihtYXliZUljb25EZWZpbml0aW9uIHx8IHt9KTtcbiAgICB2YXIgbWFzayA9IHBhcmFtcy5tYXNrO1xuXG4gICAgaWYgKG1hc2spIHtcbiAgICAgIG1hc2sgPSAobWFzayB8fCB7fSkuaWNvbiA/IG1hc2sgOiBmaW5kSWNvbkRlZmluaXRpb24obWFzayB8fCB7fSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5leHQoaWNvbkRlZmluaXRpb24sIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBwYXJhbXMpLCB7fSwge1xuICAgICAgbWFzazogbWFza1xuICAgIH0pKTtcbiAgfTtcbn1cblxudmFyIHJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcihpY29uRGVmaW5pdGlvbikge1xuICB2YXIgcGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgdmFyIF9wYXJhbXMkdHJhbnNmb3JtID0gcGFyYW1zLnRyYW5zZm9ybSxcbiAgICAgIHRyYW5zZm9ybSA9IF9wYXJhbXMkdHJhbnNmb3JtID09PSB2b2lkIDAgPyBtZWFuaW5nbGVzc1RyYW5zZm9ybSA6IF9wYXJhbXMkdHJhbnNmb3JtLFxuICAgICAgX3BhcmFtcyRzeW1ib2wgPSBwYXJhbXMuc3ltYm9sLFxuICAgICAgc3ltYm9sID0gX3BhcmFtcyRzeW1ib2wgPT09IHZvaWQgMCA/IGZhbHNlIDogX3BhcmFtcyRzeW1ib2wsXG4gICAgICBfcGFyYW1zJG1hc2sgPSBwYXJhbXMubWFzayxcbiAgICAgIG1hc2sgPSBfcGFyYW1zJG1hc2sgPT09IHZvaWQgMCA/IG51bGwgOiBfcGFyYW1zJG1hc2ssXG4gICAgICBfcGFyYW1zJG1hc2tJZCA9IHBhcmFtcy5tYXNrSWQsXG4gICAgICBtYXNrSWQgPSBfcGFyYW1zJG1hc2tJZCA9PT0gdm9pZCAwID8gbnVsbCA6IF9wYXJhbXMkbWFza0lkLFxuICAgICAgX3BhcmFtcyR0aXRsZSA9IHBhcmFtcy50aXRsZSxcbiAgICAgIHRpdGxlID0gX3BhcmFtcyR0aXRsZSA9PT0gdm9pZCAwID8gbnVsbCA6IF9wYXJhbXMkdGl0bGUsXG4gICAgICBfcGFyYW1zJHRpdGxlSWQgPSBwYXJhbXMudGl0bGVJZCxcbiAgICAgIHRpdGxlSWQgPSBfcGFyYW1zJHRpdGxlSWQgPT09IHZvaWQgMCA/IG51bGwgOiBfcGFyYW1zJHRpdGxlSWQsXG4gICAgICBfcGFyYW1zJGNsYXNzZXMgPSBwYXJhbXMuY2xhc3NlcyxcbiAgICAgIGNsYXNzZXMgPSBfcGFyYW1zJGNsYXNzZXMgPT09IHZvaWQgMCA/IFtdIDogX3BhcmFtcyRjbGFzc2VzLFxuICAgICAgX3BhcmFtcyRhdHRyaWJ1dGVzID0gcGFyYW1zLmF0dHJpYnV0ZXMsXG4gICAgICBhdHRyaWJ1dGVzID0gX3BhcmFtcyRhdHRyaWJ1dGVzID09PSB2b2lkIDAgPyB7fSA6IF9wYXJhbXMkYXR0cmlidXRlcyxcbiAgICAgIF9wYXJhbXMkc3R5bGVzID0gcGFyYW1zLnN0eWxlcyxcbiAgICAgIHN0eWxlcyA9IF9wYXJhbXMkc3R5bGVzID09PSB2b2lkIDAgPyB7fSA6IF9wYXJhbXMkc3R5bGVzO1xuICBpZiAoIWljb25EZWZpbml0aW9uKSByZXR1cm47XG4gIHZhciBwcmVmaXggPSBpY29uRGVmaW5pdGlvbi5wcmVmaXgsXG4gICAgICBpY29uTmFtZSA9IGljb25EZWZpbml0aW9uLmljb25OYW1lLFxuICAgICAgaWNvbiA9IGljb25EZWZpbml0aW9uLmljb247XG4gIHJldHVybiBkb21WYXJpYW50cyhfb2JqZWN0U3ByZWFkMih7XG4gICAgdHlwZTogJ2ljb24nXG4gIH0sIGljb25EZWZpbml0aW9uKSwgZnVuY3Rpb24gKCkge1xuICAgIGNhbGxIb29rcygnYmVmb3JlRE9NRWxlbWVudENyZWF0aW9uJywge1xuICAgICAgaWNvbkRlZmluaXRpb246IGljb25EZWZpbml0aW9uLFxuICAgICAgcGFyYW1zOiBwYXJhbXNcbiAgICB9KTtcblxuICAgIGlmIChjb25maWcuYXV0b0ExMXkpIHtcbiAgICAgIGlmICh0aXRsZSkge1xuICAgICAgICBhdHRyaWJ1dGVzWydhcmlhLWxhYmVsbGVkYnknXSA9IFwiXCIuY29uY2F0KGNvbmZpZy5yZXBsYWNlbWVudENsYXNzLCBcIi10aXRsZS1cIikuY29uY2F0KHRpdGxlSWQgfHwgbmV4dFVuaXF1ZUlkKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0cmlidXRlc1snYXJpYS1oaWRkZW4nXSA9ICd0cnVlJztcbiAgICAgICAgYXR0cmlidXRlc1snZm9jdXNhYmxlJ10gPSAnZmFsc2UnO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYWtlSW5saW5lU3ZnQWJzdHJhY3Qoe1xuICAgICAgaWNvbnM6IHtcbiAgICAgICAgbWFpbjogYXNGb3VuZEljb24oaWNvbiksXG4gICAgICAgIG1hc2s6IG1hc2sgPyBhc0ZvdW5kSWNvbihtYXNrLmljb24pIDoge1xuICAgICAgICAgIGZvdW5kOiBmYWxzZSxcbiAgICAgICAgICB3aWR0aDogbnVsbCxcbiAgICAgICAgICBoZWlnaHQ6IG51bGwsXG4gICAgICAgICAgaWNvbjoge31cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHByZWZpeDogcHJlZml4LFxuICAgICAgaWNvbk5hbWU6IGljb25OYW1lLFxuICAgICAgdHJhbnNmb3JtOiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgbWVhbmluZ2xlc3NUcmFuc2Zvcm0pLCB0cmFuc2Zvcm0pLFxuICAgICAgc3ltYm9sOiBzeW1ib2wsXG4gICAgICB0aXRsZTogdGl0bGUsXG4gICAgICBtYXNrSWQ6IG1hc2tJZCxcbiAgICAgIHRpdGxlSWQ6IHRpdGxlSWQsXG4gICAgICBleHRyYToge1xuICAgICAgICBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVzLFxuICAgICAgICBzdHlsZXM6IHN0eWxlcyxcbiAgICAgICAgY2xhc3NlczogY2xhc3Nlc1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn07XG52YXIgUmVwbGFjZUVsZW1lbnRzID0ge1xuICBtaXhvdXQ6IGZ1bmN0aW9uIG1peG91dCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWNvbjogcmVzb2x2ZUljb25zKHJlbmRlcilcbiAgICB9O1xuICB9LFxuICBob29rczogZnVuY3Rpb24gaG9va3MoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG11dGF0aW9uT2JzZXJ2ZXJDYWxsYmFja3M6IGZ1bmN0aW9uIG11dGF0aW9uT2JzZXJ2ZXJDYWxsYmFja3MoYWNjdW11bGF0b3IpIHtcbiAgICAgICAgYWNjdW11bGF0b3IudHJlZUNhbGxiYWNrID0gb25UcmVlO1xuICAgICAgICBhY2N1bXVsYXRvci5ub2RlQ2FsbGJhY2sgPSBvbk5vZGU7XG4gICAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBwcm92aWRlczogZnVuY3Rpb24gcHJvdmlkZXMocHJvdmlkZXJzJCQxKSB7XG4gICAgcHJvdmlkZXJzJCQxLmkyc3ZnID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgdmFyIF9wYXJhbXMkbm9kZSA9IHBhcmFtcy5ub2RlLFxuICAgICAgICAgIG5vZGUgPSBfcGFyYW1zJG5vZGUgPT09IHZvaWQgMCA/IERPQ1VNRU5UIDogX3BhcmFtcyRub2RlLFxuICAgICAgICAgIF9wYXJhbXMkY2FsbGJhY2sgPSBwYXJhbXMuY2FsbGJhY2ssXG4gICAgICAgICAgY2FsbGJhY2sgPSBfcGFyYW1zJGNhbGxiYWNrID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoKSB7fSA6IF9wYXJhbXMkY2FsbGJhY2s7XG4gICAgICByZXR1cm4gb25UcmVlKG5vZGUsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgcHJvdmlkZXJzJCQxLmdlbmVyYXRlU3ZnUmVwbGFjZW1lbnRNdXRhdGlvbiA9IGZ1bmN0aW9uIChub2RlLCBub2RlTWV0YSkge1xuICAgICAgdmFyIGljb25OYW1lID0gbm9kZU1ldGEuaWNvbk5hbWUsXG4gICAgICAgICAgdGl0bGUgPSBub2RlTWV0YS50aXRsZSxcbiAgICAgICAgICB0aXRsZUlkID0gbm9kZU1ldGEudGl0bGVJZCxcbiAgICAgICAgICBwcmVmaXggPSBub2RlTWV0YS5wcmVmaXgsXG4gICAgICAgICAgdHJhbnNmb3JtID0gbm9kZU1ldGEudHJhbnNmb3JtLFxuICAgICAgICAgIHN5bWJvbCA9IG5vZGVNZXRhLnN5bWJvbCxcbiAgICAgICAgICBtYXNrID0gbm9kZU1ldGEubWFzayxcbiAgICAgICAgICBtYXNrSWQgPSBub2RlTWV0YS5tYXNrSWQsXG4gICAgICAgICAgZXh0cmEgPSBub2RlTWV0YS5leHRyYTtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIFByb21pc2UuYWxsKFtmaW5kSWNvbihpY29uTmFtZSwgcHJlZml4KSwgbWFzay5pY29uTmFtZSA/IGZpbmRJY29uKG1hc2suaWNvbk5hbWUsIG1hc2sucHJlZml4KSA6IFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgZm91bmQ6IGZhbHNlLFxuICAgICAgICAgIHdpZHRoOiA1MTIsXG4gICAgICAgICAgaGVpZ2h0OiA1MTIsXG4gICAgICAgICAgaWNvbjoge31cbiAgICAgICAgfSldKS50aGVuKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMiksXG4gICAgICAgICAgICAgIG1haW4gPSBfcmVmMlswXSxcbiAgICAgICAgICAgICAgbWFzayA9IF9yZWYyWzFdO1xuXG4gICAgICAgICAgcmVzb2x2ZShbbm9kZSwgbWFrZUlubGluZVN2Z0Fic3RyYWN0KHtcbiAgICAgICAgICAgIGljb25zOiB7XG4gICAgICAgICAgICAgIG1haW46IG1haW4sXG4gICAgICAgICAgICAgIG1hc2s6IG1hc2tcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmVmaXg6IHByZWZpeCxcbiAgICAgICAgICAgIGljb25OYW1lOiBpY29uTmFtZSxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtLFxuICAgICAgICAgICAgc3ltYm9sOiBzeW1ib2wsXG4gICAgICAgICAgICBtYXNrSWQ6IG1hc2tJZCxcbiAgICAgICAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgICAgICAgIHRpdGxlSWQ6IHRpdGxlSWQsXG4gICAgICAgICAgICBleHRyYTogZXh0cmEsXG4gICAgICAgICAgICB3YXRjaGFibGU6IHRydWVcbiAgICAgICAgICB9KV0pO1xuICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHByb3ZpZGVycyQkMS5nZW5lcmF0ZUFic3RyYWN0SWNvbiA9IGZ1bmN0aW9uIChfcmVmMykge1xuICAgICAgdmFyIGNoaWxkcmVuID0gX3JlZjMuY2hpbGRyZW4sXG4gICAgICAgICAgYXR0cmlidXRlcyA9IF9yZWYzLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgbWFpbiA9IF9yZWYzLm1haW4sXG4gICAgICAgICAgdHJhbnNmb3JtID0gX3JlZjMudHJhbnNmb3JtLFxuICAgICAgICAgIHN0eWxlcyA9IF9yZWYzLnN0eWxlcztcbiAgICAgIHZhciBzdHlsZVN0cmluZyA9IGpvaW5TdHlsZXMoc3R5bGVzKTtcblxuICAgICAgaWYgKHN0eWxlU3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYXR0cmlidXRlc1snc3R5bGUnXSA9IHN0eWxlU3RyaW5nO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV4dENoaWxkO1xuXG4gICAgICBpZiAodHJhbnNmb3JtSXNNZWFuaW5nZnVsKHRyYW5zZm9ybSkpIHtcbiAgICAgICAgbmV4dENoaWxkID0gY2FsbFByb3ZpZGVkKCdnZW5lcmF0ZUFic3RyYWN0VHJhbnNmb3JtR3JvdXBpbmcnLCB7XG4gICAgICAgICAgbWFpbjogbWFpbixcbiAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgICAgICAgICBjb250YWluZXJXaWR0aDogbWFpbi53aWR0aCxcbiAgICAgICAgICBpY29uV2lkdGg6IG1haW4ud2lkdGhcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkcmVuLnB1c2gobmV4dENoaWxkIHx8IG1haW4uaWNvbik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICAgIGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZXNcbiAgICAgIH07XG4gICAgfTtcbiAgfVxufTtcblxudmFyIExheWVycyA9IHtcbiAgbWl4b3V0OiBmdW5jdGlvbiBtaXhvdXQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxheWVyOiBmdW5jdGlvbiBsYXllcihhc3NlbWJsZXIpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICAgIHZhciBfcGFyYW1zJGNsYXNzZXMgPSBwYXJhbXMuY2xhc3NlcyxcbiAgICAgICAgICAgIGNsYXNzZXMgPSBfcGFyYW1zJGNsYXNzZXMgPT09IHZvaWQgMCA/IFtdIDogX3BhcmFtcyRjbGFzc2VzO1xuICAgICAgICByZXR1cm4gZG9tVmFyaWFudHMoe1xuICAgICAgICAgIHR5cGU6ICdsYXllcidcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNhbGxIb29rcygnYmVmb3JlRE9NRWxlbWVudENyZWF0aW9uJywge1xuICAgICAgICAgICAgYXNzZW1ibGVyOiBhc3NlbWJsZXIsXG4gICAgICAgICAgICBwYXJhbXM6IHBhcmFtc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBjaGlsZHJlbiA9IFtdO1xuICAgICAgICAgIGFzc2VtYmxlcihmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAgICAgQXJyYXkuaXNBcnJheShhcmdzKSA/IGFyZ3MubWFwKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgIGNoaWxkcmVuID0gY2hpbGRyZW4uY29uY2F0KGEuYWJzdHJhY3QpO1xuICAgICAgICAgICAgfSkgOiBjaGlsZHJlbiA9IGNoaWxkcmVuLmNvbmNhdChhcmdzLmFic3RyYWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICAgIHRhZzogJ3NwYW4nLFxuICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICBjbGFzczogW1wiXCIuY29uY2F0KGNvbmZpZy5jc3NQcmVmaXgsIFwiLWxheWVyc1wiKV0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShjbGFzc2VzKSkuam9pbignICcpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gICAgICAgICAgfV07XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG5cbnZhciBMYXllcnNDb3VudGVyID0ge1xuICBtaXhvdXQ6IGZ1bmN0aW9uIG1peG91dCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY291bnRlcjogZnVuY3Rpb24gY291bnRlcihjb250ZW50KSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgICB2YXIgX3BhcmFtcyR0aXRsZSA9IHBhcmFtcy50aXRsZSxcbiAgICAgICAgICAgIHRpdGxlID0gX3BhcmFtcyR0aXRsZSA9PT0gdm9pZCAwID8gbnVsbCA6IF9wYXJhbXMkdGl0bGUsXG4gICAgICAgICAgICBfcGFyYW1zJGNsYXNzZXMgPSBwYXJhbXMuY2xhc3NlcyxcbiAgICAgICAgICAgIGNsYXNzZXMgPSBfcGFyYW1zJGNsYXNzZXMgPT09IHZvaWQgMCA/IFtdIDogX3BhcmFtcyRjbGFzc2VzLFxuICAgICAgICAgICAgX3BhcmFtcyRhdHRyaWJ1dGVzID0gcGFyYW1zLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzID0gX3BhcmFtcyRhdHRyaWJ1dGVzID09PSB2b2lkIDAgPyB7fSA6IF9wYXJhbXMkYXR0cmlidXRlcyxcbiAgICAgICAgICAgIF9wYXJhbXMkc3R5bGVzID0gcGFyYW1zLnN0eWxlcyxcbiAgICAgICAgICAgIHN0eWxlcyA9IF9wYXJhbXMkc3R5bGVzID09PSB2b2lkIDAgPyB7fSA6IF9wYXJhbXMkc3R5bGVzO1xuICAgICAgICByZXR1cm4gZG9tVmFyaWFudHMoe1xuICAgICAgICAgIHR5cGU6ICdjb3VudGVyJyxcbiAgICAgICAgICBjb250ZW50OiBjb250ZW50XG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjYWxsSG9va3MoJ2JlZm9yZURPTUVsZW1lbnRDcmVhdGlvbicsIHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IGNvbnRlbnQsXG4gICAgICAgICAgICBwYXJhbXM6IHBhcmFtc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBtYWtlTGF5ZXJzQ291bnRlckFic3RyYWN0KHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IGNvbnRlbnQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgICAgICAgIGV4dHJhOiB7XG4gICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgIHN0eWxlczogc3R5bGVzLFxuICAgICAgICAgICAgICBjbGFzc2VzOiBbXCJcIi5jb25jYXQoY29uZmlnLmNzc1ByZWZpeCwgXCItbGF5ZXJzLWNvdW50ZXJcIildLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoY2xhc3NlcykpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG5cbnZhciBMYXllcnNUZXh0ID0ge1xuICBtaXhvdXQ6IGZ1bmN0aW9uIG1peG91dCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGV4dDogZnVuY3Rpb24gdGV4dChjb250ZW50KSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgICB2YXIgX3BhcmFtcyR0cmFuc2Zvcm0gPSBwYXJhbXMudHJhbnNmb3JtLFxuICAgICAgICAgICAgdHJhbnNmb3JtID0gX3BhcmFtcyR0cmFuc2Zvcm0gPT09IHZvaWQgMCA/IG1lYW5pbmdsZXNzVHJhbnNmb3JtIDogX3BhcmFtcyR0cmFuc2Zvcm0sXG4gICAgICAgICAgICBfcGFyYW1zJHRpdGxlID0gcGFyYW1zLnRpdGxlLFxuICAgICAgICAgICAgdGl0bGUgPSBfcGFyYW1zJHRpdGxlID09PSB2b2lkIDAgPyBudWxsIDogX3BhcmFtcyR0aXRsZSxcbiAgICAgICAgICAgIF9wYXJhbXMkY2xhc3NlcyA9IHBhcmFtcy5jbGFzc2VzLFxuICAgICAgICAgICAgY2xhc3NlcyA9IF9wYXJhbXMkY2xhc3NlcyA9PT0gdm9pZCAwID8gW10gOiBfcGFyYW1zJGNsYXNzZXMsXG4gICAgICAgICAgICBfcGFyYW1zJGF0dHJpYnV0ZXMgPSBwYXJhbXMuYXR0cmlidXRlcyxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMgPSBfcGFyYW1zJGF0dHJpYnV0ZXMgPT09IHZvaWQgMCA/IHt9IDogX3BhcmFtcyRhdHRyaWJ1dGVzLFxuICAgICAgICAgICAgX3BhcmFtcyRzdHlsZXMgPSBwYXJhbXMuc3R5bGVzLFxuICAgICAgICAgICAgc3R5bGVzID0gX3BhcmFtcyRzdHlsZXMgPT09IHZvaWQgMCA/IHt9IDogX3BhcmFtcyRzdHlsZXM7XG4gICAgICAgIHJldHVybiBkb21WYXJpYW50cyh7XG4gICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgIGNvbnRlbnQ6IGNvbnRlbnRcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNhbGxIb29rcygnYmVmb3JlRE9NRWxlbWVudENyZWF0aW9uJywge1xuICAgICAgICAgICAgY29udGVudDogY29udGVudCxcbiAgICAgICAgICAgIHBhcmFtczogcGFyYW1zXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIG1ha2VMYXllcnNUZXh0QWJzdHJhY3Qoe1xuICAgICAgICAgICAgY29udGVudDogY29udGVudCxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIG1lYW5pbmdsZXNzVHJhbnNmb3JtKSwgdHJhbnNmb3JtKSxcbiAgICAgICAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgICAgICAgIGV4dHJhOiB7XG4gICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgIHN0eWxlczogc3R5bGVzLFxuICAgICAgICAgICAgICBjbGFzc2VzOiBbXCJcIi5jb25jYXQoY29uZmlnLmNzc1ByZWZpeCwgXCItbGF5ZXJzLXRleHRcIildLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoY2xhc3NlcykpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIHByb3ZpZGVzOiBmdW5jdGlvbiBwcm92aWRlcyhwcm92aWRlcnMkJDEpIHtcbiAgICBwcm92aWRlcnMkJDEuZ2VuZXJhdGVMYXllcnNUZXh0ID0gZnVuY3Rpb24gKG5vZGUsIG5vZGVNZXRhKSB7XG4gICAgICB2YXIgdGl0bGUgPSBub2RlTWV0YS50aXRsZSxcbiAgICAgICAgICB0cmFuc2Zvcm0gPSBub2RlTWV0YS50cmFuc2Zvcm0sXG4gICAgICAgICAgZXh0cmEgPSBub2RlTWV0YS5leHRyYTtcbiAgICAgIHZhciB3aWR0aCA9IG51bGw7XG4gICAgICB2YXIgaGVpZ2h0ID0gbnVsbDtcblxuICAgICAgaWYgKElTX0lFKSB7XG4gICAgICAgIHZhciBjb21wdXRlZEZvbnRTaXplID0gcGFyc2VJbnQoZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS5mb250U2l6ZSwgMTApO1xuICAgICAgICB2YXIgYm91bmRpbmdDbGllbnRSZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgd2lkdGggPSBib3VuZGluZ0NsaWVudFJlY3Qud2lkdGggLyBjb21wdXRlZEZvbnRTaXplO1xuICAgICAgICBoZWlnaHQgPSBib3VuZGluZ0NsaWVudFJlY3QuaGVpZ2h0IC8gY29tcHV0ZWRGb250U2l6ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbmZpZy5hdXRvQTExeSAmJiAhdGl0bGUpIHtcbiAgICAgICAgZXh0cmEuYXR0cmlidXRlc1snYXJpYS1oaWRkZW4nXSA9ICd0cnVlJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbbm9kZSwgbWFrZUxheWVyc1RleHRBYnN0cmFjdCh7XG4gICAgICAgIGNvbnRlbnQ6IG5vZGUuaW5uZXJIVE1MLFxuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgICAgICAgdGl0bGU6IHRpdGxlLFxuICAgICAgICBleHRyYTogZXh0cmEsXG4gICAgICAgIHdhdGNoYWJsZTogdHJ1ZVxuICAgICAgfSldKTtcbiAgICB9O1xuICB9XG59O1xuXG52YXIgQ0xFQU5fQ09OVEVOVF9QQVRURVJOID0gbmV3IFJlZ0V4cChcIlxcXCJcIiwgJ3VnJyk7XG52YXIgU0VDT05EQVJZX1VOSUNPREVfUkFOR0UgPSBbMTEwNTkyMCwgMTExMjMxOV07XG5mdW5jdGlvbiBoZXhWYWx1ZUZyb21Db250ZW50KGNvbnRlbnQpIHtcbiAgdmFyIGNsZWFuZWQgPSBjb250ZW50LnJlcGxhY2UoQ0xFQU5fQ09OVEVOVF9QQVRURVJOLCAnJyk7XG4gIHZhciBjb2RlUG9pbnQgPSBjb2RlUG9pbnRBdChjbGVhbmVkLCAwKTtcbiAgdmFyIGlzUHJlcGVuZFRlbiA9IGNvZGVQb2ludCA+PSBTRUNPTkRBUllfVU5JQ09ERV9SQU5HRVswXSAmJiBjb2RlUG9pbnQgPD0gU0VDT05EQVJZX1VOSUNPREVfUkFOR0VbMV07XG4gIHZhciBpc0RvdWJsZWQgPSBjbGVhbmVkLmxlbmd0aCA9PT0gMiA/IGNsZWFuZWRbMF0gPT09IGNsZWFuZWRbMV0gOiBmYWxzZTtcbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogaXNEb3VibGVkID8gdG9IZXgoY2xlYW5lZFswXSkgOiB0b0hleChjbGVhbmVkKSxcbiAgICBpc1NlY29uZGFyeTogaXNQcmVwZW5kVGVuIHx8IGlzRG91YmxlZFxuICB9O1xufVxuXG5mdW5jdGlvbiByZXBsYWNlRm9yUG9zaXRpb24obm9kZSwgcG9zaXRpb24pIHtcbiAgdmFyIHBlbmRpbmdBdHRyaWJ1dGUgPSBcIlwiLmNvbmNhdChEQVRBX0ZBX1BTRVVET19FTEVNRU5UX1BFTkRJTkcpLmNvbmNhdChwb3NpdGlvbi5yZXBsYWNlKCc6JywgJy0nKSk7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgaWYgKG5vZGUuZ2V0QXR0cmlidXRlKHBlbmRpbmdBdHRyaWJ1dGUpICE9PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIG5vZGUgaXMgYWxyZWFkeSBiZWluZyBwcm9jZXNzZWRcbiAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkcmVuID0gdG9BcnJheShub2RlLmNoaWxkcmVuKTtcbiAgICB2YXIgYWxyZWFkeVByb2Nlc3NlZFBzZXVkb0VsZW1lbnQgPSBjaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGMpIHtcbiAgICAgIHJldHVybiBjLmdldEF0dHJpYnV0ZShEQVRBX0ZBX1BTRVVET19FTEVNRU5UKSA9PT0gcG9zaXRpb247XG4gICAgfSlbMF07XG4gICAgdmFyIHN0eWxlcyA9IFdJTkRPVy5nZXRDb21wdXRlZFN0eWxlKG5vZGUsIHBvc2l0aW9uKTtcbiAgICB2YXIgZm9udEZhbWlseSA9IHN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKCdmb250LWZhbWlseScpLm1hdGNoKEZPTlRfRkFNSUxZX1BBVFRFUk4pO1xuICAgIHZhciBmb250V2VpZ2h0ID0gc3R5bGVzLmdldFByb3BlcnR5VmFsdWUoJ2ZvbnQtd2VpZ2h0Jyk7XG4gICAgdmFyIGNvbnRlbnQgPSBzdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgnY29udGVudCcpO1xuXG4gICAgaWYgKGFscmVhZHlQcm9jZXNzZWRQc2V1ZG9FbGVtZW50ICYmICFmb250RmFtaWx5KSB7XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IHByb2Nlc3NlZCBpdCBidXQgdGhlIGN1cnJlbnQgY29tcHV0ZWQgc3R5bGUgZG9lcyBub3QgcmVzdWx0IGluIGEgZm9udC1mYW1pbHksXG4gICAgICAvLyB0aGF0IHByb2JhYmx5IG1lYW5zIHRoYXQgYSBjbGFzcyBuYW1lIHRoYXQgd2FzIHByZXZpb3VzbHkgcHJlc2VudCB0byBtYWtlIHRoZSBpY29uIGhhcyBiZWVuXG4gICAgICAvLyByZW1vdmVkLiBTbyB3ZSBub3cgc2hvdWxkIGRlbGV0ZSB0aGUgaWNvbi5cbiAgICAgIG5vZGUucmVtb3ZlQ2hpbGQoYWxyZWFkeVByb2Nlc3NlZFBzZXVkb0VsZW1lbnQpO1xuICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICB9IGVsc2UgaWYgKGZvbnRGYW1pbHkgJiYgY29udGVudCAhPT0gJ25vbmUnICYmIGNvbnRlbnQgIT09ICcnKSB7XG4gICAgICB2YXIgX2NvbnRlbnQgPSBzdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgnY29udGVudCcpO1xuXG4gICAgICB2YXIgZmFtaWx5ID0gflsnU2hhcnAnXS5pbmRleE9mKGZvbnRGYW1pbHlbMl0pID8gRkFNSUxZX1NIQVJQIDogRkFNSUxZX0NMQVNTSUM7XG4gICAgICB2YXIgcHJlZml4ID0gflsnU29saWQnLCAnUmVndWxhcicsICdMaWdodCcsICdUaGluJywgJ0R1b3RvbmUnLCAnQnJhbmRzJywgJ0tpdCddLmluZGV4T2YoZm9udEZhbWlseVsyXSkgPyBTVFlMRV9UT19QUkVGSVhbZmFtaWx5XVtmb250RmFtaWx5WzJdLnRvTG93ZXJDYXNlKCldIDogRk9OVF9XRUlHSFRfVE9fUFJFRklYW2ZhbWlseV1bZm9udFdlaWdodF07XG5cbiAgICAgIHZhciBfaGV4VmFsdWVGcm9tQ29udGVudCA9IGhleFZhbHVlRnJvbUNvbnRlbnQoX2NvbnRlbnQpLFxuICAgICAgICAgIGhleFZhbHVlID0gX2hleFZhbHVlRnJvbUNvbnRlbnQudmFsdWUsXG4gICAgICAgICAgaXNTZWNvbmRhcnkgPSBfaGV4VmFsdWVGcm9tQ29udGVudC5pc1NlY29uZGFyeTtcblxuICAgICAgdmFyIGlzVjQgPSBmb250RmFtaWx5WzBdLnN0YXJ0c1dpdGgoJ0ZvbnRBd2Vzb21lJyk7XG4gICAgICB2YXIgaWNvbk5hbWUgPSBieVVuaWNvZGUocHJlZml4LCBoZXhWYWx1ZSk7XG4gICAgICB2YXIgaWNvbklkZW50aWZpZXIgPSBpY29uTmFtZTtcblxuICAgICAgaWYgKGlzVjQpIHtcbiAgICAgICAgdmFyIGljb25OYW1lNCA9IGJ5T2xkVW5pY29kZShoZXhWYWx1ZSk7XG5cbiAgICAgICAgaWYgKGljb25OYW1lNC5pY29uTmFtZSAmJiBpY29uTmFtZTQucHJlZml4KSB7XG4gICAgICAgICAgaWNvbk5hbWUgPSBpY29uTmFtZTQuaWNvbk5hbWU7XG4gICAgICAgICAgcHJlZml4ID0gaWNvbk5hbWU0LnByZWZpeDtcbiAgICAgICAgfVxuICAgICAgfSAvLyBPbmx5IGNvbnZlcnQgdGhlIHBzZXVkbyBlbGVtZW50IGluIHRoaXMgOjpiZWZvcmUvOjphZnRlciBwb3NpdGlvbiBpbnRvIGFuIGljb24gaWYgd2UgaGF2ZW4ndFxuICAgICAgLy8gYWxyZWFkeSBkb25lIHNvIHdpdGggdGhlIHNhbWUgcHJlZml4IGFuZCBpY29uTmFtZVxuXG5cbiAgICAgIGlmIChpY29uTmFtZSAmJiAhaXNTZWNvbmRhcnkgJiYgKCFhbHJlYWR5UHJvY2Vzc2VkUHNldWRvRWxlbWVudCB8fCBhbHJlYWR5UHJvY2Vzc2VkUHNldWRvRWxlbWVudC5nZXRBdHRyaWJ1dGUoREFUQV9QUkVGSVgpICE9PSBwcmVmaXggfHwgYWxyZWFkeVByb2Nlc3NlZFBzZXVkb0VsZW1lbnQuZ2V0QXR0cmlidXRlKERBVEFfSUNPTikgIT09IGljb25JZGVudGlmaWVyKSkge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShwZW5kaW5nQXR0cmlidXRlLCBpY29uSWRlbnRpZmllcik7XG5cbiAgICAgICAgaWYgKGFscmVhZHlQcm9jZXNzZWRQc2V1ZG9FbGVtZW50KSB7XG4gICAgICAgICAgLy8gRGVsZXRlIHRoZSBvbGQgb25lLCBzaW5jZSB3ZSdyZSByZXBsYWNpbmcgaXQgd2l0aCBhIG5ldyBvbmVcbiAgICAgICAgICBub2RlLnJlbW92ZUNoaWxkKGFscmVhZHlQcm9jZXNzZWRQc2V1ZG9FbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtZXRhID0gYmxhbmtNZXRhKCk7XG4gICAgICAgIHZhciBleHRyYSA9IG1ldGEuZXh0cmE7XG4gICAgICAgIGV4dHJhLmF0dHJpYnV0ZXNbREFUQV9GQV9QU0VVRE9fRUxFTUVOVF0gPSBwb3NpdGlvbjtcbiAgICAgICAgZmluZEljb24oaWNvbk5hbWUsIHByZWZpeCkudGhlbihmdW5jdGlvbiAobWFpbikge1xuICAgICAgICAgIHZhciBhYnN0cmFjdCA9IG1ha2VJbmxpbmVTdmdBYnN0cmFjdChfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgbWV0YSksIHt9LCB7XG4gICAgICAgICAgICBpY29uczoge1xuICAgICAgICAgICAgICBtYWluOiBtYWluLFxuICAgICAgICAgICAgICBtYXNrOiBlbXB0eUNhbm9uaWNhbEljb24oKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByZWZpeDogcHJlZml4LFxuICAgICAgICAgICAgaWNvbk5hbWU6IGljb25JZGVudGlmaWVyLFxuICAgICAgICAgICAgZXh0cmE6IGV4dHJhLFxuICAgICAgICAgICAgd2F0Y2hhYmxlOiB0cnVlXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIHZhciBlbGVtZW50ID0gRE9DVU1FTlQuY3JlYXRlRWxlbWVudCgnc3ZnJyk7XG5cbiAgICAgICAgICBpZiAocG9zaXRpb24gPT09ICc6OmJlZm9yZScpIHtcbiAgICAgICAgICAgIG5vZGUuaW5zZXJ0QmVmb3JlKGVsZW1lbnQsIG5vZGUuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZWxlbWVudC5vdXRlckhUTUwgPSBhYnN0cmFjdC5tYXAoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIHJldHVybiB0b0h0bWwoYSk7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUocGVuZGluZ0F0dHJpYnV0ZSk7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZShub2RlKSB7XG4gIHJldHVybiBQcm9taXNlLmFsbChbcmVwbGFjZUZvclBvc2l0aW9uKG5vZGUsICc6OmJlZm9yZScpLCByZXBsYWNlRm9yUG9zaXRpb24obm9kZSwgJzo6YWZ0ZXInKV0pO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzYWJsZShub2RlKSB7XG4gIHJldHVybiBub2RlLnBhcmVudE5vZGUgIT09IGRvY3VtZW50LmhlYWQgJiYgIX5UQUdOQU1FU19UT19TS0lQX0ZPUl9QU0VVRE9FTEVNRU5UUy5pbmRleE9mKG5vZGUudGFnTmFtZS50b1VwcGVyQ2FzZSgpKSAmJiAhbm9kZS5nZXRBdHRyaWJ1dGUoREFUQV9GQV9QU0VVRE9fRUxFTUVOVCkgJiYgKCFub2RlLnBhcmVudE5vZGUgfHwgbm9kZS5wYXJlbnROb2RlLnRhZ05hbWUgIT09ICdzdmcnKTtcbn1cblxuZnVuY3Rpb24gc2VhcmNoUHNldWRvRWxlbWVudHMocm9vdCkge1xuICBpZiAoIUlTX0RPTSkgcmV0dXJuO1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciBvcGVyYXRpb25zID0gdG9BcnJheShyb290LnF1ZXJ5U2VsZWN0b3JBbGwoJyonKSkuZmlsdGVyKHByb2Nlc3NhYmxlKS5tYXAocmVwbGFjZSk7XG4gICAgdmFyIGVuZCA9IHBlcmYuYmVnaW4oJ3NlYXJjaFBzZXVkb0VsZW1lbnRzJyk7XG4gICAgZGlzYWJsZU9ic2VydmF0aW9uKCk7XG4gICAgUHJvbWlzZS5hbGwob3BlcmF0aW9ucykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICBlbmQoKTtcbiAgICAgIGVuYWJsZU9ic2VydmF0aW9uKCk7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfSkuY2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgZW5kKCk7XG4gICAgICBlbmFibGVPYnNlcnZhdGlvbigpO1xuICAgICAgcmVqZWN0KCk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG52YXIgUHNldWRvRWxlbWVudHMgPSB7XG4gIGhvb2tzOiBmdW5jdGlvbiBob29rcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbXV0YXRpb25PYnNlcnZlckNhbGxiYWNrczogZnVuY3Rpb24gbXV0YXRpb25PYnNlcnZlckNhbGxiYWNrcyhhY2N1bXVsYXRvcikge1xuICAgICAgICBhY2N1bXVsYXRvci5wc2V1ZG9FbGVtZW50c0NhbGxiYWNrID0gc2VhcmNoUHNldWRvRWxlbWVudHM7XG4gICAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBwcm92aWRlczogZnVuY3Rpb24gcHJvdmlkZXMocHJvdmlkZXJzJCQxKSB7XG4gICAgcHJvdmlkZXJzJCQxLnBzZXVkb0VsZW1lbnRzMnN2ZyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgIHZhciBfcGFyYW1zJG5vZGUgPSBwYXJhbXMubm9kZSxcbiAgICAgICAgICBub2RlID0gX3BhcmFtcyRub2RlID09PSB2b2lkIDAgPyBET0NVTUVOVCA6IF9wYXJhbXMkbm9kZTtcblxuICAgICAgaWYgKGNvbmZpZy5zZWFyY2hQc2V1ZG9FbGVtZW50cykge1xuICAgICAgICBzZWFyY2hQc2V1ZG9FbGVtZW50cyhub2RlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xuXG52YXIgX3Vud2F0Y2hlZCA9IGZhbHNlO1xudmFyIE11dGF0aW9uT2JzZXJ2ZXIkMSA9IHtcbiAgbWl4b3V0OiBmdW5jdGlvbiBtaXhvdXQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRvbToge1xuICAgICAgICB1bndhdGNoOiBmdW5jdGlvbiB1bndhdGNoKCkge1xuICAgICAgICAgIGRpc2FibGVPYnNlcnZhdGlvbigpO1xuICAgICAgICAgIF91bndhdGNoZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgaG9va3M6IGZ1bmN0aW9uIGhvb2tzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBib290c3RyYXA6IGZ1bmN0aW9uIGJvb3RzdHJhcCgpIHtcbiAgICAgICAgb2JzZXJ2ZShjaGFpbkhvb2tzKCdtdXRhdGlvbk9ic2VydmVyQ2FsbGJhY2tzJywge30pKTtcbiAgICAgIH0sXG4gICAgICBub0F1dG86IGZ1bmN0aW9uIG5vQXV0bygpIHtcbiAgICAgICAgZGlzY29ubmVjdCgpO1xuICAgICAgfSxcbiAgICAgIHdhdGNoOiBmdW5jdGlvbiB3YXRjaChwYXJhbXMpIHtcbiAgICAgICAgdmFyIG9ic2VydmVNdXRhdGlvbnNSb290ID0gcGFyYW1zLm9ic2VydmVNdXRhdGlvbnNSb290O1xuXG4gICAgICAgIGlmIChfdW53YXRjaGVkKSB7XG4gICAgICAgICAgZW5hYmxlT2JzZXJ2YXRpb24oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvYnNlcnZlKGNoYWluSG9va3MoJ211dGF0aW9uT2JzZXJ2ZXJDYWxsYmFja3MnLCB7XG4gICAgICAgICAgICBvYnNlcnZlTXV0YXRpb25zUm9vdDogb2JzZXJ2ZU11dGF0aW9uc1Jvb3RcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xuXG52YXIgcGFyc2VUcmFuc2Zvcm1TdHJpbmcgPSBmdW5jdGlvbiBwYXJzZVRyYW5zZm9ybVN0cmluZyh0cmFuc2Zvcm1TdHJpbmcpIHtcbiAgdmFyIHRyYW5zZm9ybSA9IHtcbiAgICBzaXplOiAxNixcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgZmxpcFg6IGZhbHNlLFxuICAgIGZsaXBZOiBmYWxzZSxcbiAgICByb3RhdGU6IDBcbiAgfTtcbiAgcmV0dXJuIHRyYW5zZm9ybVN0cmluZy50b0xvd2VyQ2FzZSgpLnNwbGl0KCcgJykucmVkdWNlKGZ1bmN0aW9uIChhY2MsIG4pIHtcbiAgICB2YXIgcGFydHMgPSBuLnRvTG93ZXJDYXNlKCkuc3BsaXQoJy0nKTtcbiAgICB2YXIgZmlyc3QgPSBwYXJ0c1swXTtcbiAgICB2YXIgcmVzdCA9IHBhcnRzLnNsaWNlKDEpLmpvaW4oJy0nKTtcblxuICAgIGlmIChmaXJzdCAmJiByZXN0ID09PSAnaCcpIHtcbiAgICAgIGFjYy5mbGlwWCA9IHRydWU7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH1cblxuICAgIGlmIChmaXJzdCAmJiByZXN0ID09PSAndicpIHtcbiAgICAgIGFjYy5mbGlwWSA9IHRydWU7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH1cblxuICAgIHJlc3QgPSBwYXJzZUZsb2F0KHJlc3QpO1xuXG4gICAgaWYgKGlzTmFOKHJlc3QpKSB7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH1cblxuICAgIHN3aXRjaCAoZmlyc3QpIHtcbiAgICAgIGNhc2UgJ2dyb3cnOlxuICAgICAgICBhY2Muc2l6ZSA9IGFjYy5zaXplICsgcmVzdDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3Nocmluayc6XG4gICAgICAgIGFjYy5zaXplID0gYWNjLnNpemUgLSByZXN0O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgIGFjYy54ID0gYWNjLnggLSByZXN0O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICBhY2MueCA9IGFjYy54ICsgcmVzdDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3VwJzpcbiAgICAgICAgYWNjLnkgPSBhY2MueSAtIHJlc3Q7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdkb3duJzpcbiAgICAgICAgYWNjLnkgPSBhY2MueSArIHJlc3Q7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdyb3RhdGUnOlxuICAgICAgICBhY2Mucm90YXRlID0gYWNjLnJvdGF0ZSArIHJlc3Q7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBhY2M7XG4gIH0sIHRyYW5zZm9ybSk7XG59O1xudmFyIFBvd2VyVHJhbnNmb3JtcyA9IHtcbiAgbWl4b3V0OiBmdW5jdGlvbiBtaXhvdXQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhcnNlOiB7XG4gICAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24gdHJhbnNmb3JtKHRyYW5zZm9ybVN0cmluZykge1xuICAgICAgICAgIHJldHVybiBwYXJzZVRyYW5zZm9ybVN0cmluZyh0cmFuc2Zvcm1TdHJpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgaG9va3M6IGZ1bmN0aW9uIGhvb2tzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBwYXJzZU5vZGVBdHRyaWJ1dGVzOiBmdW5jdGlvbiBwYXJzZU5vZGVBdHRyaWJ1dGVzKGFjY3VtdWxhdG9yLCBub2RlKSB7XG4gICAgICAgIHZhciB0cmFuc2Zvcm1TdHJpbmcgPSBub2RlLmdldEF0dHJpYnV0ZSgnZGF0YS1mYS10cmFuc2Zvcm0nKTtcblxuICAgICAgICBpZiAodHJhbnNmb3JtU3RyaW5nKSB7XG4gICAgICAgICAgYWNjdW11bGF0b3IudHJhbnNmb3JtID0gcGFyc2VUcmFuc2Zvcm1TdHJpbmcodHJhbnNmb3JtU3RyaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBwcm92aWRlczogZnVuY3Rpb24gcHJvdmlkZXMocHJvdmlkZXJzKSB7XG4gICAgcHJvdmlkZXJzLmdlbmVyYXRlQWJzdHJhY3RUcmFuc2Zvcm1Hcm91cGluZyA9IGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICB2YXIgbWFpbiA9IF9yZWYubWFpbixcbiAgICAgICAgICB0cmFuc2Zvcm0gPSBfcmVmLnRyYW5zZm9ybSxcbiAgICAgICAgICBjb250YWluZXJXaWR0aCA9IF9yZWYuY29udGFpbmVyV2lkdGgsXG4gICAgICAgICAgaWNvbldpZHRoID0gX3JlZi5pY29uV2lkdGg7XG4gICAgICB2YXIgb3V0ZXIgPSB7XG4gICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoXCIuY29uY2F0KGNvbnRhaW5lcldpZHRoIC8gMiwgXCIgMjU2KVwiKVxuICAgICAgfTtcbiAgICAgIHZhciBpbm5lclRyYW5zbGF0ZSA9IFwidHJhbnNsYXRlKFwiLmNvbmNhdCh0cmFuc2Zvcm0ueCAqIDMyLCBcIiwgXCIpLmNvbmNhdCh0cmFuc2Zvcm0ueSAqIDMyLCBcIikgXCIpO1xuICAgICAgdmFyIGlubmVyU2NhbGUgPSBcInNjYWxlKFwiLmNvbmNhdCh0cmFuc2Zvcm0uc2l6ZSAvIDE2ICogKHRyYW5zZm9ybS5mbGlwWCA/IC0xIDogMSksIFwiLCBcIikuY29uY2F0KHRyYW5zZm9ybS5zaXplIC8gMTYgKiAodHJhbnNmb3JtLmZsaXBZID8gLTEgOiAxKSwgXCIpIFwiKTtcbiAgICAgIHZhciBpbm5lclJvdGF0ZSA9IFwicm90YXRlKFwiLmNvbmNhdCh0cmFuc2Zvcm0ucm90YXRlLCBcIiAwIDApXCIpO1xuICAgICAgdmFyIGlubmVyID0ge1xuICAgICAgICB0cmFuc2Zvcm06IFwiXCIuY29uY2F0KGlubmVyVHJhbnNsYXRlLCBcIiBcIikuY29uY2F0KGlubmVyU2NhbGUsIFwiIFwiKS5jb25jYXQoaW5uZXJSb3RhdGUpXG4gICAgICB9O1xuICAgICAgdmFyIHBhdGggPSB7XG4gICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoXCIuY29uY2F0KGljb25XaWR0aCAvIDIgKiAtMSwgXCIgLTI1NilcIilcbiAgICAgIH07XG4gICAgICB2YXIgb3BlcmF0aW9ucyA9IHtcbiAgICAgICAgb3V0ZXI6IG91dGVyLFxuICAgICAgICBpbm5lcjogaW5uZXIsXG4gICAgICAgIHBhdGg6IHBhdGhcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0YWc6ICdnJyxcbiAgICAgICAgYXR0cmlidXRlczogX29iamVjdFNwcmVhZDIoe30sIG9wZXJhdGlvbnMub3V0ZXIpLFxuICAgICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgICB0YWc6ICdnJyxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiBfb2JqZWN0U3ByZWFkMih7fSwgb3BlcmF0aW9ucy5pbm5lciksXG4gICAgICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgICAgICB0YWc6IG1haW4uaWNvbi50YWcsXG4gICAgICAgICAgICBjaGlsZHJlbjogbWFpbi5pY29uLmNoaWxkcmVuLFxuICAgICAgICAgICAgYXR0cmlidXRlczogX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIG1haW4uaWNvbi5hdHRyaWJ1dGVzKSwgb3BlcmF0aW9ucy5wYXRoKVxuICAgICAgICAgIH1dXG4gICAgICAgIH1dXG4gICAgICB9O1xuICAgIH07XG4gIH1cbn07XG5cbnZhciBBTExfU1BBQ0UgPSB7XG4gIHg6IDAsXG4gIHk6IDAsXG4gIHdpZHRoOiAnMTAwJScsXG4gIGhlaWdodDogJzEwMCUnXG59O1xuXG5mdW5jdGlvbiBmaWxsQmxhY2soYWJzdHJhY3QpIHtcbiAgdmFyIGZvcmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuXG4gIGlmIChhYnN0cmFjdC5hdHRyaWJ1dGVzICYmIChhYnN0cmFjdC5hdHRyaWJ1dGVzLmZpbGwgfHwgZm9yY2UpKSB7XG4gICAgYWJzdHJhY3QuYXR0cmlidXRlcy5maWxsID0gJ2JsYWNrJztcbiAgfVxuXG4gIHJldHVybiBhYnN0cmFjdDtcbn1cblxuZnVuY3Rpb24gZGVHcm91cChhYnN0cmFjdCkge1xuICBpZiAoYWJzdHJhY3QudGFnID09PSAnZycpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QuY2hpbGRyZW47XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFthYnN0cmFjdF07XG4gIH1cbn1cblxudmFyIE1hc2tzID0ge1xuICBob29rczogZnVuY3Rpb24gaG9va3MoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhcnNlTm9kZUF0dHJpYnV0ZXM6IGZ1bmN0aW9uIHBhcnNlTm9kZUF0dHJpYnV0ZXMoYWNjdW11bGF0b3IsIG5vZGUpIHtcbiAgICAgICAgdmFyIG1hc2tEYXRhID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtZmEtbWFzaycpO1xuICAgICAgICB2YXIgbWFzayA9ICFtYXNrRGF0YSA/IGVtcHR5Q2Fub25pY2FsSWNvbigpIDogZ2V0Q2Fub25pY2FsSWNvbihtYXNrRGF0YS5zcGxpdCgnICcpLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgIHJldHVybiBpLnRyaW0oKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGlmICghbWFzay5wcmVmaXgpIHtcbiAgICAgICAgICBtYXNrLnByZWZpeCA9IGdldERlZmF1bHRVc2FibGVQcmVmaXgoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFjY3VtdWxhdG9yLm1hc2sgPSBtYXNrO1xuICAgICAgICBhY2N1bXVsYXRvci5tYXNrSWQgPSBub2RlLmdldEF0dHJpYnV0ZSgnZGF0YS1mYS1tYXNrLWlkJyk7XG4gICAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBwcm92aWRlczogZnVuY3Rpb24gcHJvdmlkZXMocHJvdmlkZXJzKSB7XG4gICAgcHJvdmlkZXJzLmdlbmVyYXRlQWJzdHJhY3RNYXNrID0gZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICAgICAgYXR0cmlidXRlcyA9IF9yZWYuYXR0cmlidXRlcyxcbiAgICAgICAgICBtYWluID0gX3JlZi5tYWluLFxuICAgICAgICAgIG1hc2sgPSBfcmVmLm1hc2ssXG4gICAgICAgICAgZXhwbGljaXRNYXNrSWQgPSBfcmVmLm1hc2tJZCxcbiAgICAgICAgICB0cmFuc2Zvcm0gPSBfcmVmLnRyYW5zZm9ybTtcbiAgICAgIHZhciBtYWluV2lkdGggPSBtYWluLndpZHRoLFxuICAgICAgICAgIG1haW5QYXRoID0gbWFpbi5pY29uO1xuICAgICAgdmFyIG1hc2tXaWR0aCA9IG1hc2sud2lkdGgsXG4gICAgICAgICAgbWFza1BhdGggPSBtYXNrLmljb247XG4gICAgICB2YXIgdHJhbnMgPSB0cmFuc2Zvcm1Gb3JTdmcoe1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgICAgICAgY29udGFpbmVyV2lkdGg6IG1hc2tXaWR0aCxcbiAgICAgICAgaWNvbldpZHRoOiBtYWluV2lkdGhcbiAgICAgIH0pO1xuICAgICAgdmFyIG1hc2tSZWN0ID0ge1xuICAgICAgICB0YWc6ICdyZWN0JyxcbiAgICAgICAgYXR0cmlidXRlczogX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIEFMTF9TUEFDRSksIHt9LCB7XG4gICAgICAgICAgZmlsbDogJ3doaXRlJ1xuICAgICAgICB9KVxuICAgICAgfTtcbiAgICAgIHZhciBtYXNrSW5uZXJHcm91cENoaWxkcmVuTWl4aW4gPSBtYWluUGF0aC5jaGlsZHJlbiA/IHtcbiAgICAgICAgY2hpbGRyZW46IG1haW5QYXRoLmNoaWxkcmVuLm1hcChmaWxsQmxhY2spXG4gICAgICB9IDoge307XG4gICAgICB2YXIgbWFza0lubmVyR3JvdXAgPSB7XG4gICAgICAgIHRhZzogJ2cnLFxuICAgICAgICBhdHRyaWJ1dGVzOiBfb2JqZWN0U3ByZWFkMih7fSwgdHJhbnMuaW5uZXIpLFxuICAgICAgICBjaGlsZHJlbjogW2ZpbGxCbGFjayhfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgICAgdGFnOiBtYWluUGF0aC50YWcsXG4gICAgICAgICAgYXR0cmlidXRlczogX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIG1haW5QYXRoLmF0dHJpYnV0ZXMpLCB0cmFucy5wYXRoKVxuICAgICAgICB9LCBtYXNrSW5uZXJHcm91cENoaWxkcmVuTWl4aW4pKV1cbiAgICAgIH07XG4gICAgICB2YXIgbWFza091dGVyR3JvdXAgPSB7XG4gICAgICAgIHRhZzogJ2cnLFxuICAgICAgICBhdHRyaWJ1dGVzOiBfb2JqZWN0U3ByZWFkMih7fSwgdHJhbnMub3V0ZXIpLFxuICAgICAgICBjaGlsZHJlbjogW21hc2tJbm5lckdyb3VwXVxuICAgICAgfTtcbiAgICAgIHZhciBtYXNrSWQgPSBcIm1hc2stXCIuY29uY2F0KGV4cGxpY2l0TWFza0lkIHx8IG5leHRVbmlxdWVJZCgpKTtcbiAgICAgIHZhciBjbGlwSWQgPSBcImNsaXAtXCIuY29uY2F0KGV4cGxpY2l0TWFza0lkIHx8IG5leHRVbmlxdWVJZCgpKTtcbiAgICAgIHZhciBtYXNrVGFnID0ge1xuICAgICAgICB0YWc6ICdtYXNrJyxcbiAgICAgICAgYXR0cmlidXRlczogX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIEFMTF9TUEFDRSksIHt9LCB7XG4gICAgICAgICAgaWQ6IG1hc2tJZCxcbiAgICAgICAgICBtYXNrVW5pdHM6ICd1c2VyU3BhY2VPblVzZScsXG4gICAgICAgICAgbWFza0NvbnRlbnRVbml0czogJ3VzZXJTcGFjZU9uVXNlJ1xuICAgICAgICB9KSxcbiAgICAgICAgY2hpbGRyZW46IFttYXNrUmVjdCwgbWFza091dGVyR3JvdXBdXG4gICAgICB9O1xuICAgICAgdmFyIGRlZnMgPSB7XG4gICAgICAgIHRhZzogJ2RlZnMnLFxuICAgICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgICB0YWc6ICdjbGlwUGF0aCcsXG4gICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgaWQ6IGNsaXBJZFxuICAgICAgICAgIH0sXG4gICAgICAgICAgY2hpbGRyZW46IGRlR3JvdXAobWFza1BhdGgpXG4gICAgICAgIH0sIG1hc2tUYWddXG4gICAgICB9O1xuICAgICAgY2hpbGRyZW4ucHVzaChkZWZzLCB7XG4gICAgICAgIHRhZzogJ3JlY3QnLFxuICAgICAgICBhdHRyaWJ1dGVzOiBfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgICAgZmlsbDogJ2N1cnJlbnRDb2xvcicsXG4gICAgICAgICAgJ2NsaXAtcGF0aCc6IFwidXJsKCNcIi5jb25jYXQoY2xpcElkLCBcIilcIiksXG4gICAgICAgICAgbWFzazogXCJ1cmwoI1wiLmNvbmNhdChtYXNrSWQsIFwiKVwiKVxuICAgICAgICB9LCBBTExfU1BBQ0UpXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICAgICAgYXR0cmlidXRlczogYXR0cmlidXRlc1xuICAgICAgfTtcbiAgICB9O1xuICB9XG59O1xuXG52YXIgTWlzc2luZ0ljb25JbmRpY2F0b3IgPSB7XG4gIHByb3ZpZGVzOiBmdW5jdGlvbiBwcm92aWRlcyhwcm92aWRlcnMpIHtcbiAgICB2YXIgcmVkdWNlTW90aW9uID0gZmFsc2U7XG5cbiAgICBpZiAoV0lORE9XLm1hdGNoTWVkaWEpIHtcbiAgICAgIHJlZHVjZU1vdGlvbiA9IFdJTkRPVy5tYXRjaE1lZGlhKCcocHJlZmVycy1yZWR1Y2VkLW1vdGlvbjogcmVkdWNlKScpLm1hdGNoZXM7XG4gICAgfVxuXG4gICAgcHJvdmlkZXJzLm1pc3NpbmdJY29uQWJzdHJhY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZ0NoaWxkcmVuID0gW107XG4gICAgICB2YXIgRklMTCA9IHtcbiAgICAgICAgZmlsbDogJ2N1cnJlbnRDb2xvcidcbiAgICAgIH07XG4gICAgICB2YXIgQU5JTUFUSU9OX0JBU0UgPSB7XG4gICAgICAgIGF0dHJpYnV0ZVR5cGU6ICdYTUwnLFxuICAgICAgICByZXBlYXRDb3VudDogJ2luZGVmaW5pdGUnLFxuICAgICAgICBkdXI6ICcycydcbiAgICAgIH07IC8vIFJpbmdcblxuICAgICAgZ0NoaWxkcmVuLnB1c2goe1xuICAgICAgICB0YWc6ICdwYXRoJyxcbiAgICAgICAgYXR0cmlidXRlczogX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIEZJTEwpLCB7fSwge1xuICAgICAgICAgIGQ6ICdNMTU2LjUsNDQ3LjdsLTEyLjYsMjkuNWMtMTguNy05LjUtMzUuOS0yMS4yLTUxLjUtMzQuOWwyMi43LTIyLjdDMTI3LjYsNDMwLjUsMTQxLjUsNDQwLDE1Ni41LDQ0Ny43eiBNNDAuNiwyNzJIOC41IGMxLjQsMjEuMiw1LjQsNDEuNywxMS43LDYxLjFMNTAsMzIxLjJDNDUuMSwzMDUuNSw0MS44LDI4OSw0MC42LDI3MnogTTQwLjYsMjQwYzEuNC0xOC44LDUuMi0zNywxMS4xLTU0LjFsLTI5LjUtMTIuNiBDMTQuNywxOTQuMywxMCwyMTYuNyw4LjUsMjQwSDQwLjZ6IE02NC4zLDE1Ni41YzcuOC0xNC45LDE3LjItMjguOCwyOC4xLTQxLjVMNjkuNyw5Mi4zYy0xMy43LDE1LjYtMjUuNSwzMi44LTM0LjksNTEuNSBMNjQuMywxNTYuNXogTTM5Nyw0MTkuNmMtMTMuOSwxMi0yOS40LDIyLjMtNDYuMSwzMC40bDExLjksMjkuOGMyMC43LTkuOSwzOS44LTIyLjYsNTYuOS0zNy42TDM5Nyw0MTkuNnogTTExNSw5Mi40IGMxMy45LTEyLDI5LjQtMjIuMyw0Ni4xLTMwLjRsLTExLjktMjkuOGMtMjAuNyw5LjktMzkuOCwyMi42LTU2LjgsMzcuNkwxMTUsOTIuNHogTTQ0Ny43LDM1NS41Yy03LjgsMTQuOS0xNy4yLDI4LjgtMjguMSw0MS41IGwyMi43LDIyLjdjMTMuNy0xNS42LDI1LjUtMzIuOSwzNC45LTUxLjVMNDQ3LjcsMzU1LjV6IE00NzEuNCwyNzJjLTEuNCwxOC44LTUuMiwzNy0xMS4xLDU0LjFsMjkuNSwxMi42IGM3LjUtMjEuMSwxMi4yLTQzLjUsMTMuNi02Ni44SDQ3MS40eiBNMzIxLjIsNDYyYy0xNS43LDUtMzIuMiw4LjItNDkuMiw5LjR2MzIuMWMyMS4yLTEuNCw0MS43LTUuNCw2MS4xLTExLjdMMzIxLjIsNDYyeiBNMjQwLDQ3MS40Yy0xOC44LTEuNC0zNy01LjItNTQuMS0xMS4xbC0xMi42LDI5LjVjMjEuMSw3LjUsNDMuNSwxMi4yLDY2LjgsMTMuNlY0NzEuNHogTTQ2MiwxOTAuOGM1LDE1LjcsOC4yLDMyLjIsOS40LDQ5LjJoMzIuMSBjLTEuNC0yMS4yLTUuNC00MS43LTExLjctNjEuMUw0NjIsMTkwLjh6IE05Mi40LDM5N2MtMTItMTMuOS0yMi4zLTI5LjQtMzAuNC00Ni4xbC0yOS44LDExLjljOS45LDIwLjcsMjIuNiwzOS44LDM3LjYsNTYuOSBMOTIuNCwzOTd6IE0yNzIsNDAuNmMxOC44LDEuNCwzNi45LDUuMiw1NC4xLDExLjFsMTIuNi0yOS41QzMxNy43LDE0LjcsMjk1LjMsMTAsMjcyLDguNVY0MC42eiBNMTkwLjgsNTAgYzE1LjctNSwzMi4yLTguMiw0OS4yLTkuNFY4LjVjLTIxLjIsMS40LTQxLjcsNS40LTYxLjEsMTEuN0wxOTAuOCw1MHogTTQ0Mi4zLDkyLjNMNDE5LjYsMTE1YzEyLDEzLjksMjIuMywyOS40LDMwLjUsNDYuMSBsMjkuOC0xMS45QzQ3MCwxMjguNSw0NTcuMywxMDkuNCw0NDIuMyw5Mi4zeiBNMzk3LDkyLjRsMjIuNy0yMi43Yy0xNS42LTEzLjctMzIuOC0yNS41LTUxLjUtMzQuOWwtMTIuNiwyOS41IEMzNzAuNCw3Mi4xLDM4NC40LDgxLjUsMzk3LDkyLjR6J1xuICAgICAgICB9KVxuICAgICAgfSk7XG5cbiAgICAgIHZhciBPUEFDSVRZX0FOSU1BVEUgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgQU5JTUFUSU9OX0JBU0UpLCB7fSwge1xuICAgICAgICBhdHRyaWJ1dGVOYW1lOiAnb3BhY2l0eSdcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgZG90ID0ge1xuICAgICAgICB0YWc6ICdjaXJjbGUnLFxuICAgICAgICBhdHRyaWJ1dGVzOiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgRklMTCksIHt9LCB7XG4gICAgICAgICAgY3g6ICcyNTYnLFxuICAgICAgICAgIGN5OiAnMzY0JyxcbiAgICAgICAgICByOiAnMjgnXG4gICAgICAgIH0pLFxuICAgICAgICBjaGlsZHJlbjogW11cbiAgICAgIH07XG5cbiAgICAgIGlmICghcmVkdWNlTW90aW9uKSB7XG4gICAgICAgIGRvdC5jaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgICB0YWc6ICdhbmltYXRlJyxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgQU5JTUFUSU9OX0JBU0UpLCB7fSwge1xuICAgICAgICAgICAgYXR0cmlidXRlTmFtZTogJ3InLFxuICAgICAgICAgICAgdmFsdWVzOiAnMjg7MTQ7Mjg7Mjg7MTQ7Mjg7J1xuICAgICAgICAgIH0pXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB0YWc6ICdhbmltYXRlJyxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgT1BBQ0lUWV9BTklNQVRFKSwge30sIHtcbiAgICAgICAgICAgIHZhbHVlczogJzE7MDsxOzE7MDsxOydcbiAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZ0NoaWxkcmVuLnB1c2goZG90KTtcbiAgICAgIGdDaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgdGFnOiAncGF0aCcsXG4gICAgICAgIGF0dHJpYnV0ZXM6IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBGSUxMKSwge30sIHtcbiAgICAgICAgICBvcGFjaXR5OiAnMScsXG4gICAgICAgICAgZDogJ00yNjMuNywzMTJoLTE2Yy02LjYsMC0xMi01LjQtMTItMTJjMC03MSw3Ny40LTYzLjksNzcuNC0xMDcuOGMwLTIwLTE3LjgtNDAuMi01Ny40LTQwLjJjLTI5LjEsMC00NC4zLDkuNi01OS4yLDI4LjcgYy0zLjksNS0xMS4xLDYtMTYuMiwyLjRsLTEzLjEtOS4yYy01LjYtMy45LTYuOS0xMS44LTIuNi0xNy4yYzIxLjItMjcuMiw0Ni40LTQ0LjcsOTEuMi00NC43YzUyLjMsMCw5Ny40LDI5LjgsOTcuNCw4MC4yIGMwLDY3LjYtNzcuNCw2My41LTc3LjQsMTA3LjhDMjc1LjcsMzA2LjYsMjcwLjMsMzEyLDI2My43LDMxMnonXG4gICAgICAgIH0pLFxuICAgICAgICBjaGlsZHJlbjogcmVkdWNlTW90aW9uID8gW10gOiBbe1xuICAgICAgICAgIHRhZzogJ2FuaW1hdGUnLFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBPUEFDSVRZX0FOSU1BVEUpLCB7fSwge1xuICAgICAgICAgICAgdmFsdWVzOiAnMTswOzA7MDswOzE7J1xuICAgICAgICAgIH0pXG4gICAgICAgIH1dXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFyZWR1Y2VNb3Rpb24pIHtcbiAgICAgICAgLy8gRXhjbGFtYXRpb25cbiAgICAgICAgZ0NoaWxkcmVuLnB1c2goe1xuICAgICAgICAgIHRhZzogJ3BhdGgnLFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBGSUxMKSwge30sIHtcbiAgICAgICAgICAgIG9wYWNpdHk6ICcwJyxcbiAgICAgICAgICAgIGQ6ICdNMjMyLjUsMTM0LjVsNywxNjhjMC4zLDYuNCw1LjYsMTEuNSwxMiwxMS41aDljNi40LDAsMTEuNy01LjEsMTItMTEuNWw3LTE2OGMwLjMtNi44LTUuMi0xMi41LTEyLTEyLjVoLTIzIEMyMzcuNywxMjIsMjMyLjIsMTI3LjcsMjMyLjUsMTM0LjV6J1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICAgICAgdGFnOiAnYW5pbWF0ZScsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgT1BBQ0lUWV9BTklNQVRFKSwge30sIHtcbiAgICAgICAgICAgICAgdmFsdWVzOiAnMDswOzE7MTswOzA7J1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGFnOiAnZycsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAnY2xhc3MnOiAnbWlzc2luZydcbiAgICAgICAgfSxcbiAgICAgICAgY2hpbGRyZW46IGdDaGlsZHJlblxuICAgICAgfTtcbiAgICB9O1xuICB9XG59O1xuXG52YXIgU3ZnU3ltYm9scyA9IHtcbiAgaG9va3M6IGZ1bmN0aW9uIGhvb2tzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBwYXJzZU5vZGVBdHRyaWJ1dGVzOiBmdW5jdGlvbiBwYXJzZU5vZGVBdHRyaWJ1dGVzKGFjY3VtdWxhdG9yLCBub2RlKSB7XG4gICAgICAgIHZhciBzeW1ib2xEYXRhID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtZmEtc3ltYm9sJyk7XG4gICAgICAgIHZhciBzeW1ib2wgPSBzeW1ib2xEYXRhID09PSBudWxsID8gZmFsc2UgOiBzeW1ib2xEYXRhID09PSAnJyA/IHRydWUgOiBzeW1ib2xEYXRhO1xuICAgICAgICBhY2N1bXVsYXRvclsnc3ltYm9sJ10gPSBzeW1ib2w7XG4gICAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xuXG52YXIgcGx1Z2lucyA9IFtJbmplY3RDU1MsIFJlcGxhY2VFbGVtZW50cywgTGF5ZXJzLCBMYXllcnNDb3VudGVyLCBMYXllcnNUZXh0LCBQc2V1ZG9FbGVtZW50cywgTXV0YXRpb25PYnNlcnZlciQxLCBQb3dlclRyYW5zZm9ybXMsIE1hc2tzLCBNaXNzaW5nSWNvbkluZGljYXRvciwgU3ZnU3ltYm9sc107XG5cbnJlZ2lzdGVyUGx1Z2lucyhwbHVnaW5zLCB7XG4gIG1peG91dHNUbzogYXBpXG59KTtcbnZhciBub0F1dG8kMSA9IGFwaS5ub0F1dG87XG52YXIgY29uZmlnJDEgPSBhcGkuY29uZmlnO1xudmFyIGxpYnJhcnkkMSA9IGFwaS5saWJyYXJ5O1xudmFyIGRvbSQxID0gYXBpLmRvbTtcbnZhciBwYXJzZSQxID0gYXBpLnBhcnNlO1xudmFyIGZpbmRJY29uRGVmaW5pdGlvbiQxID0gYXBpLmZpbmRJY29uRGVmaW5pdGlvbjtcbnZhciB0b0h0bWwkMSA9IGFwaS50b0h0bWw7XG52YXIgaWNvbiA9IGFwaS5pY29uO1xudmFyIGxheWVyID0gYXBpLmxheWVyO1xudmFyIHRleHQgPSBhcGkudGV4dDtcbnZhciBjb3VudGVyID0gYXBpLmNvdW50ZXI7XG5cbmV4cG9ydCB7IG5vQXV0byQxIGFzIG5vQXV0bywgY29uZmlnJDEgYXMgY29uZmlnLCBsaWJyYXJ5JDEgYXMgbGlicmFyeSwgZG9tJDEgYXMgZG9tLCBwYXJzZSQxIGFzIHBhcnNlLCBmaW5kSWNvbkRlZmluaXRpb24kMSBhcyBmaW5kSWNvbkRlZmluaXRpb24sIHRvSHRtbCQxIGFzIHRvSHRtbCwgaWNvbiwgbGF5ZXIsIHRleHQsIGNvdW50ZXIsIGFwaSB9O1xuIiwiZnVuY3Rpb24gbihuKXtmb3IodmFyIHI9YXJndW1lbnRzLmxlbmd0aCx0PUFycmF5KHI+MT9yLTE6MCksZT0xO2U8cjtlKyspdFtlLTFdPWFyZ3VtZW50c1tlXTtpZihcInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WKXt2YXIgaT1ZW25dLG89aT9cImZ1bmN0aW9uXCI9PXR5cGVvZiBpP2kuYXBwbHkobnVsbCx0KTppOlwidW5rbm93biBlcnJvciBucjogXCIrbjt0aHJvdyBFcnJvcihcIltJbW1lcl0gXCIrbyl9dGhyb3cgRXJyb3IoXCJbSW1tZXJdIG1pbmlmaWVkIGVycm9yIG5yOiBcIituKyh0Lmxlbmd0aD9cIiBcIit0Lm1hcCgoZnVuY3Rpb24obil7cmV0dXJuXCInXCIrbitcIidcIn0pKS5qb2luKFwiLFwiKTpcIlwiKStcIi4gRmluZCB0aGUgZnVsbCBlcnJvciBhdDogaHR0cHM6Ly9iaXQubHkvM2NYRUtXZlwiKX1mdW5jdGlvbiByKG4pe3JldHVybiEhbiYmISFuW1FdfWZ1bmN0aW9uIHQobil7dmFyIHI7cmV0dXJuISFuJiYoZnVuY3Rpb24obil7aWYoIW58fFwib2JqZWN0XCIhPXR5cGVvZiBuKXJldHVybiExO3ZhciByPU9iamVjdC5nZXRQcm90b3R5cGVPZihuKTtpZihudWxsPT09cilyZXR1cm4hMDt2YXIgdD1PYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChyLFwiY29uc3RydWN0b3JcIikmJnIuY29uc3RydWN0b3I7cmV0dXJuIHQ9PT1PYmplY3R8fFwiZnVuY3Rpb25cIj09dHlwZW9mIHQmJkZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwodCk9PT1afShuKXx8QXJyYXkuaXNBcnJheShuKXx8ISFuW0xdfHwhIShudWxsPT09KHI9bi5jb25zdHJ1Y3Rvcil8fHZvaWQgMD09PXI/dm9pZCAwOnJbTF0pfHxzKG4pfHx2KG4pKX1mdW5jdGlvbiBlKHQpe3JldHVybiByKHQpfHxuKDIzLHQpLHRbUV0udH1mdW5jdGlvbiBpKG4scix0KXt2b2lkIDA9PT10JiYodD0hMSksMD09PW8obik/KHQ/T2JqZWN0LmtleXM6bm4pKG4pLmZvckVhY2goKGZ1bmN0aW9uKGUpe3QmJlwic3ltYm9sXCI9PXR5cGVvZiBlfHxyKGUsbltlXSxuKX0pKTpuLmZvckVhY2goKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHIoZSx0LG4pfSkpfWZ1bmN0aW9uIG8obil7dmFyIHI9bltRXTtyZXR1cm4gcj9yLmk+Mz9yLmktNDpyLmk6QXJyYXkuaXNBcnJheShuKT8xOnMobik/Mjp2KG4pPzM6MH1mdW5jdGlvbiB1KG4scil7cmV0dXJuIDI9PT1vKG4pP24uaGFzKHIpOk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuLHIpfWZ1bmN0aW9uIGEobixyKXtyZXR1cm4gMj09PW8obik/bi5nZXQocik6bltyXX1mdW5jdGlvbiBmKG4scix0KXt2YXIgZT1vKG4pOzI9PT1lP24uc2V0KHIsdCk6Mz09PWU/KG4uZGVsZXRlKHIpLG4uYWRkKHQpKTpuW3JdPXR9ZnVuY3Rpb24gYyhuLHIpe3JldHVybiBuPT09cj8wIT09bnx8MS9uPT0xL3I6biE9biYmciE9cn1mdW5jdGlvbiBzKG4pe3JldHVybiBYJiZuIGluc3RhbmNlb2YgTWFwfWZ1bmN0aW9uIHYobil7cmV0dXJuIHEmJm4gaW5zdGFuY2VvZiBTZXR9ZnVuY3Rpb24gcChuKXtyZXR1cm4gbi5vfHxuLnR9ZnVuY3Rpb24gbChuKXtpZihBcnJheS5pc0FycmF5KG4pKXJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChuKTt2YXIgcj1ybihuKTtkZWxldGUgcltRXTtmb3IodmFyIHQ9bm4ociksZT0wO2U8dC5sZW5ndGg7ZSsrKXt2YXIgaT10W2VdLG89cltpXTshMT09PW8ud3JpdGFibGUmJihvLndyaXRhYmxlPSEwLG8uY29uZmlndXJhYmxlPSEwKSwoby5nZXR8fG8uc2V0KSYmKHJbaV09e2NvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCxlbnVtZXJhYmxlOm8uZW51bWVyYWJsZSx2YWx1ZTpuW2ldfSl9cmV0dXJuIE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKG4pLHIpfWZ1bmN0aW9uIGQobixlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9ITEpLHkobil8fHIobil8fCF0KG4pP246KG8obik+MSYmKG4uc2V0PW4uYWRkPW4uY2xlYXI9bi5kZWxldGU9aCksT2JqZWN0LmZyZWV6ZShuKSxlJiZpKG4sKGZ1bmN0aW9uKG4scil7cmV0dXJuIGQociwhMCl9KSwhMCksbil9ZnVuY3Rpb24gaCgpe24oMil9ZnVuY3Rpb24geShuKXtyZXR1cm4gbnVsbD09bnx8XCJvYmplY3RcIiE9dHlwZW9mIG58fE9iamVjdC5pc0Zyb3plbihuKX1mdW5jdGlvbiBiKHIpe3ZhciB0PXRuW3JdO3JldHVybiB0fHxuKDE4LHIpLHR9ZnVuY3Rpb24gbShuLHIpe3RuW25dfHwodG5bbl09cil9ZnVuY3Rpb24gXygpe3JldHVyblwicHJvZHVjdGlvblwiPT09cHJvY2Vzcy5lbnYuTk9ERV9FTlZ8fFV8fG4oMCksVX1mdW5jdGlvbiBqKG4scil7ciYmKGIoXCJQYXRjaGVzXCIpLG4udT1bXSxuLnM9W10sbi52PXIpfWZ1bmN0aW9uIE8obil7ZyhuKSxuLnAuZm9yRWFjaChTKSxuLnA9bnVsbH1mdW5jdGlvbiBnKG4pe249PT1VJiYoVT1uLmwpfWZ1bmN0aW9uIHcobil7cmV0dXJuIFU9e3A6W10sbDpVLGg6bixtOiEwLF86MH19ZnVuY3Rpb24gUyhuKXt2YXIgcj1uW1FdOzA9PT1yLml8fDE9PT1yLmk/ci5qKCk6ci5PPSEwfWZ1bmN0aW9uIFAocixlKXtlLl89ZS5wLmxlbmd0aDt2YXIgaT1lLnBbMF0sbz12b2lkIDAhPT1yJiZyIT09aTtyZXR1cm4gZS5oLmd8fGIoXCJFUzVcIikuUyhlLHIsbyksbz8oaVtRXS5QJiYoTyhlKSxuKDQpKSx0KHIpJiYocj1NKGUsciksZS5sfHx4KGUscikpLGUudSYmYihcIlBhdGNoZXNcIikuTShpW1FdLnQscixlLnUsZS5zKSk6cj1NKGUsaSxbXSksTyhlKSxlLnUmJmUudihlLnUsZS5zKSxyIT09SD9yOnZvaWQgMH1mdW5jdGlvbiBNKG4scix0KXtpZih5KHIpKXJldHVybiByO3ZhciBlPXJbUV07aWYoIWUpcmV0dXJuIGkociwoZnVuY3Rpb24oaSxvKXtyZXR1cm4gQShuLGUscixpLG8sdCl9KSwhMCkscjtpZihlLkEhPT1uKXJldHVybiByO2lmKCFlLlApcmV0dXJuIHgobixlLnQsITApLGUudDtpZighZS5JKXtlLkk9ITAsZS5BLl8tLTt2YXIgbz00PT09ZS5pfHw1PT09ZS5pP2Uubz1sKGUuayk6ZS5vO2koMz09PWUuaT9uZXcgU2V0KG8pOm8sKGZ1bmN0aW9uKHIsaSl7cmV0dXJuIEEobixlLG8scixpLHQpfSkpLHgobixvLCExKSx0JiZuLnUmJmIoXCJQYXRjaGVzXCIpLlIoZSx0LG4udSxuLnMpfXJldHVybiBlLm99ZnVuY3Rpb24gQShlLGksbyxhLGMscyl7aWYoXCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOViYmYz09PW8mJm4oNSkscihjKSl7dmFyIHY9TShlLGMscyYmaSYmMyE9PWkuaSYmIXUoaS5ELGEpP3MuY29uY2F0KGEpOnZvaWQgMCk7aWYoZihvLGEsdiksIXIodikpcmV0dXJuO2UubT0hMX1pZih0KGMpJiYheShjKSl7aWYoIWUuaC5GJiZlLl88MSlyZXR1cm47TShlLGMpLGkmJmkuQS5sfHx4KGUsYyl9fWZ1bmN0aW9uIHgobixyLHQpe3ZvaWQgMD09PXQmJih0PSExKSxuLmguRiYmbi5tJiZkKHIsdCl9ZnVuY3Rpb24geihuLHIpe3ZhciB0PW5bUV07cmV0dXJuKHQ/cCh0KTpuKVtyXX1mdW5jdGlvbiBJKG4scil7aWYociBpbiBuKWZvcih2YXIgdD1PYmplY3QuZ2V0UHJvdG90eXBlT2Yobik7dDspe3ZhciBlPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxyKTtpZihlKXJldHVybiBlO3Q9T2JqZWN0LmdldFByb3RvdHlwZU9mKHQpfX1mdW5jdGlvbiBrKG4pe24uUHx8KG4uUD0hMCxuLmwmJmsobi5sKSl9ZnVuY3Rpb24gRShuKXtuLm98fChuLm89bChuLnQpKX1mdW5jdGlvbiBSKG4scix0KXt2YXIgZT1zKHIpP2IoXCJNYXBTZXRcIikuTihyLHQpOnYocik/YihcIk1hcFNldFwiKS5UKHIsdCk6bi5nP2Z1bmN0aW9uKG4scil7dmFyIHQ9QXJyYXkuaXNBcnJheShuKSxlPXtpOnQ/MTowLEE6cj9yLkE6XygpLFA6ITEsSTohMSxEOnt9LGw6cix0Om4sazpudWxsLG86bnVsbCxqOm51bGwsQzohMX0saT1lLG89ZW47dCYmKGk9W2VdLG89b24pO3ZhciB1PVByb3h5LnJldm9jYWJsZShpLG8pLGE9dS5yZXZva2UsZj11LnByb3h5O3JldHVybiBlLms9ZixlLmo9YSxmfShyLHQpOmIoXCJFUzVcIikuSihyLHQpO3JldHVybih0P3QuQTpfKCkpLnAucHVzaChlKSxlfWZ1bmN0aW9uIEQoZSl7cmV0dXJuIHIoZSl8fG4oMjIsZSksZnVuY3Rpb24gbihyKXtpZighdChyKSlyZXR1cm4gcjt2YXIgZSx1PXJbUV0sYz1vKHIpO2lmKHUpe2lmKCF1LlAmJih1Lmk8NHx8IWIoXCJFUzVcIikuSyh1KSkpcmV0dXJuIHUudDt1Lkk9ITAsZT1GKHIsYyksdS5JPSExfWVsc2UgZT1GKHIsYyk7cmV0dXJuIGkoZSwoZnVuY3Rpb24ocix0KXt1JiZhKHUudCxyKT09PXR8fGYoZSxyLG4odCkpfSkpLDM9PT1jP25ldyBTZXQoZSk6ZX0oZSl9ZnVuY3Rpb24gRihuLHIpe3N3aXRjaChyKXtjYXNlIDI6cmV0dXJuIG5ldyBNYXAobik7Y2FzZSAzOnJldHVybiBBcnJheS5mcm9tKG4pfXJldHVybiBsKG4pfWZ1bmN0aW9uIE4oKXtmdW5jdGlvbiB0KG4scil7dmFyIHQ9c1tuXTtyZXR1cm4gdD90LmVudW1lcmFibGU9cjpzW25dPXQ9e2NvbmZpZ3VyYWJsZTohMCxlbnVtZXJhYmxlOnIsZ2V0OmZ1bmN0aW9uKCl7dmFyIHI9dGhpc1tRXTtyZXR1cm5cInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WJiZmKHIpLGVuLmdldChyLG4pfSxzZXQ6ZnVuY3Rpb24ocil7dmFyIHQ9dGhpc1tRXTtcInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WJiZmKHQpLGVuLnNldCh0LG4scil9fSx0fWZ1bmN0aW9uIGUobil7Zm9yKHZhciByPW4ubGVuZ3RoLTE7cj49MDtyLS0pe3ZhciB0PW5bcl1bUV07aWYoIXQuUClzd2l0Y2godC5pKXtjYXNlIDU6YSh0KSYmayh0KTticmVhaztjYXNlIDQ6byh0KSYmayh0KX19fWZ1bmN0aW9uIG8obil7Zm9yKHZhciByPW4udCx0PW4uayxlPW5uKHQpLGk9ZS5sZW5ndGgtMTtpPj0wO2ktLSl7dmFyIG89ZVtpXTtpZihvIT09USl7dmFyIGE9cltvXTtpZih2b2lkIDA9PT1hJiYhdShyLG8pKXJldHVybiEwO3ZhciBmPXRbb10scz1mJiZmW1FdO2lmKHM/cy50IT09YTohYyhmLGEpKXJldHVybiEwfX12YXIgdj0hIXJbUV07cmV0dXJuIGUubGVuZ3RoIT09bm4ocikubGVuZ3RoKyh2PzA6MSl9ZnVuY3Rpb24gYShuKXt2YXIgcj1uLms7aWYoci5sZW5ndGghPT1uLnQubGVuZ3RoKXJldHVybiEwO3ZhciB0PU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocixyLmxlbmd0aC0xKTtpZih0JiYhdC5nZXQpcmV0dXJuITA7Zm9yKHZhciBlPTA7ZTxyLmxlbmd0aDtlKyspaWYoIXIuaGFzT3duUHJvcGVydHkoZSkpcmV0dXJuITA7cmV0dXJuITF9ZnVuY3Rpb24gZihyKXtyLk8mJm4oMyxKU09OLnN0cmluZ2lmeShwKHIpKSl9dmFyIHM9e307bShcIkVTNVwiLHtKOmZ1bmN0aW9uKG4scil7dmFyIGU9QXJyYXkuaXNBcnJheShuKSxpPWZ1bmN0aW9uKG4scil7aWYobil7Zm9yKHZhciBlPUFycmF5KHIubGVuZ3RoKSxpPTA7aTxyLmxlbmd0aDtpKyspT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJcIitpLHQoaSwhMCkpO3JldHVybiBlfXZhciBvPXJuKHIpO2RlbGV0ZSBvW1FdO2Zvcih2YXIgdT1ubihvKSxhPTA7YTx1Lmxlbmd0aDthKyspe3ZhciBmPXVbYV07b1tmXT10KGYsbnx8ISFvW2ZdLmVudW1lcmFibGUpfXJldHVybiBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihyKSxvKX0oZSxuKSxvPXtpOmU/NTo0LEE6cj9yLkE6XygpLFA6ITEsSTohMSxEOnt9LGw6cix0Om4sazppLG86bnVsbCxPOiExLEM6ITF9O3JldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoaSxRLHt2YWx1ZTpvLHdyaXRhYmxlOiEwfSksaX0sUzpmdW5jdGlvbihuLHQsbyl7bz9yKHQpJiZ0W1FdLkE9PT1uJiZlKG4ucCk6KG4udSYmZnVuY3Rpb24gbihyKXtpZihyJiZcIm9iamVjdFwiPT10eXBlb2Ygcil7dmFyIHQ9cltRXTtpZih0KXt2YXIgZT10LnQsbz10LmssZj10LkQsYz10Lmk7aWYoND09PWMpaShvLChmdW5jdGlvbihyKXtyIT09USYmKHZvaWQgMCE9PWVbcl18fHUoZSxyKT9mW3JdfHxuKG9bcl0pOihmW3JdPSEwLGsodCkpKX0pKSxpKGUsKGZ1bmN0aW9uKG4pe3ZvaWQgMCE9PW9bbl18fHUobyxuKXx8KGZbbl09ITEsayh0KSl9KSk7ZWxzZSBpZig1PT09Yyl7aWYoYSh0KSYmKGsodCksZi5sZW5ndGg9ITApLG8ubGVuZ3RoPGUubGVuZ3RoKWZvcih2YXIgcz1vLmxlbmd0aDtzPGUubGVuZ3RoO3MrKylmW3NdPSExO2Vsc2UgZm9yKHZhciB2PWUubGVuZ3RoO3Y8by5sZW5ndGg7disrKWZbdl09ITA7Zm9yKHZhciBwPU1hdGgubWluKG8ubGVuZ3RoLGUubGVuZ3RoKSxsPTA7bDxwO2wrKylvLmhhc093blByb3BlcnR5KGwpfHwoZltsXT0hMCksdm9pZCAwPT09ZltsXSYmbihvW2xdKX19fX0obi5wWzBdKSxlKG4ucCkpfSxLOmZ1bmN0aW9uKG4pe3JldHVybiA0PT09bi5pP28obik6YShuKX19KX1mdW5jdGlvbiBUKCl7ZnVuY3Rpb24gZShuKXtpZighdChuKSlyZXR1cm4gbjtpZihBcnJheS5pc0FycmF5KG4pKXJldHVybiBuLm1hcChlKTtpZihzKG4pKXJldHVybiBuZXcgTWFwKEFycmF5LmZyb20obi5lbnRyaWVzKCkpLm1hcCgoZnVuY3Rpb24obil7cmV0dXJuW25bMF0sZShuWzFdKV19KSkpO2lmKHYobikpcmV0dXJuIG5ldyBTZXQoQXJyYXkuZnJvbShuKS5tYXAoZSkpO3ZhciByPU9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKG4pKTtmb3IodmFyIGkgaW4gbilyW2ldPWUobltpXSk7cmV0dXJuIHUobixMKSYmKHJbTF09bltMXSkscn1mdW5jdGlvbiBmKG4pe3JldHVybiByKG4pP2Uobik6bn12YXIgYz1cImFkZFwiO20oXCJQYXRjaGVzXCIseyQ6ZnVuY3Rpb24ocix0KXtyZXR1cm4gdC5mb3JFYWNoKChmdW5jdGlvbih0KXtmb3IodmFyIGk9dC5wYXRoLHU9dC5vcCxmPXIscz0wO3M8aS5sZW5ndGgtMTtzKyspe3ZhciB2PW8oZikscD1cIlwiK2lbc107MCE9PXYmJjEhPT12fHxcIl9fcHJvdG9fX1wiIT09cCYmXCJjb25zdHJ1Y3RvclwiIT09cHx8bigyNCksXCJmdW5jdGlvblwiPT10eXBlb2YgZiYmXCJwcm90b3R5cGVcIj09PXAmJm4oMjQpLFwib2JqZWN0XCIhPXR5cGVvZihmPWEoZixwKSkmJm4oMTUsaS5qb2luKFwiL1wiKSl9dmFyIGw9byhmKSxkPWUodC52YWx1ZSksaD1pW2kubGVuZ3RoLTFdO3N3aXRjaCh1KXtjYXNlXCJyZXBsYWNlXCI6c3dpdGNoKGwpe2Nhc2UgMjpyZXR1cm4gZi5zZXQoaCxkKTtjYXNlIDM6bigxNik7ZGVmYXVsdDpyZXR1cm4gZltoXT1kfWNhc2UgYzpzd2l0Y2gobCl7Y2FzZSAxOnJldHVyblwiLVwiPT09aD9mLnB1c2goZCk6Zi5zcGxpY2UoaCwwLGQpO2Nhc2UgMjpyZXR1cm4gZi5zZXQoaCxkKTtjYXNlIDM6cmV0dXJuIGYuYWRkKGQpO2RlZmF1bHQ6cmV0dXJuIGZbaF09ZH1jYXNlXCJyZW1vdmVcIjpzd2l0Y2gobCl7Y2FzZSAxOnJldHVybiBmLnNwbGljZShoLDEpO2Nhc2UgMjpyZXR1cm4gZi5kZWxldGUoaCk7Y2FzZSAzOnJldHVybiBmLmRlbGV0ZSh0LnZhbHVlKTtkZWZhdWx0OnJldHVybiBkZWxldGUgZltoXX1kZWZhdWx0Om4oMTcsdSl9fSkpLHJ9LFI6ZnVuY3Rpb24obixyLHQsZSl7c3dpdGNoKG4uaSl7Y2FzZSAwOmNhc2UgNDpjYXNlIDI6cmV0dXJuIGZ1bmN0aW9uKG4scix0LGUpe3ZhciBvPW4udCxzPW4ubztpKG4uRCwoZnVuY3Rpb24obixpKXt2YXIgdj1hKG8sbikscD1hKHMsbiksbD1pP3UobyxuKT9cInJlcGxhY2VcIjpjOlwicmVtb3ZlXCI7aWYodiE9PXB8fFwicmVwbGFjZVwiIT09bCl7dmFyIGQ9ci5jb25jYXQobik7dC5wdXNoKFwicmVtb3ZlXCI9PT1sP3tvcDpsLHBhdGg6ZH06e29wOmwscGF0aDpkLHZhbHVlOnB9KSxlLnB1c2gobD09PWM/e29wOlwicmVtb3ZlXCIscGF0aDpkfTpcInJlbW92ZVwiPT09bD97b3A6YyxwYXRoOmQsdmFsdWU6Zih2KX06e29wOlwicmVwbGFjZVwiLHBhdGg6ZCx2YWx1ZTpmKHYpfSl9fSkpfShuLHIsdCxlKTtjYXNlIDU6Y2FzZSAxOnJldHVybiBmdW5jdGlvbihuLHIsdCxlKXt2YXIgaT1uLnQsbz1uLkQsdT1uLm87aWYodS5sZW5ndGg8aS5sZW5ndGgpe3ZhciBhPVt1LGldO2k9YVswXSx1PWFbMV07dmFyIHM9W2UsdF07dD1zWzBdLGU9c1sxXX1mb3IodmFyIHY9MDt2PGkubGVuZ3RoO3YrKylpZihvW3ZdJiZ1W3ZdIT09aVt2XSl7dmFyIHA9ci5jb25jYXQoW3ZdKTt0LnB1c2goe29wOlwicmVwbGFjZVwiLHBhdGg6cCx2YWx1ZTpmKHVbdl0pfSksZS5wdXNoKHtvcDpcInJlcGxhY2VcIixwYXRoOnAsdmFsdWU6ZihpW3ZdKX0pfWZvcih2YXIgbD1pLmxlbmd0aDtsPHUubGVuZ3RoO2wrKyl7dmFyIGQ9ci5jb25jYXQoW2xdKTt0LnB1c2goe29wOmMscGF0aDpkLHZhbHVlOmYodVtsXSl9KX1pLmxlbmd0aDx1Lmxlbmd0aCYmZS5wdXNoKHtvcDpcInJlcGxhY2VcIixwYXRoOnIuY29uY2F0KFtcImxlbmd0aFwiXSksdmFsdWU6aS5sZW5ndGh9KX0obixyLHQsZSk7Y2FzZSAzOnJldHVybiBmdW5jdGlvbihuLHIsdCxlKXt2YXIgaT1uLnQsbz1uLm8sdT0wO2kuZm9yRWFjaCgoZnVuY3Rpb24obil7aWYoIW8uaGFzKG4pKXt2YXIgaT1yLmNvbmNhdChbdV0pO3QucHVzaCh7b3A6XCJyZW1vdmVcIixwYXRoOmksdmFsdWU6bn0pLGUudW5zaGlmdCh7b3A6YyxwYXRoOmksdmFsdWU6bn0pfXUrK30pKSx1PTAsby5mb3JFYWNoKChmdW5jdGlvbihuKXtpZighaS5oYXMobikpe3ZhciBvPXIuY29uY2F0KFt1XSk7dC5wdXNoKHtvcDpjLHBhdGg6byx2YWx1ZTpufSksZS51bnNoaWZ0KHtvcDpcInJlbW92ZVwiLHBhdGg6byx2YWx1ZTpufSl9dSsrfSkpfShuLHIsdCxlKX19LE06ZnVuY3Rpb24obixyLHQsZSl7dC5wdXNoKHtvcDpcInJlcGxhY2VcIixwYXRoOltdLHZhbHVlOnI9PT1IP3ZvaWQgMDpyfSksZS5wdXNoKHtvcDpcInJlcGxhY2VcIixwYXRoOltdLHZhbHVlOm59KX19KX1mdW5jdGlvbiBDKCl7ZnVuY3Rpb24gcihuLHIpe2Z1bmN0aW9uIHQoKXt0aGlzLmNvbnN0cnVjdG9yPW59YShuLHIpLG4ucHJvdG90eXBlPSh0LnByb3RvdHlwZT1yLnByb3RvdHlwZSxuZXcgdCl9ZnVuY3Rpb24gZShuKXtuLm98fChuLkQ9bmV3IE1hcCxuLm89bmV3IE1hcChuLnQpKX1mdW5jdGlvbiBvKG4pe24ub3x8KG4ubz1uZXcgU2V0LG4udC5mb3JFYWNoKChmdW5jdGlvbihyKXtpZih0KHIpKXt2YXIgZT1SKG4uQS5oLHIsbik7bi5wLnNldChyLGUpLG4uby5hZGQoZSl9ZWxzZSBuLm8uYWRkKHIpfSkpKX1mdW5jdGlvbiB1KHIpe3IuTyYmbigzLEpTT04uc3RyaW5naWZ5KHAocikpKX12YXIgYT1mdW5jdGlvbihuLHIpe3JldHVybihhPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbihuLHIpe24uX19wcm90b19fPXJ9fHxmdW5jdGlvbihuLHIpe2Zvcih2YXIgdCBpbiByKXIuaGFzT3duUHJvcGVydHkodCkmJihuW3RdPXJbdF0pfSkobixyKX0sZj1mdW5jdGlvbigpe2Z1bmN0aW9uIG4obixyKXtyZXR1cm4gdGhpc1tRXT17aToyLGw6cixBOnI/ci5BOl8oKSxQOiExLEk6ITEsbzp2b2lkIDAsRDp2b2lkIDAsdDpuLGs6dGhpcyxDOiExLE86ITF9LHRoaXN9cihuLE1hcCk7dmFyIG89bi5wcm90b3R5cGU7cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLFwic2l6ZVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcCh0aGlzW1FdKS5zaXplfX0pLG8uaGFzPWZ1bmN0aW9uKG4pe3JldHVybiBwKHRoaXNbUV0pLmhhcyhuKX0sby5zZXQ9ZnVuY3Rpb24obixyKXt2YXIgdD10aGlzW1FdO3JldHVybiB1KHQpLHAodCkuaGFzKG4pJiZwKHQpLmdldChuKT09PXJ8fChlKHQpLGsodCksdC5ELnNldChuLCEwKSx0Lm8uc2V0KG4sciksdC5ELnNldChuLCEwKSksdGhpc30sby5kZWxldGU9ZnVuY3Rpb24obil7aWYoIXRoaXMuaGFzKG4pKXJldHVybiExO3ZhciByPXRoaXNbUV07cmV0dXJuIHUociksZShyKSxrKHIpLHIudC5oYXMobik/ci5ELnNldChuLCExKTpyLkQuZGVsZXRlKG4pLHIuby5kZWxldGUobiksITB9LG8uY2xlYXI9ZnVuY3Rpb24oKXt2YXIgbj10aGlzW1FdO3UobikscChuKS5zaXplJiYoZShuKSxrKG4pLG4uRD1uZXcgTWFwLGkobi50LChmdW5jdGlvbihyKXtuLkQuc2V0KHIsITEpfSkpLG4uby5jbGVhcigpKX0sby5mb3JFYWNoPWZ1bmN0aW9uKG4scil7dmFyIHQ9dGhpcztwKHRoaXNbUV0pLmZvckVhY2goKGZ1bmN0aW9uKGUsaSl7bi5jYWxsKHIsdC5nZXQoaSksaSx0KX0pKX0sby5nZXQ9ZnVuY3Rpb24obil7dmFyIHI9dGhpc1tRXTt1KHIpO3ZhciBpPXAocikuZ2V0KG4pO2lmKHIuSXx8IXQoaSkpcmV0dXJuIGk7aWYoaSE9PXIudC5nZXQobikpcmV0dXJuIGk7dmFyIG89UihyLkEuaCxpLHIpO3JldHVybiBlKHIpLHIuby5zZXQobixvKSxvfSxvLmtleXM9ZnVuY3Rpb24oKXtyZXR1cm4gcCh0aGlzW1FdKS5rZXlzKCl9LG8udmFsdWVzPWZ1bmN0aW9uKCl7dmFyIG4scj10aGlzLHQ9dGhpcy5rZXlzKCk7cmV0dXJuKG49e30pW1ZdPWZ1bmN0aW9uKCl7cmV0dXJuIHIudmFsdWVzKCl9LG4ubmV4dD1mdW5jdGlvbigpe3ZhciBuPXQubmV4dCgpO3JldHVybiBuLmRvbmU/bjp7ZG9uZTohMSx2YWx1ZTpyLmdldChuLnZhbHVlKX19LG59LG8uZW50cmllcz1mdW5jdGlvbigpe3ZhciBuLHI9dGhpcyx0PXRoaXMua2V5cygpO3JldHVybihuPXt9KVtWXT1mdW5jdGlvbigpe3JldHVybiByLmVudHJpZXMoKX0sbi5uZXh0PWZ1bmN0aW9uKCl7dmFyIG49dC5uZXh0KCk7aWYobi5kb25lKXJldHVybiBuO3ZhciBlPXIuZ2V0KG4udmFsdWUpO3JldHVybntkb25lOiExLHZhbHVlOltuLnZhbHVlLGVdfX0sbn0sb1tWXT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVudHJpZXMoKX0sbn0oKSxjPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbihuLHIpe3JldHVybiB0aGlzW1FdPXtpOjMsbDpyLEE6cj9yLkE6XygpLFA6ITEsSTohMSxvOnZvaWQgMCx0Om4sazp0aGlzLHA6bmV3IE1hcCxPOiExLEM6ITF9LHRoaXN9cihuLFNldCk7dmFyIHQ9bi5wcm90b3R5cGU7cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwic2l6ZVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcCh0aGlzW1FdKS5zaXplfX0pLHQuaGFzPWZ1bmN0aW9uKG4pe3ZhciByPXRoaXNbUV07cmV0dXJuIHUociksci5vPyEhci5vLmhhcyhuKXx8ISghci5wLmhhcyhuKXx8IXIuby5oYXMoci5wLmdldChuKSkpOnIudC5oYXMobil9LHQuYWRkPWZ1bmN0aW9uKG4pe3ZhciByPXRoaXNbUV07cmV0dXJuIHUociksdGhpcy5oYXMobil8fChvKHIpLGsociksci5vLmFkZChuKSksdGhpc30sdC5kZWxldGU9ZnVuY3Rpb24obil7aWYoIXRoaXMuaGFzKG4pKXJldHVybiExO3ZhciByPXRoaXNbUV07cmV0dXJuIHUociksbyhyKSxrKHIpLHIuby5kZWxldGUobil8fCEhci5wLmhhcyhuKSYmci5vLmRlbGV0ZShyLnAuZ2V0KG4pKX0sdC5jbGVhcj1mdW5jdGlvbigpe3ZhciBuPXRoaXNbUV07dShuKSxwKG4pLnNpemUmJihvKG4pLGsobiksbi5vLmNsZWFyKCkpfSx0LnZhbHVlcz1mdW5jdGlvbigpe3ZhciBuPXRoaXNbUV07cmV0dXJuIHUobiksbyhuKSxuLm8udmFsdWVzKCl9LHQuZW50cmllcz1mdW5jdGlvbigpe3ZhciBuPXRoaXNbUV07cmV0dXJuIHUobiksbyhuKSxuLm8uZW50cmllcygpfSx0LmtleXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YWx1ZXMoKX0sdFtWXT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZhbHVlcygpfSx0LmZvckVhY2g9ZnVuY3Rpb24obixyKXtmb3IodmFyIHQ9dGhpcy52YWx1ZXMoKSxlPXQubmV4dCgpOyFlLmRvbmU7KW4uY2FsbChyLGUudmFsdWUsZS52YWx1ZSx0aGlzKSxlPXQubmV4dCgpfSxufSgpO20oXCJNYXBTZXRcIix7TjpmdW5jdGlvbihuLHIpe3JldHVybiBuZXcgZihuLHIpfSxUOmZ1bmN0aW9uKG4scil7cmV0dXJuIG5ldyBjKG4scil9fSl9ZnVuY3Rpb24gSigpe04oKSxDKCksVCgpfWZ1bmN0aW9uIEsobil7cmV0dXJuIG59ZnVuY3Rpb24gJChuKXtyZXR1cm4gbn12YXIgRyxVLFc9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbChcInhcIiksWD1cInVuZGVmaW5lZFwiIT10eXBlb2YgTWFwLHE9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFNldCxCPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBQcm94eSYmdm9pZCAwIT09UHJveHkucmV2b2NhYmxlJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgUmVmbGVjdCxIPVc/U3ltYm9sLmZvcihcImltbWVyLW5vdGhpbmdcIik6KChHPXt9KVtcImltbWVyLW5vdGhpbmdcIl09ITAsRyksTD1XP1N5bWJvbC5mb3IoXCJpbW1lci1kcmFmdGFibGVcIik6XCJfXyRpbW1lcl9kcmFmdGFibGVcIixRPVc/U3ltYm9sLmZvcihcImltbWVyLXN0YXRlXCIpOlwiX18kaW1tZXJfc3RhdGVcIixWPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC5pdGVyYXRvcnx8XCJAQGl0ZXJhdG9yXCIsWT17MDpcIklsbGVnYWwgc3RhdGVcIiwxOlwiSW1tZXIgZHJhZnRzIGNhbm5vdCBoYXZlIGNvbXB1dGVkIHByb3BlcnRpZXNcIiwyOlwiVGhpcyBvYmplY3QgaGFzIGJlZW4gZnJvemVuIGFuZCBzaG91bGQgbm90IGJlIG11dGF0ZWRcIiwzOmZ1bmN0aW9uKG4pe3JldHVyblwiQ2Fubm90IHVzZSBhIHByb3h5IHRoYXQgaGFzIGJlZW4gcmV2b2tlZC4gRGlkIHlvdSBwYXNzIGFuIG9iamVjdCBmcm9tIGluc2lkZSBhbiBpbW1lciBmdW5jdGlvbiB0byBhbiBhc3luYyBwcm9jZXNzPyBcIitufSw0OlwiQW4gaW1tZXIgcHJvZHVjZXIgcmV0dXJuZWQgYSBuZXcgdmFsdWUgKmFuZCogbW9kaWZpZWQgaXRzIGRyYWZ0LiBFaXRoZXIgcmV0dXJuIGEgbmV3IHZhbHVlICpvciogbW9kaWZ5IHRoZSBkcmFmdC5cIiw1OlwiSW1tZXIgZm9yYmlkcyBjaXJjdWxhciByZWZlcmVuY2VzXCIsNjpcIlRoZSBmaXJzdCBvciBzZWNvbmQgYXJndW1lbnQgdG8gYHByb2R1Y2VgIG11c3QgYmUgYSBmdW5jdGlvblwiLDc6XCJUaGUgdGhpcmQgYXJndW1lbnQgdG8gYHByb2R1Y2VgIG11c3QgYmUgYSBmdW5jdGlvbiBvciB1bmRlZmluZWRcIiw4OlwiRmlyc3QgYXJndW1lbnQgdG8gYGNyZWF0ZURyYWZ0YCBtdXN0IGJlIGEgcGxhaW4gb2JqZWN0LCBhbiBhcnJheSwgb3IgYW4gaW1tZXJhYmxlIG9iamVjdFwiLDk6XCJGaXJzdCBhcmd1bWVudCB0byBgZmluaXNoRHJhZnRgIG11c3QgYmUgYSBkcmFmdCByZXR1cm5lZCBieSBgY3JlYXRlRHJhZnRgXCIsMTA6XCJUaGUgZ2l2ZW4gZHJhZnQgaXMgYWxyZWFkeSBmaW5hbGl6ZWRcIiwxMTpcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eSgpIGNhbm5vdCBiZSB1c2VkIG9uIGFuIEltbWVyIGRyYWZ0XCIsMTI6XCJPYmplY3Quc2V0UHJvdG90eXBlT2YoKSBjYW5ub3QgYmUgdXNlZCBvbiBhbiBJbW1lciBkcmFmdFwiLDEzOlwiSW1tZXIgb25seSBzdXBwb3J0cyBkZWxldGluZyBhcnJheSBpbmRpY2VzXCIsMTQ6XCJJbW1lciBvbmx5IHN1cHBvcnRzIHNldHRpbmcgYXJyYXkgaW5kaWNlcyBhbmQgdGhlICdsZW5ndGgnIHByb3BlcnR5XCIsMTU6ZnVuY3Rpb24obil7cmV0dXJuXCJDYW5ub3QgYXBwbHkgcGF0Y2gsIHBhdGggZG9lc24ndCByZXNvbHZlOiBcIitufSwxNjonU2V0cyBjYW5ub3QgaGF2ZSBcInJlcGxhY2VcIiBwYXRjaGVzLicsMTc6ZnVuY3Rpb24obil7cmV0dXJuXCJVbnN1cHBvcnRlZCBwYXRjaCBvcGVyYXRpb246IFwiK259LDE4OmZ1bmN0aW9uKG4pe3JldHVyblwiVGhlIHBsdWdpbiBmb3IgJ1wiK24rXCInIGhhcyBub3QgYmVlbiBsb2FkZWQgaW50byBJbW1lci4gVG8gZW5hYmxlIHRoZSBwbHVnaW4sIGltcG9ydCBhbmQgY2FsbCBgZW5hYmxlXCIrbitcIigpYCB3aGVuIGluaXRpYWxpemluZyB5b3VyIGFwcGxpY2F0aW9uLlwifSwyMDpcIkNhbm5vdCB1c2UgcHJveGllcyBpZiBQcm94eSwgUHJveHkucmV2b2NhYmxlIG9yIFJlZmxlY3QgYXJlIG5vdCBhdmFpbGFibGVcIiwyMTpmdW5jdGlvbihuKXtyZXR1cm5cInByb2R1Y2UgY2FuIG9ubHkgYmUgY2FsbGVkIG9uIHRoaW5ncyB0aGF0IGFyZSBkcmFmdGFibGU6IHBsYWluIG9iamVjdHMsIGFycmF5cywgTWFwLCBTZXQgb3IgY2xhc3NlcyB0aGF0IGFyZSBtYXJrZWQgd2l0aCAnW2ltbWVyYWJsZV06IHRydWUnLiBHb3QgJ1wiK24rXCInXCJ9LDIyOmZ1bmN0aW9uKG4pe3JldHVyblwiJ2N1cnJlbnQnIGV4cGVjdHMgYSBkcmFmdCwgZ290OiBcIitufSwyMzpmdW5jdGlvbihuKXtyZXR1cm5cIidvcmlnaW5hbCcgZXhwZWN0cyBhIGRyYWZ0LCBnb3Q6IFwiK259LDI0OlwiUGF0Y2hpbmcgcmVzZXJ2ZWQgYXR0cmlidXRlcyBsaWtlIF9fcHJvdG9fXywgcHJvdG90eXBlIGFuZCBjb25zdHJ1Y3RvciBpcyBub3QgYWxsb3dlZFwifSxaPVwiXCIrT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcixubj1cInVuZGVmaW5lZFwiIT10eXBlb2YgUmVmbGVjdCYmUmVmbGVjdC5vd25LZXlzP1JlZmxlY3Qub3duS2V5czp2b2lkIDAhPT1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzP2Z1bmN0aW9uKG4pe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhuKS5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhuKSl9Ok9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzLHJuPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzfHxmdW5jdGlvbihuKXt2YXIgcj17fTtyZXR1cm4gbm4obikuZm9yRWFjaCgoZnVuY3Rpb24odCl7clt0XT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sdCl9KSkscn0sdG49e30sZW49e2dldDpmdW5jdGlvbihuLHIpe2lmKHI9PT1RKXJldHVybiBuO3ZhciBlPXAobik7aWYoIXUoZSxyKSlyZXR1cm4gZnVuY3Rpb24obixyLHQpe3ZhciBlLGk9SShyLHQpO3JldHVybiBpP1widmFsdWVcImluIGk/aS52YWx1ZTpudWxsPT09KGU9aS5nZXQpfHx2b2lkIDA9PT1lP3ZvaWQgMDplLmNhbGwobi5rKTp2b2lkIDB9KG4sZSxyKTt2YXIgaT1lW3JdO3JldHVybiBuLkl8fCF0KGkpP2k6aT09PXoobi50LHIpPyhFKG4pLG4ub1tyXT1SKG4uQS5oLGksbikpOml9LGhhczpmdW5jdGlvbihuLHIpe3JldHVybiByIGluIHAobil9LG93bktleXM6ZnVuY3Rpb24obil7cmV0dXJuIFJlZmxlY3Qub3duS2V5cyhwKG4pKX0sc2V0OmZ1bmN0aW9uKG4scix0KXt2YXIgZT1JKHAobikscik7aWYobnVsbD09ZT92b2lkIDA6ZS5zZXQpcmV0dXJuIGUuc2V0LmNhbGwobi5rLHQpLCEwO2lmKCFuLlApe3ZhciBpPXoocChuKSxyKSxvPW51bGw9PWk/dm9pZCAwOmlbUV07aWYobyYmby50PT09dClyZXR1cm4gbi5vW3JdPXQsbi5EW3JdPSExLCEwO2lmKGModCxpKSYmKHZvaWQgMCE9PXR8fHUobi50LHIpKSlyZXR1cm4hMDtFKG4pLGsobil9cmV0dXJuIG4ub1tyXT09PXQmJlwibnVtYmVyXCIhPXR5cGVvZiB0JiYodm9pZCAwIT09dHx8ciBpbiBuLm8pfHwobi5vW3JdPXQsbi5EW3JdPSEwLCEwKX0sZGVsZXRlUHJvcGVydHk6ZnVuY3Rpb24obixyKXtyZXR1cm4gdm9pZCAwIT09eihuLnQscil8fHIgaW4gbi50PyhuLkRbcl09ITEsRShuKSxrKG4pKTpkZWxldGUgbi5EW3JdLG4ubyYmZGVsZXRlIG4ub1tyXSwhMH0sZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOmZ1bmN0aW9uKG4scil7dmFyIHQ9cChuKSxlPVJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQscik7cmV0dXJuIGU/e3dyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZToxIT09bi5pfHxcImxlbmd0aFwiIT09cixlbnVtZXJhYmxlOmUuZW51bWVyYWJsZSx2YWx1ZTp0W3JdfTplfSxkZWZpbmVQcm9wZXJ0eTpmdW5jdGlvbigpe24oMTEpfSxnZXRQcm90b3R5cGVPZjpmdW5jdGlvbihuKXtyZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKG4udCl9LHNldFByb3RvdHlwZU9mOmZ1bmN0aW9uKCl7bigxMil9fSxvbj17fTtpKGVuLChmdW5jdGlvbihuLHIpe29uW25dPWZ1bmN0aW9uKCl7cmV0dXJuIGFyZ3VtZW50c1swXT1hcmd1bWVudHNbMF1bMF0sci5hcHBseSh0aGlzLGFyZ3VtZW50cyl9fSkpLG9uLmRlbGV0ZVByb3BlcnR5PWZ1bmN0aW9uKHIsdCl7cmV0dXJuXCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOViYmaXNOYU4ocGFyc2VJbnQodCkpJiZuKDEzKSxvbi5zZXQuY2FsbCh0aGlzLHIsdCx2b2lkIDApfSxvbi5zZXQ9ZnVuY3Rpb24ocix0LGUpe3JldHVyblwicHJvZHVjdGlvblwiIT09cHJvY2Vzcy5lbnYuTk9ERV9FTlYmJlwibGVuZ3RoXCIhPT10JiZpc05hTihwYXJzZUludCh0KSkmJm4oMTQpLGVuLnNldC5jYWxsKHRoaXMsclswXSx0LGUsclswXSl9O3ZhciB1bj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUocil7dmFyIGU9dGhpczt0aGlzLmc9Qix0aGlzLkY9ITAsdGhpcy5wcm9kdWNlPWZ1bmN0aW9uKHIsaSxvKXtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiByJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBpKXt2YXIgdT1pO2k9cjt2YXIgYT1lO3JldHVybiBmdW5jdGlvbihuKXt2YXIgcj10aGlzO3ZvaWQgMD09PW4mJihuPXUpO2Zvcih2YXIgdD1hcmd1bWVudHMubGVuZ3RoLGU9QXJyYXkodD4xP3QtMTowKSxvPTE7bzx0O28rKyllW28tMV09YXJndW1lbnRzW29dO3JldHVybiBhLnByb2R1Y2UobiwoZnVuY3Rpb24obil7dmFyIHQ7cmV0dXJuKHQ9aSkuY2FsbC5hcHBseSh0LFtyLG5dLmNvbmNhdChlKSl9KSl9fXZhciBmO2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGkmJm4oNiksdm9pZCAwIT09byYmXCJmdW5jdGlvblwiIT10eXBlb2YgbyYmbig3KSx0KHIpKXt2YXIgYz13KGUpLHM9UihlLHIsdm9pZCAwKSx2PSEwO3RyeXtmPWkocyksdj0hMX1maW5hbGx5e3Y/TyhjKTpnKGMpfXJldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBQcm9taXNlJiZmIGluc3RhbmNlb2YgUHJvbWlzZT9mLnRoZW4oKGZ1bmN0aW9uKG4pe3JldHVybiBqKGMsbyksUChuLGMpfSksKGZ1bmN0aW9uKG4pe3Rocm93IE8oYyksbn0pKTooaihjLG8pLFAoZixjKSl9aWYoIXJ8fFwib2JqZWN0XCIhPXR5cGVvZiByKXtpZih2b2lkIDA9PT0oZj1pKHIpKSYmKGY9ciksZj09PUgmJihmPXZvaWQgMCksZS5GJiZkKGYsITApLG8pe3ZhciBwPVtdLGw9W107YihcIlBhdGNoZXNcIikuTShyLGYscCxsKSxvKHAsbCl9cmV0dXJuIGZ9bigyMSxyKX0sdGhpcy5wcm9kdWNlV2l0aFBhdGNoZXM9ZnVuY3Rpb24obixyKXtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBuKXJldHVybiBmdW5jdGlvbihyKXtmb3IodmFyIHQ9YXJndW1lbnRzLmxlbmd0aCxpPUFycmF5KHQ+MT90LTE6MCksbz0xO288dDtvKyspaVtvLTFdPWFyZ3VtZW50c1tvXTtyZXR1cm4gZS5wcm9kdWNlV2l0aFBhdGNoZXMociwoZnVuY3Rpb24ocil7cmV0dXJuIG4uYXBwbHkodm9pZCAwLFtyXS5jb25jYXQoaSkpfSkpfTt2YXIgdCxpLG89ZS5wcm9kdWNlKG4sciwoZnVuY3Rpb24obixyKXt0PW4saT1yfSkpO3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBQcm9taXNlJiZvIGluc3RhbmNlb2YgUHJvbWlzZT9vLnRoZW4oKGZ1bmN0aW9uKG4pe3JldHVybltuLHQsaV19KSk6W28sdCxpXX0sXCJib29sZWFuXCI9PXR5cGVvZihudWxsPT1yP3ZvaWQgMDpyLnVzZVByb3hpZXMpJiZ0aGlzLnNldFVzZVByb3hpZXMoci51c2VQcm94aWVzKSxcImJvb2xlYW5cIj09dHlwZW9mKG51bGw9PXI/dm9pZCAwOnIuYXV0b0ZyZWV6ZSkmJnRoaXMuc2V0QXV0b0ZyZWV6ZShyLmF1dG9GcmVlemUpfXZhciBpPWUucHJvdG90eXBlO3JldHVybiBpLmNyZWF0ZURyYWZ0PWZ1bmN0aW9uKGUpe3QoZSl8fG4oOCkscihlKSYmKGU9RChlKSk7dmFyIGk9dyh0aGlzKSxvPVIodGhpcyxlLHZvaWQgMCk7cmV0dXJuIG9bUV0uQz0hMCxnKGkpLG99LGkuZmluaXNoRHJhZnQ9ZnVuY3Rpb24ocix0KXt2YXIgZT1yJiZyW1FdO1wicHJvZHVjdGlvblwiIT09cHJvY2Vzcy5lbnYuTk9ERV9FTlYmJihlJiZlLkN8fG4oOSksZS5JJiZuKDEwKSk7dmFyIGk9ZS5BO3JldHVybiBqKGksdCksUCh2b2lkIDAsaSl9LGkuc2V0QXV0b0ZyZWV6ZT1mdW5jdGlvbihuKXt0aGlzLkY9bn0saS5zZXRVc2VQcm94aWVzPWZ1bmN0aW9uKHIpe3ImJiFCJiZuKDIwKSx0aGlzLmc9cn0saS5hcHBseVBhdGNoZXM9ZnVuY3Rpb24obix0KXt2YXIgZTtmb3IoZT10Lmxlbmd0aC0xO2U+PTA7ZS0tKXt2YXIgaT10W2VdO2lmKDA9PT1pLnBhdGgubGVuZ3RoJiZcInJlcGxhY2VcIj09PWkub3Ape249aS52YWx1ZTticmVha319ZT4tMSYmKHQ9dC5zbGljZShlKzEpKTt2YXIgbz1iKFwiUGF0Y2hlc1wiKS4kO3JldHVybiByKG4pP28obix0KTp0aGlzLnByb2R1Y2UobiwoZnVuY3Rpb24obil7cmV0dXJuIG8obix0KX0pKX0sZX0oKSxhbj1uZXcgdW4sZm49YW4ucHJvZHVjZSxjbj1hbi5wcm9kdWNlV2l0aFBhdGNoZXMuYmluZChhbiksc249YW4uc2V0QXV0b0ZyZWV6ZS5iaW5kKGFuKSx2bj1hbi5zZXRVc2VQcm94aWVzLmJpbmQoYW4pLHBuPWFuLmFwcGx5UGF0Y2hlcy5iaW5kKGFuKSxsbj1hbi5jcmVhdGVEcmFmdC5iaW5kKGFuKSxkbj1hbi5maW5pc2hEcmFmdC5iaW5kKGFuKTtleHBvcnQgZGVmYXVsdCBmbjtleHBvcnR7dW4gYXMgSW1tZXIscG4gYXMgYXBwbHlQYXRjaGVzLEsgYXMgY2FzdERyYWZ0LCQgYXMgY2FzdEltbXV0YWJsZSxsbiBhcyBjcmVhdGVEcmFmdCxEIGFzIGN1cnJlbnQsSiBhcyBlbmFibGVBbGxQbHVnaW5zLE4gYXMgZW5hYmxlRVM1LEMgYXMgZW5hYmxlTWFwU2V0LFQgYXMgZW5hYmxlUGF0Y2hlcyxkbiBhcyBmaW5pc2hEcmFmdCxkIGFzIGZyZWV6ZSxMIGFzIGltbWVyYWJsZSxyIGFzIGlzRHJhZnQsdCBhcyBpc0RyYWZ0YWJsZSxIIGFzIG5vdGhpbmcsZSBhcyBvcmlnaW5hbCxmbiBhcyBwcm9kdWNlLGNuIGFzIHByb2R1Y2VXaXRoUGF0Y2hlcyxzbiBhcyBzZXRBdXRvRnJlZXplLHZuIGFzIHNldFVzZVByb3hpZXN9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1tZXIuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9